---
title: linux下system()/execve()/execl()函数使用详解
date: 2017-08-07 10:08:23
categories: pwn
tags: linux
---

本节详细可参考
[http://www.cnblogs.com/akira90/archive/2012/12/05/2802809.html](http://www.cnblogs.com/akira90/archive/2012/12/05/2802809.html)

### 1. execve函数
```
 相关函数： fork，execl，execle，execlp，execv，execvp

 表头文件： #include unistd.h

 定义函数： int execve(const char * filename,char * const argv[ ],char * const envp[ ]);

 函数说明： execve()用来执行参数filename字符串所代表的文件路径，第二个参数系利用数组指针来传递给执行文件，最后一个参数则为传递给执行文件的新环境变量数组。

 返回值：   如果执行成功则函数不会返回，执行失败则直接返回-1，失败原因存于errno 中。

 错误代码:

 EACCES

1. 欲执行的文件不具有用户可执行的权限。
2. 欲执行的文件所属的文件系统是以noexec 方式挂上。
3. 欲执行的文件或script翻译器非一般文件。

 EPERM

1.进程处于被追踪模式，执行者并不具有root权限，欲执行的文件具有SUID 或SGID 位。

2.欲执行的文件所属的文件系统是以nosuid方式挂上，欲执行的文件具有SUID 或SGID 位元，但执行者并不具有root权限。

E2BIG 参数数组过大

 ENOEXEC 无法判断欲执行文件的执行文件格式，有可能是格式错误或无法在此平台执行。

 EFAULT 参数filename所指的字符串地址超出可存取空间范围。

 ENAMETOOLONG 参数filename所指的字符串太长。

 ENOENT 参数filename字符串所指定的文件不存在。

 ENOMEM 核心内存不足

 ENOTDIR 参数filename字符串所包含的目录路径并非有效目录

 EACCES 参数filename字符串所包含的目录路径无法存取，权限不足

 ELOOP 过多的符号连接

 ETXTBUSY 欲执行的文件已被其他进程打开而且正把数据写入该文件中

 EIO I/O 存取错误

 ENFILE 已达到系统所允许的打开文件总数。

 EMFILE 已达到系统所允许单一进程所能打开的文件总数。

 EINVAL 欲执行文件的ELF执行格式不只一个PT_INTERP节区

 EISDIR ELF翻译器为一目录

 ELIBBAD ELF翻译器有问题。
```



### 2. system()函数

```
相关函数： fork，execve，waitpid，popen

表头文件： #include stdlib.h

定义函数： int system(const char * string);

函数说明： system()会调用fork()产生子进程，由子进程来调用/bin/sh  c string来执行参数string字符串所代表的命令，此命>令执行完后随即返回原调用的进程。在调用system()期间SIGCHLD 信号会被暂时搁置，SIGINT和SIGQUIT 信号则会被忽略。

返回值：

    =-1:出现错误
    =0:调用成功但是没有出现子进程
    >0:成功退出的子进程的id

如果system()在调用/bin/sh时失败则返回127，其他失败原因返回-1。若参数string为空指针(NULL)，则返回非零值>。 如果system()调用成功则最后会返回执行shell命令后的返回值，但是此返回值也有可能为 system()调用/bin/sh失败所返回的127，因此最好能再检查errno 来确认执行成功。

附加说明： 在编写具有SUID/SGID权限的程序时请勿使用system()，system()会继承环境变量，通过环境变量可能会造成系统安全的问题。
```



### 3. execl()函数

int execl(const char \* filename,char \* const argv[ ],char \* const envp[ ]);
