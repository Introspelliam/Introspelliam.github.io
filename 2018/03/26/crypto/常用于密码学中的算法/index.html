<!DOCTYPE html>




<html class="theme-next mist" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="googleaf0347feb5ea0936.html" />














  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="rsa," />





  <link rel="alternate" href="/atom.xml" title="Introspelliam" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="0x0 前言最近做了不少密码学的题目，对于常见的RSA密钥攻击已经非常熟悉，但是对于比较特殊的密码学攻击手段，我却不甚清楚。下面主要讲解的是几种常见的算法。 0x1 baby step giant step算法baby step giant step算法常用于ACM竞赛中，该算法的目的是让$a^x=b(mod\ p)$ 求解的速度更快，核心是利用hash表查询的速度较普通查询方式快，当然同样是用空">
<meta name="keywords" content="rsa">
<meta property="og:type" content="article">
<meta property="og:title" content="常用于密码学中的算法">
<meta property="og:url" content="http://yoursite.com/2018/03/26/crypto/常用于密码学中的算法/index.html">
<meta property="og:site_name" content="Introspelliam">
<meta property="og:description" content="0x0 前言最近做了不少密码学的题目，对于常见的RSA密钥攻击已经非常熟悉，但是对于比较特殊的密码学攻击手段，我却不甚清楚。下面主要讲解的是几种常见的算法。 0x1 baby step giant step算法baby step giant step算法常用于ACM竞赛中，该算法的目的是让$a^x=b(mod\ p)$ 求解的速度更快，核心是利用hash表查询的速度较普通查询方式快，当然同样是用空">
<meta property="og:updated_time" content="2018-07-09T11:41:14.928Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="常用于密码学中的算法">
<meta name="twitter:description" content="0x0 前言最近做了不少密码学的题目，对于常见的RSA密钥攻击已经非常熟悉，但是对于比较特殊的密码学攻击手段，我却不甚清楚。下面主要讲解的是几种常见的算法。 0x1 baby step giant step算法baby step giant step算法常用于ACM竞赛中，该算法的目的是让$a^x=b(mod\ p)$ 求解的速度更快，核心是利用hash表查询的速度较普通查询方式快，当然同样是用空">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"right","display":"always","offset":0,"offset_float":0,"b2t":true,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/03/26/crypto/常用于密码学中的算法/"/>





  <title>常用于密码学中的算法 | Introspelliam</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?663212c5ef558c27e77385b620f14823";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Introspelliam</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Just do what works for you, because there will always be someone who thinks differently.</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/26/crypto/常用于密码学中的算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Introspelliam">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/me.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Introspelliam">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">常用于密码学中的算法</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-26T13:44:56+08:00">
                2018-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/crypto/" itemprop="url" rel="index">
                    <span itemprop="name">crypto</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h3><p>最近做了不少密码学的题目，对于常见的RSA密钥攻击已经非常熟悉，但是对于比较特殊的密码学攻击手段，我却不甚清楚。下面主要讲解的是几种常见的算法。</p>
<h3 id="0x1-baby-step-giant-step算法"><a href="#0x1-baby-step-giant-step算法" class="headerlink" title="0x1 baby step giant step算法"></a>0x1 baby step giant step算法</h3><p>baby step giant step算法常用于ACM竞赛中，该算法的目的是让$a^x=b(mod\ p)$ 求解的速度更快，核心是利用hash表查询的速度较普通查询方式快，当然同样是用空间换时间的一种思想。大概的时间复杂度$O(\sqrt{p}\ )$</p>
<p>设$m=\lceil\sqrt{p}\ \rceil$</p>
<p>那么可以设$x=i*m-j$</p>
<p>所以原式等价于 $a^{i*m-j}=b(mod\ p) $</p>
<p>也即 $(a^{m})^i=b*a^j$</p>
<p>枚举$j$ (从0-m)，将$b*a^j$ 存入hash表中</p>
<p>枚举i(范围1-m)，从hash表中寻找第一个满足$(a^{m})^i=b*a^j$ 的解</p>
<p>此时$x=i*m-j$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"></div><div class="line"><span class="built_in">map</span>&lt;ll,<span class="keyword">int</span>&gt;mp;</div><div class="line">ll p,a,b;</div><div class="line">ll n,m,now,ans,t;</div><div class="line"><span class="keyword">bool</span> flag;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">fast_pow</span><span class="params">(ll x)</span></span></div><div class="line">&#123;</div><div class="line">    ll sum = <span class="number">1</span>;</div><div class="line">    ll aa = a;</div><div class="line">    <span class="keyword">while</span> (x&gt;<span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (x&amp;<span class="number">1</span>) </div><div class="line">            sum = (sum*aa)%p;</div><div class="line">        x = x&gt;&gt;<span class="number">1</span>;</div><div class="line">        aa = (aa*aa)%p;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;p,&amp;a,&amp;b)!=EOF)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(a%p==<span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"no solution\n"</span>);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        mp.clear();</div><div class="line">        m = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p));</div><div class="line">        flag = <span class="literal">false</span> ;</div><div class="line">        now = b%p;        <span class="comment">//b*a^j 当j==0时 </span></div><div class="line">        mp[now] = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</div><div class="line">        &#123;</div><div class="line">            now = (now*a)%p;</div><div class="line">            mp[now] = i;</div><div class="line">        &#125;</div><div class="line">        t = fast_pow(m);</div><div class="line">        now = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)    <span class="comment">//枚举 (a^m)^i</span></div><div class="line">        &#123;</div><div class="line">            now = (now*t)%p;</div><div class="line">            <span class="keyword">if</span>(mp[now])</div><div class="line">            &#123;</div><div class="line">                flag = <span class="literal">true</span>;</div><div class="line">                ans = i*m-mp[now];</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(ans%p+p)%p);    <span class="comment">//printf("%lld\n",(ans%p+p)%p);</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!flag) <span class="built_in">printf</span>(<span class="string">"no solution\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="0x2-Pohlig-Hellman算法"><a href="#0x2-Pohlig-Hellman算法" class="headerlink" title="0x2 Pohlig-Hellman算法"></a>0x2 Pohlig-Hellman算法</h3><p>此算法应用于密码学中比bsgs算法更广，而且效果也更佳！（因为bsgs算法所能求解的p值不能太大，位数多了就不能在有限时间内跑完）</p>
<p>原理： </p>
<p>问题： 已知a,b,p,以及p-1的分解质因数，求x使得 $a^x=b(mod\ p)$</p>
<p>设 $p-1=p_1^{e_1}*p_2^{e_2}...p_k^{e_k}$</p>
<p>若能有 $k$ 组可用的等式  $x=x_i\ (mod\ p_i^{e_i})$ ，就可以用中国剩余定理求解出 $x(mod\ p-1)$ </p>
<h4 id="2-1-求解-x-i"><a href="#2-1-求解-x-i" class="headerlink" title="2.1 求解$x_i$"></a>2.1 求解$x_i$</h4><p>对于 $p_i$ ，设   $x_i=c_0+c_1*p_i+c_2*p_i^2...c_{e_i-1}*p_i^{e_i-1}$ ，则  $x=x_i+s*p_i^{e_i}$</p>
<p><strong>求解 $c_0$ ：</strong></p>
<p>$b^{(p-1)/p_i}=(a^x)^{(p-1)/p_i}\ mod\ p$</p>
<p>$=(a^{c_0+c_1*p_i+c_2*p_i^2...c_{e_i-1}*p_i^{e_i-1}+s*p_i^{e_i}})^{(p-1)/p_i} \ mod\ p$</p>
<p>$=(a ^{c_0})^{(p-1)/p_i}\ mod\ p$</p>
<p>由于 $b^{(p-1)/p_i}$ 已知， 而 $c_0$ 取值范围只在$[0,p_i-1]$ ，因而在 $p_i$ 不是特别大的时候，完全是可解的。</p>
<p>有心的同学会发现，这个求解只需要在 $O(\lceil \sqrt{p_i} \rceil)$ 时间内就可求解，使用的仍是大步小步的思想。</p>
<p>设 $m=\lceil \sqrt{p_i}\ \rceil $ ，$c_0 = u*m - v$</p>
<p>则上式可表示为 $b^{(p-1)/p_i}*(a^{(p-1)/p_i})^v = (a^{m*(p-1)/p_i})^u$</p>
<p>利用hash表可以快速求解出来！</p>
<p><strong>求解 $c_i $ :</strong></p>
<p>基于上面的表达式，我们可以快速求解出$c_0$ 等值，然后求解$c_1$ ，依次求解，最终可以将所有解求出来。</p>
<p><strong>组合：</strong></p>
<p>$x_i=c_0+c_1*p_i+c_2*p_i^2+...+c_{e_i-1}*p_i^{e_i-1}$</p>
<h4 id="2-2-中国剩余定理求解x"><a href="#2-2-中国剩余定理求解x" class="headerlink" title="2.2 中国剩余定理求解x"></a>2.2 中国剩余定理求解x</h4><h4 id="2-3-范例"><a href="#2-3-范例" class="headerlink" title="2.3 范例"></a>2.3 范例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">Let the prime p = 8101, and a generator of Z(8101) be a = 6. Find x so that</div><div class="line">a^x = 7531 mod 8101.</div><div class="line"></div><div class="line">Observe that p-1 = 8100 = (2^2)(3^4)(5^2), is a product of small primes. We shall determine the numbers x2 = x mod (2^2), x3 = x mod (3^4) and x5 = x mod (5^2).</div><div class="line"></div><div class="line">Determination of x2.</div><div class="line">Since x2 is a number mod 4, we have x2 = c0 + c1 (2), with the coefficients being either 0 or 1. We determine these coefficients as follows.</div><div class="line">7531^(p-1)/2 = 7531^4050 = -1 and as this = a^(c0*(p-1)/2), we have c0 = 1.</div><div class="line">Now, divide 7531 by a^c0 to get</div><div class="line">7531^(a-1) = 7531^(6751) = 8006 mod p.</div><div class="line">8006^(p-1)/4 = 8006^2025 = 1 and as this = a^(c1*(p-1)/2), we have c1 = 0.</div><div class="line"></div><div class="line">x2 = c0 + c1 (2) = 1 + 0(2) = 1.</div><div class="line"></div><div class="line">Determination of x3.</div><div class="line">Since x3 is a number mod 81, we have x3 = c0 + c1 (3) + c2 (9) + c3 (27), with the coefficients being either 0, 1 or 2. It will be of use to know the numbers a^(p-1)/3 = 5883, and a^(2*(p-1)/3) = 2217.</div><div class="line">7531^(p-1)/3 = 2217, so c0 = 2.</div><div class="line">Now divide 7531 by ac0 to get</div><div class="line">7531^(a-2) = 6735 mod p.</div><div class="line">6735^(p-1)/9 = 1, so c1 = 0.</div><div class="line">Now divide 6735 by a3c1 to get</div><div class="line">6735(a0) = 6735 mod p.</div><div class="line">6735^(p-1)/27 = 2217, so c2 = 2.</div><div class="line">Now divide 6735 by a9c2 to get</div><div class="line">6735^(a-18) = 6992 mod p.</div><div class="line">6992^(p-1)/81 = 5883, so c3 = 1.</div><div class="line"></div><div class="line">x3 = 2 + 0(3) + 2(9) + 1(27) = 47.</div><div class="line"></div><div class="line">Determination of x5.</div><div class="line">Since x5 is a number mod 25, x5 = c0 + c1 (5), with the coefficients being either 0, 1, 2, 3 or 4. We need to compute a^(p-1)/5 = 3547, a^(2(p-1)/5) = 356, a^(3(p-1)/5) = 7077, a^(4(p-1)/5) = 5221.</div><div class="line">7531^(p-1)/5 = 5221, so c0 = 4.</div><div class="line">Divide 7531 by a^c0 to get</div><div class="line">7531(a-4) = 7613 mod p.</div><div class="line">7613^(p-1)/25 = 356, so c1 = 2.</div><div class="line"></div><div class="line">x5 = 4 + 2(5) = 14.</div><div class="line"></div><div class="line">Determination of x.</div><div class="line">We now use the Chinese Remainder Theorem to compute the common solution of the congruences,</div><div class="line">x = 1 mod 4</div><div class="line">x = 47 mod 81</div><div class="line">x = 14 mod 25.</div><div class="line">M1 = 8100/(4) = 2025 </div><div class="line">y1 = M1-1 mod 4, y1 = 1.</div><div class="line">M2 = 8100/81 = 100</div><div class="line">y2 = M2-1 mod 81, y2 = 64.</div><div class="line"></div><div class="line">M3 = 8100/25 = 324</div><div class="line">y3 = M3-1 mod 25, y3 = 24.</div><div class="line"></div><div class="line">x = 1(2025)(1) + 47(100)(64) + 14(324)(24) = 6689 mod 8100.</div></pre></td></tr></table></figure>
<p>上文转载于 <a href="http://www-math.ucdenver.edu/~wcherowi/courses/m5410/phexam.html" target="_blank" rel="external">Pohlig-Hellman范例</a></p>
<p>相对于用上述方式进行计算，我们其实可以直接使用sage来快速获取结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">b = mod(6,8101)</div><div class="line">a = 7531</div><div class="line">discrete_log(a,b)</div></pre></td></tr></table></figure>
<h3 id="0x3-Pollard’s-rho算法"><a href="#0x3-Pollard’s-rho算法" class="headerlink" title="0x3 Pollard’s rho算法"></a>0x3 Pollard’s rho算法</h3><p>Pollard’s rho算法是一种常用的因数分解算法，对于分解因子较小的组合数特别有用。对于一个正整数n，在一般情况下，我们主要使用的是枚举1到n^(1/2)来求n的因子，所以算法复杂度是O(n^(1/2))。但是实际上有更好的办法，那就是Pollard&#39;s Rho算法，这个算法是一个随机化的算法，简单的说不是完全靠谱，一般我们认为它的平均算法复杂度是O(n^(1/4))。</p>
<h4 id="3-1-通过-𝐁𝐢𝐫𝐭𝐡𝐝𝐚𝐲-𝐓𝐫𝐢𝐜𝐤-提高概率"><a href="#3-1-通过-𝐁𝐢𝐫𝐭𝐡𝐝𝐚𝐲-𝐓𝐫𝐢𝐜𝐤-提高概率" class="headerlink" title="3.1 通过 𝐁𝐢𝐫𝐭𝐡𝐝𝐚𝐲 𝐓𝐫𝐢𝐜𝐤 提高概率"></a>3.1 通过 𝐁𝐢𝐫𝐭𝐡𝐝𝐚𝐲 𝐓𝐫𝐢𝐜𝐤 提高概率</h4><p>我们随即地从[1,N]中选择一个数，这个数是 p 或者 q 的可能性是非常小的，所有我们不得不重复运行算法来提高概率。那么，我们现在可以提出一个不同的问题：<br>不再只选取一个整数，我们能够选取 𝑘 个数，并问是否存在𝑥𝑖 − 𝑥𝑗能够整除N</p>
<p>当 $k=\sqrt{N}$ 时，可能性跳高到了50%</p>
<p>策略：</p>
<blockquote>
<p>在区间[𝟐, 𝑵 − 𝟏]中随即选取 𝒌 个数，𝒙𝟏, … … , 𝒙𝒌<br>判断是否存在𝒈𝒄𝒅(𝒙𝒊 − 𝒙𝒚 , 𝑵) &gt; 𝟏, 若存在，𝒈𝒄𝒅(𝒙𝒊 − 𝒙𝒚 ,𝑵) 是𝑵的一个因子 ( 𝒑 或 𝒒 )</p>
</blockquote>
<p>但是很早就出现了一个问题，我们需要选取大约 𝑁^1/4 个数，<br>这个数量太大了，以至于我们并不能将其存放在内存中</p>
<h4 id="3-2-Pollard‘s-rho算法详解"><a href="#3-2-Pollard‘s-rho算法详解" class="headerlink" title="3.2 Pollard‘s rho算法详解"></a>3.2 Pollard‘s rho算法详解</h4><p>为了解决数太多无法存储的问题，Pollard′s rho algorithm 只将两个数存放在内存中。</p>
<p>我们并不随机生成 k 个数并两两进行比较，而是一个一个地生成并检查连续的两个数。反复执行这个步骤并希望能够得到我们想要的数。我们使用一个函数来生成伪随机数。换句话说，我们不断地使用函数 𝑓 来生成（看上去或者说感觉上像的）随机数。并不是所有的函都能够这样做，但是有一个神奇的函数可以。它就是</p>
<p>$𝑓(𝑥) = ( 𝑥^2 + 𝑎 ) mod 𝑁$</p>
<p>你可以发现对于大部分的数据这个算法能够正常运行，但是对于某些数据，它将会进入无限循环。为什么呢？这是因为存在 𝑓 环的原因。当它发生的时候，我们会在一个有限数集中进行无限循环。</p>
<p>例如，我们可以构造一个伪随机函数并生成如下伪随机数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2, 10, 16, 23, 29, 13, 16, 23, 29, 13 … …</div></pre></td></tr></table></figure>
<p>在这个例子中，我们最终将会在16, 23, 29, 13这个圈中无限循环，永远找不到因子。</p>
<p>那么，<strong>如何探测环的出现呢？</strong></p>
<p>一种方法是记录当前产生过的所有的数𝑥1, 𝑥2, … … 𝑥𝑛,并检测是否存在𝑥𝑙 = 𝑥𝑛(𝑙 &lt; 𝑛)。在实际过程中，当 𝑛 增长到一定大小时，可能会造成的内存不够用的情况。</p>
<p>另一种方法是由Floyd发明的一个算法，我们举例来说明这个聪明而又有趣的算法。假设我们在一个很长很长的圆形轨道上行走，我们如何知道我们已经走完了一圈呢？当然，我们可以像第一种方法那样做，但是更聪明的方法是让 A 和 B 按照 B 的速度是A 的速度的两倍从同一起点开始往前走，当 B 第一次敢上 A 时(也就是我们常说的套圈)，我们便知道，B 已经走了至少一圈了。</p>
<h4 id="3-3-算法实现"><a href="#3-3-算法实现" class="headerlink" title="3.3 算法实现"></a>3.3 算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  </span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> times = <span class="number">50</span>;</div><div class="line"><span class="keyword">int</span> number = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt;m;</div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Random</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> n )</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> ((<span class="keyword">double</span>)rand( ) / RAND_MAX*n + <span class="number">0.5</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">q_mul</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> mod )</span> <span class="comment">//快速乘法取模</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(b)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>)</div><div class="line">		&#123;</div><div class="line">			ans += a;</div><div class="line">		&#125;</div><div class="line">		b /= <span class="number">2</span>;</div><div class="line">		a = (a + a) % mod;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">q_pow</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> mod )</span> <span class="comment">//快速乘法下的快速幂，叼</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span>(b)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>)</div><div class="line">		&#123;</div><div class="line">			ans = q_mul( ans, a, mod );</div><div class="line">		&#125;</div><div class="line">		b /= <span class="number">2</span>;</div><div class="line">		a = q_mul( a, a, mod );</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">witness</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> n )</span><span class="comment">//miller_rabin算法的精华</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> tem = n - <span class="number">1</span>;</div><div class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(tem % <span class="number">2</span> == <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		tem /= <span class="number">2</span>;</div><div class="line">		j++;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> x = q_pow( a, tem, n ); <span class="comment">//得到a^(n-1) mod n</span></div><div class="line">	<span class="keyword">if</span>(x == <span class="number">1</span> || x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">while</span>(j--)</div><div class="line">	&#123;</div><div class="line">		x = q_mul( x, x, n );</div><div class="line">		<span class="keyword">if</span>(x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">miller_rabin</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> n )</span>  <span class="comment">//检验n是否是素数</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(n == <span class="number">2</span>)</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">if</span>(n &lt; <span class="number">2</span> || n % <span class="number">2</span> == <span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= times; i++)  <span class="comment">//做times次随机检验</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">long</span> <span class="keyword">long</span> a = Random( n - <span class="number">2</span> ) + <span class="number">1</span>; <span class="comment">//得到随机检验算子 a</span></div><div class="line">		<span class="keyword">if</span>(!witness( a, n ))  <span class="comment">//用a检验n是否是素数</span></div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b )</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(b == <span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> a;</div><div class="line">	<span class="keyword">return</span> gcd( b, a%b );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">pollard_rho</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> c )</span><span class="comment">//找到n的一个因子</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> x, y, d, i = <span class="number">1</span>, k = <span class="number">2</span>;</div><div class="line">	x = Random( n - <span class="number">1</span> ) + <span class="number">1</span>;</div><div class="line">	y = x;</div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">	&#123;</div><div class="line">		i++;</div><div class="line">		x = (q_mul( x, x, n ) + c) % n;</div><div class="line">		d = gcd( y - x, n );</div><div class="line">		<span class="keyword">if</span>(<span class="number">1</span>&lt;d&amp;&amp;d&lt;n)</div><div class="line">			<span class="keyword">return</span> d;</div><div class="line">		<span class="keyword">if</span>(y == x)<span class="comment">//找到循环，选取失败，重新来</span></div><div class="line">			<span class="keyword">return</span> n;</div><div class="line">		<span class="keyword">if</span>(i == k) <span class="comment">//似乎是一个优化，但是不是很清楚</span></div><div class="line">		&#123;</div><div class="line">			y = x;</div><div class="line">			k &lt;&lt;= <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> c )</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	<span class="keyword">if</span>(miller_rabin( n ))</div><div class="line">	&#123;</div><div class="line">		m[n]++;</div><div class="line">		number++;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> p = n;</div><div class="line">	<span class="keyword">while</span>(p &gt;= n)</div><div class="line">		p = pollard_rho( p, c-- );</div><div class="line">	find( p, c );</div><div class="line">	find( n / p, c );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> tar;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; tar)</div><div class="line">	&#123;</div><div class="line">		number = <span class="number">0</span>;</div><div class="line">		m.clear();</div><div class="line">		find( tar, <span class="number">2137342</span> );</div><div class="line">		<span class="built_in">printf</span>( <span class="string">"%lld = "</span>, tar );</div><div class="line">		<span class="keyword">if</span>(m.empty())</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">printf</span>( <span class="string">"%lld\n"</span>, tar );</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt;::iterator c = m.begin(); c != m.end();)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">printf</span>( <span class="string">"%lld^%d"</span>, c-&gt;first, c-&gt;second );</div><div class="line">			<span class="keyword">if</span>((++c) != m.end())</div><div class="line">				<span class="built_in">printf</span>( <span class="string">" * "</span> );</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">printf</span>( <span class="string">"\n"</span> );</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="0x4-Pollard-39-s-p-1-算法"><a href="#0x4-Pollard-39-s-p-1-算法" class="headerlink" title="0x4 Pollard&#39;s p-1 算法"></a>0x4 Pollard&#39;s p-1 算法</h3><h4 id="4-1-smooth与powersmooth"><a href="#4-1-smooth与powersmooth" class="headerlink" title="4.1 smooth与powersmooth"></a>4.1 smooth与powersmooth</h4><p>如果一个整数的所有素因子都不大于B，我们称这个整数是B-Smooth数</p>
<p>如果一个整数的所有素因子的对应指数次幂不大于B，我们称这个整数是B-powersmooth数</p>
<p>$720({2^4}{3^2}{5^1})$ 是一个5-smooth数，6-smooth数，7-smooth数</p>
<p>但5^1\&lt;3^2\&lt;2^4=16，所以它也是一个16-powersmooth数</p>
<h4 id="4-2-原理解释"><a href="#4-2-原理解释" class="headerlink" title="4.2 原理解释"></a>4.2 原理解释</h4><p>n 是一个合数，其中一个质数位p，由费马小定理有：$a^{K(p-1)}=1(mod\ p)$</p>
<p>如果 $x=1(mod\ p)$ ，就有 $p|gcd(x-1,n)$</p>
<p>这个算法的思想就是构造p-1，其有多个素因子，并且每个素因子的powersmooth不超过B，开始时随机选取一个x， 计算 $x^w\ mod\ n$ , $w=\prod_{primes\ q\leq\ B}\ q^{\lfloor \log_{q}{B}\rfloor}$ ， 如果有$gcd(x^w-1, n)$ 不等于1， 那么我们就相当于找到一个素数p了</p>
<h4 id="4-3-算法"><a href="#4-3-算法" class="headerlink" title="4.3 算法"></a>4.3 算法</h4><p><strong>Inputs</strong>: n: a composite number<br><strong>Output</strong>: a nontrivial factor of n or failure</p>
<ol>
<li>select a smoothness bound B</li>
<li>define $M=\prod_{primes\ q\leq\ B}\ q^{\lfloor \log_{q}{B}\rfloor}$ (note: explicitly evaluating M may not be necessary)</li>
<li>randomly pick a coprime to n (note: we can actually fix a, e.g. if n is odd, then we can always select a = 2, random selection here is not imperative)</li>
<li>compute $g = gcd(a^M − 1, n)$ (note: exponentiation can be done modulo n)</li>
<li>if 1 &lt; g &lt; n then return g</li>
<li>if g = 1 then select a larger B and go to step 2 or return failure</li>
<li>if g = n then select a smaller B and go to step 2 or return failure</li>
</ol>
<p>这里的larger B和smaller B有选择性的方法，具体是啥我也不太清楚！ </p>
<h4 id="4-4-范例"><a href="#4-4-范例" class="headerlink" title="4.4 范例"></a>4.4 范例</h4><p>If we want to factor the number n = 299.</p>
<ol>
<li>We select B = 5.</li>
<li>Thus $M = 2^2 × 3^1 × 5^1$.</li>
<li>We select a = 2.</li>
<li>$g = gcd(a^M − 1, n) = 13$.</li>
<li>Since 1 &lt; 13 &lt; 299, thus return 13.</li>
<li>299 / 13 = 23 is prime, thus it is fully factored: 299 = 13 × 23.</li>
</ol>
<h3 id="0x5-Williams-39-s-p-1-算法"><a href="#0x5-Williams-39-s-p-1-算法" class="headerlink" title="0x5 Williams&#39;s p + 1 算法"></a>0x5 Williams&#39;s p + 1 算法</h3><p>Pollard&#39;s p-1算法比较容易懂，但是Williams’s p+1算法却不怎么让人明白！</p>
<h4 id="5-1-算法"><a href="#5-1-算法" class="headerlink" title="5.1 算法"></a>5.1 算法</h4><p>选择大于2的整数A，用其生成一个卢卡斯序列：</p>
<p>$V_0=2, V_1=A,V_j=AV_{j-1}-V_{j-2}$      (貌似实际上用的是下面给出的算法)</p>
<p>对于任意的奇素数 $p|gcd(N, V_M -2)$ ，都有M是 $p-(D/p)$ 的因子， $D=A^2-4$ ，而 $(D/p)$ 为雅可比符号</p>
<p>当 $(D/p)=-1$ ，所表示的就是Williams&#39;s p+1算法；而 $(D/p)=1$ 时，表示的就是Pollard&#39;s p-1算法</p>
<p>对于不同的M，我们计算 $gcd(N, V_M -2)$ ，当结果不等于1或者N时，我们得到N的非平凡因子</p>
<p>下面是计算V的第M个值的算法！！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">x=B           </div><div class="line">y=(B^2-2) mod N     </div><div class="line">for each bit of M to the right of the most significant bit</div><div class="line">  if the bit is 1</div><div class="line">    x=(x*y-B) mod N </div><div class="line">    y=(y^2-2) mod N </div><div class="line">  else</div><div class="line">    y=(x*y-B) mod N </div><div class="line">    x=(x^2-2) mod N </div><div class="line">V=x</div></pre></td></tr></table></figure>
<h4 id="5-2-范例"><a href="#5-2-范例" class="headerlink" title="5.2 范例"></a>5.2 范例</h4><p>With <em>N</em>=112729 and <em>A</em>=5, successive values of V_Mare:</p>
<ul>
<li>V1 = 5</li>
<li>V2=23</li>
<li>V3=12098</li>
<li>V4=87680</li>
<li>V5=53242</li>
<li>V6=27666</li>
<li>V7=110229</li>
</ul>
<p>At this point, gcd(110229-2,112729) = 139, so 139 is a non-trivial factor of 112729. Notice that$ p+1 = 140 = 2^2 × 5 × 7$. The number 7! is the lowest factorial which is multiple of 140, so the proper factor 139 is found in this step.</p>
<p>Using another initial value, say <em>A</em> = 9, we get:</p>
<ul>
<li>V1=9</li>
<li>V2=79</li>
<li>V3=41886</li>
<li>V4=79378</li>
<li>V5=1934</li>
<li>V6=10582</li>
<li>V7=84241</li>
<li>V8=93973</li>
<li>V9=91645</li>
</ul>
<p>At this point gcd(91645-2,112729) = 811, so 811 is a non-trivial factor of 112729. Notice that $p-1 = 810 = 2 × 5 × 3^4$. The number 9! is the lowest factorial which is multiple of 810, so the proper factor 811 is found in this step. The factor 139 is not found this time because p-1 = 138 = 2 × 3 × 23 which is not a divisor of 9!</p>
<p>As can be seen in these examples we do not know in advance whether the prime that will be found has a smooth p+1 or p-1.</p>
<h3 id="0x6-ecm"><a href="#0x6-ecm" class="headerlink" title="0x6 ecm"></a>0x6 ecm</h3><p>ecm全称elliptic-curve factorization method。它是一个次指数级运算时间算法，主要用于整数分解。它是第三快的整数分解方法；第二快的是<a href="https://en.wikipedia.org/wiki/Quadratic_sieve" target="_blank" rel="external">multiple polynomial quadratic sieve</a>；最快的是<a href="https://en.wikipedia.org/wiki/General_number_field_sieve" target="_blank" rel="external">general number field sieve</a>.</p>
<p>它非常适合寻找小整数因子，并且它仍是分解超过50-60位数字的最佳算法。其运算时间有最小的质数p来决定。</p>
<h4 id="6-1-算法原理"><a href="#6-1-算法原理" class="headerlink" title="6.1 算法原理"></a>6.1 算法原理</h4><ol>
<li>选择整数域上的椭圆曲线 $y^2=x^3+ax+b (mod n)$ 以及非平凡点 $P(x_0, y_0)$ 。这个过程其实可以先任取a，然后 $b=y_0^2-x_0^3-ax_0 (mod n)$</li>
<li>对于kP，若其切线u/v有gcd(u,n)=1，而v=0(mod n)，那么u/v表示无穷远，最终会结果为无穷远点，且此时得到的曲线abel群正常。然而，若gcd(v,n)不为1或者n，那么此时仍然会产生一个非平凡的无穷远点，此时的曲线abel群并不是最大的群group (mod n)；但是我们找到了n的因子gcd(v,n)</li>
<li>我们使用2P，3(2P)，4(3!P)这种方式产生新点，由于B!P中的B!会在一定时间内成为曲线域的大小的倍数，所以当到达其倍数时将会成为无穷远点。<ul>
<li>如果完成所有的运算，但并未遇到可逆的分母，我们将选择其他的曲线</li>
<li>若遇到kP= ∞，但是坟墓v=0(mod n)，我们将重新选择一条曲线。</li>
<li>若遇到gcd(v,n)不为1或n，则得到正确的解</li>
</ul>
</li>
</ol>
<p>可以看到该算法的运算时间为$exp[(\sqrt{2}+o(1))\sqrt{lnp\ ln\ lnp}]$</p>
<h4 id="6-2-范例"><a href="#6-2-范例" class="headerlink" title="6.2 范例"></a>6.2 范例</h4><p>The following example is from <a href="https://en.wikipedia.org/wiki/Lenstra_elliptic-curve_factorization#CITEREFTrappeWashington2006" target="_blank" rel="external">Trappe &amp; Washington (2006)</a>, with some details added.</p>
<p>We want to factor <em>n</em> = 455839. Let&#39;s choose the elliptic curve $y^2 = x^3 + 5x – 5$, with the point <em>P</em> = (1, 1) on it, and let&#39;s try to compute (10!)<em>P</em>.</p>
<p>The slope(斜率) of the tangent line(切线) at some point <em>A</em>=(<em>x</em>, <em>y</em>) is $s = (3x^2 + 5)/(2y) (mod n)$. Using <em>s</em> we can compute 2<em>A</em>. If the value of <em>s</em> is of the form <em>a/b</em> where <em>b</em> &gt; 1 and gcd(<em>a</em>,<em>b</em>) = 1, we have to find the <a href="https://en.wikipedia.org/wiki/Modular_inverse" target="_blank" rel="external">modular inverse</a> of <em>b</em>. If it does not exist, gcd(<em>n</em>,<em>b</em>) is a non-trivial factor of <em>n</em>. </p>
<p>First we compute 2<em>P</em>. We have <em>s</em>(<em>P</em>) = <em>s</em>(1,1) = 4, so the coordinates of 2<em>P</em> = (<em>x′</em>, <em>y′</em>) are $x′ = s^2 – 2x = 14$ and $y′ = s(x – x′) – y = 4(1 – 14) – 1 = –53$, all numbers understood (mod <em>n</em>). Just to check that this 2<em>P</em> is indeed on the curve: $(–53)^2 = 2809 = 14^3 + 5·14 – 5$.</p>
<p>Then we compute 3(2<em>P</em>). We have <em>s</em>(2<em>P</em>) = <em>s</em>(14,-53) = –593/106 (mod <em>n</em>). gcd(455839, 106) = 1, and working backwards (a version of the <a href="https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm" target="_blank" rel="external">extended Euclidean algorithm</a>): 106^(−1) = 81707 (mod 455839), and –593/106 = –133317 (mod 455839). Given this <em>s</em>, we can compute the coordinates of 2(2<em>P</em>), just as we did above: 4<em>P</em> = (259851, 116255). After this, we can compute 3(2P)=4P+2P.</p>
<p>We can similarly compute 4!<em>P</em>, and so on, but 8!<em>P</em> requires inverting 599 (mod 455839). The Euclidean algorithm gives that 455839 is divisible by 599, and we have found a factorization 455839 = 599·761.</p>
<p>The reason that this worked is that the curve (mod 599) has $640 = 2^7·5$ points, while (mod 761) it has 777 = 3·7·37 points. Moreover, 640 and 777 are the smallest positive integers <em>k</em> such that <em>kP</em> = ∞ on the curve (mod 599) and (mod 761), respectively. Since 8! is a multiple of 640 but not a multiple of 777, we have 8!<em>P</em> = ∞ on the curve (mod 599), but not on the curve (mod 761), hence the repeated addition broke down here, yielding the factorization.</p>
<h3 id="0x7-smooth质数"><a href="#0x7-smooth质数" class="headerlink" title="0x7 smooth质数"></a>0x7 smooth质数</h3><h4 id="7-1-p-1-光滑"><a href="#7-1-p-1-光滑" class="headerlink" title="7.1 p - 1 光滑"></a>7.1 p - 1 光滑</h4><p>当 p 是 N 的因数，并且 p - 1 是光滑的时候，可能可以使用 Pollard&#39;s p − 1 算法来分解 N，但是也不是完全可以成功的。</p>
<h4 id="7-2-p-1-光滑"><a href="#7-2-p-1-光滑" class="headerlink" title="7.2 p + 1 光滑"></a>7.2 p + 1 光滑</h4><p>当 p 是 n 的因数，并且 p + 1 是光滑的时候，可能可以使用 Williams&#39;s p + 1 算法来分解 N，但是也不是完全可以成功的。</p>
<h4 id="7-3-primefac包"><a href="#7-3-primefac包" class="headerlink" title="7.3 primefac包"></a>7.3 primefac包</h4><p>上面的两种光滑，都可以使用包<a href="https://pypi.python.org/pypi/primefac" target="_blank" rel="external">primefac</a> 来做</p>
<p>primefac是一个贼好用的工具，环境一般在linux上，cygwin上也能用，运行速度贼快！</p>
<font color="#f00">不能在windows上使用的原因</font>

<p>在Windows中，多进程multiprocessing使用的是序列化pickle来在多进程之间转移数据，而socket对象是不能被序列化的，但是在linux操作系统上却没问题，因为在linux上多进程multiprocessing使用的是fork，所以在windows上可以改用多线程。</p>
<p>常用的命令行使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">python -m primefac [-vs] [-v|--verbose] [-s|--summary] [-t=NUM] [-r=NUM]</div><div class="line">                [-m=[prb][,p-1][,p+1][,ecm][,mpqs]] rpn</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">rpn is an expression in revese Polish notation and is evaluated using integer arithmetic. Each number that remains on the stack after evaluation is then factored.</div><div class="line"></div><div class="line">-t sets the trial division limit; the default value is 1000. Use -t=inf to use trial division exclusively.</div><div class="line"></div><div class="line">-r sets the number of rounds of Pollard’s rho algorithm to try before calling a factor “difficult”. The default value is 42,000. Use -r=inf to use Pollard’s rho exclusively once the trial division is completed.</div><div class="line"></div><div class="line">If verbosity is invoked, we indicate in the output which algorithm produced which factors during the multifactor phase.</div><div class="line"></div><div class="line">If the -s (or --summary) flag is absent, then output is identical to the output of the GNU factor command, except possibly for the order of the factors and, if verbosity has been turned on, the annotations indicating which algorithm produced which factors.</div><div class="line"></div><div class="line">If the -s (or --summary) flag is present, then output is modified by adding a single newline between each item’s output, before the first item, and after the last item. Each item’s output is also modified by printing a second line of data summarizing the results by describing the number of decimal digits in the input, the number of decimal digits in each prime factor, and the factors’ multiplicities</div><div class="line"></div><div class="line">The -v and -s flags may be combined into a single flag in either order — i.e., into -vs or -sv.</div><div class="line"></div><div class="line">The -m= flag controls the functions used during the multifactor phase. The options are prb, p-1, p+1, ecm, and mpqs, representing Pollard’s rho, Pollard’s p-1, Williams’ p+1, the elliptic curve method, and the multiple polynomial quadratic sieve, respectively. The options must be separated by commas. The options can be repeated: if prb is listed twice, for example, then multifactor will run two instances of pollardRho_brent simultaneously. In the case of prb and ecm, this decreases the expectation value of the time to find a factor, whereas the other three algorithms (p-1, p+1, and MPQS) have no randomized component so that running duplicate instances of these three algorithms confers no benefit. We therefore ignore repeated listings of the latter three methods: for example, calling</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python -m primefac -m=prb,prb,ecm,ecm,ecm,mpqs,mpqs 38 ! 1 +</div></pre></td></tr></table></figure>
<p>从上面的说明中可以看出，primefac可以使用多种常用的分解质因数的方法，而rpn时使用逆波兰表示法表示的数。</p>
<h4 id="7-4-整数分解的方法"><a href="#7-4-整数分解的方法" class="headerlink" title="7.4 整数分解的方法"></a>7.4 整数分解的方法</h4><ul>
<li><a href="https://en.wikipedia.org/wiki/Trial_division" target="_blank" rel="external">Trial division</a></li>
<li><a href="https://en.wikipedia.org/wiki/Wheel_factorization" target="_blank" rel="external">Wheel factorization</a></li>
<li><a href="https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm" target="_blank" rel="external">Pollard&#39;s rho algorithm</a></li>
<li><a href="https://en.wikipedia.org/wiki/Algebraic-group_factorisation_algorithms" target="_blank" rel="external">Algebraic-group factorisation algorithms</a>, among which are <a href="https://en.wikipedia.org/wiki/Pollard%27s_p_%E2%88%92_1_algorithm" target="_blank" rel="external">Pollard&#39;s <em>p</em> − 1 algorithm</a>, <a href="https://en.wikipedia.org/wiki/Williams%27_p_%2B_1_algorithm" target="_blank" rel="external">Williams&#39; <em>p</em> + 1 algorithm</a>, and <a href="https://en.wikipedia.org/wiki/Lenstra_elliptic_curve_factorization" target="_blank" rel="external">Lenstra elliptic curve factorization</a></li>
<li><a href="https://en.wikipedia.org/wiki/Fermat%27s_factorization_method" target="_blank" rel="external">Fermat&#39;s factorization method</a></li>
<li><a href="https://en.wikipedia.org/wiki/Euler%27s_factorization_method" target="_blank" rel="external">Euler&#39;s factorization method</a></li>
<li><a href="https://en.wikipedia.org/wiki/Special_number_field_sieve" target="_blank" rel="external">Special number field sieve</a></li>
</ul>
<h3 id="0x8-ctf中范例"><a href="#0x8-ctf中范例" class="headerlink" title="0x8 ctf中范例"></a>0x8 ctf中范例</h3><h4 id="8-1-2017-SECCON-very-smooth"><a href="#8-1-2017-SECCON-very-smooth" class="headerlink" title="8.1 2017 SECCON very smooth"></a>8.1 2017 SECCON very smooth</h4><p>将题目从文件中binwalk出来之后，发现了一个证书，给出了大整数n</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">python -m primefac -vs -m=p+1  149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897</div><div class="line"></div><div class="line">149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897: p+1 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897</div><div class="line">Z309  =  P155 x P155  =  11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 x 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897</div></pre></td></tr></table></figure>
<p>至于这里为什么只能用Williams&#39;s <em>p</em> + 1 算法而不能用 Pollard&#39;s p − 1 算法分解，其原因可能如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">➜ python -m primefac -vs 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002</div><div class="line"></div><div class="line">1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002: 2 7 43 503 761429 5121103123294685745276806480148867612214394022184063853387799606010231770631857868979139305712805242051823263337587909550709296150544706624823</div><div class="line">Z154  =  P1 x P1 x P2 x P3 x P6 x P142  =  2 x 7 x 43 x 503 x 761429 x 5121103123294685745276806480148867612214394022184063853387799606010231770631857868979139305712805242051823263337587909550709296150544706624823</div><div class="line"></div><div class="line">➜ python -m primefac -vs 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 </div><div class="line"></div><div class="line">1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000: 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5</div><div class="line">Z154  =  P1^185 x P1^62 x P1^97  =  2^185 x 3^62 x 5^97</div></pre></td></tr></table></figure>
<p>其实从此处看出，对于 p-1 确实有很多小因子，但是个数太多，这就会使得进行枚举的时候出现指数爆炸的情况，因此没有分解出来。</p>
<h4 id="8-2-2018-Backdoor-Awesome-mix2"><a href="#8-2-2018-Backdoor-Awesome-mix2" class="headerlink" title="8.2 2018 Backdoor Awesome-mix2"></a>8.2 2018 Backdoor Awesome-mix2</h4><p>这道题是一道验证题，但是需要解决一个问题：</p>
<p>已知s，m，（都是不超过1024位的大整数），求使得 $s^e=m(mod n)$ 的 e和n，约束条件是:</p>
<p>$e&gt;=3, n&gt;=s, n.bit_length &lt;= 1025$</p>
<p>这个时候可以让n为smooth素数，也即Pollard&#39;s p-1，然后就可以求出e</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/rsa/" rel="tag"># rsa</a>
          
        </div>
      

      
      
        <div class="post-widgets">
        
          <div class="wp_rating">
            <div id="wpac-rating"></div>
          </div>
        

        
        </div>
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/20/crypto/深度解读SSL-TLS实现/" rel="next" title="深度解读SSL/TLS实现">
                <i class="fa fa-chevron-left"></i> 深度解读SSL/TLS实现
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/03/27/hexo/hexo使用hexo-math插件支持MathJax/" rel="prev" title="hexo使用hexo-math插件支持MathJax">
                hexo使用hexo-math插件支持MathJax <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="gitalk-container"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/me.jpg"
               alt="Introspelliam" />
          <p class="site-author-name" itemprop="name">Introspelliam</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">125</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">56</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/Introspelliam" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/3008590672" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#0x0-前言"><span class="nav-text">0x0 前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x1-baby-step-giant-step算法"><span class="nav-text">0x1 baby step giant step算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x2-Pohlig-Hellman算法"><span class="nav-text">0x2 Pohlig-Hellman算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-求解-x-i"><span class="nav-text">2.1 求解$x_i$</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-中国剩余定理求解x"><span class="nav-text">2.2 中国剩余定理求解x</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-范例"><span class="nav-text">2.3 范例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x3-Pollard’s-rho算法"><span class="nav-text">0x3 Pollard’s rho算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-通过-𝐁𝐢𝐫𝐭𝐡𝐝𝐚𝐲-𝐓𝐫𝐢𝐜𝐤-提高概率"><span class="nav-text">3.1 通过 𝐁𝐢𝐫𝐭𝐡𝐝𝐚𝐲 𝐓𝐫𝐢𝐜𝐤 提高概率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-Pollard‘s-rho算法详解"><span class="nav-text">3.2 Pollard‘s rho算法详解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-算法实现"><span class="nav-text">3.3 算法实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x4-Pollard-39-s-p-1-算法"><span class="nav-text">0x4 Pollard's p-1 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-smooth与powersmooth"><span class="nav-text">4.1 smooth与powersmooth</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-原理解释"><span class="nav-text">4.2 原理解释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-算法"><span class="nav-text">4.3 算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-范例"><span class="nav-text">4.4 范例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x5-Williams-39-s-p-1-算法"><span class="nav-text">0x5 Williams's p + 1 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-算法"><span class="nav-text">5.1 算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-范例"><span class="nav-text">5.2 范例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x6-ecm"><span class="nav-text">0x6 ecm</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-算法原理"><span class="nav-text">6.1 算法原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-范例"><span class="nav-text">6.2 范例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x7-smooth质数"><span class="nav-text">0x7 smooth质数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-p-1-光滑"><span class="nav-text">7.1 p - 1 光滑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-p-1-光滑"><span class="nav-text">7.2 p + 1 光滑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-3-primefac包"><span class="nav-text">7.3 primefac包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-4-整数分解的方法"><span class="nav-text">7.4 整数分解的方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0x8-ctf中范例"><span class="nav-text">0x8 ctf中范例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-2017-SECCON-very-smooth"><span class="nav-text">8.1 2017 SECCON very smooth</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-2018-Backdoor-Awesome-mix2"><span class="nav-text">8.2 2018 Backdoor Awesome-mix2</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Introspelliam</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script src="/js/md5.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: '41857e5205be9fe36c48',
          clientSecret: 'c927ea37a432eff67cdb1081658112c7409ca7ff',
          repo: 'Introspelliam.github.io',
          owner: 'Introspelliam',
          admin: ['Introspelliam'],
          id: md5(location.pathname),
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')           
       </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  <script type="text/javascript">
  wpac_init = window.wpac_init || [];
  wpac_init.push({widget: 'Rating', id: ,
    el: 'wpac-rating',
    color: 'fc6423'
  });
  (function() {
    if ('WIDGETPACK_LOADED' in window) return;
    WIDGETPACK_LOADED = true;
    var mc = document.createElement('script');
    mc.type = 'text/javascript';
    mc.async = true;
    mc.src = '//embed.widgetpack.com/widget.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
  })();
  </script>


  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
